import { c as commonjsGlobal, r as reactExports, b as React, j as jsxs, a as jsx } from "./index-753ea245.js";
var mapboxGlExports = {};
var mapboxGl = {
  get exports() {
    return mapboxGlExports;
  },
  set exports(v) {
    mapboxGlExports = v;
  }
};
(function(module2, exports2) {
  (function(global2, factory) {
    module2.exports = factory();
  })(commonjsGlobal, function() {
    var shared, worker, mapboxgl2;
    function define(_, chunk) {
      if (!shared) {
        shared = chunk;
      } else if (!worker) {
        worker = chunk;
      } else {
        var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/api/#transpiling-v2'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;";
        var sharedChunk = {};
        shared(sharedChunk);
        mapboxgl2 = chunk(sharedChunk);
        if (typeof window !== "undefined") {
          mapboxgl2.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
        }
      }
    }
    define(["exports"], function(t) {
      var e = "2.5.1", r = n;
      function n(t2, e2, r2, n2) {
        this.cx = 3 * t2, this.bx = 3 * (r2 - t2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n2 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t2, this.p1y = n2, this.p2x = r2, this.p2y = n2;
      }
      n.prototype.sampleCurveX = function(t2) {
        return ((this.ax * t2 + this.bx) * t2 + this.cx) * t2;
      }, n.prototype.sampleCurveY = function(t2) {
        return ((this.ay * t2 + this.by) * t2 + this.cy) * t2;
      }, n.prototype.sampleCurveDerivativeX = function(t2) {
        return (3 * this.ax * t2 + 2 * this.bx) * t2 + this.cx;
      }, n.prototype.solveCurveX = function(t2, e2) {
        var r2, n2, i2, s2, a2;
        for (void 0 === e2 && (e2 = 1e-6), i2 = t2, a2 = 0; a2 < 8; a2++) {
          if (s2 = this.sampleCurveX(i2) - t2, Math.abs(s2) < e2)
            return i2;
          var o2 = this.sampleCurveDerivativeX(i2);
          if (Math.abs(o2) < 1e-6)
            break;
          i2 -= s2 / o2;
        }
        if ((i2 = t2) < (r2 = 0))
          return r2;
        if (i2 > (n2 = 1))
          return n2;
        for (; r2 < n2; ) {
          if (s2 = this.sampleCurveX(i2), Math.abs(s2 - t2) < e2)
            return i2;
          t2 > s2 ? r2 = i2 : n2 = i2, i2 = 0.5 * (n2 - r2) + r2;
        }
        return i2;
      }, n.prototype.solve = function(t2, e2) {
        return this.sampleCurveY(this.solveCurveX(t2, e2));
      };
      var i = s;
      function s(t2, e2) {
        this.x = t2, this.y = e2;
      }
      s.prototype = { clone: function() {
        return new s(this.x, this.y);
      }, add: function(t2) {
        return this.clone()._add(t2);
      }, sub: function(t2) {
        return this.clone()._sub(t2);
      }, multByPoint: function(t2) {
        return this.clone()._multByPoint(t2);
      }, divByPoint: function(t2) {
        return this.clone()._divByPoint(t2);
      }, mult: function(t2) {
        return this.clone()._mult(t2);
      }, div: function(t2) {
        return this.clone()._div(t2);
      }, rotate: function(t2) {
        return this.clone()._rotate(t2);
      }, rotateAround: function(t2, e2) {
        return this.clone()._rotateAround(t2, e2);
      }, matMult: function(t2) {
        return this.clone()._matMult(t2);
      }, unit: function() {
        return this.clone()._unit();
      }, perp: function() {
        return this.clone()._perp();
      }, round: function() {
        return this.clone()._round();
      }, mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, equals: function(t2) {
        return this.x === t2.x && this.y === t2.y;
      }, dist: function(t2) {
        return Math.sqrt(this.distSqr(t2));
      }, distSqr: function(t2) {
        var e2 = t2.x - this.x, r2 = t2.y - this.y;
        return e2 * e2 + r2 * r2;
      }, angle: function() {
        return Math.atan2(this.y, this.x);
      }, angleTo: function(t2) {
        return Math.atan2(this.y - t2.y, this.x - t2.x);
      }, angleWith: function(t2) {
        return this.angleWithSep(t2.x, t2.y);
      }, angleWithSep: function(t2, e2) {
        return Math.atan2(this.x * e2 - this.y * t2, this.x * t2 + this.y * e2);
      }, _matMult: function(t2) {
        var e2 = t2[2] * this.x + t2[3] * this.y;
        return this.x = t2[0] * this.x + t2[1] * this.y, this.y = e2, this;
      }, _add: function(t2) {
        return this.x += t2.x, this.y += t2.y, this;
      }, _sub: function(t2) {
        return this.x -= t2.x, this.y -= t2.y, this;
      }, _mult: function(t2) {
        return this.x *= t2, this.y *= t2, this;
      }, _div: function(t2) {
        return this.x /= t2, this.y /= t2, this;
      }, _multByPoint: function(t2) {
        return this.x *= t2.x, this.y *= t2.y, this;
      }, _divByPoint: function(t2) {
        return this.x /= t2.x, this.y /= t2.y, this;
      }, _unit: function() {
        return this._div(this.mag()), this;
      }, _perp: function() {
        var t2 = this.y;
        return this.y = this.x, this.x = -t2, this;
      }, _rotate: function(t2) {
        var e2 = Math.cos(t2), r2 = Math.sin(t2), n2 = r2 * this.x + e2 * this.y;
        return this.x = e2 * this.x - r2 * this.y, this.y = n2, this;
      }, _rotateAround: function(t2, e2) {
        var r2 = Math.cos(t2), n2 = Math.sin(t2), i2 = e2.y + n2 * (this.x - e2.x) + r2 * (this.y - e2.y);
        return this.x = e2.x + r2 * (this.x - e2.x) - n2 * (this.y - e2.y), this.y = i2, this;
      }, _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      } }, s.convert = function(t2) {
        return t2 instanceof s ? t2 : Array.isArray(t2) ? new s(t2[0], t2[1]) : t2;
      };
      var a = "undefined" != typeof self ? self : {};
      const o = Math.pow(2, 53) - 1, l = Math.PI / 180, u = 180 / Math.PI;
      function c(t2) {
        return t2 * l;
      }
      const h = [[0, 0], [1, 0], [1, 1], [0, 1]];
      function p(t2) {
        if (t2 <= 0)
          return 0;
        if (t2 >= 1)
          return 1;
        const e2 = t2 * t2, r2 = e2 * t2;
        return 4 * (t2 < 0.5 ? r2 : 3 * (t2 - e2) + r2 - 0.75);
      }
      function d(t2, e2, n2, i2) {
        const s2 = new r(t2, e2, n2, i2);
        return function(t3) {
          return s2.solve(t3);
        };
      }
      const f = d(0.25, 0.1, 0.25, 1);
      function y(t2, e2, r2) {
        return Math.min(r2, Math.max(e2, t2));
      }
      function m(t2, e2, r2) {
        const n2 = r2 - e2, i2 = ((t2 - e2) % n2 + n2) % n2 + e2;
        return i2 === e2 ? r2 : i2;
      }
      function g(t2, e2, r2) {
        if (!t2.length)
          return r2(null, []);
        let n2 = t2.length;
        const i2 = new Array(t2.length);
        let s2 = null;
        t2.forEach((t3, a2) => {
          e2(t3, (t4, e3) => {
            t4 && (s2 = t4), i2[a2] = e3, 0 == --n2 && r2(s2, i2);
          });
        });
      }
      function x(t2) {
        const e2 = [];
        for (const r2 in t2)
          e2.push(t2[r2]);
        return e2;
      }
      function v(t2, ...e2) {
        for (const r2 of e2)
          for (const e3 in r2)
            t2[e3] = r2[e3];
        return t2;
      }
      let b = 1;
      function w() {
        return b++;
      }
      function _() {
        return function t2(e2) {
          return e2 ? (e2 ^ 16 * Math.random() >> e2 / 4).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t2);
        }();
      }
      function A(t2) {
        return t2 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t2) / Math.LN2));
      }
      function k(t2) {
        return !!t2 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t2);
      }
      function S(t2, e2) {
        t2.forEach((t3) => {
          e2[t3] && (e2[t3] = e2[t3].bind(e2));
        });
      }
      function I(t2, e2) {
        return -1 !== t2.indexOf(e2, t2.length - e2.length);
      }
      function z(t2, e2, r2) {
        const n2 = {};
        for (const i2 in t2)
          n2[i2] = e2.call(r2 || this, t2[i2], i2, t2);
        return n2;
      }
      function T(t2, e2, r2) {
        const n2 = {};
        for (const i2 in t2)
          e2.call(r2 || this, t2[i2], i2, t2) && (n2[i2] = t2[i2]);
        return n2;
      }
      function M(t2) {
        return Array.isArray(t2) ? t2.map(M) : "object" == typeof t2 && t2 ? z(t2, M) : t2;
      }
      const E = {};
      function C(t2) {
        E[t2] || ("undefined" != typeof console && console.warn(t2), E[t2] = true);
      }
      function B(t2, e2, r2) {
        return (r2.y - t2.y) * (e2.x - t2.x) > (e2.y - t2.y) * (r2.x - t2.x);
      }
      function D(t2) {
        let e2 = 0;
        for (let r2, n2, i2 = 0, s2 = t2.length, a2 = s2 - 1; i2 < s2; a2 = i2++)
          r2 = t2[i2], n2 = t2[a2], e2 += (n2.x - r2.x) * (r2.y + n2.y);
        return e2;
      }
      function P() {
        return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
      }
      function V(t2) {
        const e2 = {};
        if (t2.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t3, r2, n2, i2) => {
          const s2 = n2 || i2;
          return e2[r2] = !s2 || s2.toLowerCase(), "";
        }), e2["max-age"]) {
          const t3 = parseInt(e2["max-age"], 10);
          isNaN(t3) ? delete e2["max-age"] : e2["max-age"] = t3;
        }
        return e2;
      }
      let L, F, R, $ = null;
      function U(t2) {
        if (null == $) {
          const e2 = t2.navigator ? t2.navigator.userAgent : null;
          $ = !!t2.safari || !(!e2 || !(/\b(iPad|iPhone|iPod)\b/.test(e2) || e2.match("Safari") && !e2.match("Chrome")));
        }
        return $;
      }
      function O(t2) {
        try {
          const e2 = a[t2];
          return e2.setItem("_mapbox_test_", 1), e2.removeItem("_mapbox_test_"), true;
        } catch (t3) {
          return false;
        }
      }
      const q = { now: () => void 0 !== R ? R : a.performance.now(), setNow(t2) {
        R = t2;
      }, restoreNow() {
        R = void 0;
      }, frame(t2) {
        const e2 = a.requestAnimationFrame(t2);
        return { cancel: () => a.cancelAnimationFrame(e2) };
      }, getImageData(t2, e2 = 0) {
        const r2 = a.document.createElement("canvas"), n2 = r2.getContext("2d");
        if (!n2)
          throw new Error("failed to create canvas 2d context");
        return r2.width = t2.width, r2.height = t2.height, n2.drawImage(t2, 0, 0, t2.width, t2.height), n2.getImageData(-e2, -e2, t2.width + 2 * e2, t2.height + 2 * e2);
      }, resolveURL: (t2) => (L || (L = a.document.createElement("a")), L.href = t2, L.href), get devicePixelRatio() {
        return a.devicePixelRatio;
      }, get prefersReducedMotion() {
        return !!a.matchMedia && (null == F && (F = a.matchMedia("(prefers-reduced-motion: reduce)")), F.matches);
      } };
      let j;
      const N = { API_URL: "https://api.mapbox.com", get API_URL_REGEX() {
        if (null == j) {
          const t2 = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
          try {
            j = null != {}.API_URL_REGEX ? new RegExp({}.API_URL_REGEX) : t2;
          } catch (e2) {
            j = t2;
          }
        }
        return j;
      }, get EVENTS_URL() {
        return this.API_URL ? 0 === this.API_URL.indexOf("https://api.mapbox.cn") ? "https://events.mapbox.cn/events/v2" : 0 === this.API_URL.indexOf("https://api.mapbox.com") ? "https://events.mapbox.com/events/v2" : null : null;
      }, SESSION_PATH: "/map-sessions/v1", FEEDBACK_URL: "https://apps.mapbox.com/feedback", TILE_URL_VERSION: "v4", RASTER_URL_PREFIX: "raster/v1", REQUIRE_ACCESS_TOKEN: true, ACCESS_TOKEN: null, MAX_PARALLEL_IMAGE_REQUESTS: 16 }, Z = { supported: false, testSupport: function(t2) {
        !K && X && (Y ? H(t2) : G = t2);
      } };
      let G, X, K = false, Y = false;
      function H(t2) {
        const e2 = t2.createTexture();
        t2.bindTexture(t2.TEXTURE_2D, e2);
        try {
          if (t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, X), t2.isContextLost())
            return;
          Z.supported = true;
        } catch (t3) {
        }
        t2.deleteTexture(e2), K = true;
      }
      a.document && (X = a.document.createElement("img"), X.onload = function() {
        G && H(G), G = null, Y = true;
      }, X.onerror = function() {
        K = true, G = null;
      }, X.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
      const J = "01", W = "NO_ACCESS_TOKEN";
      function Q(t2) {
        return 0 === t2.indexOf("mapbox:");
      }
      function tt(t2) {
        return N.API_URL_REGEX.test(t2);
      }
      const et = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
      function rt(t2) {
        const e2 = t2.match(et);
        if (!e2)
          throw new Error("Unable to parse URL object");
        return { protocol: e2[1], authority: e2[2], path: e2[3] || "/", params: e2[4] ? e2[4].split("&") : [] };
      }
      function nt(t2) {
        const e2 = t2.params.length ? `?${t2.params.join("&")}` : "";
        return `${t2.protocol}://${t2.authority}${t2.path}${e2}`;
      }
      function it(t2) {
        if (!t2)
          return null;
        const e2 = t2.split(".");
        if (!e2 || 3 !== e2.length)
          return null;
        try {
          return JSON.parse(decodeURIComponent(a.atob(e2[1]).split("").map((t3) => "%" + ("00" + t3.charCodeAt(0).toString(16)).slice(-2)).join("")));
        } catch (t3) {
          return null;
        }
      }
      class st {
        constructor(t2) {
          this.type = t2, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
        }
        getStorageKey(t2) {
          const e2 = it(N.ACCESS_TOKEN);
          let r2 = "";
          return r2 = e2 && e2.u ? a.btoa(encodeURIComponent(e2.u).replace(/%([0-9A-F]{2})/g, (t3, e3) => String.fromCharCode(Number("0x" + e3)))) : N.ACCESS_TOKEN || "", t2 ? `mapbox.eventData.${t2}:${r2}` : `mapbox.eventData:${r2}`;
        }
        fetchEventData() {
          const t2 = O("localStorage"), e2 = this.getStorageKey(), r2 = this.getStorageKey("uuid");
          if (t2)
            try {
              const t3 = a.localStorage.getItem(e2);
              t3 && (this.eventData = JSON.parse(t3));
              const n2 = a.localStorage.getItem(r2);
              n2 && (this.anonId = n2);
            } catch (t3) {
              C("Unable to read from LocalStorage");
            }
        }
        saveEventData() {
          const t2 = O("localStorage"), e2 = this.getStorageKey(), r2 = this.getStorageKey("uuid");
          if (t2)
            try {
              a.localStorage.setItem(r2, this.anonId), Object.keys(this.eventData).length >= 1 && a.localStorage.setItem(e2, JSON.stringify(this.eventData));
            } catch (t3) {
              C("Unable to write to LocalStorage");
            }
        }
        processRequests(t2) {
        }
        postEvent(t2, r2, n2, i2) {
          if (!N.EVENTS_URL)
            return;
          const s2 = rt(N.EVENTS_URL);
          s2.params.push(`access_token=${i2 || N.ACCESS_TOKEN || ""}`);
          const a2 = { event: this.type, created: new Date(t2).toISOString(), sdkIdentifier: "mapbox-gl-js", sdkVersion: e, skuId: J, userId: this.anonId }, o2 = r2 ? v(a2, r2) : a2, l2 = { url: nt(s2), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([o2]) };
          this.pendingRequest = It(l2, (t3) => {
            this.pendingRequest = null, n2(t3), this.saveEventData(), this.processRequests(i2);
          });
        }
        queueRequest(t2, e2) {
          this.queue.push(t2), this.processRequests(e2);
        }
      }
      const at = new class extends st {
        constructor(t2) {
          super("appUserTurnstile"), this._customAccessToken = t2;
        }
        postTurnstileEvent(t2, e2) {
          N.EVENTS_URL && N.ACCESS_TOKEN && Array.isArray(t2) && t2.some((t3) => Q(t3) || tt(t3)) && this.queueRequest(Date.now(), e2);
        }
        processRequests(t2) {
          if (this.pendingRequest || 0 === this.queue.length)
            return;
          this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
          const e2 = it(N.ACCESS_TOKEN), r2 = e2 ? e2.u : N.ACCESS_TOKEN;
          let n2 = r2 !== this.eventData.tokenU;
          k(this.anonId) || (this.anonId = _(), n2 = true);
          const i2 = this.queue.shift();
          if (this.eventData.lastSuccess) {
            const t3 = new Date(this.eventData.lastSuccess), e3 = new Date(i2), r3 = (i2 - this.eventData.lastSuccess) / 864e5;
            n2 = n2 || r3 >= 1 || r3 < -1 || t3.getDate() !== e3.getDate();
          } else
            n2 = true;
          if (!n2)
            return this.processRequests();
          this.postEvent(i2, { "enabled.telemetry": false }, (t3) => {
            t3 || (this.eventData.lastSuccess = i2, this.eventData.tokenU = r2);
          }, t2);
        }
      }(), ot = at.postTurnstileEvent.bind(at), lt = new class extends st {
        constructor() {
          super("map.load"), this.success = {}, this.skuToken = "";
        }
        postMapLoadEvent(t2, e2, r2, n2) {
          this.skuToken = e2, this.errorCb = n2, N.EVENTS_URL && (r2 || N.ACCESS_TOKEN ? this.queueRequest({ id: t2, timestamp: Date.now() }, r2) : this.errorCb(new Error(W)));
        }
        processRequests(t2) {
          if (this.pendingRequest || 0 === this.queue.length)
            return;
          const { id: e2, timestamp: r2 } = this.queue.shift();
          e2 && this.success[e2] || (this.anonId || this.fetchEventData(), k(this.anonId) || (this.anonId = _()), this.postEvent(r2, { skuToken: this.skuToken }, (t3) => {
            t3 ? this.errorCb(t3) : e2 && (this.success[e2] = true);
          }, t2));
        }
      }(), ut = lt.postMapLoadEvent.bind(lt), ct = new class extends st {
        constructor() {
          super("map.auth"), this.success = {}, this.skuToken = "";
        }
        getSession(t2, e2, r2, n2) {
          if (!N.API_URL || !N.SESSION_PATH)
            return;
          const i2 = rt(N.API_URL + N.SESSION_PATH);
          i2.params.push(`sku=${e2 || ""}`), i2.params.push(`access_token=${n2 || N.ACCESS_TOKEN || ""}`);
          const s2 = { url: nt(i2), headers: { "Content-Type": "text/plain" } };
          this.pendingRequest = zt(s2, (t3) => {
            this.pendingRequest = null, r2(t3), this.saveEventData(), this.processRequests(n2);
          });
        }
        getSessionAPI(t2, e2, r2, n2) {
          this.skuToken = e2, this.errorCb = n2, N.SESSION_PATH && N.API_URL && (r2 || N.ACCESS_TOKEN ? this.queueRequest({ id: t2, timestamp: Date.now() }, r2) : this.errorCb(new Error(W)));
        }
        processRequests(t2) {
          if (this.pendingRequest || 0 === this.queue.length)
            return;
          const { id: e2, timestamp: r2 } = this.queue.shift();
          e2 && this.success[e2] || this.getSession(r2, this.skuToken, (t3) => {
            t3 ? this.errorCb(t3) : e2 && (this.success[e2] = true);
          }, t2);
        }
      }(), ht = ct.getSessionAPI.bind(ct), pt = /* @__PURE__ */ new Set(), dt = "mapbox-tiles";
      let ft, yt, mt = 500, gt = 50;
      function xt() {
        a.caches && !ft && (ft = a.caches.open(dt));
      }
      function vt(t2) {
        const e2 = t2.indexOf("?");
        return e2 < 0 ? t2 : t2.slice(0, e2);
      }
      let bt = 1 / 0;
      const wt = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" };
      "function" == typeof Object.freeze && Object.freeze(wt);
      class _t extends Error {
        constructor(t2, e2, r2) {
          401 === e2 && tt(r2) && (t2 += ": you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes"), super(t2), this.status = e2, this.url = r2;
        }
        toString() {
          return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
        }
      }
      const At = P() ? () => self.worker && self.worker.referrer : () => ("blob:" === a.location.protocol ? a.parent : a).location.href;
      const kt = function(t2, e2) {
        if (!(/^file:/.test(r2 = t2.url) || /^file:/.test(At()) && !/^\w+:/.test(r2))) {
          if (a.fetch && a.Request && a.AbortController && a.Request.prototype.hasOwnProperty("signal"))
            return function(t3, e3) {
              const r3 = new a.AbortController(), n2 = new a.Request(t3.url, { method: t3.method || "GET", body: t3.body, credentials: t3.credentials, headers: t3.headers, referrer: At(), signal: r3.signal });
              let i2 = false, s2 = false;
              const o2 = (l2 = n2.url).indexOf("sku=") > 0 && tt(l2);
              var l2;
              "json" === t3.type && n2.headers.set("Accept", "application/json");
              const u2 = (r4, i3, l3) => {
                if (s2)
                  return;
                if (r4 && "SecurityError" !== r4.message && C(r4), i3 && l3)
                  return c2(i3);
                const u3 = Date.now();
                a.fetch(n2).then((r5) => {
                  if (r5.ok) {
                    const t4 = o2 ? r5.clone() : null;
                    return c2(r5, t4, u3);
                  }
                  return e3(new _t(r5.statusText, r5.status, t3.url));
                }).catch((t4) => {
                  20 !== t4.code && e3(new Error(t4.message));
                });
              }, c2 = (r4, o3, l3) => {
                ("arrayBuffer" === t3.type ? r4.arrayBuffer() : "json" === t3.type ? r4.json() : r4.text()).then((t4) => {
                  s2 || (o3 && l3 && function(t5, e4, r5) {
                    if (xt(), !ft)
                      return;
                    const n3 = { status: e4.status, statusText: e4.statusText, headers: new a.Headers() };
                    e4.headers.forEach((t6, e5) => n3.headers.set(e5, t6));
                    const i3 = V(e4.headers.get("Cache-Control") || "");
                    i3["no-store"] || (i3["max-age"] && n3.headers.set("Expires", new Date(r5 + 1e3 * i3["max-age"]).toUTCString()), new Date(n3.headers.get("Expires")).getTime() - r5 < 42e4 || function(t6, e5) {
                      if (void 0 === yt)
                        try {
                          new Response(new ReadableStream()), yt = true;
                        } catch (t7) {
                          yt = false;
                        }
                      yt ? e5(t6.body) : t6.blob().then(e5);
                    }(e4, (e5) => {
                      const r6 = new a.Response(e5, n3);
                      xt(), ft && ft.then((e6) => e6.put(vt(t5.url), r6)).catch((t6) => C(t6.message));
                    }));
                  }(n2, o3, l3), i2 = true, e3(null, t4, r4.headers.get("Cache-Control"), r4.headers.get("Expires")));
                }).catch((t4) => {
                  s2 || e3(new Error(t4.message));
                });
              };
              return o2 ? function(t4, e4) {
                if (xt(), !ft)
                  return e4(null);
                const r4 = vt(t4.url);
                ft.then((t5) => {
                  t5.match(r4).then((n3) => {
                    const i3 = function(t6) {
                      if (!t6)
                        return false;
                      const e5 = new Date(t6.headers.get("Expires") || 0), r5 = V(t6.headers.get("Cache-Control") || "");
                      return e5 > Date.now() && !r5["no-cache"];
                    }(n3);
                    t5.delete(r4), i3 && t5.put(r4, n3.clone()), e4(null, n3, i3);
                  }).catch(e4);
                }).catch(e4);
              }(n2, u2) : u2(null, null), { cancel: () => {
                s2 = true, i2 || r3.abort();
              } };
            }(t2, e2);
          if (P() && self.worker && self.worker.actor)
            return self.worker.actor.send("getResource", t2, e2, void 0, true);
        }
        var r2;
        return function(t3, e3) {
          const r3 = new a.XMLHttpRequest();
          r3.open(t3.method || "GET", t3.url, true), "arrayBuffer" === t3.type && (r3.responseType = "arraybuffer");
          for (const e4 in t3.headers)
            r3.setRequestHeader(e4, t3.headers[e4]);
          return "json" === t3.type && (r3.responseType = "text", r3.setRequestHeader("Accept", "application/json")), r3.withCredentials = "include" === t3.credentials, r3.onerror = () => {
            e3(new Error(r3.statusText));
          }, r3.onload = () => {
            if ((r3.status >= 200 && r3.status < 300 || 0 === r3.status) && null !== r3.response) {
              let n2 = r3.response;
              if ("json" === t3.type)
                try {
                  n2 = JSON.parse(r3.response);
                } catch (t4) {
                  return e3(t4);
                }
              e3(null, n2, r3.getResponseHeader("Cache-Control"), r3.getResponseHeader("Expires"));
            } else
              e3(new _t(r3.statusText, r3.status, t3.url));
          }, r3.send(t3.body), { cancel: () => r3.abort() };
        }(t2, e2);
      }, St = function(t2, e2) {
        return kt(v(t2, { type: "arrayBuffer" }), e2);
      }, It = function(t2, e2) {
        return kt(v(t2, { method: "POST" }), e2);
      }, zt = function(t2, e2) {
        return kt(v(t2, { method: "GET" }), e2);
      };
      function Tt(t2) {
        const e2 = a.document.createElement("a");
        return e2.href = t2, e2.protocol === a.document.location.protocol && e2.host === a.document.location.host;
      }
      const Mt = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      let Et, Ct;
      Et = [], Ct = 0;
      const Bt = function(t2, e2) {
        if (Z.supported && (t2.headers || (t2.headers = {}), t2.headers.accept = "image/webp,*/*"), Ct >= N.MAX_PARALLEL_IMAGE_REQUESTS) {
          const r3 = { requestParameters: t2, callback: e2, cancelled: false, cancel() {
            this.cancelled = true;
          } };
          return Et.push(r3), r3;
        }
        Ct++;
        let r2 = false;
        const n2 = () => {
          if (!r2)
            for (r2 = true, Ct--; Et.length && Ct < N.MAX_PARALLEL_IMAGE_REQUESTS; ) {
              const t3 = Et.shift(), { requestParameters: e3, callback: r3, cancelled: n3 } = t3;
              n3 || (t3.cancel = Bt(e3, r3).cancel);
            }
        }, i2 = St(t2, (t3, r3, i3, s2) => {
          n2(), t3 ? e2(t3) : r3 && (a.createImageBitmap ? function(t4, e3) {
            const r4 = new a.Blob([new Uint8Array(t4)], { type: "image/png" });
            a.createImageBitmap(r4).then((t5) => {
              e3(null, t5);
            }).catch((t5) => {
              e3(new Error(`Could not load image because of ${t5.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
            });
          }(r3, (t4, r4) => e2(t4, r4, i3, s2)) : function(t4, e3) {
            const r4 = new a.Image(), n3 = a.URL;
            r4.onload = () => {
              e3(null, r4), n3.revokeObjectURL(r4.src), r4.onload = null, a.requestAnimationFrame(() => {
                r4.src = Mt;
              });
            }, r4.onerror = () => e3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            const i4 = new a.Blob([new Uint8Array(t4)], { type: "image/png" });
            r4.src = t4.byteLength ? n3.createObjectURL(i4) : Mt;
          }(r3, (t4, r4) => e2(t4, r4, i3, s2)));
        });
        return { cancel: () => {
          i2.cancel(), n2();
        } };
      };
      function Dt(t2, e2, r2) {
        r2[t2] && -1 !== r2[t2].indexOf(e2) || (r2[t2] = r2[t2] || [], r2[t2].push(e2));
      }
      function Pt(t2, e2, r2) {
        if (r2 && r2[t2]) {
          const n2 = r2[t2].indexOf(e2);
          -1 !== n2 && r2[t2].splice(n2, 1);
        }
      }
      class Vt {
        constructor(t2, e2 = {}) {
          v(this, e2), this.type = t2;
        }
      }
      class Lt extends Vt {
        constructor(t2, e2 = {}) {
          super("error", v({ error: t2 }, e2));
        }
      }
      class Ft {
        on(t2, e2) {
          return this._listeners = this._listeners || {}, Dt(t2, e2, this._listeners), this;
        }
        off(t2, e2) {
          return Pt(t2, e2, this._listeners), Pt(t2, e2, this._oneTimeListeners), this;
        }
        once(t2, e2) {
          return e2 ? (this._oneTimeListeners = this._oneTimeListeners || {}, Dt(t2, e2, this._oneTimeListeners), this) : new Promise((e3) => this.once(t2, e3));
        }
        fire(t2, e2) {
          "string" == typeof t2 && (t2 = new Vt(t2, e2 || {}));
          const r2 = t2.type;
          if (this.listens(r2)) {
            t2.target = this;
            const e3 = this._listeners && this._listeners[r2] ? this._listeners[r2].slice() : [];
            for (const r3 of e3)
              r3.call(this, t2);
            const n2 = this._oneTimeListeners && this._oneTimeListeners[r2] ? this._oneTimeListeners[r2].slice() : [];
            for (const e4 of n2)
              Pt(r2, e4, this._oneTimeListeners), e4.call(this, t2);
            const i2 = this._eventedParent;
            i2 && (v(t2, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i2.fire(t2));
          } else
            t2 instanceof Lt && console.error(t2.error);
          return this;
        }
        listens(t2) {
          return !!(this._listeners && this._listeners[t2] && this._listeners[t2].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t2] && this._oneTimeListeners[t2].length > 0 || this._eventedParent && this._eventedParent.listens(t2));
        }
        setEventedParent(t2, e2) {
          return this._eventedParent = t2, this._eventedParentData = e2, this;
        }
      }
      var Rt = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, terrain: { type: "terrain" }, fog: { type: "fog" }, sources: { required: true, type: "sources" }, sprite: { type: "string" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {} }, default: "mapbox" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {}, sky: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background", "layout_sky"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_sky: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {}, within: {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, fog: { range: { type: "array", default: [0.5, 10], minimum: -20, maximum: 20, length: 2, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-blend": { type: "number", "property-type": "data-constant", default: 0.1, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, terrain: { source: { type: "string", required: true }, exaggeration: { type: "number", "property-type": "data-constant", default: 1, minimum: 0, maximum: 1e3, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background", "paint_sky"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_sky: { "sky-type": { type: "enum", values: { gradient: {}, atmosphere: {} }, default: "atmosphere", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "sky-atmosphere-sun": { type: "array", value: "number", length: 2, units: "degrees", minimum: [0, 0], maximum: [360, 180], transition: false, requires: [{ "sky-type": "atmosphere" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "sky-atmosphere-sun-intensity": { type: "number", requires: [{ "sky-type": "atmosphere" }], default: 10, minimum: 0, maximum: 100, transition: false, "property-type": "data-constant" }, "sky-gradient-center": { type: "array", requires: [{ "sky-type": "gradient" }], value: "number", default: [0, 0], length: 2, units: "degrees", minimum: [0, 0], maximum: [360, 180], transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "sky-gradient-radius": { type: "number", requires: [{ "sky-type": "gradient" }], default: 90, minimum: 0, maximum: 180, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "sky-gradient": { type: "color", default: ["interpolate", ["linear"], ["sky-radial-progress"], 0.8, "#87ceeb", 1, "white"], transition: false, requires: [{ "sky-type": "gradient" }], expression: { interpolated: true, parameters: ["sky-radial-progress"] }, "property-type": "color-ramp" }, "sky-atmosphere-halo-color": { type: "color", default: "white", transition: false, requires: [{ "sky-type": "atmosphere" }], "property-type": "data-constant" }, "sky-atmosphere-color": { type: "color", default: "white", transition: false, requires: [{ "sky-type": "atmosphere" }], "property-type": "data-constant" }, "sky-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
      class $t {
        constructor(t2, e2, r2, n2) {
          this.message = (t2 ? `${t2}: ` : "") + r2, n2 && (this.identifier = n2), null != e2 && e2.__line__ && (this.line = e2.__line__);
        }
      }
      function Ut(t2) {
        const e2 = t2.value;
        return e2 ? [new $t(t2.key, e2, "constants have been deprecated as of v8")] : [];
      }
      function Ot(t2, ...e2) {
        for (const r2 of e2)
          for (const e3 in r2)
            t2[e3] = r2[e3];
        return t2;
      }
      function qt(t2) {
        return t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean ? t2.valueOf() : t2;
      }
      function jt(t2) {
        if (Array.isArray(t2))
          return t2.map(jt);
        if (t2 instanceof Object && !(t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean)) {
          const e2 = {};
          for (const r2 in t2)
            e2[r2] = jt(t2[r2]);
          return e2;
        }
        return qt(t2);
      }
      class Nt extends Error {
        constructor(t2, e2) {
          super(e2), this.message = e2, this.key = t2;
        }
      }
      class Zt {
        constructor(t2, e2 = []) {
          this.parent = t2, this.bindings = {};
          for (const [t3, r2] of e2)
            this.bindings[t3] = r2;
        }
        concat(t2) {
          return new Zt(this, t2);
        }
        get(t2) {
          if (this.bindings[t2])
            return this.bindings[t2];
          if (this.parent)
            return this.parent.get(t2);
          throw new Error(`${t2} not found in scope.`);
        }
        has(t2) {
          return !!this.bindings[t2] || !!this.parent && this.parent.has(t2);
        }
      }
      const Gt = { kind: "null" }, Xt = { kind: "number" }, Kt = { kind: "string" }, Yt = { kind: "boolean" }, Ht = { kind: "color" }, Jt = { kind: "object" }, Wt = { kind: "value" }, Qt = { kind: "collator" }, te = { kind: "formatted" }, ee = { kind: "resolvedImage" };
      function re(t2, e2) {
        return { kind: "array", itemType: t2, N: e2 };
      }
      function ne(t2) {
        if ("array" === t2.kind) {
          const e2 = ne(t2.itemType);
          return "number" == typeof t2.N ? `array<${e2}, ${t2.N}>` : "value" === t2.itemType.kind ? "array" : `array<${e2}>`;
        }
        return t2.kind;
      }
      const ie = [Gt, Xt, Kt, Yt, Ht, te, Jt, re(Wt), ee];
      function se(t2, e2) {
        if ("error" === e2.kind)
          return null;
        if ("array" === t2.kind) {
          if ("array" === e2.kind && (0 === e2.N && "value" === e2.itemType.kind || !se(t2.itemType, e2.itemType)) && ("number" != typeof t2.N || t2.N === e2.N))
            return null;
        } else {
          if (t2.kind === e2.kind)
            return null;
          if ("value" === t2.kind) {
            for (const t3 of ie)
              if (!se(t3, e2))
                return null;
          }
        }
        return `Expected ${ne(t2)} but found ${ne(e2)} instead.`;
      }
      function ae(t2, e2) {
        return e2.some((e3) => e3.kind === t2.kind);
      }
      function oe(t2, e2) {
        return e2.some((e3) => "null" === e3 ? null === t2 : "array" === e3 ? Array.isArray(t2) : "object" === e3 ? t2 && !Array.isArray(t2) && "object" == typeof t2 : e3 === typeof t2);
      }
      function le(t2) {
        var e2 = { exports: {} };
        return t2(e2, e2.exports), e2.exports;
      }
      var ue = le(function(t2, e2) {
        var r2 = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
        function n2(t3) {
          return (t3 = Math.round(t3)) < 0 ? 0 : t3 > 255 ? 255 : t3;
        }
        function i2(t3) {
          return n2("%" === t3[t3.length - 1] ? parseFloat(t3) / 100 * 255 : parseInt(t3));
        }
        function s2(t3) {
          return (e3 = "%" === t3[t3.length - 1] ? parseFloat(t3) / 100 : parseFloat(t3)) < 0 ? 0 : e3 > 1 ? 1 : e3;
          var e3;
        }
        function a2(t3, e3, r3) {
          return r3 < 0 ? r3 += 1 : r3 > 1 && (r3 -= 1), 6 * r3 < 1 ? t3 + (e3 - t3) * r3 * 6 : 2 * r3 < 1 ? e3 : 3 * r3 < 2 ? t3 + (e3 - t3) * (2 / 3 - r3) * 6 : t3;
        }
        try {
          e2.parseCSSColor = function(t3) {
            var e3, o2 = t3.replace(/ /g, "").toLowerCase();
            if (o2 in r2)
              return r2[o2].slice();
            if ("#" === o2[0])
              return 4 === o2.length ? (e3 = parseInt(o2.substr(1), 16)) >= 0 && e3 <= 4095 ? [(3840 & e3) >> 4 | (3840 & e3) >> 8, 240 & e3 | (240 & e3) >> 4, 15 & e3 | (15 & e3) << 4, 1] : null : 7 === o2.length && (e3 = parseInt(o2.substr(1), 16)) >= 0 && e3 <= 16777215 ? [(16711680 & e3) >> 16, (65280 & e3) >> 8, 255 & e3, 1] : null;
            var l2 = o2.indexOf("("), u2 = o2.indexOf(")");
            if (-1 !== l2 && u2 + 1 === o2.length) {
              var c2 = o2.substr(0, l2), h2 = o2.substr(l2 + 1, u2 - (l2 + 1)).split(","), p2 = 1;
              switch (c2) {
                case "rgba":
                  if (4 !== h2.length)
                    return null;
                  p2 = s2(h2.pop());
                case "rgb":
                  return 3 !== h2.length ? null : [i2(h2[0]), i2(h2[1]), i2(h2[2]), p2];
                case "hsla":
                  if (4 !== h2.length)
                    return null;
                  p2 = s2(h2.pop());
                case "hsl":
                  if (3 !== h2.length)
                    return null;
                  var d2 = (parseFloat(h2[0]) % 360 + 360) % 360 / 360, f2 = s2(h2[1]), y2 = s2(h2[2]), m2 = y2 <= 0.5 ? y2 * (f2 + 1) : y2 + f2 - y2 * f2, g2 = 2 * y2 - m2;
                  return [n2(255 * a2(g2, m2, d2 + 1 / 3)), n2(255 * a2(g2, m2, d2)), n2(255 * a2(g2, m2, d2 - 1 / 3)), p2];
                default:
                  return null;
              }
            }
            return null;
          };
        } catch (t3) {
        }
      });
      class ce {
        constructor(t2, e2, r2, n2 = 1) {
          this.r = t2, this.g = e2, this.b = r2, this.a = n2;
        }
        static parse(t2) {
          if (!t2)
            return;
          if (t2 instanceof ce)
            return t2;
          if ("string" != typeof t2)
            return;
          const e2 = ue.parseCSSColor(t2);
          return e2 ? new ce(e2[0] / 255 * e2[3], e2[1] / 255 * e2[3], e2[2] / 255 * e2[3], e2[3]) : void 0;
        }
        toString() {
          const [t2, e2, r2, n2] = this.toArray();
          return `rgba(${Math.round(t2)},${Math.round(e2)},${Math.round(r2)},${n2})`;
        }
        toArray() {
          const { r: t2, g: e2, b: r2, a: n2 } = this;
          return 0 === n2 ? [0, 0, 0, 0] : [255 * t2 / n2, 255 * e2 / n2, 255 * r2 / n2, n2];
        }
      }
      ce.black = new ce(0, 0, 0, 1), ce.white = new ce(1, 1, 1, 1), ce.transparent = new ce(0, 0, 0, 0), ce.red = new ce(1, 0, 0, 1), ce.blue = new ce(0, 0, 1, 1);
      class he {
        constructor(t2, e2, r2) {
          this.sensitivity = t2 ? e2 ? "variant" : "case" : e2 ? "accent" : "base", this.locale = r2, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
        }
        compare(t2, e2) {
          return this.collator.compare(t2, e2);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      }
      class pe {
        constructor(t2, e2, r2, n2, i2) {
          this.text = t2, this.image = e2, this.scale = r2, this.fontStack = n2, this.textColor = i2;
        }
      }
      class de {
        constructor(t2) {
          this.sections = t2;
        }
        static fromString(t2) {
          return new de([new pe(t2, null, null, null, null)]);
        }
        isEmpty() {
          return 0 === this.sections.length || !this.sections.some((t2) => 0 !== t2.text.length || t2.image && 0 !== t2.image.name.length);
        }
        static factory(t2) {
          return t2 instanceof de ? t2 : de.fromString(t2);
        }
        toString() {
          return 0 === this.sections.length ? "" : this.sections.map((t2) => t2.text).join("");
        }
        serialize() {
          const t2 = ["format"];
          for (const e2 of this.sections) {
            if (e2.image) {
              t2.push(["image", e2.image.name]);
              continue;
            }
            t2.push(e2.text);
            const r2 = {};
            e2.fontStack && (r2["text-font"] = ["literal", e2.fontStack.split(",")]), e2.scale && (r2["font-scale"] = e2.scale), e2.textColor && (r2["text-color"] = ["rgba"].concat(e2.textColor.toArray())), t2.push(r2);
          }
          return t2;
        }
      }
      class fe {
        constructor(t2) {
          this.name = t2.name, this.available = t2.available;
        }
        toString() {
          return this.name;
        }
        static fromString(t2) {
          return t2 ? new fe({ name: t2, available: false }) : null;
        }
        serialize() {
          return ["image", this.name];
        }
      }
      function ye(t2, e2, r2, n2) {
        return "number" == typeof t2 && t2 >= 0 && t2 <= 255 && "number" == typeof e2 && e2 >= 0 && e2 <= 255 && "number" == typeof r2 && r2 >= 0 && r2 <= 255 ? void 0 === n2 || "number" == typeof n2 && n2 >= 0 && n2 <= 1 ? null : `Invalid rgba value [${[t2, e2, r2, n2].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n2 ? [t2, e2, r2, n2] : [t2, e2, r2]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
      }
      function me(t2) {
        if (null === t2)
          return true;
        if ("string" == typeof t2)
          return true;
        if ("boolean" == typeof t2)
          return true;
        if ("number" == typeof t2)
          return true;
        if (t2 instanceof ce)
          return true;
        if (t2 instanceof he)
          return true;
        if (t2 instanceof de)
          return true;
        if (t2 instanceof fe)
          return true;
        if (Array.isArray(t2)) {
          for (const e2 of t2)
            if (!me(e2))
              return false;
          return true;
        }
        if ("object" == typeof t2) {
          for (const e2 in t2)
            if (!me(t2[e2]))
              return false;
          return true;
        }
        return false;
      }
      function ge(t2) {
        if (null === t2)
          return Gt;
        if ("string" == typeof t2)
          return Kt;
        if ("boolean" == typeof t2)
          return Yt;
        if ("number" == typeof t2)
          return Xt;
        if (t2 instanceof ce)
          return Ht;
        if (t2 instanceof he)
          return Qt;
        if (t2 instanceof de)
          return te;
        if (t2 instanceof fe)
          return ee;
        if (Array.isArray(t2)) {
          const e2 = t2.length;
          let r2;
          for (const e3 of t2) {
            const t3 = ge(e3);
            if (r2) {
              if (r2 === t3)
                continue;
              r2 = Wt;
              break;
            }
            r2 = t3;
          }
          return re(r2 || Wt, e2);
        }
        return Jt;
      }
      function xe(t2) {
        const e2 = typeof t2;
        return null === t2 ? "" : "string" === e2 || "number" === e2 || "boolean" === e2 ? String(t2) : t2 instanceof ce || t2 instanceof de || t2 instanceof fe ? t2.toString() : JSON.stringify(t2);
      }
      class ve {
        constructor(t2, e2) {
          this.type = t2, this.value = e2;
        }
        static parse(t2, e2) {
          if (2 !== t2.length)
            return e2.error(`'literal' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
          if (!me(t2[1]))
            return e2.error("invalid value");
          const r2 = t2[1];
          let n2 = ge(r2);
          const i2 = e2.expectedType;
          return "array" !== n2.kind || 0 !== n2.N || !i2 || "array" !== i2.kind || "number" == typeof i2.N && 0 !== i2.N || (n2 = i2), new ve(n2, r2);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
        serialize() {
          return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof ce ? ["rgba"].concat(this.value.toArray()) : this.value instanceof de ? this.value.serialize() : this.value;
        }
      }
      class be {
        constructor(t2) {
          this.name = "ExpressionEvaluationError", this.message = t2;
        }
        toJSON() {
          return this.message;
        }
      }
      const we = { string: Kt, number: Xt, boolean: Yt, object: Jt };
      class _e {
        constructor(t2, e2) {
          this.type = t2, this.args = e2;
        }
        static parse(t2, e2) {
          if (t2.length < 2)
            return e2.error("Expected at least one argument.");
          let r2, n2 = 1;
          const i2 = t2[0];
          if ("array" === i2) {
            let i3, s3;
            if (t2.length > 2) {
              const r3 = t2[1];
              if ("string" != typeof r3 || !(r3 in we) || "object" === r3)
                return e2.error('The item type argument of "array" must be one of string, number, boolean', 1);
              i3 = we[r3], n2++;
            } else
              i3 = Wt;
            if (t2.length > 3) {
              if (null !== t2[2] && ("number" != typeof t2[2] || t2[2] < 0 || t2[2] !== Math.floor(t2[2])))
                return e2.error('The length argument to "array" must be a positive integer literal', 2);
              s3 = t2[2], n2++;
            }
            r2 = re(i3, s3);
          } else
            r2 = we[i2];
          const s2 = [];
          for (; n2 < t2.length; n2++) {
            const r3 = e2.parse(t2[n2], n2, Wt);
            if (!r3)
              return null;
            s2.push(r3);
          }
          return new _e(r2, s2);
        }
        evaluate(t2) {
          for (let e2 = 0; e2 < this.args.length; e2++) {
            const r2 = this.args[e2].evaluate(t2);
            if (!se(this.type, ge(r2)))
              return r2;
            if (e2 === this.args.length - 1)
              throw new be(`Expected value to be of type ${ne(this.type)}, but found ${ne(ge(r2))} instead.`);
          }
          return null;
        }
        eachChild(t2) {
          this.args.forEach(t2);
        }
        outputDefined() {
          return this.args.every((t2) => t2.outputDefined());
        }
        serialize() {
          const t2 = this.type, e2 = [t2.kind];
          if ("array" === t2.kind) {
            const r2 = t2.itemType;
            if ("string" === r2.kind || "number" === r2.kind || "boolean" === r2.kind) {
              e2.push(r2.kind);
              const n2 = t2.N;
              ("number" == typeof n2 || this.args.length > 1) && e2.push(n2);
            }
          }
          return e2.concat(this.args.map((t3) => t3.serialize()));
        }
      }
      class Ae {
        constructor(t2) {
          this.type = te, this.sections = t2;
        }
        static parse(t2, e2) {
          if (t2.length < 2)
            return e2.error("Expected at least one argument.");
          const r2 = t2[1];
          if (!Array.isArray(r2) && "object" == typeof r2)
            return e2.error("First argument must be an image or text section.");
          const n2 = [];
          let i2 = false;
          for (let r3 = 1; r3 <= t2.length - 1; ++r3) {
            const s2 = t2[r3];
            if (i2 && "object" == typeof s2 && !Array.isArray(s2)) {
              i2 = false;
              let t3 = null;
              if (s2["font-scale"] && (t3 = e2.parse(s2["font-scale"], 1, Xt), !t3))
                return null;
              let r4 = null;
              if (s2["text-font"] && (r4 = e2.parse(s2["text-font"], 1, re(Kt)), !r4))
                return null;
              let a2 = null;
              if (s2["text-color"] && (a2 = e2.parse(s2["text-color"], 1, Ht), !a2))
                return null;
              const o2 = n2[n2.length - 1];
              o2.scale = t3, o2.font = r4, o2.textColor = a2;
            } else {
              const s3 = e2.parse(t2[r3], 1, Wt);
              if (!s3)
                return null;
              const a2 = s3.type.kind;
              if ("string" !== a2 && "value" !== a2 && "null" !== a2 && "resolvedImage" !== a2)
                return e2.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              i2 = true, n2.push({ content: s3, scale: null, font: null, textColor: null });
            }
          }
          return new Ae(n2);
        }
        evaluate(t2) {
          return new de(this.sections.map((e2) => {
            const r2 = e2.content.evaluate(t2);
            return ge(r2) === ee ? new pe("", r2, null, null, null) : new pe(xe(r2), null, e2.scale ? e2.scale.evaluate(t2) : null, e2.font ? e2.font.evaluate(t2).join(",") : null, e2.textColor ? e2.textColor.evaluate(t2) : null);
          }));
        }
        eachChild(t2) {
          for (const e2 of this.sections)
            t2(e2.content), e2.scale && t2(e2.scale), e2.font && t2(e2.font), e2.textColor && t2(e2.textColor);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const t2 = ["format"];
          for (const e2 of this.sections) {
            t2.push(e2.content.serialize());
            const r2 = {};
            e2.scale && (r2["font-scale"] = e2.scale.serialize()), e2.font && (r2["text-font"] = e2.font.serialize()), e2.textColor && (r2["text-color"] = e2.textColor.serialize()), t2.push(r2);
          }
          return t2;
        }
      }
      class ke {
        constructor(t2) {
          this.type = ee, this.input = t2;
        }
        static parse(t2, e2) {
          if (2 !== t2.length)
            return e2.error("Expected two arguments.");
          const r2 = e2.parse(t2[1], 1, Kt);
          return r2 ? new ke(r2) : e2.error("No image name provided.");
        }
        evaluate(t2) {
          const e2 = this.input.evaluate(t2), r2 = fe.fromString(e2);
          return r2 && t2.availableImages && (r2.available = t2.availableImages.indexOf(e2) > -1), r2;
        }
        eachChild(t2) {
          t2(this.input);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return ["image", this.input.serialize()];
        }
      }
      const Se = { "to-boolean": Yt, "to-color": Ht, "to-number": Xt, "to-string": Kt };
      class Ie {
        constructor(t2, e2) {
          this.type = t2, this.args = e2;
        }
        static parse(t2, e2) {
          if (t2.length < 2)
            return e2.error("Expected at least one argument.");
          const r2 = t2[0];
          if (("to-boolean" === r2 || "to-string" === r2) && 2 !== t2.length)
            return e2.error("Expected one argument.");
          const n2 = Se[r2], i2 = [];
          for (let r3 = 1; r3 < t2.length; r3++) {
            const n3 = e2.parse(t2[r3], r3, Wt);
            if (!n3)
              return null;
            i2.push(n3);
          }
          return new Ie(n2, i2);
        }
        evaluate(t2) {
          if ("boolean" === this.type.kind)
            return Boolean(this.args[0].evaluate(t2));
          if ("color" === this.type.kind) {
            let e2, r2;
            for (const n2 of this.args) {
              if (e2 = n2.evaluate(t2), r2 = null, e2 instanceof ce)
                return e2;
              if ("string" == typeof e2) {
                const r3 = t2.parseColor(e2);
                if (r3)
                  return r3;
              } else if (Array.isArray(e2) && (r2 = e2.length < 3 || e2.length > 4 ? `Invalid rbga value ${JSON.stringify(e2)}: expected an array containing either three or four numeric values.` : ye(e2[0], e2[1], e2[2], e2[3]), !r2))
                return new ce(e2[0] / 255, e2[1] / 255, e2[2] / 255, e2[3]);
            }
            throw new be(r2 || `Could not parse color from value '${"string" == typeof e2 ? e2 : String(JSON.stringify(e2))}'`);
          }
          if ("number" === this.type.kind) {
            let e2 = null;
            for (const r2 of this.args) {
              if (e2 = r2.evaluate(t2), null === e2)
                return 0;
              const n2 = Number(e2);
              if (!isNaN(n2))
                return n2;
            }
            throw new be(`Could not convert ${JSON.stringify(e2)} to number.`);
          }
          return "formatted" === this.type.kind ? de.fromString(xe(this.args[0].evaluate(t2))) : "resolvedImage" === this.type.kind ? fe.fromString(xe(this.args[0].evaluate(t2))) : xe(this.args[0].evaluate(t2));
        }
        eachChild(t2) {
          this.args.forEach(t2);
        }
        outputDefined() {
          return this.args.every((t2) => t2.outputDefined());
        }
        serialize() {
          if ("formatted" === this.type.kind)
            return new Ae([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
          if ("resolvedImage" === this.type.kind)
            return new ke(this.args[0]).serialize();
          const t2 = [`to-${this.type.kind}`];
          return this.eachChild((e2) => {
            t2.push(e2.serialize());
          }), t2;
        }
      }
      const ze = ["Unknown", "Point", "LineString", "Polygon"];
      class Te {
        constructor() {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
        }
        id() {
          return this.feature && "id" in this.feature ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? "number" == typeof this.feature.type ? ze[this.feature.type] : this.feature.type : null;
        }
        geometry() {
          return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return this.feature && this.feature.properties || {};
        }
        parseColor(t2) {
          let e2 = this._parseColorCache[t2];
          return e2 || (e2 = this._parseColorCache[t2] = ce.parse(t2)), e2;
        }
      }
      class Me {
        constructor(t2, e2, r2, n2) {
          this.name = t2, this.type = e2, this._evaluate = r2, this.args = n2;
        }
        evaluate(t2) {
          return this._evaluate(t2, this.args);
        }
        eachChild(t2) {
          this.args.forEach(t2);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return [this.name].concat(this.args.map((t2) => t2.serialize()));
        }
        static parse(t2, e2) {
          const r2 = t2[0], n2 = Me.definitions[r2];
          if (!n2)
            return e2.error(`Unknown expression "${r2}". If you wanted a literal array, use ["literal", [...]].`, 0);
          const i2 = Array.isArray(n2) ? n2[0] : n2.type, s2 = Array.isArray(n2) ? [[n2[1], n2[2]]] : n2.overloads, a2 = s2.filter(([e3]) => !Array.isArray(e3) || e3.length === t2.length - 1);
          let o2 = null;
          for (const [n3, s3] of a2) {
            o2 = new We(e2.registry, e2.path, null, e2.scope);
            const a3 = [];
            let l2 = false;
            for (let e3 = 1; e3 < t2.length; e3++) {
              const r3 = t2[e3], i3 = Array.isArray(n3) ? n3[e3 - 1] : n3.type, s4 = o2.parse(r3, 1 + a3.length, i3);
              if (!s4) {
                l2 = true;
                break;
              }
              a3.push(s4);
            }
            if (!l2)
              if (Array.isArray(n3) && n3.length !== a3.length)
                o2.error(`Expected ${n3.length} arguments, but found ${a3.length} instead.`);
              else {
                for (let t3 = 0; t3 < a3.length; t3++) {
                  const e3 = Array.isArray(n3) ? n3[t3] : n3.type, r3 = a3[t3];
                  o2.concat(t3 + 1).checkSubtype(e3, r3.type);
                }
                if (0 === o2.errors.length)
                  return new Me(r2, i2, s3, a3);
              }
          }
          if (1 === a2.length)
            e2.errors.push(...o2.errors);
          else {
            const r3 = (a2.length ? a2 : s2).map(([t3]) => {
              return e3 = t3, Array.isArray(e3) ? `(${e3.map(ne).join(", ")})` : `(${ne(e3.type)}...)`;
              var e3;
            }).join(" | "), n3 = [];
            for (let r4 = 1; r4 < t2.length; r4++) {
              const i3 = e2.parse(t2[r4], 1 + n3.length);
              if (!i3)
                return null;
              n3.push(ne(i3.type));
            }
            e2.error(`Expected arguments of type ${r3}, but found (${n3.join(", ")}) instead.`);
          }
          return null;
        }
        static register(t2, e2) {
          Me.definitions = e2;
          for (const r2 in e2)
            t2[r2] = Me;
        }
      }
      class Ee {
        constructor(t2, e2, r2) {
          this.type = Qt, this.locale = r2, this.caseSensitive = t2, this.diacriticSensitive = e2;
        }
        static parse(t2, e2) {
          if (2 !== t2.length)
            return e2.error("Expected one argument.");
          const r2 = t2[1];
          if ("object" != typeof r2 || Array.isArray(r2))
            return e2.error("Collator options argument must be an object.");
          const n2 = e2.parse(void 0 !== r2["case-sensitive"] && r2["case-sensitive"], 1, Yt);
          if (!n2)
            return null;
          const i2 = e2.parse(void 0 !== r2["diacritic-sensitive"] && r2["diacritic-sensitive"], 1, Yt);
          if (!i2)
            return null;
          let s2 = null;
          return r2.locale && (s2 = e2.parse(r2.locale, 1, Kt), !s2) ? null : new Ee(n2, i2, s2);
        }
        evaluate(t2) {
          return new he(this.caseSensitive.evaluate(t2), this.diacriticSensitive.evaluate(t2), this.locale ? this.locale.evaluate(t2) : null);
        }
        eachChild(t2) {
          t2(this.caseSensitive), t2(this.diacriticSensitive), this.locale && t2(this.locale);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const t2 = {};
          return t2["case-sensitive"] = this.caseSensitive.serialize(), t2["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t2.locale = this.locale.serialize()), ["collator", t2];
        }
      }
      const Ce = 8192;
      function Be(t2, e2) {
        t2[0] = Math.min(t2[0], e2[0]), t2[1] = Math.min(t2[1], e2[1]), t2[2] = Math.max(t2[2], e2[0]), t2[3] = Math.max(t2[3], e2[1]);
      }
      function De(t2, e2) {
        return !(t2[0] <= e2[0] || t2[2] >= e2[2] || t2[1] <= e2[1] || t2[3] >= e2[3]);
      }
      function Pe(t2, e2) {
        const r2 = (180 + t2[0]) / 360, n2 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2[1] * Math.PI / 360))) / 360, i2 = Math.pow(2, e2.z);
        return [Math.round(r2 * i2 * Ce), Math.round(n2 * i2 * Ce)];
      }
      function Ve(t2, e2, r2) {
        const n2 = t2[0] - e2[0], i2 = t2[1] - e2[1], s2 = t2[0] - r2[0], a2 = t2[1] - r2[1];
        return n2 * a2 - s2 * i2 == 0 && n2 * s2 <= 0 && i2 * a2 <= 0;
      }
      function Le(t2, e2) {
        let r2 = false;
        for (let a2 = 0, o2 = e2.length; a2 < o2; a2++) {
          const o3 = e2[a2];
          for (let e3 = 0, a3 = o3.length; e3 < a3 - 1; e3++) {
            if (Ve(t2, o3[e3], o3[e3 + 1]))
              return false;
            (i2 = o3[e3])[1] > (n2 = t2)[1] != (s2 = o3[e3 + 1])[1] > n2[1] && n2[0] < (s2[0] - i2[0]) * (n2[1] - i2[1]) / (s2[1] - i2[1]) + i2[0] && (r2 = !r2);
          }
        }
        var n2, i2, s2;
        return r2;
      }
      function Fe(t2, e2) {
        for (let r2 = 0; r2 < e2.length; r2++)
          if (Le(t2, e2[r2]))
            return true;
        return false;
      }
      function Re(t2, e2, r2, n2) {
        const i2 = n2[0] - r2[0], s2 = n2[1] - r2[1], a2 = (t2[0] - r2[0]) * s2 - i2 * (t2[1] - r2[1]), o2 = (e2[0] - r2[0]) * s2 - i2 * (e2[1] - r2[1]);
        return a2 > 0 && o2 < 0 || a2 < 0 && o2 > 0;
      }
      function $e(t2, e2, r2) {
        for (const u2 of r2)
          for (let r3 = 0; r3 < u2.length - 1; ++r3)
            if (0 != (o2 = [(a2 = u2[r3 + 1])[0] - (s2 = u2[r3])[0], a2[1] - s2[1]])[0] * (l2 = [(i2 = e2)[0] - (n2 = t2)[0], i2[1] - n2[1]])[1] - o2[1] * l2[0] && Re(n2, i2, s2, a2) && Re(s2, a2, n2, i2))
              return true;
        var n2, i2, s2, a2, o2, l2;
        return false;
      }
      function Ue(t2, e2) {
        for (let r2 = 0; r2 < t2.length; ++r2)
          if (!Le(t2[r2], e2))
            return false;
        for (let r2 = 0; r2 < t2.length - 1; ++r2)
          if ($e(t2[r2], t2[r2 + 1], e2))
            return false;
        return true;
      }
      function Oe(t2, e2) {
        for (let r2 = 0; r2 < e2.length; r2++)
          if (Ue(t2, e2[r2]))
            return true;
        return false;
      }
      function qe(t2, e2, r2) {
        const n2 = [];
        for (let i2 = 0; i2 < t2.length; i2++) {
          const s2 = [];
          for (let n3 = 0; n3 < t2[i2].length; n3++) {
            const a2 = Pe(t2[i2][n3], r2);
            Be(e2, a2), s2.push(a2);
          }
          n2.push(s2);
        }
        return n2;
      }
      function je(t2, e2, r2) {
        const n2 = [];
        for (let i2 = 0; i2 < t2.length; i2++) {
          const s2 = qe(t2[i2], e2, r2);
          n2.push(s2);
        }
        return n2;
      }
      function Ne(t2, e2, r2, n2) {
        if (t2[0] < r2[0] || t2[0] > r2[2]) {
          const e3 = 0.5 * n2;
          let i2 = t2[0] - r2[0] > e3 ? -n2 : r2[0] - t2[0] > e3 ? n2 : 0;
          0 === i2 && (i2 = t2[0] - r2[2] > e3 ? -n2 : r2[2] - t2[0] > e3 ? n2 : 0), t2[0] += i2;
        }
        Be(e2, t2);
      }
      function Ze(t2, e2, r2, n2) {
        const i2 = Math.pow(2, n2.z) * Ce, s2 = [n2.x * Ce, n2.y * Ce], a2 = [];
        for (const n3 of t2)
          for (const t3 of n3) {
            const n4 = [t3.x + s2[0], t3.y + s2[1]];
            Ne(n4, e2, r2, i2), a2.push(n4);
          }
        return a2;
      }
      function Ge(t2, e2, r2, n2) {
        const i2 = Math.pow(2, n2.z) * Ce, s2 = [n2.x * Ce, n2.y * Ce], a2 = [];
        for (const r3 of t2) {
          const t3 = [];
          for (const n3 of r3) {
            const r4 = [n3.x + s2[0], n3.y + s2[1]];
            Be(e2, r4), t3.push(r4);
          }
          a2.push(t3);
        }
        if (e2[2] - e2[0] <= i2 / 2) {
          (o2 = e2)[0] = o2[1] = 1 / 0, o2[2] = o2[3] = -1 / 0;
          for (const t3 of a2)
            for (const n3 of t3)
              Ne(n3, e2, r2, i2);
        }
        var o2;
        return a2;
      }
      class Xe {
        constructor(t2, e2) {
          this.type = Yt, this.geojson = t2, this.geometries = e2;
        }
        static parse(t2, e2) {
          if (2 !== t2.length)
            return e2.error(`'within' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
          if (me(t2[1])) {
            const e3 = t2[1];
            if ("FeatureCollection" === e3.type)
              for (let t3 = 0; t3 < e3.features.length; ++t3) {
                const r2 = e3.features[t3].geometry.type;
                if ("Polygon" === r2 || "MultiPolygon" === r2)
                  return new Xe(e3, e3.features[t3].geometry);
              }
            else if ("Feature" === e3.type) {
              const t3 = e3.geometry.type;
              if ("Polygon" === t3 || "MultiPolygon" === t3)
                return new Xe(e3, e3.geometry);
            } else if ("Polygon" === e3.type || "MultiPolygon" === e3.type)
              return new Xe(e3, e3);
          }
          return e2.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(t2) {
          if (null != t2.geometry() && null != t2.canonicalID()) {
            if ("Point" === t2.geometryType())
              return function(t3, e2) {
                const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                if ("Polygon" === e2.type) {
                  const s2 = qe(e2.coordinates, n2, i2), a2 = Ze(t3.geometry(), r2, n2, i2);
                  if (!De(r2, n2))
                    return false;
                  for (const t4 of a2)
                    if (!Le(t4, s2))
                      return false;
                }
                if ("MultiPolygon" === e2.type) {
                  const s2 = je(e2.coordinates, n2, i2), a2 = Ze(t3.geometry(), r2, n2, i2);
                  if (!De(r2, n2))
                    return false;
                  for (const t4 of a2)
                    if (!Fe(t4, s2))
                      return false;
                }
                return true;
              }(t2, this.geometries);
            if ("LineString" === t2.geometryType())
              return function(t3, e2) {
                const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                if ("Polygon" === e2.type) {
                  const s2 = qe(e2.coordinates, n2, i2), a2 = Ge(t3.geometry(), r2, n2, i2);
                  if (!De(r2, n2))
                    return false;
                  for (const t4 of a2)
                    if (!Ue(t4, s2))
                      return false;
                }
                if ("MultiPolygon" === e2.type) {
                  const s2 = je(e2.coordinates, n2, i2), a2 = Ge(t3.geometry(), r2, n2, i2);
                  if (!De(r2, n2))
                    return false;
                  for (const t4 of a2)
                    if (!Oe(t4, s2))
                      return false;
                }
                return true;
              }(t2, this.geometries);
          }
          return false;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
        serialize() {
          return ["within", this.geojson];
        }
      }
      function Ke(t2) {
        if (t2 instanceof Me) {
          if ("get" === t2.name && 1 === t2.args.length)
            return false;
          if ("feature-state" === t2.name)
            return false;
          if ("has" === t2.name && 1 === t2.args.length)
            return false;
          if ("properties" === t2.name || "geometry-type" === t2.name || "id" === t2.name)
            return false;
          if (/^filter-/.test(t2.name))
            return false;
        }
        if (t2 instanceof Xe)
          return false;
        let e2 = true;
        return t2.eachChild((t3) => {
          e2 && !Ke(t3) && (e2 = false);
        }), e2;
      }
      function Ye(t2) {
        if (t2 instanceof Me && "feature-state" === t2.name)
          return false;
        let e2 = true;
        return t2.eachChild((t3) => {
          e2 && !Ye(t3) && (e2 = false);
        }), e2;
      }
      function He(t2, e2) {
        if (t2 instanceof Me && e2.indexOf(t2.name) >= 0)
          return false;
        let r2 = true;
        return t2.eachChild((t3) => {
          r2 && !He(t3, e2) && (r2 = false);
        }), r2;
      }
      class Je {
        constructor(t2, e2) {
          this.type = e2.type, this.name = t2, this.boundExpression = e2;
        }
        static parse(t2, e2) {
          if (2 !== t2.length || "string" != typeof t2[1])
            return e2.error("'var' expression requires exactly one string literal argument.");
          const r2 = t2[1];
          return e2.scope.has(r2) ? new Je(r2, e2.scope.get(r2)) : e2.error(`Unknown variable "${r2}". Make sure "${r2}" has been bound in an enclosing "let" expression before using it.`, 1);
        }
        evaluate(t2) {
          return this.boundExpression.evaluate(t2);
        }
        eachChild() {
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return ["var", this.name];
        }
      }
      class We {
        constructor(t2, e2 = [], r2, n2 = new Zt(), i2 = []) {
          this.registry = t2, this.path = e2, this.key = e2.map((t3) => `[${t3}]`).join(""), this.scope = n2, this.errors = i2, this.expectedType = r2;
        }
        parse(t2, e2, r2, n2, i2 = {}) {
          return e2 ? this.concat(e2, r2, n2)._parse(t2, i2) : this._parse(t2, i2);
        }
        _parse(t2, e2) {
          function r2(t3, e3, r3) {
            return "assert" === r3 ? new _e(e3, [t3]) : "coerce" === r3 ? new Ie(e3, [t3]) : t3;
          }
          if (null !== t2 && "string" != typeof t2 && "boolean" != typeof t2 && "number" != typeof t2 || (t2 = ["literal", t2]), Array.isArray(t2)) {
            if (0 === t2.length)
              return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            const n2 = t2[0];
            if ("string" != typeof n2)
              return this.error(`Expression name must be a string, but found ${typeof n2} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
            const i2 = this.registry[n2];
            if (i2) {
              let n3 = i2.parse(t2, this);
              if (!n3)
                return null;
              if (this.expectedType) {
                const t3 = this.expectedType, i3 = n3.type;
                if ("string" !== t3.kind && "number" !== t3.kind && "boolean" !== t3.kind && "object" !== t3.kind && "array" !== t3.kind || "value" !== i3.kind)
                  if ("color" !== t3.kind && "formatted" !== t3.kind && "resolvedImage" !== t3.kind || "value" !== i3.kind && "string" !== i3.kind) {
                    if (this.checkSubtype(t3, i3))
                      return null;
                  } else
                    n3 = r2(n3, t3, e2.typeAnnotation || "coerce");
                else
                  n3 = r2(n3, t3, e2.typeAnnotation || "assert");
              }
              if (!(n3 instanceof ve) && "resolvedImage" !== n3.type.kind && Qe(n3)) {
                const t3 = new Te();
                try {
                  n3 = new ve(n3.type, n3.evaluate(t3));
                } catch (t4) {
                  return this.error(t4.message), null;
                }
              }
              return n3;
            }
            return this.error(`Unknown expression "${n2}". If you wanted a literal array, use ["literal", [...]].`, 0);
          }
          return this.error(void 0 === t2 ? "'undefined' value invalid. Use null instead." : "object" == typeof t2 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t2} instead.`);
        }
        concat(t2, e2, r2) {
          const n2 = "number" == typeof t2 ? this.path.concat(t2) : this.path, i2 = r2 ? this.scope.concat(r2) : this.scope;
          return new We(this.registry, n2, e2 || null, i2, this.errors);
        }
        error(t2, ...e2) {
          const r2 = `${this.key}${e2.map((t3) => `[${t3}]`).join("")}`;
          this.errors.push(new Nt(r2, t2));
        }
        checkSubtype(t2, e2) {
          const r2 = se(t2, e2);
          return r2 && this.error(r2), r2;
        }
      }
      function Qe(t2) {
        if (t2 instanceof Je)
          return Qe(t2.boundExpression);
        if (t2 instanceof Me && "error" === t2.name)
          return false;
        if (t2 instanceof Ee)
          return false;
        if (t2 instanceof Xe)
          return false;
        const e2 = t2 instanceof Ie || t2 instanceof _e;
        let r2 = true;
        return t2.eachChild((t3) => {
          r2 = e2 ? r2 && Qe(t3) : r2 && t3 instanceof ve;
        }), !!r2 && Ke(t2) && He(t2, ["zoom", "heatmap-density", "line-progress", "sky-radial-progress", "accumulated", "is-supported-script"]);
      }
      function tr(t2, e2) {
        const r2 = t2.length - 1;
        let n2, i2, s2 = 0, a2 = r2, o2 = 0;
        for (; s2 <= a2; )
          if (o2 = Math.floor((s2 + a2) / 2), n2 = t2[o2], i2 = t2[o2 + 1], n2 <= e2) {
            if (o2 === r2 || e2 < i2)
              return o2;
            s2 = o2 + 1;
          } else {
            if (!(n2 > e2))
              throw new be("Input is not a number.");
            a2 = o2 - 1;
          }
        return 0;
      }
      class er {
        constructor(t2, e2, r2) {
          this.type = t2, this.input = e2, this.labels = [], this.outputs = [];
          for (const [t3, e3] of r2)
            this.labels.push(t3), this.outputs.push(e3);
        }
        static parse(t2, e2) {
          if (t2.length - 1 < 4)
            return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
          if ((t2.length - 1) % 2 != 0)
            return e2.error("Expected an even number of arguments.");
          const r2 = e2.parse(t2[1], 1, Xt);
          if (!r2)
            return null;
          const n2 = [];
          let i2 = null;
          e2.expectedType && "value" !== e2.expectedType.kind && (i2 = e2.expectedType);
          for (let r3 = 1; r3 < t2.length; r3 += 2) {
            const s2 = 1 === r3 ? -1 / 0 : t2[r3], a2 = t2[r3 + 1], o2 = r3, l2 = r3 + 1;
            if ("number" != typeof s2)
              return e2.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o2);
            if (n2.length && n2[n2.length - 1][0] >= s2)
              return e2.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o2);
            const u2 = e2.parse(a2, l2, i2);
            if (!u2)
              return null;
            i2 = i2 || u2.type, n2.push([s2, u2]);
          }
          return new er(i2, r2, n2);
        }
        evaluate(t2) {
          const e2 = this.labels, r2 = this.outputs;
          if (1 === e2.length)
            return r2[0].evaluate(t2);
          const n2 = this.input.evaluate(t2);
          if (n2 <= e2[0])
            return r2[0].evaluate(t2);
          const i2 = e2.length;
          return n2 >= e2[i2 - 1] ? r2[i2 - 1].evaluate(t2) : r2[tr(e2, n2)].evaluate(t2);
        }
        eachChild(t2) {
          t2(this.input);
          for (const e2 of this.outputs)
            t2(e2);
        }
        outputDefined() {
          return this.outputs.every((t2) => t2.outputDefined());
        }
        serialize() {
          const t2 = ["step", this.input.serialize()];
          for (let e2 = 0; e2 < this.labels.length; e2++)
            e2 > 0 && t2.push(this.labels[e2]), t2.push(this.outputs[e2].serialize());
          return t2;
        }
      }
      function rr(t2, e2, r2) {
        return t2 * (1 - r2) + e2 * r2;
      }
      var nr = Object.freeze({ __proto__: null, number: rr, color: function(t2, e2, r2) {
        return new ce(rr(t2.r, e2.r, r2), rr(t2.g, e2.g, r2), rr(t2.b, e2.b, r2), rr(t2.a, e2.a, r2));
      }, array: function(t2, e2, r2) {
        return t2.map((t3, n2) => rr(t3, e2[n2], r2));
      } });
      const ir = 0.95047, sr = 1.08883, ar = 4 / 29, or = 6 / 29, lr = 3 * or * or, ur = Math.PI / 180, cr = 180 / Math.PI;
      function hr(t2) {
        return t2 > 0.008856451679035631 ? Math.pow(t2, 1 / 3) : t2 / lr + ar;
      }
      function pr(t2) {
        return t2 > or ? t2 * t2 * t2 : lr * (t2 - ar);
      }
      function dr(t2) {
        return 255 * (t2 <= 31308e-7 ? 12.92 * t2 : 1.055 * Math.pow(t2, 1 / 2.4) - 0.055);
      }
      function fr(t2) {
        return (t2 /= 255) <= 0.04045 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4);
      }
      function yr(t2) {
        const e2 = fr(t2.r), r2 = fr(t2.g), n2 = fr(t2.b), i2 = hr((0.4124564 * e2 + 0.3575761 * r2 + 0.1804375 * n2) / ir), s2 = hr((0.2126729 * e2 + 0.7151522 * r2 + 0.072175 * n2) / 1);
        return { l: 116 * s2 - 16, a: 500 * (i2 - s2), b: 200 * (s2 - hr((0.0193339 * e2 + 0.119192 * r2 + 0.9503041 * n2) / sr)), alpha: t2.a };
      }
      function mr(t2) {
        let e2 = (t2.l + 16) / 116, r2 = isNaN(t2.a) ? e2 : e2 + t2.a / 500, n2 = isNaN(t2.b) ? e2 : e2 - t2.b / 200;
        return e2 = 1 * pr(e2), r2 = ir * pr(r2), n2 = sr * pr(n2), new ce(dr(3.2404542 * r2 - 1.5371385 * e2 - 0.4985314 * n2), dr(-0.969266 * r2 + 1.8760108 * e2 + 0.041556 * n2), dr(0.0556434 * r2 - 0.2040259 * e2 + 1.0572252 * n2), t2.alpha);
      }
      function gr(t2, e2, r2) {
        const n2 = e2 - t2;
        return t2 + r2 * (n2 > 180 || n2 < -180 ? n2 - 360 * Math.round(n2 / 360) : n2);
      }
      const xr = { forward: yr, reverse: mr, interpolate: function(t2, e2, r2) {
        return { l: rr(t2.l, e2.l, r2), a: rr(t2.a, e2.a, r2), b: rr(t2.b, e2.b, r2), alpha: rr(t2.alpha, e2.alpha, r2) };
      } }, vr = { forward: function(t2) {
        const { l: e2, a: r2, b: n2 } = yr(t2), i2 = Math.atan2(n2, r2) * cr;
        return { h: i2 < 0 ? i2 + 360 : i2, c: Math.sqrt(r2 * r2 + n2 * n2), l: e2, alpha: t2.a };
      }, reverse: function(t2) {
        const e2 = t2.h * ur, r2 = t2.c;
        return mr({ l: t2.l, a: Math.cos(e2) * r2, b: Math.sin(e2) * r2, alpha: t2.alpha });
      }, interpolate: function(t2, e2, r2) {
        return { h: gr(t2.h, e2.h, r2), c: rr(t2.c, e2.c, r2), l: rr(t2.l, e2.l, r2), alpha: rr(t2.alpha, e2.alpha, r2) };
      } };
      var br = Object.freeze({ __proto__: null, lab: xr, hcl: vr });
      class wr {
        constructor(t2, e2, r2, n2, i2) {
          this.type = t2, this.operator = e2, this.interpolation = r2, this.input = n2, this.labels = [], this.outputs = [];
          for (const [t3, e3] of i2)
            this.labels.push(t3), this.outputs.push(e3);
        }
        static interpolationFactor(t2, e2, n2, i2) {
          let s2 = 0;
          if ("exponential" === t2.name)
            s2 = _r(e2, t2.base, n2, i2);
          else if ("linear" === t2.name)
            s2 = _r(e2, 1, n2, i2);
          else if ("cubic-bezier" === t2.name) {
            const a2 = t2.controlPoints;
            s2 = new r(a2[0], a2[1], a2[2], a2[3]).solve(_r(e2, 1, n2, i2));
          }
          return s2;
        }
        static parse(t2, e2) {
          let [r2, n2, i2, ...s2] = t2;
          if (!Array.isArray(n2) || 0 === n2.length)
            return e2.error("Expected an interpolation type expression.", 1);
          if ("linear" === n2[0])
            n2 = { name: "linear" };
          else if ("exponential" === n2[0]) {
            const t3 = n2[1];
            if ("number" != typeof t3)
              return e2.error("Exponential interpolation requires a numeric base.", 1, 1);
            n2 = { name: "exponential", base: t3 };
          } else {
            if ("cubic-bezier" !== n2[0])
              return e2.error(`Unknown interpolation type ${String(n2[0])}`, 1, 0);
            {
              const t3 = n2.slice(1);
              if (4 !== t3.length || t3.some((t4) => "number" != typeof t4 || t4 < 0 || t4 > 1))
                return e2.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
              n2 = { name: "cubic-bezier", controlPoints: t3 };
            }
          }
          if (t2.length - 1 < 4)
            return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
          if ((t2.length - 1) % 2 != 0)
            return e2.error("Expected an even number of arguments.");
          if (i2 = e2.parse(i2, 2, Xt), !i2)
            return null;
          const a2 = [];
          let o2 = null;
          "interpolate-hcl" === r2 || "interpolate-lab" === r2 ? o2 = Ht : e2.expectedType && "value" !== e2.expectedType.kind && (o2 = e2.expectedType);
          for (let t3 = 0; t3 < s2.length; t3 += 2) {
            const r3 = s2[t3], n3 = s2[t3 + 1], i3 = t3 + 3, l2 = t3 + 4;
            if ("number" != typeof r3)
              return e2.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i3);
            if (a2.length && a2[a2.length - 1][0] >= r3)
              return e2.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i3);
            const u2 = e2.parse(n3, l2, o2);
            if (!u2)
              return null;
            o2 = o2 || u2.type, a2.push([r3, u2]);
          }
          return "number" === o2.kind || "color" === o2.kind || "array" === o2.kind && "number" === o2.itemType.kind && "number" == typeof o2.N ? new wr(o2, r2, n2, i2, a2) : e2.error(`Type ${ne(o2)} is not interpolatable.`);
        }
        evaluate(t2) {
          const e2 = this.labels, r2 = this.outputs;
          if (1 === e2.length)
            return r2[0].evaluate(t2);
          const n2 = this.input.evaluate(t2);
          if (n2 <= e2[0])
            return r2[0].evaluate(t2);
          const i2 = e2.length;
          if (n2 >= e2[i2 - 1])
            return r2[i2 - 1].evaluate(t2);
          const s2 = tr(e2, n2), a2 = wr.interpolationFactor(this.interpolation, n2, e2[s2], e2[s2 + 1]), o2 = r2[s2].evaluate(t2), l2 = r2[s2 + 1].evaluate(t2);
          return "interpolate" === this.operator ? nr[this.type.kind.toLowerCase()](o2, l2, a2) : "interpolate-hcl" === this.operator ? vr.reverse(vr.interpolate(vr.forward(o2), vr.forward(l2), a2)) : xr.reverse(xr.interpolate(xr.forward(o2), xr.forward(l2), a2));
        }
        eachChild(t2) {
          t2(this.input);
          for (const e2 of this.outputs)
            t2(e2);
        }
        outputDefined() {
          return this.outputs.every((t2) => t2.outputDefined());
        }
        serialize() {
          let t2;
          t2 = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
          const e2 = [this.operator, t2, this.input.serialize()];
          for (let t3 = 0; t3 < this.labels.length; t3++)
            e2.push(this.labels[t3], this.outputs[t3].serialize());
          return e2;
        }
      }
      function _r(t2, e2, r2, n2) {
        const i2 = n2 - r2, s2 = t2 - r2;
        return 0 === i2 ? 0 : 1 === e2 ? s2 / i2 : (Math.pow(e2, s2) - 1) / (Math.pow(e2, i2) - 1);
      }
      class Ar {
        constructor(t2, e2) {
          this.type = t2, this.args = e2;
        }
        static parse(t2, e2) {
          if (t2.length < 2)
            return e2.error("Expectected at least one argument.");
          let r2 = null;
          const n2 = e2.expectedType;
          n2 && "value" !== n2.kind && (r2 = n2);
          const i2 = [];
          for (const n3 of t2.slice(1)) {
            const t3 = e2.parse(n3, 1 + i2.length, r2, void 0, { typeAnnotation: "omit" });
            if (!t3)
              return null;
            r2 = r2 || t3.type, i2.push(t3);
          }
          const s2 = n2 && i2.some((t3) => se(n2, t3.type));
          return new Ar(s2 ? Wt : r2, i2);
        }
        evaluate(t2) {
          let e2, r2 = null, n2 = 0;
          for (const i2 of this.args)
            if (n2++, r2 = i2.evaluate(t2), r2 && r2 instanceof fe && !r2.available && (e2 || (e2 = r2.name), r2 = null, n2 === this.args.length && (r2 = e2)), null !== r2)
              break;
          return r2;
        }
        eachChild(t2) {
          this.args.forEach(t2);
        }
        outputDefined() {
          return this.args.every((t2) => t2.outputDefined());
        }
        serialize() {
          const t2 = ["coalesce"];
          return this.eachChild((e2) => {
            t2.push(e2.serialize());
          }), t2;
        }
      }
      class kr {
        constructor(t2, e2) {
          this.type = e2.type, this.bindings = [].concat(t2), this.result = e2;
        }
        evaluate(t2) {
          return this.result.evaluate(t2);
        }
        eachChild(t2) {
          for (const e2 of this.bindings)
            t2(e2[1]);
          t2(this.result);
        }
        static parse(t2, e2) {
          if (t2.length < 4)
            return e2.error(`Expected at least 3 arguments, but found ${t2.length - 1} instead.`);
          const r2 = [];
          for (let n3 = 1; n3 < t2.length - 1; n3 += 2) {
            const i2 = t2[n3];
            if ("string" != typeof i2)
              return e2.error(`Expected string, but found ${typeof i2} instead.`, n3);
            if (/[^a-zA-Z0-9_]/.test(i2))
              return e2.error("Variable names must contain only alphanumeric characters or '_'.", n3);
            const s2 = e2.parse(t2[n3 + 1], n3 + 1);
            if (!s2)
              return null;
            r2.push([i2, s2]);
          }
          const n2 = e2.parse(t2[t2.length - 1], t2.length - 1, e2.expectedType, r2);
          return n2 ? new kr(r2, n2) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
        serialize() {
          const t2 = ["let"];
          for (const [e2, r2] of this.bindings)
            t2.push(e2, r2.serialize());
          return t2.push(this.result.serialize()), t2;
        }
      }
      class Sr {
        constructor(t2, e2, r2) {
          this.type = t2, this.index = e2, this.input = r2;
        }
        static parse(t2, e2) {
          if (3 !== t2.length)
            return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
          const r2 = e2.parse(t2[1], 1, Xt), n2 = e2.parse(t2[2], 2, re(e2.expectedType || Wt));
          return r2 && n2 ? new Sr(n2.type.itemType, r2, n2) : null;
        }
        evaluate(t2) {
          const e2 = this.index.evaluate(t2), r2 = this.input.evaluate(t2);
          if (e2 < 0)
            throw new be(`Array index out of bounds: ${e2} < 0.`);
          if (e2 >= r2.length)
            throw new be(`Array index out of bounds: ${e2} > ${r2.length - 1}.`);
          if (e2 !== Math.floor(e2))
            throw new be(`Array index must be an integer, but found ${e2} instead.`);
          return r2[e2];
        }
        eachChild(t2) {
          t2(this.index), t2(this.input);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return ["at", this.index.serialize(), this.input.serialize()];
        }
      }
      class Ir {
        constructor(t2, e2) {
          this.type = Yt, this.needle = t2, this.haystack = e2;
        }
        static parse(t2, e2) {
          if (3 !== t2.length)
            return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
          const r2 = e2.parse(t2[1], 1, Wt), n2 = e2.parse(t2[2], 2, Wt);
          return r2 && n2 ? ae(r2.type, [Yt, Kt, Xt, Gt, Wt]) ? new Ir(r2, n2) : e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${ne(r2.type)} instead`) : null;
        }
        evaluate(t2) {
          const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
          if (!r2)
            return false;
          if (!oe(e2, ["boolean", "string", "number", "null"]))
            throw new be(`Expected first argument to be of type boolean, string, number or null, but found ${ne(ge(e2))} instead.`);
          if (!oe(r2, ["string", "array"]))
            throw new be(`Expected second argument to be of type array or string, but found ${ne(ge(r2))} instead.`);
          return r2.indexOf(e2) >= 0;
        }
        eachChild(t2) {
          t2(this.needle), t2(this.haystack);
        }
        outputDefined() {
          return true;
        }
        serialize() {
          return ["in", this.needle.serialize(), this.haystack.serialize()];
        }
      }
      class zr {
        constructor(t2, e2, r2) {
          this.type = Xt, this.needle = t2, this.haystack = e2, this.fromIndex = r2;
        }
        static parse(t2, e2) {
          if (t2.length <= 2 || t2.length >= 5)
            return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
          const r2 = e2.parse(t2[1], 1, Wt), n2 = e2.parse(t2[2], 2, Wt);
          if (!r2 || !n2)
            return null;
          if (!ae(r2.type, [Yt, Kt, Xt, Gt, Wt]))
            return e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${ne(r2.type)} instead`);
          if (4 === t2.length) {
            const i2 = e2.parse(t2[3], 3, Xt);
            return i2 ? new zr(r2, n2, i2) : null;
          }
          return new zr(r2, n2);
        }
        evaluate(t2) {
          const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
          if (!oe(e2, ["boolean", "string", "number", "null"]))
            throw new be(`Expected first argument to be of type boolean, string, number or null, but found ${ne(ge(e2))} instead.`);
          if (!oe(r2, ["string", "array"]))
            throw new be(`Expected second argument to be of type array or string, but found ${ne(ge(r2))} instead.`);
          if (this.fromIndex) {
            const n2 = this.fromIndex.evaluate(t2);
            return r2.indexOf(e2, n2);
          }
          return r2.indexOf(e2);
        }
        eachChild(t2) {
          t2(this.needle), t2(this.haystack), this.fromIndex && t2(this.fromIndex);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          if (null != this.fromIndex && void 0 !== this.fromIndex) {
            const t2 = this.fromIndex.serialize();
            return ["index-of", this.needle.serialize(), this.haystack.serialize(), t2];
          }
          return ["index-of", this.needle.serialize(), this.haystack.serialize()];
        }
      }
      class Tr {
        constructor(t2, e2, r2, n2, i2, s2) {
          this.inputType = t2, this.type = e2, this.input = r2, this.cases = n2, this.outputs = i2, this.otherwise = s2;
        }
        static parse(t2, e2) {
          if (t2.length < 5)
            return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
          if (t2.length % 2 != 1)
            return e2.error("Expected an even number of arguments.");
          let r2, n2;
          e2.expectedType && "value" !== e2.expectedType.kind && (n2 = e2.expectedType);
          const i2 = {}, s2 = [];
          for (let a3 = 2; a3 < t2.length - 1; a3 += 2) {
            let o3 = t2[a3];
            const l2 = t2[a3 + 1];
            Array.isArray(o3) || (o3 = [o3]);
            const u2 = e2.concat(a3);
            if (0 === o3.length)
              return u2.error("Expected at least one branch label.");
            for (const t3 of o3) {
              if ("number" != typeof t3 && "string" != typeof t3)
                return u2.error("Branch labels must be numbers or strings.");
              if ("number" == typeof t3 && Math.abs(t3) > Number.MAX_SAFE_INTEGER)
                return u2.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
              if ("number" == typeof t3 && Math.floor(t3) !== t3)
                return u2.error("Numeric branch labels must be integer values.");
              if (r2) {
                if (u2.checkSubtype(r2, ge(t3)))
                  return null;
              } else
                r2 = ge(t3);
              if (void 0 !== i2[String(t3)])
                return u2.error("Branch labels must be unique.");
              i2[String(t3)] = s2.length;
            }
            const c2 = e2.parse(l2, a3, n2);
            if (!c2)
              return null;
            n2 = n2 || c2.type, s2.push(c2);
          }
          const a2 = e2.parse(t2[1], 1, Wt);
          if (!a2)
            return null;
          const o2 = e2.parse(t2[t2.length - 1], t2.length - 1, n2);
          return o2 ? "value" !== a2.type.kind && e2.concat(1).checkSubtype(r2, a2.type) ? null : new Tr(r2, n2, a2, i2, s2, o2) : null;
        }
        evaluate(t2) {
          const e2 = this.input.evaluate(t2);
          return (ge(e2) === this.inputType && this.outputs[this.cases[e2]] || this.otherwise).evaluate(t2);
        }
        eachChild(t2) {
          t2(this.input), this.outputs.forEach(t2), t2(this.otherwise);
        }
        outputDefined() {
          return this.outputs.every((t2) => t2.outputDefined()) && this.otherwise.outputDefined();
        }
        serialize() {
          const t2 = ["match", this.input.serialize()], e2 = Object.keys(this.cases).sort(), r2 = [], n2 = {};
          for (const t3 of e2) {
            const e3 = n2[this.cases[t3]];
            void 0 === e3 ? (n2[this.cases[t3]] = r2.length, r2.push([this.cases[t3], [t3]])) : r2[e3][1].push(t3);
          }
          const i2 = (t3) => "number" === this.inputType.kind ? Number(t3) : t3;
          for (const [e3, n3] of r2)
            t2.push(1 === n3.length ? i2(n3[0]) : n3.map(i2)), t2.push(this.outputs[e3].serialize());
          return t2.push(this.otherwise.serialize()), t2;
        }
      }
      class Mr {
        constructor(t2, e2, r2) {
          this.type = t2, this.branches = e2, this.otherwise = r2;
        }
        static parse(t2, e2) {
          if (t2.length < 4)
            return e2.error(`Expected at least 3 arguments, but found only ${t2.length - 1}.`);
          if (t2.length % 2 != 0)
            return e2.error("Expected an odd number of arguments.");
          let r2;
          e2.expectedType && "value" !== e2.expectedType.kind && (r2 = e2.expectedType);
          const n2 = [];
          for (let i3 = 1; i3 < t2.length - 1; i3 += 2) {
            const s2 = e2.parse(t2[i3], i3, Yt);
            if (!s2)
              return null;
            const a2 = e2.parse(t2[i3 + 1], i3 + 1, r2);
            if (!a2)
              return null;
            n2.push([s2, a2]), r2 = r2 || a2.type;
          }
          const i2 = e2.parse(t2[t2.length - 1], t2.length - 1, r2);
          return i2 ? new Mr(r2, n2, i2) : null;
        }
        evaluate(t2) {
          for (const [e2, r2] of this.branches)
            if (e2.evaluate(t2))
              return r2.evaluate(t2);
          return this.otherwise.evaluate(t2);
        }
        eachChild(t2) {
          for (const [e2, r2] of this.branches)
            t2(e2), t2(r2);
          t2(this.otherwise);
        }
        outputDefined() {
          return this.branches.every(([t2, e2]) => e2.outputDefined()) && this.otherwise.outputDefined();
        }
        serialize() {
          const t2 = ["case"];
          return this.eachChild((e2) => {
            t2.push(e2.serialize());
          }), t2;
        }
      }
      class Er {
        constructor(t2, e2, r2, n2) {
          this.type = t2, this.input = e2, this.beginIndex = r2, this.endIndex = n2;
        }
        static parse(t2, e2) {
          if (t2.length <= 2 || t2.length >= 5)
            return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
          const r2 = e2.parse(t2[1], 1, Wt), n2 = e2.parse(t2[2], 2, Xt);
          if (!r2 || !n2)
            return null;
          if (!ae(r2.type, [re(Wt), Kt, Wt]))
            return e2.error(`Expected first argument to be of type array or string, but found ${ne(r2.type)} instead`);
          if (4 === t2.length) {
            const i2 = e2.parse(t2[3], 3, Xt);
            return i2 ? new Er(r2.type, r2, n2, i2) : null;
          }
          return new Er(r2.type, r2, n2);
        }
        evaluate(t2) {
          const e2 = this.input.evaluate(t2), r2 = this.beginIndex.evaluate(t2);
          if (!oe(e2, ["string", "array"]))
            throw new be(`Expected first argument to be of type array or string, but found ${ne(ge(e2))} instead.`);
          if (this.endIndex) {
            const n2 = this.endIndex.evaluate(t2);
            return e2.slice(r2, n2);
          }
          return e2.slice(r2);
        }
        eachChild(t2) {
          t2(this.input), t2(this.beginIndex), this.endIndex && t2(this.endIndex);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          if (null != this.endIndex && void 0 !== this.endIndex) {
            const t2 = this.endIndex.serialize();
            return ["slice", this.input.serialize(), this.beginIndex.serialize(), t2];
          }
          return ["slice", this.input.serialize(), this.beginIndex.serialize()];
        }
      }
      function Cr(t2, e2) {
        return "==" === t2 || "!=" === t2 ? "boolean" === e2.kind || "string" === e2.kind || "number" === e2.kind || "null" === e2.kind || "value" === e2.kind : "string" === e2.kind || "number" === e2.kind || "value" === e2.kind;
      }
      function Br(t2, e2, r2, n2) {
        return 0 === n2.compare(e2, r2);
      }
      function Dr(t2, e2, r2) {
        const n2 = "==" !== t2 && "!=" !== t2;
        return class i2 {
          constructor(t3, e3, r3) {
            this.type = Yt, this.lhs = t3, this.rhs = e3, this.collator = r3, this.hasUntypedArgument = "value" === t3.type.kind || "value" === e3.type.kind;
          }
          static parse(t3, e3) {
            if (3 !== t3.length && 4 !== t3.length)
              return e3.error("Expected two or three arguments.");
            const r3 = t3[0];
            let s2 = e3.parse(t3[1], 1, Wt);
            if (!s2)
              return null;
            if (!Cr(r3, s2.type))
              return e3.concat(1).error(`"${r3}" comparisons are not supported for type '${ne(s2.type)}'.`);
            let a2 = e3.parse(t3[2], 2, Wt);
            if (!a2)
              return null;
            if (!Cr(r3, a2.type))
              return e3.concat(2).error(`"${r3}" comparisons are not supported for type '${ne(a2.type)}'.`);
            if (s2.type.kind !== a2.type.kind && "value" !== s2.type.kind && "value" !== a2.type.kind)
              return e3.error(`Cannot compare types '${ne(s2.type)}' and '${ne(a2.type)}'.`);
            n2 && ("value" === s2.type.kind && "value" !== a2.type.kind ? s2 = new _e(a2.type, [s2]) : "value" !== s2.type.kind && "value" === a2.type.kind && (a2 = new _e(s2.type, [a2])));
            let o2 = null;
            if (4 === t3.length) {
              if ("string" !== s2.type.kind && "string" !== a2.type.kind && "value" !== s2.type.kind && "value" !== a2.type.kind)
                return e3.error("Cannot use collator to compare non-string types.");
              if (o2 = e3.parse(t3[3], 3, Qt), !o2)
                return null;
            }
            return new i2(s2, a2, o2);
          }
          evaluate(i3) {
            const s2 = this.lhs.evaluate(i3), a2 = this.rhs.evaluate(i3);
            if (n2 && this.hasUntypedArgument) {
              const e3 = ge(s2), r3 = ge(a2);
              if (e3.kind !== r3.kind || "string" !== e3.kind && "number" !== e3.kind)
                throw new be(`Expected arguments for "${t2}" to be (string, string) or (number, number), but found (${e3.kind}, ${r3.kind}) instead.`);
            }
            if (this.collator && !n2 && this.hasUntypedArgument) {
              const t3 = ge(s2), r3 = ge(a2);
              if ("string" !== t3.kind || "string" !== r3.kind)
                return e2(i3, s2, a2);
            }
            return this.collator ? r2(i3, s2, a2, this.collator.evaluate(i3)) : e2(i3, s2, a2);
          }
          eachChild(t3) {
            t3(this.lhs), t3(this.rhs), this.collator && t3(this.collator);
          }
          outputDefined() {
            return true;
          }
          serialize() {
            const e3 = [t2];
            return this.eachChild((t3) => {
              e3.push(t3.serialize());
            }), e3;
          }
        };
      }
      const Pr = Dr("==", function(t2, e2, r2) {
        return e2 === r2;
      }, Br), Vr = Dr("!=", function(t2, e2, r2) {
        return e2 !== r2;
      }, function(t2, e2, r2, n2) {
        return !Br(0, e2, r2, n2);
      }), Lr = Dr("<", function(t2, e2, r2) {
        return e2 < r2;
      }, function(t2, e2, r2, n2) {
        return n2.compare(e2, r2) < 0;
      }), Fr = Dr(">", function(t2, e2, r2) {
        return e2 > r2;
      }, function(t2, e2, r2, n2) {
        return n2.compare(e2, r2) > 0;
      }), Rr = Dr("<=", function(t2, e2, r2) {
        return e2 <= r2;
      }, function(t2, e2, r2, n2) {
        return n2.compare(e2, r2) <= 0;
      }), $r = Dr(">=", function(t2, e2, r2) {
        return e2 >= r2;
      }, function(t2, e2, r2, n2) {
        return n2.compare(e2, r2) >= 0;
      });
      class Ur {
        constructor(t2, e2, r2, n2, i2) {
          this.type = Kt, this.number = t2, this.locale = e2, this.currency = r2, this.minFractionDigits = n2, this.maxFractionDigits = i2;
        }
        static parse(t2, e2) {
          if (3 !== t2.length)
            return e2.error("Expected two arguments.");
          const r2 = e2.parse(t2[1], 1, Xt);
          if (!r2)
            return null;
          const n2 = t2[2];
          if ("object" != typeof n2 || Array.isArray(n2))
            return e2.error("NumberFormat options argument must be an object.");
          let i2 = null;
          if (n2.locale && (i2 = e2.parse(n2.locale, 1, Kt), !i2))
            return null;
          let s2 = null;
          if (n2.currency && (s2 = e2.parse(n2.currency, 1, Kt), !s2))
            return null;
          let a2 = null;
          if (n2["min-fraction-digits"] && (a2 = e2.parse(n2["min-fraction-digits"], 1, Xt), !a2))
            return null;
          let o2 = null;
          return n2["max-fraction-digits"] && (o2 = e2.parse(n2["max-fraction-digits"], 1, Xt), !o2) ? null : new Ur(r2, i2, s2, a2, o2);
        }
        evaluate(t2) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t2) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t2) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t2) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t2) : void 0 }).format(this.number.evaluate(t2));
        }
        eachChild(t2) {
          t2(this.number), this.locale && t2(this.locale), this.currency && t2(this.currency), this.minFractionDigits && t2(this.minFractionDigits), this.maxFractionDigits && t2(this.maxFractionDigits);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const t2 = {};
          return this.locale && (t2.locale = this.locale.serialize()), this.currency && (t2.currency = this.currency.serialize()), this.minFractionDigits && (t2["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t2["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t2];
        }
      }
      class Or {
        constructor(t2) {
          this.type = Xt, this.input = t2;
        }
        static parse(t2, e2) {
          if (2 !== t2.length)
            return e2.error(`Expected 1 argument, but found ${t2.length - 1} instead.`);
          const r2 = e2.parse(t2[1], 1);
          return r2 ? "array" !== r2.type.kind && "string" !== r2.type.kind && "value" !== r2.type.kind ? e2.error(`Expected argument of type string or array, but found ${ne(r2.type)} instead.`) : new Or(r2) : null;
        }
        evaluate(t2) {
          const e2 = this.input.evaluate(t2);
          if ("string" == typeof e2)
            return e2.length;
          if (Array.isArray(e2))
            return e2.length;
          throw new be(`Expected value to be of type string or array, but found ${ne(ge(e2))} instead.`);
        }
        eachChild(t2) {
          t2(this.input);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          const t2 = ["length"];
          return this.eachChild((e2) => {
            t2.push(e2.serialize());
          }), t2;
        }
      }
      const qr = { "==": Pr, "!=": Vr, ">": Fr, "<": Lr, ">=": $r, "<=": Rr, array: _e, at: Sr, boolean: _e, case: Mr, coalesce: Ar, collator: Ee, format: Ae, image: ke, in: Ir, "index-of": zr, interpolate: wr, "interpolate-hcl": wr, "interpolate-lab": wr, length: Or, let: kr, literal: ve, match: Tr, number: _e, "number-format": Ur, object: _e, slice: Er, step: er, string: _e, "to-boolean": Ie, "to-color": Ie, "to-number": Ie, "to-string": Ie, var: Je, within: Xe };
      function jr(t2, [e2, r2, n2, i2]) {
        e2 = e2.evaluate(t2), r2 = r2.evaluate(t2), n2 = n2.evaluate(t2);
        const s2 = i2 ? i2.evaluate(t2) : 1, a2 = ye(e2, r2, n2, s2);
        if (a2)
          throw new be(a2);
        return new ce(e2 / 255 * s2, r2 / 255 * s2, n2 / 255 * s2, s2);
      }
      function Nr(t2, e2) {
        return t2 in e2;
      }
      function Zr(t2, e2) {
        const r2 = e2[t2];
        return void 0 === r2 ? null : r2;
      }
      function Gr(t2) {
        return { type: t2 };
      }
      function Xr(t2) {
        return { result: "success", value: t2 };
      }
      function Kr(t2) {
        return { result: "error", value: t2 };
      }
      function Yr(t2) {
        return "data-driven" === t2["property-type"] || "cross-faded-data-driven" === t2["property-type"];
      }
      function Hr(t2) {
        return !!t2.expression && t2.expression.parameters.indexOf("zoom") > -1;
      }
      function Jr(t2) {
        return !!t2.expression && t2.expression.interpolated;
      }
      function Wr(t2) {
        return t2 instanceof Number ? "number" : t2 instanceof String ? "string" : t2 instanceof Boolean ? "boolean" : Array.isArray(t2) ? "array" : null === t2 ? "null" : typeof t2;
      }
      function Qr(t2) {
        return "object" == typeof t2 && null !== t2 && !Array.isArray(t2);
      }
      function tn(t2) {
        return t2;
      }
      function en(t2, e2) {
        const r2 = "color" === e2.type, n2 = t2.stops && "object" == typeof t2.stops[0][0], i2 = n2 || !(n2 || void 0 !== t2.property), s2 = t2.type || (Jr(e2) ? "exponential" : "interval");
        if (r2 && ((t2 = Ot({}, t2)).stops && (t2.stops = t2.stops.map((t3) => [t3[0], ce.parse(t3[1])])), t2.default = ce.parse(t2.default ? t2.default : e2.default)), t2.colorSpace && "rgb" !== t2.colorSpace && !br[t2.colorSpace])
          throw new Error(`Unknown color space: ${t2.colorSpace}`);
        let a2, o2, l2;
        if ("exponential" === s2)
          a2 = an;
        else if ("interval" === s2)
          a2 = sn;
        else if ("categorical" === s2) {
          a2 = nn, o2 = /* @__PURE__ */ Object.create(null);
          for (const e3 of t2.stops)
            o2[e3[0]] = e3[1];
          l2 = typeof t2.stops[0][0];
        } else {
          if ("identity" !== s2)
            throw new Error(`Unknown function type "${s2}"`);
          a2 = on;
        }
        if (n2) {
          const r3 = {}, n3 = [];
          for (let e3 = 0; e3 < t2.stops.length; e3++) {
            const i4 = t2.stops[e3], s4 = i4[0].zoom;
            void 0 === r3[s4] && (r3[s4] = { zoom: s4, type: t2.type, property: t2.property, default: t2.default, stops: [] }, n3.push(s4)), r3[s4].stops.push([i4[0].value, i4[1]]);
          }
          const i3 = [];
          for (const t3 of n3)
            i3.push([r3[t3].zoom, en(r3[t3], e2)]);
          const s3 = { name: "linear" };
          return { kind: "composite", interpolationType: s3, interpolationFactor: wr.interpolationFactor.bind(void 0, s3), zoomStops: i3.map((t3) => t3[0]), evaluate: ({ zoom: r4 }, n4) => an({ stops: i3, base: t2.base }, e2, r4).evaluate(r4, n4) };
        }
        if (i2) {
          const r3 = "exponential" === s2 ? { name: "exponential", base: void 0 !== t2.base ? t2.base : 1 } : null;
          return { kind: "camera", interpolationType: r3, interpolationFactor: wr.interpolationFactor.bind(void 0, r3), zoomStops: t2.stops.map((t3) => t3[0]), evaluate: ({ zoom: r4 }) => a2(t2, e2, r4, o2, l2) };
        }
        return { kind: "source", evaluate(r3, n3) {
          const i3 = n3 && n3.properties ? n3.properties[t2.property] : void 0;
          return void 0 === i3 ? rn(t2.default, e2.default) : a2(t2, e2, i3, o2, l2);
        } };
      }
      function rn(t2, e2, r2) {
        return void 0 !== t2 ? t2 : void 0 !== e2 ? e2 : void 0 !== r2 ? r2 : void 0;
      }
      function nn(t2, e2, r2, n2, i2) {
        return rn(typeof r2 === i2 ? n2[r2] : void 0, t2.default, e2.default);
      }
      function sn(t2, e2, r2) {
        if ("number" !== Wr(r2))
          return rn(t2.default, e2.default);
        const n2 = t2.stops.length;
        if (1 === n2)
          return t2.stops[0][1];
        if (r2 <= t2.stops[0][0])
          return t2.stops[0][1];
        if (r2 >= t2.stops[n2 - 1][0])
          return t2.stops[n2 - 1][1];
        const i2 = tr(t2.stops.map((t3) => t3[0]), r2);
        return t2.stops[i2][1];
      }
      function an(t2, e2, r2) {
        const n2 = void 0 !== t2.base ? t2.base : 1;
        if ("number" !== Wr(r2))
          return rn(t2.default, e2.default);
        const i2 = t2.stops.length;
        if (1 === i2)
          return t2.stops[0][1];
        if (r2 <= t2.stops[0][0])
          return t2.stops[0][1];
        if (r2 >= t2.stops[i2 - 1][0])
          return t2.stops[i2 - 1][1];
        const s2 = tr(t2.stops.map((t3) => t3[0]), r2), a2 = function(t3, e3, r3, n3) {
          const i3 = n3 - r3, s3 = t3 - r3;
          return 0 === i3 ? 0 : 1 === e3 ? s3 / i3 : (Math.pow(e3, s3) - 1) / (Math.pow(e3, i3) - 1);
        }(r2, n2, t2.stops[s2][0], t2.stops[s2 + 1][0]), o2 = t2.stops[s2][1], l2 = t2.stops[s2 + 1][1];
        let u2 = nr[e2.type] || tn;
        if (t2.colorSpace && "rgb" !== t2.colorSpace) {
          const e3 = br[t2.colorSpace];
          u2 = (t3, r3) => e3.reverse(e3.interpolate(e3.forward(t3), e3.forward(r3), a2));
        }
        return "function" == typeof o2.evaluate ? { evaluate(...t3) {
          const e3 = o2.evaluate.apply(void 0, t3), r3 = l2.evaluate.apply(void 0, t3);
          if (void 0 !== e3 && void 0 !== r3)
            return u2(e3, r3, a2);
        } } : u2(o2, l2, a2);
      }
      function on(t2, e2, r2) {
        return "color" === e2.type ? r2 = ce.parse(r2) : "formatted" === e2.type ? r2 = de.fromString(r2.toString()) : "resolvedImage" === e2.type ? r2 = fe.fromString(r2.toString()) : Wr(r2) === e2.type || "enum" === e2.type && e2.values[r2] || (r2 = void 0), rn(r2, t2.default, e2.default);
      }
      Me.register(qr, { error: [{ kind: "error" }, [Kt], (t2, [e2]) => {
        throw new be(e2.evaluate(t2));
      }], typeof: [Kt, [Wt], (t2, [e2]) => ne(ge(e2.evaluate(t2)))], "to-rgba": [re(Xt, 4), [Ht], (t2, [e2]) => e2.evaluate(t2).toArray()], rgb: [Ht, [Xt, Xt, Xt], jr], rgba: [Ht, [Xt, Xt, Xt, Xt], jr], has: { type: Yt, overloads: [[[Kt], (t2, [e2]) => Nr(e2.evaluate(t2), t2.properties())], [[Kt, Jt], (t2, [e2, r2]) => Nr(e2.evaluate(t2), r2.evaluate(t2))]] }, get: { type: Wt, overloads: [[[Kt], (t2, [e2]) => Zr(e2.evaluate(t2), t2.properties())], [[Kt, Jt], (t2, [e2, r2]) => Zr(e2.evaluate(t2), r2.evaluate(t2))]] }, "feature-state": [Wt, [Kt], (t2, [e2]) => Zr(e2.evaluate(t2), t2.featureState || {})], properties: [Jt, [], (t2) => t2.properties()], "geometry-type": [Kt, [], (t2) => t2.geometryType()], id: [Wt, [], (t2) => t2.id()], zoom: [Xt, [], (t2) => t2.globals.zoom], "heatmap-density": [Xt, [], (t2) => t2.globals.heatmapDensity || 0], "line-progress": [Xt, [], (t2) => t2.globals.lineProgress || 0], "sky-radial-progress": [Xt, [], (t2) => t2.globals.skyRadialProgress || 0], accumulated: [Wt, [], (t2) => void 0 === t2.globals.accumulated ? null : t2.globals.accumulated], "+": [Xt, Gr(Xt), (t2, e2) => {
        let r2 = 0;
        for (const n2 of e2)
          r2 += n2.evaluate(t2);
        return r2;
      }], "*": [Xt, Gr(Xt), (t2, e2) => {
        let r2 = 1;
        for (const n2 of e2)
          r2 *= n2.evaluate(t2);
        return r2;
      }], "-": { type: Xt, overloads: [[[Xt, Xt], (t2, [e2, r2]) => e2.evaluate(t2) - r2.evaluate(t2)], [[Xt], (t2, [e2]) => -e2.evaluate(t2)]] }, "/": [Xt, [Xt, Xt], (t2, [e2, r2]) => e2.evaluate(t2) / r2.evaluate(t2)], "%": [Xt, [Xt, Xt], (t2, [e2, r2]) => e2.evaluate(t2) % r2.evaluate(t2)], ln2: [Xt, [], () => Math.LN2], pi: [Xt, [], () => Math.PI], e: [Xt, [], () => Math.E], "^": [Xt, [Xt, Xt], (t2, [e2, r2]) => Math.pow(e2.evaluate(t2), r2.evaluate(t2))], sqrt: [Xt, [Xt], (t2, [e2]) => Math.sqrt(e2.evaluate(t2))], log10: [Xt, [Xt], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN10], ln: [Xt, [Xt], (t2, [e2]) => Math.log(e2.evaluate(t2))], log2: [Xt, [Xt], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN2], sin: [Xt, [Xt], (t2, [e2]) => Math.sin(e2.evaluate(t2))], cos: [Xt, [Xt], (t2, [e2]) => Math.cos(e2.evaluate(t2))], tan: [Xt, [Xt], (t2, [e2]) => Math.tan(e2.evaluate(t2))], asin: [Xt, [Xt], (t2, [e2]) => Math.asin(e2.evaluate(t2))], acos: [Xt, [Xt], (t2, [e2]) => Math.acos(e2.evaluate(t2))], atan: [Xt, [Xt], (t2, [e2]) => Math.atan(e2.evaluate(t2))], min: [Xt, Gr(Xt), (t2, e2) => Math.min(...e2.map((e3) => e3.evaluate(t2)))], max: [Xt, Gr(Xt), (t2, e2) => Math.max(...e2.map((e3) => e3.evaluate(t2)))], abs: [Xt, [Xt], (t2, [e2]) => Math.abs(e2.evaluate(t2))], round: [Xt, [Xt], (t2, [e2]) => {
        const r2 = e2.evaluate(t2);
        return r2 < 0 ? -Math.round(-r2) : Math.round(r2);
      }], floor: [Xt, [Xt], (t2, [e2]) => Math.floor(e2.evaluate(t2))], ceil: [Xt, [Xt], (t2, [e2]) => Math.ceil(e2.evaluate(t2))], "filter-==": [Yt, [Kt, Wt], (t2, [e2, r2]) => t2.properties()[e2.value] === r2.value], "filter-id-==": [Yt, [Wt], (t2, [e2]) => t2.id() === e2.value], "filter-type-==": [Yt, [Kt], (t2, [e2]) => t2.geometryType() === e2.value], "filter-<": [Yt, [Kt, Wt], (t2, [e2, r2]) => {
        const n2 = t2.properties()[e2.value], i2 = r2.value;
        return typeof n2 == typeof i2 && n2 < i2;
      }], "filter-id-<": [Yt, [Wt], (t2, [e2]) => {
        const r2 = t2.id(), n2 = e2.value;
        return typeof r2 == typeof n2 && r2 < n2;
      }], "filter->": [Yt, [Kt, Wt], (t2, [e2, r2]) => {
        const n2 = t2.properties()[e2.value], i2 = r2.value;
        return typeof n2 == typeof i2 && n2 > i2;
      }], "filter-id->": [Yt, [Wt], (t2, [e2]) => {
        const r2 = t2.id(), n2 = e2.value;
        return typeof r2 == typeof n2 && r2 > n2;
      }], "filter-<=": [Yt, [Kt, Wt], (t2, [e2, r2]) => {
        const n2 = t2.properties()[e2.value], i2 = r2.value;
        return typeof n2 == typeof i2 && n2 <= i2;
      }], "filter-id-<=": [Yt, [Wt], (t2, [e2]) => {
        const r2 = t2.id(), n2 = e2.value;
        return typeof r2 == typeof n2 && r2 <= n2;
      }], "filter->=": [Yt, [Kt, Wt], (t2, [e2, r2]) => {
        const n2 = t2.properties()[e2.value], i2 = r2.value;
        return typeof n2 == typeof i2 && n2 >= i2;
      }], "filter-id->=": [Yt, [Wt], (t2, [e2]) => {
        const r2 = t2.id(), n2 = e2.value;
        return typeof r2 == typeof n2 && r2 >= n2;
      }], "filter-has": [Yt, [Wt], (t2, [e2]) => e2.value in t2.properties()], "filter-has-id": [Yt, [], (t2) => null !== t2.id() && void 0 !== t2.id()], "filter-type-in": [Yt, [re(Kt)], (t2, [e2]) => e2.value.indexOf(t2.geometryType()) >= 0], "filter-id-in": [Yt, [re(Wt)], (t2, [e2]) => e2.value.indexOf(t2.id()) >= 0], "filter-in-small": [Yt, [Kt, re(Wt)], (t2, [e2, r2]) => r2.value.indexOf(t2.properties()[e2.value]) >= 0], "filter-in-large": [Yt, [Kt, re(Wt)], (t2, [e2, r2]) => function(t3, e3, r3, n2) {
        for (; r3 <= n2; ) {
          const i2 = r3 + n2 >> 1;
          if (e3[i2] === t3)
            return true;
          e3[i2] > t3 ? n2 = i2 - 1 : r3 = i2 + 1;
        }
        return false;
      }(t2.properties()[e2.value], r2.value, 0, r2.value.length - 1)], all: { type: Yt, overloads: [[[Yt, Yt], (t2, [e2, r2]) => e2.evaluate(t2) && r2.evaluate(t2)], [Gr(Yt), (t2, e2) => {
        for (const r2 of e2)
          if (!r2.evaluate(t2))
            return false;
        return true;
      }]] }, any: { type: Yt, overloads: [[[Yt, Yt], (t2, [e2, r2]) => e2.evaluate(t2) || r2.evaluate(t2)], [Gr(Yt), (t2, e2) => {
        for (const r2 of e2)
          if (r2.evaluate(t2))
            return true;
        return false;
      }]] }, "!": [Yt, [Yt], (t2, [e2]) => !e2.evaluate(t2)], "is-supported-script": [Yt, [Kt], (t2, [e2]) => {
        const r2 = t2.globals && t2.globals.isSupportedScript;
        return !r2 || r2(e2.evaluate(t2));
      }], upcase: [Kt, [Kt], (t2, [e2]) => e2.evaluate(t2).toUpperCase()], downcase: [Kt, [Kt], (t2, [e2]) => e2.evaluate(t2).toLowerCase()], concat: [Kt, Gr(Wt), (t2, e2) => e2.map((e3) => xe(e3.evaluate(t2))).join("")], "resolved-locale": [Kt, [Qt], (t2, [e2]) => e2.evaluate(t2).resolvedLocale()] });
      class ln {
        constructor(t2, e2) {
          this.expression = t2, this._warningHistory = {}, this._evaluator = new Te(), this._defaultValue = e2 ? function(t3) {
            return "color" === t3.type && Qr(t3.default) ? new ce(0, 0, 0, 0) : "color" === t3.type ? ce.parse(t3.default) || null : void 0 === t3.default ? null : t3.default;
          }(e2) : null, this._enumValues = e2 && "enum" === e2.type ? e2.values : null;
        }
        evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
          return this._evaluator.globals = t2, this._evaluator.feature = e2, this._evaluator.featureState = r2, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2, this.expression.evaluate(this._evaluator);
        }
        evaluate(t2, e2, r2, n2, i2, s2) {
          this._evaluator.globals = t2, this._evaluator.feature = e2 || null, this._evaluator.featureState = r2 || null, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2 || null;
          try {
            const t3 = this.expression.evaluate(this._evaluator);
            if (null == t3 || "number" == typeof t3 && t3 != t3)
              return this._defaultValue;
            if (this._enumValues && !(t3 in this._enumValues))
              throw new be(`Expected value to be one of ${Object.keys(this._enumValues).map((t4) => JSON.stringify(t4)).join(", ")}, but found ${JSON.stringify(t3)} instead.`);
            return t3;
          } catch (t3) {
            return this._warningHistory[t3.message] || (this._warningHistory[t3.message] = true, "undefined" != typeof console && console.warn(t3.message)), this._defaultValue;
          }
        }
      }
      function un(t2) {
        return Array.isArray(t2) && t2.length > 0 && "string" == typeof t2[0] && t2[0] in qr;
      }
      function cn(t2, e2) {
        const r2 = new We(qr, [], e2 ? function(t3) {
          const e3 = { color: Ht, string: Kt, number: Xt, enum: Kt, boolean: Yt, formatted: te, resolvedImage: ee };
          return "array" === t3.type ? re(e3[t3.value] || Wt, t3.length) : e3[t3.type];
        }(e2) : void 0), n2 = r2.parse(t2, void 0, void 0, void 0, e2 && "string" === e2.type ? { typeAnnotation: "coerce" } : void 0);
        return n2 ? Xr(new ln(n2, e2)) : Kr(r2.errors);
      }
      class hn {
        constructor(t2, e2) {
          this.kind = t2, this._styleExpression = e2, this.isStateDependent = "constant" !== t2 && !Ye(e2.expression);
        }
        evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
          return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2);
        }
        evaluate(t2, e2, r2, n2, i2, s2) {
          return this._styleExpression.evaluate(t2, e2, r2, n2, i2, s2);
        }
      }
      class pn {
        constructor(t2, e2, r2, n2) {
          this.kind = t2, this.zoomStops = r2, this._styleExpression = e2, this.isStateDependent = "camera" !== t2 && !Ye(e2.expression), this.interpolationType = n2;
        }
        evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
          return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2);
        }
        evaluate(t2, e2, r2, n2, i2, s2) {
          return this._styleExpression.evaluate(t2, e2, r2, n2, i2, s2);
        }
        interpolationFactor(t2, e2, r2) {
          return this.interpolationType ? wr.interpolationFactor(this.interpolationType, t2, e2, r2) : 0;
        }
      }
      function dn(t2, e2) {
        if ("error" === (t2 = cn(t2, e2)).result)
          return t2;
        const r2 = t2.value.expression, n2 = Ke(r2);
        if (!n2 && !Yr(e2))
          return Kr([new Nt("", "data expressions not supported")]);
        const i2 = He(r2, ["zoom"]);
        if (!i2 && !Hr(e2))
          return Kr([new Nt("", "zoom expressions not supported")]);
        const s2 = yn(r2);
        return s2 || i2 ? s2 instanceof Nt ? Kr([s2]) : s2 instanceof wr && !Jr(e2) ? Kr([new Nt("", '"interpolate" expressions cannot be used with this property')]) : Xr(s2 ? new pn(n2 ? "camera" : "composite", t2.value, s2.labels, s2 instanceof wr ? s2.interpolation : void 0) : new hn(n2 ? "constant" : "source", t2.value)) : Kr([new Nt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
      }
      class fn {
        constructor(t2, e2) {
          this._parameters = t2, this._specification = e2, Ot(this, en(this._parameters, this._specification));
        }
        static deserialize(t2) {
          return new fn(t2._parameters, t2._specification);
        }
        static serialize(t2) {
          return { _parameters: t2._parameters, _specification: t2._specification };
        }
      }
      function yn(t2) {
        let e2 = null;
        if (t2 instanceof kr)
          e2 = yn(t2.result);
        else if (t2 instanceof Ar) {
          for (const r2 of t2.args)
            if (e2 = yn(r2), e2)
              break;
        } else
          (t2 instanceof er || t2 instanceof wr) && t2.input instanceof Me && "zoom" === t2.input.name && (e2 = t2);
        return e2 instanceof Nt || t2.eachChild((t3) => {
          const r2 = yn(t3);
          r2 instanceof Nt ? e2 = r2 : !e2 && r2 ? e2 = new Nt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e2 && r2 && e2 !== r2 && (e2 = new Nt("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
        }), e2;
      }
      function mn(t2) {
        const e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec || {}, i2 = t2.objectElementValidators || {}, s2 = t2.style, a2 = t2.styleSpec;
        let o2 = [];
        const l2 = Wr(r2);
        if ("object" !== l2)
          return [new $t(e2, r2, `object expected, ${l2} found`)];
        for (const t3 in r2) {
          const l3 = t3.split(".")[0], u2 = n2[l3] || n2["*"];
          let c2;
          if (i2[l3])
            c2 = i2[l3];
          else if (n2[l3])
            c2 = Zn;
          else if (i2["*"])
            c2 = i2["*"];
          else {
            if (!n2["*"]) {
              o2.push(new $t(e2, r2[t3], `unknown property "${t3}"`));
              continue;
            }
            c2 = Zn;
          }
          o2 = o2.concat(c2({ key: (e2 ? `${e2}.` : e2) + t3, value: r2[t3], valueSpec: u2, style: s2, styleSpec: a2, object: r2, objectKey: t3 }, r2));
        }
        for (const t3 in n2)
          i2[t3] || n2[t3].required && void 0 === n2[t3].default && void 0 === r2[t3] && o2.push(new $t(e2, r2, `missing required property "${t3}"`));
        return o2;
      }
      function gn(t2) {
        const e2 = t2.value, r2 = t2.valueSpec, n2 = t2.style, i2 = t2.styleSpec, s2 = t2.key, a2 = t2.arrayElementValidator || Zn;
        if ("array" !== Wr(e2))
          return [new $t(s2, e2, `array expected, ${Wr(e2)} found`)];
        if (r2.length && e2.length !== r2.length)
          return [new $t(s2, e2, `array length ${r2.length} expected, length ${e2.length} found`)];
        if (r2["min-length"] && e2.length < r2["min-length"])
          return [new $t(s2, e2, `array length at least ${r2["min-length"]} expected, length ${e2.length} found`)];
        let o2 = { type: r2.value, values: r2.values, minimum: r2.minimum, maximum: r2.maximum };
        i2.$version < 7 && (o2.function = r2.function), "object" === Wr(r2.value) && (o2 = r2.value);
        let l2 = [];
        for (let t3 = 0; t3 < e2.length; t3++)
          l2 = l2.concat(a2({ array: e2, arrayIndex: t3, value: e2[t3], valueSpec: o2, style: n2, styleSpec: i2, key: `${s2}[${t3}]` }));
        return l2;
      }
      function xn(t2) {
        const e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec;
        let i2 = Wr(r2);
        if ("number" === i2 && r2 != r2 && (i2 = "NaN"), "number" !== i2)
          return [new $t(e2, r2, `number expected, ${i2} found`)];
        if ("minimum" in n2) {
          let i3 = n2.minimum;
          if ("array" === Wr(n2.minimum) && (i3 = n2.minimum[t2.arrayIndex]), r2 < i3)
            return [new $t(e2, r2, `${r2} is less than the minimum value ${i3}`)];
        }
        if ("maximum" in n2) {
          let i3 = n2.maximum;
          if ("array" === Wr(n2.maximum) && (i3 = n2.maximum[t2.arrayIndex]), r2 > i3)
            return [new $t(e2, r2, `${r2} is greater than the maximum value ${i3}`)];
        }
        return [];
      }
      function vn(t2) {
        const e2 = t2.valueSpec, r2 = qt(t2.value.type);
        let n2, i2, s2, a2 = {};
        const o2 = "categorical" !== r2 && void 0 === t2.value.property, l2 = !o2, u2 = "array" === Wr(t2.value.stops) && "array" === Wr(t2.value.stops[0]) && "object" === Wr(t2.value.stops[0][0]), c2 = mn({ key: t2.key, value: t2.value, valueSpec: t2.styleSpec.function, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { stops: function(t3) {
          if ("identity" === r2)
            return [new $t(t3.key, t3.value, 'identity function may not have a "stops" property')];
          let e3 = [];
          const n3 = t3.value;
          return e3 = e3.concat(gn({ key: t3.key, value: n3, valueSpec: t3.valueSpec, style: t3.style, styleSpec: t3.styleSpec, arrayElementValidator: h2 })), "array" === Wr(n3) && 0 === n3.length && e3.push(new $t(t3.key, n3, "array must have at least one stop")), e3;
        }, default: function(t3) {
          return Zn({ key: t3.key, value: t3.value, valueSpec: e2, style: t3.style, styleSpec: t3.styleSpec });
        } } });
        return "identity" === r2 && o2 && c2.push(new $t(t2.key, t2.value, 'missing required property "property"')), "identity" === r2 || t2.value.stops || c2.push(new $t(t2.key, t2.value, 'missing required property "stops"')), "exponential" === r2 && t2.valueSpec.expression && !Jr(t2.valueSpec) && c2.push(new $t(t2.key, t2.value, "exponential functions not supported")), t2.styleSpec.$version >= 8 && (l2 && !Yr(t2.valueSpec) ? c2.push(new $t(t2.key, t2.value, "property functions not supported")) : o2 && !Hr(t2.valueSpec) && c2.push(new $t(t2.key, t2.value, "zoom functions not supported"))), "categorical" !== r2 && !u2 || void 0 !== t2.value.property || c2.push(new $t(t2.key, t2.value, '"property" property is required')), c2;
        function h2(t3) {
          let r3 = [];
          const n3 = t3.value, o3 = t3.key;
          if ("array" !== Wr(n3))
            return [new $t(o3, n3, `array expected, ${Wr(n3)} found`)];
          if (2 !== n3.length)
            return [new $t(o3, n3, `array length 2 expected, length ${n3.length} found`)];
          if (u2) {
            if ("object" !== Wr(n3[0]))
              return [new $t(o3, n3, `object expected, ${Wr(n3[0])} found`)];
            if (void 0 === n3[0].zoom)
              return [new $t(o3, n3, "object stop key must have zoom")];
            if (void 0 === n3[0].value)
              return [new $t(o3, n3, "object stop key must have value")];
            if (s2 && s2 > qt(n3[0].zoom))
              return [new $t(o3, n3[0].zoom, "stop zoom values must appear in ascending order")];
            qt(n3[0].zoom) !== s2 && (s2 = qt(n3[0].zoom), i2 = void 0, a2 = {}), r3 = r3.concat(mn({ key: `${o3}[0]`, value: n3[0], valueSpec: { zoom: {} }, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { zoom: xn, value: p2 } }));
          } else
            r3 = r3.concat(p2({ key: `${o3}[0]`, value: n3[0], valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec }, n3));
          return un(jt(n3[1])) ? r3.concat([new $t(`${o3}[1]`, n3[1], "expressions are not allowed in function stops.")]) : r3.concat(Zn({ key: `${o3}[1]`, value: n3[1], valueSpec: e2, style: t3.style, styleSpec: t3.styleSpec }));
        }
        function p2(t3, s3) {
          const o3 = Wr(t3.value), l3 = qt(t3.value), u3 = null !== t3.value ? t3.value : s3;
          if (n2) {
            if (o3 !== n2)
              return [new $t(t3.key, u3, `${o3} stop domain type must match previous stop domain type ${n2}`)];
          } else
            n2 = o3;
          if ("number" !== o3 && "string" !== o3 && "boolean" !== o3)
            return [new $t(t3.key, u3, "stop domain value must be a number, string, or boolean")];
          if ("number" !== o3 && "categorical" !== r2) {
            let n3 = `number expected, ${o3} found`;
            return Yr(e2) && void 0 === r2 && (n3 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new $t(t3.key, u3, n3)];
          }
          return "categorical" !== r2 || "number" !== o3 || isFinite(l3) && Math.floor(l3) === l3 ? "categorical" !== r2 && "number" === o3 && void 0 !== i2 && l3 < i2 ? [new $t(t3.key, u3, "stop domain values must appear in ascending order")] : (i2 = l3, "categorical" === r2 && l3 in a2 ? [new $t(t3.key, u3, "stop domain values must be unique")] : (a2[l3] = true, [])) : [new $t(t3.key, u3, `integer expected, found ${l3}`)];
        }
      }
      function bn(t2) {
        const e2 = ("property" === t2.expressionContext ? dn : cn)(jt(t2.value), t2.valueSpec);
        if ("error" === e2.result)
          return e2.value.map((e3) => new $t(`${t2.key}${e3.key}`, t2.value, e3.message));
        const r2 = e2.value.expression || e2.value._styleExpression.expression;
        if ("property" === t2.expressionContext && "text-font" === t2.propertyKey && !r2.outputDefined())
          return [new $t(t2.key, t2.value, `Invalid data expression for "${t2.propertyKey}". Output values must be contained as literals within the expression.`)];
        if ("property" === t2.expressionContext && "layout" === t2.propertyType && !Ye(r2))
          return [new $t(t2.key, t2.value, '"feature-state" data expressions are not supported with layout properties.')];
        if ("filter" === t2.expressionContext && !Ye(r2))
          return [new $t(t2.key, t2.value, '"feature-state" data expressions are not supported with filters.')];
        if (t2.expressionContext && 0 === t2.expressionContext.indexOf("cluster")) {
          if (!He(r2, ["zoom", "feature-state"]))
            return [new $t(t2.key, t2.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if ("cluster-initial" === t2.expressionContext && !Ke(r2))
            return [new $t(t2.key, t2.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function wn(t2) {
        const e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec, i2 = [];
        return Array.isArray(n2.values) ? -1 === n2.values.indexOf(qt(r2)) && i2.push(new $t(e2, r2, `expected one of [${n2.values.join(", ")}], ${JSON.stringify(r2)} found`)) : -1 === Object.keys(n2.values).indexOf(qt(r2)) && i2.push(new $t(e2, r2, `expected one of [${Object.keys(n2.values).join(", ")}], ${JSON.stringify(r2)} found`)), i2;
      }
      function _n(t2) {
        if (true === t2 || false === t2)
          return true;
        if (!Array.isArray(t2) || 0 === t2.length)
          return false;
        switch (t2[0]) {
          case "has":
            return t2.length >= 2 && "$id" !== t2[1] && "$type" !== t2[1];
          case "in":
            return t2.length >= 3 && ("string" != typeof t2[1] || Array.isArray(t2[2]));
          case "!in":
          case "!has":
          case "none":
            return false;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return 3 !== t2.length || Array.isArray(t2[1]) || Array.isArray(t2[2]);
          case "any":
          case "all":
            for (const e2 of t2.slice(1))
              if (!_n(e2) && "boolean" != typeof e2)
                return false;
            return true;
          default:
            return true;
        }
      }
      const An = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
      function kn(t2) {
        if (null == t2)
          return { filter: () => true, needGeometry: false };
        _n(t2) || (t2 = zn(t2));
        const e2 = cn(t2, An);
        if ("error" === e2.result)
          throw new Error(e2.value.map((t3) => `${t3.key}: ${t3.message}`).join(", "));
        return { filter: (t3, r2, n2) => e2.value.evaluate(t3, r2, {}, n2), needGeometry: In(t2) };
      }
      function Sn(t2, e2) {
        return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
      }
      function In(t2) {
        if (!Array.isArray(t2))
          return false;
        if ("within" === t2[0])
          return true;
        for (let e2 = 1; e2 < t2.length; e2++)
          if (In(t2[e2]))
            return true;
        return false;
      }
      function zn(t2) {
        if (!t2)
          return true;
        const e2 = t2[0];
        return t2.length <= 1 ? "any" !== e2 : "==" === e2 ? Tn(t2[1], t2[2], "==") : "!=" === e2 ? Cn(Tn(t2[1], t2[2], "==")) : "<" === e2 || ">" === e2 || "<=" === e2 || ">=" === e2 ? Tn(t2[1], t2[2], e2) : "any" === e2 ? (r2 = t2.slice(1), ["any"].concat(r2.map(zn))) : "all" === e2 ? ["all"].concat(t2.slice(1).map(zn)) : "none" === e2 ? ["all"].concat(t2.slice(1).map(zn).map(Cn)) : "in" === e2 ? Mn(t2[1], t2.slice(2)) : "!in" === e2 ? Cn(Mn(t2[1], t2.slice(2))) : "has" === e2 ? En(t2[1]) : "!has" === e2 ? Cn(En(t2[1])) : "within" !== e2 || t2;
        var r2;
      }
      function Tn(t2, e2, r2) {
        switch (t2) {
          case "$type":
            return [`filter-type-${r2}`, e2];
          case "$id":
            return [`filter-id-${r2}`, e2];
          default:
            return [`filter-${r2}`, t2, e2];
        }
      }
      function Mn(t2, e2) {
        if (0 === e2.length)
          return false;
        switch (t2) {
          case "$type":
            return ["filter-type-in", ["literal", e2]];
          case "$id":
            return ["filter-id-in", ["literal", e2]];
          default:
            return e2.length > 200 && !e2.some((t3) => typeof t3 != typeof e2[0]) ? ["filter-in-large", t2, ["literal", e2.sort(Sn)]] : ["filter-in-small", t2, ["literal", e2]];
        }
      }
      function En(t2) {
        switch (t2) {
          case "$type":
            return true;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", t2];
        }
      }
      function Cn(t2) {
        return ["!", t2];
      }
      function Bn(t2) {
        return _n(jt(t2.value)) ? bn(Ot({}, t2, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : Dn(t2);
      }
      function Dn(t2) {
        const e2 = t2.value, r2 = t2.key;
        if ("array" !== Wr(e2))
          return [new $t(r2, e2, `array expected, ${Wr(e2)} found`)];
        const n2 = t2.styleSpec;
        let i2, s2 = [];
        if (e2.length < 1)
          return [new $t(r2, e2, "filter array must have at least 1 element")];
        switch (s2 = s2.concat(wn({ key: `${r2}[0]`, value: e2[0], valueSpec: n2.filter_operator, style: t2.style, styleSpec: t2.styleSpec })), qt(e2[0])) {
          case "<":
          case "<=":
          case ">":
          case ">=":
            e2.length >= 2 && "$type" === qt(e2[1]) && s2.push(new $t(r2, e2, `"$type" cannot be use with operator "${e2[0]}"`));
          case "==":
          case "!=":
            3 !== e2.length && s2.push(new $t(r2, e2, `filter array for operator "${e2[0]}" must have 3 elements`));
          case "in":
          case "!in":
            e2.length >= 2 && (i2 = Wr(e2[1]), "string" !== i2 && s2.push(new $t(`${r2}[1]`, e2[1], `string expected, ${i2} found`)));
            for (let a2 = 2; a2 < e2.length; a2++)
              i2 = Wr(e2[a2]), "$type" === qt(e2[1]) ? s2 = s2.concat(wn({ key: `${r2}[${a2}]`, value: e2[a2], valueSpec: n2.geometry_type, style: t2.style, styleSpec: t2.styleSpec })) : "string" !== i2 && "number" !== i2 && "boolean" !== i2 && s2.push(new $t(`${r2}[${a2}]`, e2[a2], `string, number, or boolean expected, ${i2} found`));
            break;
          case "any":
          case "all":
          case "none":
            for (let n3 = 1; n3 < e2.length; n3++)
              s2 = s2.concat(Dn({ key: `${r2}[${n3}]`, value: e2[n3], style: t2.style, styleSpec: t2.styleSpec }));
            break;
          case "has":
          case "!has":
            i2 = Wr(e2[1]), 2 !== e2.length ? s2.push(new $t(r2, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : "string" !== i2 && s2.push(new $t(`${r2}[1]`, e2[1], `string expected, ${i2} found`));
            break;
          case "within":
            i2 = Wr(e2[1]), 2 !== e2.length ? s2.push(new $t(r2, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : "object" !== i2 && s2.push(new $t(`${r2}[1]`, e2[1], `object expected, ${i2} found`));
        }
        return s2;
      }
      function Pn(t2, e2) {
        const r2 = t2.key, n2 = t2.style, i2 = t2.styleSpec, s2 = t2.value, a2 = t2.objectKey, o2 = i2[`${e2}_${t2.layerType}`];
        if (!o2)
          return [];
        const l2 = a2.match(/^(.*)-transition$/);
        if ("paint" === e2 && l2 && o2[l2[1]] && o2[l2[1]].transition)
          return Zn({ key: r2, value: s2, valueSpec: i2.transition, style: n2, styleSpec: i2 });
        const u2 = t2.valueSpec || o2[a2];
        if (!u2)
          return [new $t(r2, s2, `unknown property "${a2}"`)];
        let c2;
        if ("string" === Wr(s2) && Yr(u2) && !u2.tokens && (c2 = /^{([^}]+)}$/.exec(s2)))
          return [new $t(r2, s2, `"${a2}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(c2[1])} }\`.`)];
        const h2 = [];
        return "symbol" === t2.layerType && ("text-field" === a2 && n2 && !n2.glyphs && h2.push(new $t(r2, s2, 'use of "text-field" requires a style "glyphs" property')), "text-font" === a2 && Qr(jt(s2)) && "identity" === qt(s2.type) && h2.push(new $t(r2, s2, '"text-font" does not support identity functions'))), h2.concat(Zn({ key: t2.key, value: s2, valueSpec: u2, style: n2, styleSpec: i2, expressionContext: "property", propertyType: e2, propertyKey: a2 }));
      }
      function Vn(t2) {
        return Pn(t2, "paint");
      }
      function Ln(t2) {
        return Pn(t2, "layout");
      }
      function Fn(t2) {
        let e2 = [];
        const r2 = t2.value, n2 = t2.key, i2 = t2.style, s2 = t2.styleSpec;
        r2.type || r2.ref || e2.push(new $t(n2, r2, 'either "type" or "ref" is required'));
        let a2 = qt(r2.type);
        const o2 = qt(r2.ref);
        if (r2.id) {
          const s3 = qt(r2.id);
          for (let a3 = 0; a3 < t2.arrayIndex; a3++) {
            const t3 = i2.layers[a3];
            qt(t3.id) === s3 && e2.push(new $t(n2, r2.id, `duplicate layer id "${r2.id}", previously used at line ${t3.id.__line__}`));
          }
        }
        if ("ref" in r2) {
          let t3;
          ["type", "source", "source-layer", "filter", "layout"].forEach((t4) => {
            t4 in r2 && e2.push(new $t(n2, r2[t4], `"${t4}" is prohibited for ref layers`));
          }), i2.layers.forEach((e3) => {
            qt(e3.id) === o2 && (t3 = e3);
          }), t3 ? t3.ref ? e2.push(new $t(n2, r2.ref, "ref cannot reference another ref layer")) : a2 = qt(t3.type) : e2.push(new $t(n2, r2.ref, `ref layer "${o2}" not found`));
        } else if ("background" !== a2 && "sky" !== a2)
          if (r2.source) {
            const t3 = i2.sources && i2.sources[r2.source], s3 = t3 && qt(t3.type);
            t3 ? "vector" === s3 && "raster" === a2 ? e2.push(new $t(n2, r2.source, `layer "${r2.id}" requires a raster source`)) : "raster" === s3 && "raster" !== a2 ? e2.push(new $t(n2, r2.source, `layer "${r2.id}" requires a vector source`)) : "vector" !== s3 || r2["source-layer"] ? "raster-dem" === s3 && "hillshade" !== a2 ? e2.push(new $t(n2, r2.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== a2 || !r2.paint || !r2.paint["line-gradient"] || "geojson" === s3 && t3.lineMetrics || e2.push(new $t(n2, r2, `layer "${r2.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e2.push(new $t(n2, r2, `layer "${r2.id}" must specify a "source-layer"`)) : e2.push(new $t(n2, r2.source, `source "${r2.source}" not found`));
          } else
            e2.push(new $t(n2, r2, 'missing required property "source"'));
        return e2 = e2.concat(mn({ key: n2, value: r2, valueSpec: s2.layer, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { "*": () => [], type: () => Zn({ key: `${n2}.type`, value: r2.type, valueSpec: s2.layer.type, style: t2.style, styleSpec: t2.styleSpec, object: r2, objectKey: "type" }), filter: Bn, layout: (t3) => mn({ layer: r2, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => Ln(Ot({ layerType: a2 }, t4)) } }), paint: (t3) => mn({ layer: r2, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => Vn(Ot({ layerType: a2 }, t4)) } }) } })), e2;
      }
      function Rn(t2) {
        const e2 = t2.value, r2 = t2.key, n2 = Wr(e2);
        return "string" !== n2 ? [new $t(r2, e2, `string expected, ${n2} found`)] : [];
      }
      const $n = { promoteId: function({ key: t2, value: e2 }) {
        if ("string" === Wr(e2))
          return Rn({ key: t2, value: e2 });
        {
          const r2 = [];
          for (const n2 in e2)
            r2.push(...Rn({ key: `${t2}.${n2}`, value: e2[n2] }));
          return r2;
        }
      } };
      function Un(t2) {
        const e2 = t2.value, r2 = t2.key, n2 = t2.styleSpec, i2 = t2.style;
        if (!e2.type)
          return [new $t(r2, e2, '"type" is required')];
        const s2 = qt(e2.type);
        let a2;
        switch (s2) {
          case "vector":
          case "raster":
          case "raster-dem":
            return a2 = mn({ key: r2, value: e2, valueSpec: n2[`source_${s2.replace("-", "_")}`], style: t2.style, styleSpec: n2, objectElementValidators: $n }), a2;
          case "geojson":
            if (a2 = mn({ key: r2, value: e2, valueSpec: n2.source_geojson, style: i2, styleSpec: n2, objectElementValidators: $n }), e2.cluster)
              for (const t3 in e2.clusterProperties) {
                const [n3, i3] = e2.clusterProperties[t3], s3 = "string" == typeof n3 ? [n3, ["accumulated"], ["get", t3]] : n3;
                a2.push(...bn({ key: `${r2}.${t3}.map`, value: i3, expressionContext: "cluster-map" })), a2.push(...bn({ key: `${r2}.${t3}.reduce`, value: s3, expressionContext: "cluster-reduce" }));
              }
            return a2;
          case "video":
            return mn({ key: r2, value: e2, valueSpec: n2.source_video, style: i2, styleSpec: n2 });
          case "image":
            return mn({ key: r2, value: e2, valueSpec: n2.source_image, style: i2, styleSpec: n2 });
          case "canvas":
            return [new $t(r2, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return wn({ key: `${r2}.type`, value: e2.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: i2, styleSpec: n2 });
        }
      }
      function On(t2) {
        const e2 = t2.value, r2 = t2.styleSpec, n2 = r2.light, i2 = t2.style;
        let s2 = [];
        const a2 = Wr(e2);
        if (void 0 === e2)
          return s2;
        if ("object" !== a2)
          return s2 = s2.concat([new $t("light", e2, `object expected, ${a2} found`)]), s2;
        for (const t3 in e2) {
          const a3 = t3.match(/^(.*)-transition$/);
          s2 = s2.concat(a3 && n2[a3[1]] && n2[a3[1]].transition ? Zn({ key: t3, value: e2[t3], valueSpec: r2.transition, style: i2, styleSpec: r2 }) : n2[t3] ? Zn({ key: t3, value: e2[t3], valueSpec: n2[t3], style: i2, styleSpec: r2 }) : [new $t(t3, e2[t3], `unknown property "${t3}"`)]);
        }
        return s2;
      }
      function qn(t2) {
        const e2 = t2.value, r2 = t2.key, n2 = t2.style, i2 = t2.styleSpec, s2 = i2.terrain;
        let a2 = [];
        const o2 = Wr(e2);
        if (void 0 === e2)
          return a2;
        if ("object" !== o2)
          return a2 = a2.concat([new $t("terrain", e2, `object expected, ${o2} found`)]), a2;
        for (const t3 in e2) {
          const r3 = t3.match(/^(.*)-transition$/);
          a2 = a2.concat(r3 && s2[r3[1]] && s2[r3[1]].transition ? Zn({ key: t3, value: e2[t3], valueSpec: i2.transition, style: n2, styleSpec: i2 }) : s2[t3] ? Zn({ key: t3, value: e2[t3], valueSpec: s2[t3], style: n2, styleSpec: i2 }) : [new $t(t3, e2[t3], `unknown property "${t3}"`)]);
        }
        if (e2.source) {
          const t3 = n2.sources && n2.sources[e2.source], i3 = t3 && qt(t3.type);
          t3 ? "raster-dem" !== i3 && a2.push(new $t(r2, e2.source, `terrain cannot be used with a source of type ${i3}, it only be used with a "raster-dem" source type`)) : a2.push(new $t(r2, e2.source, `source "${e2.source}" not found`));
        } else
          a2.push(new $t(r2, e2, 'terrain is missing required property "source"'));
        return a2;
      }
      function jn(t2) {
        const e2 = t2.value, r2 = t2.style, n2 = t2.styleSpec, i2 = n2.fog;
        let s2 = [];
        const a2 = Wr(e2);
        if (void 0 === e2)
          return s2;
        if ("object" !== a2)
          return s2 = s2.concat([new $t("fog", e2, `object expected, ${a2} found`)]), s2;
        for (const t3 in e2) {
          const a3 = t3.match(/^(.*)-transition$/);
          s2 = s2.concat(a3 && i2[a3[1]] && i2[a3[1]].transition ? Zn({ key: t3, value: e2[t3], valueSpec: n2.transition, style: r2, styleSpec: n2 }) : i2[t3] ? Zn({ key: t3, value: e2[t3], valueSpec: i2[t3], style: r2, styleSpec: n2 }) : [new $t(t3, e2[t3], `unknown property "${t3}"`)]);
        }
        return s2;
      }
      const Nn = { "*": () => [], array: gn, boolean: function(t2) {
        const e2 = t2.value, r2 = t2.key, n2 = Wr(e2);
        return "boolean" !== n2 ? [new $t(r2, e2, `boolean expected, ${n2} found`)] : [];
      }, number: xn, color: function(t2) {
        const e2 = t2.key, r2 = t2.value, n2 = Wr(r2);
        return "string" !== n2 ? [new $t(e2, r2, `color expected, ${n2} found`)] : null === ue.parseCSSColor(r2) ? [new $t(e2, r2, `color expected, "${r2}" found`)] : [];
      }, constants: Ut, enum: wn, filter: Bn, function: vn, layer: Fn, object: mn, source: Un, light: On, terrain: qn, fog: jn, string: Rn, formatted: function(t2) {
        return 0 === Rn(t2).length ? [] : bn(t2);
      }, resolvedImage: function(t2) {
        return 0 === Rn(t2).length ? [] : bn(t2);
      } };
      function Zn(t2) {
        const e2 = t2.value, r2 = t2.valueSpec, n2 = t2.styleSpec;
        return r2.expression && Qr(qt(e2)) ? vn(t2) : r2.expression && un(jt(e2)) ? bn(t2) : r2.type && Nn[r2.type] ? Nn[r2.type](t2) : mn(Ot({}, t2, { valueSpec: r2.type ? n2[r2.type] : r2 }));
      }
      function Gn(t2) {
        const e2 = t2.value, r2 = t2.key, n2 = Rn(t2);
        return n2.length || (-1 === e2.indexOf("{fontstack}") && n2.push(new $t(r2, e2, '"glyphs" url must include a "{fontstack}" token')), -1 === e2.indexOf("{range}") && n2.push(new $t(r2, e2, '"glyphs" url must include a "{range}" token'))), n2;
      }
      function Xn(t2, e2 = Rt) {
        let r2 = [];
        return r2 = r2.concat(Zn({ key: "", value: t2, valueSpec: e2.$root, styleSpec: e2, style: t2, objectElementValidators: { glyphs: Gn, "*": () => [] } })), t2.constants && (r2 = r2.concat(Ut({ key: "constants", value: t2.constants, style: t2, styleSpec: e2 }))), Kn(r2);
      }
      function Kn(t2) {
        return [].concat(t2).sort((t3, e2) => t3.line - e2.line);
      }
      function Yn(t2) {
        return function(...e2) {
          return Kn(t2.apply(this, e2));
        };
      }
      Xn.source = Yn(Un), Xn.light = Yn(On), Xn.terrain = Yn(qn), Xn.fog = Yn(jn), Xn.layer = Yn(Fn), Xn.filter = Yn(Bn), Xn.paintProperty = Yn(Vn), Xn.layoutProperty = Yn(Ln);
      const Hn = Xn, Jn = Hn.light, Wn = Hn.fog, Qn = Hn.paintProperty, ti = Hn.layoutProperty;
      function ei(t2, e2) {
        let r2 = false;
        if (e2 && e2.length)
          for (const n2 of e2)
            t2.fire(new Lt(new Error(n2.message))), r2 = true;
        return r2;
      }
      var ri = ni;
      function ni(t2, e2, r2) {
        var n2 = this.cells = [];
        if (t2 instanceof ArrayBuffer) {
          this.arrayBuffer = t2;
          var i2 = new Int32Array(this.arrayBuffer);
          t2 = i2[0], this.d = (e2 = i2[1]) + 2 * (r2 = i2[2]);
          for (var s2 = 0; s2 < this.d * this.d; s2++) {
            var a2 = i2[3 + s2], o2 = i2[3 + s2 + 1];
            n2.push(a2 === o2 ? null : i2.subarray(a2, o2));
          }
          var l2 = i2[3 + n2.length + 1];
          this.keys = i2.subarray(i2[3 + n2.length], l2), this.bboxes = i2.subarray(l2), this.insert = this._insertReadonly;
        } else {
          this.d = e2 + 2 * r2;
          for (var u2 = 0; u2 < this.d * this.d; u2++)
            n2.push([]);
          this.keys = [], this.bboxes = [];
        }
        this.n = e2, this.extent = t2, this.padding = r2, this.scale = e2 / t2, this.uid = 0;
        var c2 = r2 / e2 * t2;
        this.min = -c2, this.max = t2 + c2;
      }
      ni.prototype.insert = function(t2, e2, r2, n2, i2) {
        this._forEachCell(e2, r2, n2, i2, this._insertCell, this.uid++), this.keys.push(t2), this.bboxes.push(e2), this.bboxes.push(r2), this.bboxes.push(n2), this.bboxes.push(i2);
      }, ni.prototype._insertReadonly = function() {
        throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
      }, ni.prototype._insertCell = function(t2, e2, r2, n2, i2, s2) {
        this.cells[i2].push(s2);
      }, ni.prototype.query = function(t2, e2, r2, n2, i2) {
        var s2 = this.min, a2 = this.max;
        if (t2 <= s2 && e2 <= s2 && a2 <= r2 && a2 <= n2 && !i2)
          return Array.prototype.slice.call(this.keys);
        var o2 = [];
        return this._forEachCell(t2, e2, r2, n2, this._queryCell, o2, {}, i2), o2;
      }, ni.prototype._queryCell = function(t2, e2, r2, n2, i2, s2, a2, o2) {
        var l2 = this.cells[i2];
        if (null !== l2)
          for (var u2 = this.keys, c2 = this.bboxes, h2 = 0; h2 < l2.length; h2++) {
            var p2 = l2[h2];
            if (void 0 === a2[p2]) {
              var d2 = 4 * p2;
              (o2 ? o2(c2[d2 + 0], c2[d2 + 1], c2[d2 + 2], c2[d2 + 3]) : t2 <= c2[d2 + 2] && e2 <= c2[d2 + 3] && r2 >= c2[d2 + 0] && n2 >= c2[d2 + 1]) ? (a2[p2] = true, s2.push(u2[p2])) : a2[p2] = false;
            }
          }
      }, ni.prototype._forEachCell = function(t2, e2, r2, n2, i2, s2, a2, o2) {
        for (var l2 = this._convertToCellCoord(t2), u2 = this._convertToCellCoord(e2), c2 = this._convertToCellCoord(r2), h2 = this._convertToCellCoord(n2), p2 = l2; p2 <= c2; p2++)
          for (var d2 = u2; d2 <= h2; d2++) {
            var f2 = this.d * d2 + p2;
            if ((!o2 || o2(this._convertFromCellCoord(p2), this._convertFromCellCoord(d2), this._convertFromCellCoord(p2 + 1), this._convertFromCellCoord(d2 + 1))) && i2.call(this, t2, e2, r2, n2, f2, s2, a2, o2))
              return;
          }
      }, ni.prototype._convertFromCellCoord = function(t2) {
        return (t2 - this.padding) / this.scale;
      }, ni.prototype._convertToCellCoord = function(t2) {
        return Math.max(0, Math.min(this.d - 1, Math.floor(t2 * this.scale) + this.padding));
      }, ni.prototype.toArrayBuffer = function() {
        if (this.arrayBuffer)
          return this.arrayBuffer;
        for (var t2 = this.cells, e2 = 3 + this.cells.length + 1 + 1, r2 = 0, n2 = 0; n2 < this.cells.length; n2++)
          r2 += this.cells[n2].length;
        var i2 = new Int32Array(e2 + r2 + this.keys.length + this.bboxes.length);
        i2[0] = this.extent, i2[1] = this.n, i2[2] = this.padding;
        for (var s2 = e2, a2 = 0; a2 < t2.length; a2++) {
          var o2 = t2[a2];
          i2[3 + a2] = s2, i2.set(o2, s2), s2 += o2.length;
        }
        return i2[3 + t2.length] = s2, i2.set(this.keys, s2), i2[3 + t2.length + 1] = s2 += this.keys.length, i2.set(this.bboxes, s2), s2 += this.bboxes.length, i2.buffer;
      };
      const { ImageData: ii, ImageBitmap: si } = a, ai = {};
      function oi(t2, e2, r2 = {}) {
        Object.defineProperty(e2, "_classRegistryKey", { value: t2, writeable: false }), ai[t2] = { klass: e2, omit: r2.omit || [], shallow: r2.shallow || [] };
      }
      oi("Object", Object), ri.serialize = function(t2, e2) {
        const r2 = t2.toArrayBuffer();
        return e2 && e2.push(r2), { buffer: r2 };
      }, ri.deserialize = function(t2) {
        return new ri(t2.buffer);
      }, oi("Grid", ri), oi("Color", ce), oi("Error", Error), oi("ResolvedImage", fe), oi("StylePropertyFunction", fn), oi("StyleExpression", ln, { omit: ["_evaluator"] }), oi("ZoomDependentExpression", pn), oi("ZoomConstantExpression", hn), oi("CompoundExpression", Me, { omit: ["_evaluate"] });
      for (const t2 in qr)
        qr[t2]._classRegistryKey || oi(`Expression_${t2}`, qr[t2]);
      function li(t2) {
        return t2 && "undefined" != typeof ArrayBuffer && (t2 instanceof ArrayBuffer || t2.constructor && "ArrayBuffer" === t2.constructor.name);
      }
      function ui(t2) {
        return si && t2 instanceof si;
      }
      function ci(t2, e2) {
        if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp)
          return t2;
        if (li(t2) || ui(t2))
          return e2 && e2.push(t2), t2;
        if (ArrayBuffer.isView(t2)) {
          const r2 = t2;
          return e2 && e2.push(r2.buffer), r2;
        }
        if (t2 instanceof ii)
          return e2 && e2.push(t2.data.buffer), t2;
        if (Array.isArray(t2)) {
          const r2 = [];
          for (const n2 of t2)
            r2.push(ci(n2, e2));
          return r2;
        }
        if ("object" == typeof t2) {
          const r2 = t2.constructor, n2 = r2._classRegistryKey;
          if (!n2)
            throw new Error("can't serialize object of unregistered class");
          const i2 = r2.serialize ? r2.serialize(t2, e2) : {};
          if (!r2.serialize) {
            for (const r3 in t2) {
              if (!t2.hasOwnProperty(r3))
                continue;
              if (ai[n2].omit.indexOf(r3) >= 0)
                continue;
              const s2 = t2[r3];
              i2[r3] = ai[n2].shallow.indexOf(r3) >= 0 ? s2 : ci(s2, e2);
            }
            t2 instanceof Error && (i2.message = t2.message);
          }
          if (i2.$name)
            throw new Error("$name property is reserved for worker serialization logic.");
          return "Object" !== n2 && (i2.$name = n2), i2;
        }
        throw new Error("can't serialize object of type " + typeof t2);
      }
      function hi(t2) {
        if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || li(t2) || ui(t2) || ArrayBuffer.isView(t2) || t2 instanceof ii)
          return t2;
        if (Array.isArray(t2))
          return t2.map(hi);
        if ("object" == typeof t2) {
          const e2 = t2.$name || "Object", { klass: r2 } = ai[e2];
          if (!r2)
            throw new Error(`can't deserialize unregistered class ${e2}`);
          if (r2.deserialize)
            return r2.deserialize(t2);
          const n2 = Object.create(r2.prototype);
          for (const r3 of Object.keys(t2)) {
            if ("$name" === r3)
              continue;
            const i2 = t2[r3];
            n2[r3] = ai[e2].shallow.indexOf(r3) >= 0 ? i2 : hi(i2);
          }
          return n2;
        }
        throw new Error("can't deserialize object of type " + typeof t2);
      }
      class pi {
        constructor() {
          this.first = true;
        }
        update(t2, e2) {
          const r2 = Math.floor(t2);
          return this.first ? (this.first = false, this.lastIntegerZoom = r2, this.lastIntegerZoomTime = 0, this.lastZoom = t2, this.lastFloorZoom = r2, true) : (this.lastFloorZoom > r2 ? (this.lastIntegerZoom = r2 + 1, this.lastIntegerZoomTime = e2) : this.lastFloorZoom < r2 && (this.lastIntegerZoom = r2, this.lastIntegerZoomTime = e2), t2 !== this.lastZoom && (this.lastZoom = t2, this.lastFloorZoom = r2, true));
        }
      }
      const di = (t2) => t2 >= 1536 && t2 <= 1791, fi = (t2) => t2 >= 1872 && t2 <= 1919, yi = (t2) => t2 >= 2208 && t2 <= 2303, mi = (t2) => t2 >= 11904 && t2 <= 12031, gi = (t2) => t2 >= 12032 && t2 <= 12255, xi = (t2) => t2 >= 12272 && t2 <= 12287, vi = (t2) => t2 >= 12288 && t2 <= 12351, bi = (t2) => t2 >= 12352 && t2 <= 12447, wi = (t2) => t2 >= 12448 && t2 <= 12543, _i = (t2) => t2 >= 12544 && t2 <= 12591, Ai = (t2) => t2 >= 12704 && t2 <= 12735, ki = (t2) => t2 >= 12736 && t2 <= 12783, Si = (t2) => t2 >= 12784 && t2 <= 12799, Ii = (t2) => t2 >= 12800 && t2 <= 13055, zi = (t2) => t2 >= 13056 && t2 <= 13311, Ti = (t2) => t2 >= 13312 && t2 <= 19903, Mi = (t2) => t2 >= 19968 && t2 <= 40959, Ei = (t2) => t2 >= 40960 && t2 <= 42127, Ci = (t2) => t2 >= 42128 && t2 <= 42191, Bi = (t2) => t2 >= 44032 && t2 <= 55215, Di = (t2) => t2 >= 63744 && t2 <= 64255, Pi = (t2) => t2 >= 64336 && t2 <= 65023, Vi = (t2) => t2 >= 65040 && t2 <= 65055, Li = (t2) => t2 >= 65072 && t2 <= 65103, Fi = (t2) => t2 >= 65104 && t2 <= 65135, Ri = (t2) => t2 >= 65136 && t2 <= 65279, $i = (t2) => t2 >= 65280 && t2 <= 65519;
      function Ui(t2) {
        for (const e2 of t2)
          if (ji(e2.charCodeAt(0)))
            return true;
        return false;
      }
      function Oi(t2) {
        for (const e2 of t2)
          if (!qi(e2.charCodeAt(0)))
            return false;
        return true;
      }
      function qi(t2) {
        return !(di(t2) || fi(t2) || yi(t2) || Pi(t2) || Ri(t2));
      }
      function ji(t2) {
        return !(746 !== t2 && 747 !== t2 && (t2 < 4352 || !(Ai(t2) || _i(t2) || Li(t2) && !(t2 >= 65097 && t2 <= 65103) || Di(t2) || zi(t2) || mi(t2) || ki(t2) || !(!vi(t2) || t2 >= 12296 && t2 <= 12305 || t2 >= 12308 && t2 <= 12319 || 12336 === t2) || Ti(t2) || Mi(t2) || Ii(t2) || ((t3) => t3 >= 12592 && t3 <= 12687)(t2) || ((t3) => t3 >= 43360 && t3 <= 43391)(t2) || ((t3) => t3 >= 55216 && t3 <= 55295)(t2) || ((t3) => t3 >= 4352 && t3 <= 4607)(t2) || Bi(t2) || bi(t2) || xi(t2) || ((t3) => t3 >= 12688 && t3 <= 12703)(t2) || gi(t2) || Si(t2) || wi(t2) && 12540 !== t2 || !(!$i(t2) || 65288 === t2 || 65289 === t2 || 65293 === t2 || t2 >= 65306 && t2 <= 65310 || 65339 === t2 || 65341 === t2 || 65343 === t2 || t2 >= 65371 && t2 <= 65503 || 65507 === t2 || t2 >= 65512 && t2 <= 65519) || !(!Fi(t2) || t2 >= 65112 && t2 <= 65118 || t2 >= 65123 && t2 <= 65126) || ((t3) => t3 >= 5120 && t3 <= 5759)(t2) || ((t3) => t3 >= 6320 && t3 <= 6399)(t2) || Vi(t2) || ((t3) => t3 >= 19904 && t3 <= 19967)(t2) || Ei(t2) || Ci(t2))));
      }
      function Ni(t2) {
        return !(ji(t2) || function(t3) {
          return !!(((t4) => t4 >= 128 && t4 <= 255)(t3) && (167 === t3 || 169 === t3 || 174 === t3 || 177 === t3 || 188 === t3 || 189 === t3 || 190 === t3 || 215 === t3 || 247 === t3) || ((t4) => t4 >= 8192 && t4 <= 8303)(t3) && (8214 === t3 || 8224 === t3 || 8225 === t3 || 8240 === t3 || 8241 === t3 || 8251 === t3 || 8252 === t3 || 8258 === t3 || 8263 === t3 || 8264 === t3 || 8265 === t3 || 8273 === t3) || ((t4) => t4 >= 8448 && t4 <= 8527)(t3) || ((t4) => t4 >= 8528 && t4 <= 8591)(t3) || ((t4) => t4 >= 8960 && t4 <= 9215)(t3) && (t3 >= 8960 && t3 <= 8967 || t3 >= 8972 && t3 <= 8991 || t3 >= 8996 && t3 <= 9e3 || 9003 === t3 || t3 >= 9085 && t3 <= 9114 || t3 >= 9150 && t3 <= 9165 || 9167 === t3 || t3 >= 9169 && t3 <= 9179 || t3 >= 9186 && t3 <= 9215) || ((t4) => t4 >= 9216 && t4 <= 9279)(t3) && 9251 !== t3 || ((t4) => t4 >= 9280 && t4 <= 9311)(t3) || ((t4) => t4 >= 9312 && t4 <= 9471)(t3) || ((t4) => t4 >= 9632 && t4 <= 9727)(t3) || ((t4) => t4 >= 9728 && t4 <= 9983)(t3) && !(t3 >= 9754 && t3 <= 9759) || ((t4) => t4 >= 11008 && t4 <= 11263)(t3) && (t3 >= 11026 && t3 <= 11055 || t3 >= 11088 && t3 <= 11097 || t3 >= 11192 && t3 <= 11243) || vi(t3) || wi(t3) || ((t4) => t4 >= 57344 && t4 <= 63743)(t3) || Li(t3) || Fi(t3) || $i(t3) || 8734 === t3 || 8756 === t3 || 8757 === t3 || t3 >= 9984 && t3 <= 10087 || t3 >= 10102 && t3 <= 10131 || 65532 === t3 || 65533 === t3);
        }(t2));
      }
      function Zi(t2) {
        return t2 >= 1424 && t2 <= 2303 || Pi(t2) || Ri(t2);
      }
      function Gi(t2, e2) {
        return !(!e2 && Zi(t2) || t2 >= 2304 && t2 <= 3583 || t2 >= 3840 && t2 <= 4255 || ((t3) => t3 >= 6016 && t3 <= 6143)(t2));
      }
      function Xi(t2) {
        for (const e2 of t2)
          if (Zi(e2.charCodeAt(0)))
            return true;
        return false;
      }
      const Ki = "deferred", Yi = "loading", Hi = "loaded";
      let Ji = null, Wi = "unavailable", Qi = null;
      const ts = function(t2) {
        t2 && "string" == typeof t2 && t2.indexOf("NetworkError") > -1 && (Wi = "error"), Ji && Ji(t2);
      };
      function es() {
        rs.fire(new Vt("pluginStateChange", { pluginStatus: Wi, pluginURL: Qi }));
      }
      const rs = new Ft(), ns = function() {
        return Wi;
      }, is = function() {
        if (Wi !== Ki || !Qi)
          throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
        Wi = Yi, es(), Qi && St({ url: Qi }, (t2) => {
          t2 ? ts(t2) : (Wi = Hi, es());
        });
      }, ss = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => Wi === Hi || null != ss.applyArabicShaping, isLoading: () => Wi === Yi, setState(t2) {
        Wi = t2.pluginStatus, Qi = t2.pluginURL;
      }, isParsed: () => null != ss.applyArabicShaping && null != ss.processBidirectionalText && null != ss.processStyledBidirectionalText, getPluginURL: () => Qi };
      class as {
        constructor(t2, e2) {
          this.zoom = t2, e2 ? (this.now = e2.now, this.fadeDuration = e2.fadeDuration, this.zoomHistory = e2.zoomHistory, this.transition = e2.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new pi(), this.transition = {});
        }
        isSupportedScript(t2) {
          return function(t3, e2) {
            for (const r2 of t3)
              if (!Gi(r2.charCodeAt(0), e2))
                return false;
            return true;
          }(t2, ss.isLoaded());
        }
        crossFadingFactor() {
          return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
        }
        getCrossfadeParameters() {
          const t2 = this.zoom, e2 = t2 - Math.floor(t2), r2 = this.crossFadingFactor();
          return t2 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e2 + (1 - e2) * r2 } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - r2) * e2 };
        }
      }
      class os {
        constructor(t2, e2) {
          this.property = t2, this.value = e2, this.expression = function(t3, e3) {
            if (Qr(t3))
              return new fn(t3, e3);
            if (un(t3)) {
              const r2 = dn(t3, e3);
              if ("error" === r2.result)
                throw new Error(r2.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
              return r2.value;
            }
            {
              let r2 = t3;
              return "string" == typeof t3 && "color" === e3.type && (r2 = ce.parse(t3)), { kind: "constant", evaluate: () => r2 };
            }
          }(void 0 === e2 ? t2.specification.default : e2, t2.specification);
        }
        isDataDriven() {
          return "source" === this.expression.kind || "composite" === this.expression.kind;
        }
        possiblyEvaluate(t2, e2, r2) {
          return this.property.possiblyEvaluate(this, t2, e2, r2);
        }
      }
      class ls {
        constructor(t2) {
          this.property = t2, this.value = new os(t2, void 0);
        }
        transitioned(t2, e2) {
          return new cs(this.property, this.value, e2, v({}, t2.transition, this.transition), t2.now);
        }
        untransitioned() {
          return new cs(this.property, this.value, null, {}, 0);
        }
      }
      class us {
        constructor(t2) {
          this._properties = t2, this._values = Object.create(t2.defaultTransitionablePropertyValues);
        }
        getValue(t2) {
          return M(this._values[t2].value.value);
        }
        setValue(t2, e2) {
          this._values.hasOwnProperty(t2) || (this._values[t2] = new ls(this._values[t2].property)), this._values[t2].value = new os(this._values[t2].property, null === e2 ? void 0 : M(e2));
        }
        getTransition(t2) {
          return M(this._values[t2].transition);
        }
        setTransition(t2, e2) {
          this._values.hasOwnProperty(t2) || (this._values[t2] = new ls(this._values[t2].property)), this._values[t2].transition = M(e2) || void 0;
        }
        serialize() {
          const t2 = {};
          for (const e2 of Object.keys(this._values)) {
            const r2 = this.getValue(e2);
            void 0 !== r2 && (t2[e2] = r2);
            const n2 = this.getTransition(e2);
            void 0 !== n2 && (t2[`${e2}-transition`] = n2);
          }
          return t2;
        }
        transitioned(t2, e2) {
          const r2 = new hs(this._properties);
          for (const n2 of Object.keys(this._values))
            r2._values[n2] = this._values[n2].transitioned(t2, e2._values[n2]);
          return r2;
        }
        untransitioned() {
          const t2 = new hs(this._properties);
          for (const e2 of Object.keys(this._values))
            t2._values[e2] = this._values[e2].untransitioned();
          return t2;
        }
      }
      class cs {
        constructor(t2, e2, r2, n2, i2) {
          const s2 = n2.delay || 0, a2 = n2.duration || 0;
          i2 = i2 || 0, this.property = t2, this.value = e2, this.begin = i2 + s2, this.end = this.begin + a2, t2.specification.transition && (n2.delay || n2.duration) && (this.prior = r2);
        }
        possiblyEvaluate(t2, e2, r2) {
          const n2 = t2.now || 0, i2 = this.value.possiblyEvaluate(t2, e2, r2), s2 = this.prior;
          if (s2) {
            if (n2 > this.end)
              return this.prior = null, i2;
            if (this.value.isDataDriven())
              return this.prior = null, i2;
            if (n2 < this.begin)
              return s2.possiblyEvaluate(t2, e2, r2);
            {
              const a2 = (n2 - this.begin) / (this.end - this.begin);
              return this.property.interpolate(s2.possiblyEvaluate(t2, e2, r2), i2, p(a2));
            }
          }
          return i2;
        }
      }
      class hs {
        constructor(t2) {
          this._properties = t2, this._values = Object.create(t2.defaultTransitioningPropertyValues);
        }
        possiblyEvaluate(t2, e2, r2) {
          const n2 = new fs(this._properties);
          for (const i2 of Object.keys(this._values))
            n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
          return n2;
        }
        hasTransition() {
          for (const t2 of Object.keys(this._values))
            if (this._values[t2].prior)
              return true;
          return false;
        }
      }
      class ps {
        constructor(t2) {
          this._properties = t2, this._values = Object.create(t2.defaultPropertyValues);
        }
        getValue(t2) {
          return M(this._values[t2].value);
        }
        setValue(t2, e2) {
          this._values[t2] = new os(this._values[t2].property, null === e2 ? void 0 : M(e2));
        }
        serialize() {
          const t2 = {};
          for (const e2 of Object.keys(this._values)) {
            const r2 = this.getValue(e2);
            void 0 !== r2 && (t2[e2] = r2);
          }
          return t2;
        }
        possiblyEvaluate(t2, e2, r2) {
          const n2 = new fs(this._properties);
          for (const i2 of Object.keys(this._values))
            n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
          return n2;
        }
      }
      class ds {
        constructor(t2, e2, r2) {
          this.property = t2, this.value = e2, this.parameters = r2;
        }
        isConstant() {
          return "constant" === this.value.kind;
        }
        constantOr(t2) {
          return "constant" === this.value.kind ? this.value.value : t2;
        }
        evaluate(t2, e2, r2, n2) {
          return this.property.evaluate(this.value, this.parameters, t2, e2, r2, n2);
        }
      }
      class fs {
        constructor(t2) {
          this._properties = t2, this._values = Object.create(t2.defaultPossiblyEvaluatedValues);
        }
        get(t2) {
          return this._values[t2];
        }
      }
      class ys {
        constructor(t2) {
          this.specification = t2;
        }
        possiblyEvaluate(t2, e2) {
          return t2.expression.evaluate(e2);
        }
        interpolate(t2, e2, r2) {
          const n2 = nr[this.specification.type];
          return n2 ? n2(t2, e2, r2) : t2;
        }
      }
      class ms {
        constructor(t2, e2) {
          this.specification = t2, this.overrides = e2;
        }
        possiblyEvaluate(t2, e2, r2, n2) {
          return new ds(this, "constant" === t2.expression.kind || "camera" === t2.expression.kind ? { kind: "constant", value: t2.expression.evaluate(e2, null, {}, r2, n2) } : t2.expression, e2);
        }
        interpolate(t2, e2, r2) {
          if ("constant" !== t2.value.kind || "constant" !== e2.value.kind)
            return t2;
          if (void 0 === t2.value.value || void 0 === e2.value.value)
            return new ds(this, { kind: "constant", value: void 0 }, t2.parameters);
          const n2 = nr[this.specification.type];
          return n2 ? new ds(this, { kind: "constant", value: n2(t2.value.value, e2.value.value, r2) }, t2.parameters) : t2;
        }
        evaluate(t2, e2, r2, n2, i2, s2) {
          return "constant" === t2.kind ? t2.value : t2.evaluate(e2, r2, n2, i2, s2);
        }
      }
      class gs extends ms {
        possiblyEvaluate(t2, e2, r2, n2) {
          if (void 0 === t2.value)
            return new ds(this, { kind: "constant", value: void 0 }, e2);
          if ("constant" === t2.expression.kind) {
            const i2 = t2.expression.evaluate(e2, null, {}, r2, n2), s2 = "resolvedImage" === t2.property.specification.type && "string" != typeof i2 ? i2.name : i2, a2 = this._calculate(s2, s2, s2, e2);
            return new ds(this, { kind: "constant", value: a2 }, e2);
          }
          if ("camera" === t2.expression.kind) {
            const r3 = this._calculate(t2.expression.evaluate({ zoom: e2.zoom - 1 }), t2.expression.evaluate({ zoom: e2.zoom }), t2.expression.evaluate({ zoom: e2.zoom + 1 }), e2);
            return new ds(this, { kind: "constant", value: r3 }, e2);
          }
          return new ds(this, t2.expression, e2);
        }
        evaluate(t2, e2, r2, n2, i2, s2) {
          if ("source" === t2.kind) {
            const a2 = t2.evaluate(e2, r2, n2, i2, s2);
            return this._calculate(a2, a2, a2, e2);
          }
          return "composite" === t2.kind ? this._calculate(t2.evaluate({ zoom: Math.floor(e2.zoom) - 1 }, r2, n2), t2.evaluate({ zoom: Math.floor(e2.zoom) }, r2, n2), t2.evaluate({ zoom: Math.floor(e2.zoom) + 1 }, r2, n2), e2) : t2.value;
        }
        _calculate(t2, e2, r2, n2) {
          return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t2, to: e2, other: r2 } : { from: r2, to: e2, other: t2 };
        }
        interpolate(t2) {
          return t2;
        }
      }
      class xs {
        constructor(t2) {
          this.specification = t2;
        }
        possiblyEvaluate(t2, e2, r2, n2) {
          if (void 0 !== t2.value) {
            if ("constant" === t2.expression.kind) {
              const i2 = t2.expression.evaluate(e2, null, {}, r2, n2);
              return this._calculate(i2, i2, i2, e2);
            }
            return this._calculate(t2.expression.evaluate(new as(Math.floor(e2.zoom - 1), e2)), t2.expression.evaluate(new as(Math.floor(e2.zoom), e2)), t2.expression.evaluate(new as(Math.floor(e2.zoom + 1), e2)), e2);
          }
        }
        _calculate(t2, e2, r2, n2) {
          return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t2, to: e2 } : { from: r2, to: e2 };
        }
        interpolate(t2) {
          return t2;
        }
      }
      class vs {
        constructor(t2) {
          this.specification = t2;
        }
        possiblyEvaluate(t2, e2, r2, n2) {
          return !!t2.expression.evaluate(e2, null, {}, r2, n2);
        }
        interpolate() {
          return false;
        }
      }
      class bs {
        constructor(t2) {
          this.properties = t2, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
          for (const e2 in t2) {
            const r2 = t2[e2];
            r2.specification.overridable && this.overridableProperties.push(e2);
            const n2 = this.defaultPropertyValues[e2] = new os(r2, void 0), i2 = this.defaultTransitionablePropertyValues[e2] = new ls(r2);
            this.defaultTransitioningPropertyValues[e2] = i2.untransitioned(), this.defaultPossiblyEvaluatedValues[e2] = n2.possiblyEvaluate({});
          }
        }
      }
      function ws(t2, e2) {
        return 256 * (t2 = y(Math.floor(t2), 0, 255)) + y(Math.floor(e2), 0, 255);
      }
      oi("DataDrivenProperty", ms), oi("DataConstantProperty", ys), oi("CrossFadedDataDrivenProperty", gs), oi("CrossFadedProperty", xs), oi("ColorRampProperty", vs);
      const _s = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
      class As {
        constructor(t2, e2) {
          this._structArray = t2, this._pos1 = e2 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }
      }
      class ks {
        constructor() {
          this.isTransferred = false, this.capacity = -1, this.resize(0);
        }
        static serialize(t2, e2) {
          return t2._trim(), e2 && (t2.isTransferred = true, e2.push(t2.arrayBuffer)), { length: t2.length, arrayBuffer: t2.arrayBuffer };
        }
        static deserialize(t2) {
          const e2 = Object.create(this.prototype);
          return e2.arrayBuffer = t2.arrayBuffer, e2.length = t2.length, e2.capacity = t2.arrayBuffer.byteLength / e2.bytesPerElement, e2._refreshViews(), e2;
        }
        _trim() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(t2) {
          this.reserve(t2), this.length = t2;
        }
        reserve(t2) {
          if (t2 > this.capacity) {
            this.capacity = Math.max(t2, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            const e2 = this.uint8;
            this._refreshViews(), e2 && this.uint8.set(e2);
          }
        }
        _refreshViews() {
          throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
        }
      }
      function Ss(t2, e2 = 1) {
        let r2 = 0, n2 = 0;
        return { members: t2.map((t3) => {
          const i2 = _s[t3.type].BYTES_PER_ELEMENT, s2 = r2 = Is(r2, Math.max(e2, i2)), a2 = t3.components || 1;
          return n2 = Math.max(n2, i2), r2 += i2 * a2, { name: t3.name, type: t3.type, components: a2, offset: s2 };
        }), size: Is(r2, Math.max(n2, e2)), alignment: e2 };
      }
      function Is(t2, e2) {
        return Math.ceil(t2 / e2) * e2;
      }
      class zs extends ks {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2) {
          const r2 = this.length;
          return this.resize(r2 + 1), this.emplace(r2, t2, e2);
        }
        emplace(t2, e2, r2) {
          const n2 = 2 * t2;
          return this.int16[n2 + 0] = e2, this.int16[n2 + 1] = r2, t2;
        }
      }
      zs.prototype.bytesPerElement = 4, oi("StructArrayLayout2i4", zs);
      class Ts extends ks {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
        }
        emplace(t2, e2, r2, n2, i2) {
          const s2 = 4 * t2;
          return this.int16[s2 + 0] = e2, this.int16[s2 + 1] = r2, this.int16[s2 + 2] = n2, this.int16[s2 + 3] = i2, t2;
        }
      }
      Ts.prototype.bytesPerElement = 8, oi("StructArrayLayout4i8", Ts);
      class Ms extends ks {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2, a2) {
          const o2 = this.length;
          return this.resize(o2 + 1), this.emplace(o2, t2, e2, r2, n2, i2, s2, a2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2, o2) {
          const l2 = 6 * t2, u2 = 12 * t2, c2 = 3 * t2;
          return this.int16[l2 + 0] = e2, this.int16[l2 + 1] = r2, this.uint8[u2 + 4] = n2, this.uint8[u2 + 5] = i2, this.uint8[u2 + 6] = s2, this.uint8[u2 + 7] = a2, this.float32[c2 + 2] = o2, t2;
        }
      }
      Ms.prototype.bytesPerElement = 12, oi("StructArrayLayout2i4ub1f12", Ms);
      class Es extends ks {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2) {
          const n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
        }
        emplace(t2, e2, r2, n2) {
          const i2 = 3 * t2;
          return this.float32[i2 + 0] = e2, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, t2;
        }
      }
      Es.prototype.bytesPerElement = 12, oi("StructArrayLayout3f12", Es);
      class Cs extends ks {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
          const c2 = this.length;
          return this.resize(c2 + 1), this.emplace(c2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2) {
          const h2 = 10 * t2;
          return this.uint16[h2 + 0] = e2, this.uint16[h2 + 1] = r2, this.uint16[h2 + 2] = n2, this.uint16[h2 + 3] = i2, this.uint16[h2 + 4] = s2, this.uint16[h2 + 5] = a2, this.uint16[h2 + 6] = o2, this.uint16[h2 + 7] = l2, this.uint16[h2 + 8] = u2, this.uint16[h2 + 9] = c2, t2;
        }
      }
      Cs.prototype.bytesPerElement = 20, oi("StructArrayLayout10ui20", Cs);
      class Bs extends ks {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2) {
          const l2 = this.length;
          return this.resize(l2 + 1), this.emplace(l2, t2, e2, r2, n2, i2, s2, a2, o2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
          const u2 = 8 * t2;
          return this.uint16[u2 + 0] = e2, this.uint16[u2 + 1] = r2, this.uint16[u2 + 2] = n2, this.uint16[u2 + 3] = i2, this.uint16[u2 + 4] = s2, this.uint16[u2 + 5] = a2, this.uint16[u2 + 6] = o2, this.uint16[u2 + 7] = l2, t2;
        }
      }
      Bs.prototype.bytesPerElement = 16, oi("StructArrayLayout8ui16", Bs);
      class Ds extends ks {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, y2) {
          const m2 = this.length;
          return this.resize(m2 + 1), this.emplace(m2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, y2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, y2, m2) {
          const g2 = 16 * t2;
          return this.int16[g2 + 0] = e2, this.int16[g2 + 1] = r2, this.int16[g2 + 2] = n2, this.int16[g2 + 3] = i2, this.uint16[g2 + 4] = s2, this.uint16[g2 + 5] = a2, this.uint16[g2 + 6] = o2, this.uint16[g2 + 7] = l2, this.int16[g2 + 8] = u2, this.int16[g2 + 9] = c2, this.int16[g2 + 10] = h2, this.int16[g2 + 11] = p2, this.int16[g2 + 12] = d2, this.int16[g2 + 13] = f2, this.int16[g2 + 14] = y2, this.int16[g2 + 15] = m2, t2;
        }
      }
      Ds.prototype.bytesPerElement = 32, oi("StructArrayLayout4i4ui4i4i32", Ds);
      class Ps extends ks {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(t2) {
          const e2 = this.length;
          return this.resize(e2 + 1), this.emplace(e2, t2);
        }
        emplace(t2, e2) {
          return this.uint32[1 * t2 + 0] = e2, t2;
        }
      }
      Ps.prototype.bytesPerElement = 4, oi("StructArrayLayout1ul4", Ps);
      class Vs extends ks {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
          const d2 = this.length;
          return this.resize(d2 + 1), this.emplace(d2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2) {
          const f2 = 20 * t2, y2 = 10 * t2;
          return this.int16[f2 + 0] = e2, this.int16[f2 + 1] = r2, this.int16[f2 + 2] = n2, this.int16[f2 + 3] = i2, this.int16[f2 + 4] = s2, this.float32[y2 + 3] = a2, this.float32[y2 + 4] = o2, this.float32[y2 + 5] = l2, this.float32[y2 + 6] = u2, this.int16[f2 + 14] = c2, this.uint32[y2 + 8] = h2, this.uint16[f2 + 18] = p2, this.uint16[f2 + 19] = d2, t2;
        }
      }
      Vs.prototype.bytesPerElement = 40, oi("StructArrayLayout5i4f1i1ul2ui40", Vs);
      class Ls extends ks {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2, a2) {
          const o2 = this.length;
          return this.resize(o2 + 1), this.emplace(o2, t2, e2, r2, n2, i2, s2, a2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2, o2) {
          const l2 = 8 * t2;
          return this.int16[l2 + 0] = e2, this.int16[l2 + 1] = r2, this.int16[l2 + 2] = n2, this.int16[l2 + 4] = i2, this.int16[l2 + 5] = s2, this.int16[l2 + 6] = a2, this.int16[l2 + 7] = o2, t2;
        }
      }
      Ls.prototype.bytesPerElement = 16, oi("StructArrayLayout3i2i2i16", Ls);
      class Fs extends ks {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2) {
          const s2 = this.length;
          return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2);
        }
        emplace(t2, e2, r2, n2, i2, s2) {
          const a2 = 4 * t2, o2 = 8 * t2;
          return this.float32[a2 + 0] = e2, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n2, this.int16[o2 + 6] = i2, this.int16[o2 + 7] = s2, t2;
        }
      }
      Fs.prototype.bytesPerElement = 16, oi("StructArrayLayout2f1f2i16", Fs);
      class Rs extends ks {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
        }
        emplace(t2, e2, r2, n2, i2) {
          const s2 = 12 * t2, a2 = 3 * t2;
          return this.uint8[s2 + 0] = e2, this.uint8[s2 + 1] = r2, this.float32[a2 + 1] = n2, this.float32[a2 + 2] = i2, t2;
        }
      }
      Rs.prototype.bytesPerElement = 12, oi("StructArrayLayout2ub2f12", Rs);
      class $s extends ks {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2) {
          const n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
        }
        emplace(t2, e2, r2, n2) {
          const i2 = 3 * t2;
          return this.uint16[i2 + 0] = e2, this.uint16[i2 + 1] = r2, this.uint16[i2 + 2] = n2, t2;
        }
      }
      $s.prototype.bytesPerElement = 6, oi("StructArrayLayout3ui6", $s);
      class Us extends ks {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, y2, m2, g2, x2, v2, b2) {
          const w2 = this.length;
          return this.resize(w2 + 1), this.emplace(w2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, y2, m2, g2, x2, v2, b2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, y2, m2, g2, x2, v2, b2, w2) {
          const _2 = 30 * t2, A2 = 15 * t2, k2 = 60 * t2;
          return this.int16[_2 + 0] = e2, this.int16[_2 + 1] = r2, this.int16[_2 + 2] = n2, this.float32[A2 + 2] = i2, this.float32[A2 + 3] = s2, this.uint16[_2 + 8] = a2, this.uint16[_2 + 9] = o2, this.uint32[A2 + 5] = l2, this.uint32[A2 + 6] = u2, this.uint32[A2 + 7] = c2, this.uint16[_2 + 16] = h2, this.uint16[_2 + 17] = p2, this.uint16[_2 + 18] = d2, this.float32[A2 + 10] = f2, this.float32[A2 + 11] = y2, this.uint8[k2 + 48] = m2, this.uint8[k2 + 49] = g2, this.uint8[k2 + 50] = x2, this.uint32[A2 + 13] = v2, this.int16[_2 + 28] = b2, this.uint8[k2 + 58] = w2, t2;
        }
      }
      Us.prototype.bytesPerElement = 60, oi("StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60", Us);
      class Os extends ks {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, y2, m2, g2, x2, v2, b2, w2, _2, A2, k2, S2, I2, z2, T2, M2) {
          const E2 = this.length;
          return this.resize(E2 + 1), this.emplace(E2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, y2, m2, g2, x2, v2, b2, w2, _2, A2, k2, S2, I2, z2, T2, M2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, y2, m2, g2, x2, v2, b2, w2, _2, A2, k2, S2, I2, z2, T2, M2, E2) {
          const C2 = 38 * t2, B2 = 19 * t2;
          return this.int16[C2 + 0] = e2, this.int16[C2 + 1] = r2, this.int16[C2 + 2] = n2, this.float32[B2 + 2] = i2, this.float32[B2 + 3] = s2, this.int16[C2 + 8] = a2, this.int16[C2 + 9] = o2, this.int16[C2 + 10] = l2, this.int16[C2 + 11] = u2, this.int16[C2 + 12] = c2, this.int16[C2 + 13] = h2, this.uint16[C2 + 14] = p2, this.uint16[C2 + 15] = d2, this.uint16[C2 + 16] = f2, this.uint16[C2 + 17] = y2, this.uint16[C2 + 18] = m2, this.uint16[C2 + 19] = g2, this.uint16[C2 + 20] = x2, this.uint16[C2 + 21] = v2, this.uint16[C2 + 22] = b2, this.uint16[C2 + 23] = w2, this.uint16[C2 + 24] = _2, this.uint16[C2 + 25] = A2, this.uint16[C2 + 26] = k2, this.uint16[C2 + 27] = S2, this.uint16[C2 + 28] = I2, this.uint32[B2 + 15] = z2, this.float32[B2 + 16] = T2, this.float32[B2 + 17] = M2, this.float32[B2 + 18] = E2, t2;
        }
      }
      Os.prototype.bytesPerElement = 76, oi("StructArrayLayout3i2f6i15ui1ul3f76", Os);
      class qs extends ks {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2) {
          const e2 = this.length;
          return this.resize(e2 + 1), this.emplace(e2, t2);
        }
        emplace(t2, e2) {
          return this.float32[1 * t2 + 0] = e2, t2;
        }
      }
      qs.prototype.bytesPerElement = 4, oi("StructArrayLayout1f4", qs);
      class js extends ks {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2) {
          const n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
        }
        emplace(t2, e2, r2, n2) {
          const i2 = 3 * t2;
          return this.int16[i2 + 0] = e2, this.int16[i2 + 1] = r2, this.int16[i2 + 2] = n2, t2;
        }
      }
      js.prototype.bytesPerElement = 6, oi("StructArrayLayout3i6", js);
      class Ns extends ks {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
        }
        emplace(t2, e2, r2, n2, i2) {
          const s2 = 6 * t2;
          return this.uint32[3 * t2 + 0] = e2, this.uint16[s2 + 2] = r2, this.uint16[s2 + 3] = n2, this.uint16[s2 + 4] = i2, t2;
        }
      }
      Ns.prototype.bytesPerElement = 12, oi("StructArrayLayout1ul3ui12", Ns);
      class Zs extends ks {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2) {
          const r2 = this.length;
          return this.resize(r2 + 1), this.emplace(r2, t2, e2);
        }
        emplace(t2, e2, r2) {
          const n2 = 2 * t2;
          return this.uint16[n2 + 0] = e2, this.uint16[n2 + 1] = r2, t2;
        }
      }
      Zs.prototype.bytesPerElement = 4, oi("StructArrayLayout2ui4", Zs);
      class Gs extends ks {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2) {
          const e2 = this.length;
          return this.resize(e2 + 1), this.emplace(e2, t2);
        }
        emplace(t2, e2) {
          return this.uint16[1 * t2 + 0] = e2, t2;
        }
      }
      Gs.prototype.bytesPerElement = 2, oi("StructArrayLayout1ui2", Gs);
      class Xs extends ks {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2) {
          const s2 = this.length;
          return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2);
        }
        emplace(t2, e2, r2, n2, i2, s2) {
          const a2 = 5 * t2;
          return this.float32[a2 + 0] = e2, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n2, this.float32[a2 + 3] = i2, this.float32[a2 + 4] = s2, t2;
        }
      }
      Xs.prototype.bytesPerElement = 20, oi("StructArrayLayout5f20", Xs);
      class Ks extends ks {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2) {
          const r2 = this.length;
          return this.resize(r2 + 1), this.emplace(r2, t2, e2);
        }
        emplace(t2, e2, r2) {
          const n2 = 2 * t2;
          return this.float32[n2 + 0] = e2, this.float32[n2 + 1] = r2, t2;
        }
      }
      Ks.prototype.bytesPerElement = 8, oi("StructArrayLayout2f8", Ks);
      class Ys extends ks {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
        }
        emplace(t2, e2, r2, n2, i2) {
          const s2 = 4 * t2;
          return this.float32[s2 + 0] = e2, this.float32[s2 + 1] = r2, this.float32[s2 + 2] = n2, this.float32[s2 + 3] = i2, t2;
        }
      }
      Ys.prototype.bytesPerElement = 16, oi("StructArrayLayout4f16", Ys);
      class Hs extends As {
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get tileAnchorX() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get tileAnchorY() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get x1() {
          return this._structArray.float32[this._pos4 + 3];
        }
        get y1() {
          return this._structArray.float32[this._pos4 + 4];
        }
        get x2() {
          return this._structArray.float32[this._pos4 + 5];
        }
        get y2() {
          return this._structArray.float32[this._pos4 + 6];
        }
        get padding() {
          return this._structArray.int16[this._pos2 + 14];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 8];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 19];
        }
      }
      Hs.prototype.size = 40;
      class Js extends Vs {
        get(t2) {
          return new Hs(this, t2);
        }
      }
      oi("CollisionBoxArray", Js);
      class Ws extends As {
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get tileAnchorX() {
          return this._structArray.float32[this._pos4 + 2];
        }
        get tileAnchorY() {
          return this._structArray.float32[this._pos4 + 3];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 5];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 6];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 7];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 10];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 11];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 48];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 49];
        }
        set placedOrientation(t2) {
          this._structArray.uint8[this._pos1 + 49] = t2;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 50];
        }
        set hidden(t2) {
          this._structArray.uint8[this._pos1 + 50] = t2;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 13];
        }
        set crossTileID(t2) {
          this._structArray.uint32[this._pos4 + 13] = t2;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 28];
        }
        get flipState() {
          return this._structArray.uint8[this._pos1 + 58];
        }
        set flipState(t2) {
          this._structArray.uint8[this._pos1 + 58] = t2;
        }
      }
      Ws.prototype.size = 60;
      class Qs extends Us {
        get(t2) {
          return new Ws(this, t2);
        }
      }
      oi("PlacedSymbolArray", Qs);
      class ta extends As {
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get tileAnchorX() {
          return this._structArray.float32[this._pos4 + 2];
        }
        get tileAnchorY() {
          return this._structArray.float32[this._pos4 + 3];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 8];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 9];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 10];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 11];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 12];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 13];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 23];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 24];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 25];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 26];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 27];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 28];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 15];
        }
        set crossTileID(t2) {
          this._structArray.uint32[this._pos4 + 15] = t2;
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 16];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 17];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 18];
        }
      }
      ta.prototype.size = 76;
      class ea extends Os {
        get(t2) {
          return new ta(this, t2);
        }
      }
      oi("SymbolInstanceArray", ea);
      class ra extends qs {
        getoffsetX(t2) {
          return this.float32[1 * t2 + 0];
        }
      }
      oi("GlyphOffsetArray", ra);
      class na extends js {
        getx(t2) {
          return this.int16[3 * t2 + 0];
        }
        gety(t2) {
          return this.int16[3 * t2 + 1];
        }
        gettileUnitDistanceFromAnchor(t2) {
          return this.int16[3 * t2 + 2];
        }
      }
      oi("SymbolLineVertexArray", na);
      class ia extends As {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get layoutVertexArrayOffset() {
          return this._structArray.uint16[this._pos2 + 4];
        }
      }
      ia.prototype.size = 12;
      class sa extends Ns {
        get(t2) {
          return new ia(this, t2);
        }
      }
      oi("FeatureIndexArray", sa);
      class aa extends As {
        get a_centroid_pos0() {
          return this._structArray.uint16[this._pos2 + 0];
        }
        get a_centroid_pos1() {
          return this._structArray.uint16[this._pos2 + 1];
        }
      }
      aa.prototype.size = 4;
      class oa extends Zs {
        get(t2) {
          return new aa(this, t2);
        }
      }
      oi("FillExtrusionCentroidArray", oa);
      const la = Ss([{ name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }]), ua = Ss([{ name: "a_dash_to", components: 4, type: "Uint16" }, { name: "a_dash_from", components: 4, type: "Uint16" }]);
      var ca = le(function(t2) {
        t2.exports = function(t3, e2) {
          var r2, n2, i2, s2, a2, o2, l2, u2;
          for (n2 = t3.length - (r2 = 3 & t3.length), i2 = e2, a2 = 3432918353, o2 = 461845907, u2 = 0; u2 < n2; )
            l2 = 255 & t3.charCodeAt(u2) | (255 & t3.charCodeAt(++u2)) << 8 | (255 & t3.charCodeAt(++u2)) << 16 | (255 & t3.charCodeAt(++u2)) << 24, ++u2, i2 = 27492 + (65535 & (s2 = 5 * (65535 & (i2 = (i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & l2) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 13 | i2 >>> 19)) + ((5 * (i2 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s2 >>> 16) & 65535) << 16);
          switch (l2 = 0, r2) {
            case 3:
              l2 ^= (255 & t3.charCodeAt(u2 + 2)) << 16;
            case 2:
              l2 ^= (255 & t3.charCodeAt(u2 + 1)) << 8;
            case 1:
              i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & (l2 ^= 255 & t3.charCodeAt(u2))) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295;
          }
          return i2 ^= t3.length, i2 = 2246822507 * (65535 & (i2 ^= i2 >>> 16)) + ((2246822507 * (i2 >>> 16) & 65535) << 16) & 4294967295, i2 = 3266489909 * (65535 & (i2 ^= i2 >>> 13)) + ((3266489909 * (i2 >>> 16) & 65535) << 16) & 4294967295, (i2 ^= i2 >>> 16) >>> 0;
        };
      }), ha = le(function(t2) {
        t2.exports = function(t3, e2) {
          for (var r2, n2 = t3.length, i2 = e2 ^ n2, s2 = 0; n2 >= 4; )
            r2 = 1540483477 * (65535 & (r2 = 255 & t3.charCodeAt(s2) | (255 & t3.charCodeAt(++s2)) << 8 | (255 & t3.charCodeAt(++s2)) << 16 | (255 & t3.charCodeAt(++s2)) << 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16), i2 = 1540483477 * (65535 & i2) + ((1540483477 * (i2 >>> 16) & 65535) << 16) ^ (r2 = 1540483477 * (65535 & (r2 ^= r2 >>> 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16)), n2 -= 4, ++s2;
          switch (n2) {
            case 3:
              i2 ^= (255 & t3.charCodeAt(s2 + 2)) << 16;
            case 2:
              i2 ^= (255 & t3.charCodeAt(s2 + 1)) << 8;
            case 1:
              i2 = 1540483477 * (65535 & (i2 ^= 255 & t3.charCodeAt(s2))) + ((1540483477 * (i2 >>> 16) & 65535) << 16);
          }
          return i2 = 1540483477 * (65535 & (i2 ^= i2 >>> 13)) + ((1540483477 * (i2 >>> 16) & 65535) << 16), (i2 ^= i2 >>> 15) >>> 0;
        };
      }), pa = ca, da = ha;
      pa.murmur3 = ca, pa.murmur2 = da;
      class fa {
        constructor() {
          this.ids = [], this.positions = [], this.indexed = false;
        }
        add(t2, e2, r2, n2) {
          this.ids.push(ya(t2)), this.positions.push(e2, r2, n2);
        }
        getPositions(t2) {
          const e2 = ya(t2);
          let r2 = 0, n2 = this.ids.length - 1;
          for (; r2 < n2; ) {
            const t3 = r2 + n2 >> 1;
            this.ids[t3] >= e2 ? n2 = t3 : r2 = t3 + 1;
          }
          const i2 = [];
          for (; this.ids[r2] === e2; )
            i2.push({ index: this.positions[3 * r2], start: this.positions[3 * r2 + 1], end: this.positions[3 * r2 + 2] }), r2++;
          return i2;
        }
        static serialize(t2, e2) {
          const r2 = new Float64Array(t2.ids), n2 = new Uint32Array(t2.positions);
          return ma(r2, n2, 0, r2.length - 1), e2 && e2.push(r2.buffer, n2.buffer), { ids: r2, positions: n2 };
        }
        static deserialize(t2) {
          const e2 = new fa();
          return e2.ids = t2.ids, e2.positions = t2.positions, e2.indexed = true, e2;
        }
      }
      function ya(t2) {
        const e2 = +t2;
        return !isNaN(e2) && e2 <= o ? e2 : pa(String(t2));
      }
      function ma(t2, e2, r2, n2) {
        for (; r2 < n2; ) {
          const i2 = t2[r2 + n2 >> 1];
          let s2 = r2 - 1, a2 = n2 + 1;
          for (; ; ) {
            do {
              s2++;
            } while (t2[s2] < i2);
            do {
              a2--;
            } while (t2[a2] > i2);
            if (s2 >= a2)
              break;
            ga(t2, s2, a2), ga(e2, 3 * s2, 3 * a2), ga(e2, 3 * s2 + 1, 3 * a2 + 1), ga(e2, 3 * s2 + 2, 3 * a2 + 2);
          }
          a2 - r2 < n2 - a2 ? (ma(t2, e2, r2, a2), r2 = a2 + 1) : (ma(t2, e2, a2 + 1, n2), n2 = a2);
        }
      }
      function ga(t2, e2, r2) {
        const n2 = t2[e2];
        t2[e2] = t2[r2], t2[r2] = n2;
      }
      oi("FeaturePositionMap", fa);
      class xa {
        constructor(t2, e2) {
          this.gl = t2.gl, this.location = e2;
        }
      }
      class va extends xa {
        constructor(t2, e2) {
          super(t2, e2), this.current = 0;
        }
        set(t2) {
          this.current !== t2 && (this.current = t2, this.gl.uniform1f(this.location, t2));
        }
      }
      class ba extends xa {
        constructor(t2, e2) {
          super(t2, e2), this.current = [0, 0, 0, 0];
        }
        set(t2) {
          t2[0] === this.current[0] && t2[1] === this.current[1] && t2[2] === this.current[2] && t2[3] === this.current[3] || (this.current = t2, this.gl.uniform4f(this.location, t2[0], t2[1], t2[2], t2[3]));
        }
      }
      class wa extends xa {
        constructor(t2, e2) {
          super(t2, e2), this.current = ce.transparent;
        }
        set(t2) {
          t2.r === this.current.r && t2.g === this.current.g && t2.b === this.current.b && t2.a === this.current.a || (this.current = t2, this.gl.uniform4f(this.location, t2.r, t2.g, t2.b, t2.a));
        }
      }
      const _a = new Float32Array(16), Aa = new Float32Array(9);
      function ka(t2) {
        return [ws(255 * t2.r, 255 * t2.g), ws(255 * t2.b, 255 * t2.a)];
      }
      class Sa {
        constructor(t2, e2, r2) {
          this.value = t2, this.uniformNames = e2.map((t3) => `u_${t3}`), this.type = r2;
        }
        setUniform(t2, e2, r2) {
          t2.set(r2.constantOr(this.value));
        }
        getBinding(t2, e2, r2) {
          return "color" === this.type ? new wa(t2, e2) : new va(t2, e2);
        }
      }
      class Ia {
        constructor(t2, e2) {
          this.uniformNames = e2.map((t3) => `u_${t3}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
        }
        setConstantPatternPositions(t2, e2) {
          this.pixelRatioFrom = e2.pixelRatio, this.pixelRatioTo = t2.pixelRatio, this.patternFrom = e2.tl.concat(e2.br), this.patternTo = t2.tl.concat(t2.br);
        }
        setUniform(t2, e2, r2, n2) {
          const i2 = "u_pattern_to" === n2 || "u_dash_to" === n2 ? this.patternTo : "u_pattern_from" === n2 || "u_dash_from" === n2 ? this.patternFrom : "u_pixel_ratio_to" === n2 ? this.pixelRatioTo : "u_pixel_ratio_from" === n2 ? this.pixelRatioFrom : null;
          i2 && t2.set(i2);
        }
        getBinding(t2, e2, r2) {
          return "u_pattern_from" === r2 || "u_pattern_to" === r2 || "u_dash_from" === r2 || "u_dash_to" === r2 ? new ba(t2, e2) : new va(t2, e2);
        }
      }
      class za {
        constructor(t2, e2, r2, n2) {
          this.expression = t2, this.type = r2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: "color" === r2 ? 2 : 1, offset: 0 })), this.paintVertexArray = new n2();
        }
        populatePaintArray(t2, e2, r2, n2, i2) {
          const s2 = this.paintVertexArray.length, a2 = this.expression.evaluate(new as(0), e2, {}, n2, [], i2);
          this.paintVertexArray.resize(t2), this._setPaintValue(s2, t2, a2);
        }
        updatePaintArray(t2, e2, r2, n2) {
          const i2 = this.expression.evaluate({ zoom: 0 }, r2, n2);
          this._setPaintValue(t2, e2, i2);
        }
        _setPaintValue(t2, e2, r2) {
          if ("color" === this.type) {
            const n2 = ka(r2);
            for (let r3 = t2; r3 < e2; r3++)
              this.paintVertexArray.emplace(r3, n2[0], n2[1]);
          } else {
            for (let n2 = t2; n2 < e2; n2++)
              this.paintVertexArray.emplace(n2, r2);
            this.maxValue = Math.max(this.maxValue, Math.abs(r2));
          }
        }
        upload(t2) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class Ta {
        constructor(t2, e2, r2, n2, i2, s2) {
          this.expression = t2, this.uniformNames = e2.map((t3) => `u_${t3}_t`), this.type = r2, this.useIntegerZoom = n2, this.zoom = i2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: "color" === r2 ? 4 : 2, offset: 0 })), this.paintVertexArray = new s2();
        }
        populatePaintArray(t2, e2, r2, n2, i2) {
          const s2 = this.expression.evaluate(new as(this.zoom), e2, {}, n2, [], i2), a2 = this.expression.evaluate(new as(this.zoom + 1), e2, {}, n2, [], i2), o2 = this.paintVertexArray.length;
          this.paintVertexArray.resize(t2), this._setPaintValue(o2, t2, s2, a2);
        }
        updatePaintArray(t2, e2, r2, n2) {
          const i2 = this.expression.evaluate({ zoom: this.zoom }, r2, n2), s2 = this.expression.evaluate({ zoom: this.zoom + 1 }, r2, n2);
          this._setPaintValue(t2, e2, i2, s2);
        }
        _setPaintValue(t2, e2, r2, n2) {
          if ("color" === this.type) {
            const i2 = ka(r2), s2 = ka(n2);
            for (let r3 = t2; r3 < e2; r3++)
              this.paintVertexArray.emplace(r3, i2[0], i2[1], s2[0], s2[1]);
          } else {
            for (let i2 = t2; i2 < e2; i2++)
              this.paintVertexArray.emplace(i2, r2, n2);
            this.maxValue = Math.max(this.maxValue, Math.abs(r2), Math.abs(n2));
          }
        }
        upload(t2) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(t2, e2) {
          const r2 = this.useIntegerZoom ? Math.floor(e2.zoom) : e2.zoom, n2 = y(this.expression.interpolationFactor(r2, this.zoom, this.zoom + 1), 0, 1);
          t2.set(n2);
        }
        getBinding(t2, e2, r2) {
          return new va(t2, e2);
        }
      }
      class Ma {
        constructor(t2, e2, r2, n2, i2, s2, a2) {
          this.expression = t2, this.type = r2, this.useIntegerZoom = n2, this.zoom = i2, this.layerId = a2, this.paintVertexAttributes = ("array" === r2 ? ua : la).members;
          for (let t3 = 0; t3 < e2.length; ++t3)
            ;
          this.zoomInPaintVertexArray = new s2(), this.zoomOutPaintVertexArray = new s2();
        }
        populatePaintArray(t2, e2, r2) {
          const n2 = this.zoomInPaintVertexArray.length;
          this.zoomInPaintVertexArray.resize(t2), this.zoomOutPaintVertexArray.resize(t2), this._setPaintValues(n2, t2, e2.patterns && e2.patterns[this.layerId], r2);
        }
        updatePaintArray(t2, e2, r2, n2, i2) {
          this._setPaintValues(t2, e2, r2.patterns && r2.patterns[this.layerId], i2);
        }
        _setPaintValues(t2, e2, r2, n2) {
          if (!n2 || !r2)
            return;
          const { min: i2, mid: s2, max: a2 } = r2, o2 = n2[i2], l2 = n2[s2], u2 = n2[a2];
          if (o2 && l2 && u2)
            for (let r3 = t2; r3 < e2; r3++)
              this._setPaintValue(this.zoomInPaintVertexArray, r3, l2, o2), this._setPaintValue(this.zoomOutPaintVertexArray, r3, l2, u2);
        }
        _setPaintValue(t2, e2, r2, n2) {
          t2.emplace(e2, r2.tl[0], r2.tl[1], r2.br[0], r2.br[1], n2.tl[0], n2.tl[1], n2.br[0], n2.br[1], r2.pixelRatio, n2.pixelRatio);
        }
        upload(t2) {
          this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t2.createVertexBuffer(this.zoomInPaintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t2.createVertexBuffer(this.zoomOutPaintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
        }
      }
      class Ea {
        constructor(t2, e2, r2 = () => true) {
          this.binders = {}, this._buffers = [];
          const n2 = [];
          for (const i2 in t2.paint._values) {
            if (!r2(i2))
              continue;
            const s2 = t2.paint.get(i2);
            if (!(s2 instanceof ds && Yr(s2.property.specification)))
              continue;
            const a2 = Da(i2, t2.type), o2 = s2.value, l2 = s2.property.specification.type, u2 = s2.property.useIntegerZoom, c2 = s2.property.specification["property-type"], h2 = "cross-faded" === c2 || "cross-faded-data-driven" === c2, p2 = "line-dasharray" === String(i2) && "constant" !== t2.layout.get("line-cap").value.kind;
            if ("constant" !== o2.kind || p2)
              if ("source" === o2.kind || p2 || h2) {
                const r3 = La(i2, l2, "source");
                this.binders[i2] = h2 ? new Ma(o2, a2, l2, u2, e2, r3, t2.id) : new za(o2, a2, l2, r3), n2.push(`/a_${i2}`);
              } else {
                const t3 = La(i2, l2, "composite");
                this.binders[i2] = new Ta(o2, a2, l2, u2, e2, t3), n2.push(`/z_${i2}`);
              }
            else
              this.binders[i2] = h2 ? new Ia(o2.value, a2) : new Sa(o2.value, a2, l2), n2.push(`/u_${i2}`);
          }
          this.cacheKey = n2.sort().join("");
        }
        getMaxValue(t2) {
          const e2 = this.binders[t2];
          return e2 instanceof za || e2 instanceof Ta ? e2.maxValue : 0;
        }
        populatePaintArrays(t2, e2, r2, n2, i2) {
          for (const s2 in this.binders) {
            const a2 = this.binders[s2];
            (a2 instanceof za || a2 instanceof Ta || a2 instanceof Ma) && a2.populatePaintArray(t2, e2, r2, n2, i2);
          }
        }
        setConstantPatternPositions(t2, e2) {
          for (const r2 in this.binders) {
            const n2 = this.binders[r2];
            n2 instanceof Ia && n2.setConstantPatternPositions(t2, e2);
          }
        }
        updatePaintArrays(t2, e2, r2, n2, i2) {
          let s2 = false;
          for (const a2 in t2) {
            const o2 = e2.getPositions(a2);
            for (const e3 of o2) {
              const o3 = r2.feature(e3.index);
              for (const r3 in this.binders) {
                const l2 = this.binders[r3];
                if ((l2 instanceof za || l2 instanceof Ta || l2 instanceof Ma) && true === l2.expression.isStateDependent) {
                  const u2 = n2.paint.get(r3);
                  l2.expression = u2.value, l2.updatePaintArray(e3.start, e3.end, o3, t2[a2], i2), s2 = true;
                }
              }
            }
          }
          return s2;
        }
        defines() {
          const t2 = [];
          for (const e2 in this.binders) {
            const r2 = this.binders[e2];
            (r2 instanceof Sa || r2 instanceof Ia) && t2.push(...r2.uniformNames.map((t3) => `#define HAS_UNIFORM_${t3}`));
          }
          return t2;
        }
        getBinderAttributes() {
          const t2 = [];
          for (const e2 in this.binders) {
            const r2 = this.binders[e2];
            if (r2 instanceof za || r2 instanceof Ta || r2 instanceof Ma)
              for (let e3 = 0; e3 < r2.paintVertexAttributes.length; e3++)
                t2.push(r2.paintVertexAttributes[e3].name);
          }
          return t2;
        }
        getBinderUniforms() {
          const t2 = [];
          for (const e2 in this.binders) {
            const r2 = this.binders[e2];
            if (r2 instanceof Sa || r2 instanceof Ia || r2 instanceof Ta)
              for (const e3 of r2.uniformNames)
                t2.push(e3);
          }
          return t2;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(t2, e2) {
          const r2 = [];
          for (const n2 in this.binders) {
            const i2 = this.binders[n2];
            if (i2 instanceof Sa || i2 instanceof Ia || i2 instanceof Ta) {
              for (const s2 of i2.uniformNames)
                if (e2[s2]) {
                  const a2 = i2.getBinding(t2, e2[s2], s2);
                  r2.push({ name: s2, property: n2, binding: a2 });
                }
            }
          }
          return r2;
        }
        setUniforms(t2, e2, r2, n2) {
          for (const { name: t3, property: i2, binding: s2 } of e2)
            this.binders[i2].setUniform(s2, n2, r2.get(i2), t3);
        }
        updatePaintBuffers(t2) {
          this._buffers = [];
          for (const e2 in this.binders) {
            const r2 = this.binders[e2];
            if (t2 && r2 instanceof Ma) {
              const e3 = 2 === t2.fromScale ? r2.zoomInPaintVertexBuffer : r2.zoomOutPaintVertexBuffer;
              e3 && this._buffers.push(e3);
            } else
              (r2 instanceof za || r2 instanceof Ta) && r2.paintVertexBuffer && this._buffers.push(r2.paintVertexBuffer);
          }
        }
        upload(t2) {
          for (const e2 in this.binders) {
            const r2 = this.binders[e2];
            (r2 instanceof za || r2 instanceof Ta || r2 instanceof Ma) && r2.upload(t2);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (const t2 in this.binders) {
            const e2 = this.binders[t2];
            (e2 instanceof za || e2 instanceof Ta || e2 instanceof Ma) && e2.destroy();
          }
        }
      }
      class Ca {
        constructor(t2, e2, r2 = () => true) {
          this.programConfigurations = {};
          for (const n2 of t2)
            this.programConfigurations[n2.id] = new Ea(n2, e2, r2);
          this.needsUpload = false, this._featureMap = new fa(), this._bufferOffset = 0;
        }
        populatePaintArrays(t2, e2, r2, n2, i2, s2) {
          for (const r3 in this.programConfigurations)
            this.programConfigurations[r3].populatePaintArrays(t2, e2, n2, i2, s2);
          void 0 !== e2.id && this._featureMap.add(e2.id, r2, this._bufferOffset, t2), this._bufferOffset = t2, this.needsUpload = true;
        }
        updatePaintArrays(t2, e2, r2, n2) {
          for (const i2 of r2)
            this.needsUpload = this.programConfigurations[i2.id].updatePaintArrays(t2, this._featureMap, e2, i2, n2) || this.needsUpload;
        }
        get(t2) {
          return this.programConfigurations[t2];
        }
        upload(t2) {
          if (this.needsUpload) {
            for (const e2 in this.programConfigurations)
              this.programConfigurations[e2].upload(t2);
            this.needsUpload = false;
          }
        }
        destroy() {
          for (const t2 in this.programConfigurations)
            this.programConfigurations[t2].destroy();
        }
      }
      const Ba = { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "line-dasharray": ["dash_to", "dash_from"] };
      function Da(t2, e2) {
        return Ba[t2] || [t2.replace(`${e2}-`, "").replace(/-/g, "_")];
      }
      const Pa = { "line-pattern": { source: Cs, composite: Cs }, "fill-pattern": { source: Cs, composite: Cs }, "fill-extrusion-pattern": { source: Cs, composite: Cs }, "line-dasharray": { source: Bs, composite: Bs } }, Va = { color: { source: Ks, composite: Ys }, number: { source: qs, composite: Ks } };
      function La(t2, e2, r2) {
        const n2 = Pa[t2];
        return n2 && n2[r2] || Va[e2][r2];
      }
      oi("ConstantBinder", Sa), oi("CrossFadedConstantBinder", Ia), oi("SourceExpressionBinder", za), oi("CrossFadedCompositeBinder", Ma), oi("CompositeExpressionBinder", Ta), oi("ProgramConfiguration", Ea, { omit: ["_buffers"] }), oi("ProgramConfigurationSet", Ca);
      const Fa = "-transition";
      class Ra extends Ft {
        constructor(t2, e2) {
          if (super(), this.id = t2.id, this.type = t2.type, this._featureFilter = { filter: () => true, needGeometry: false }, "custom" !== t2.type && (this.metadata = (t2 = t2).metadata, this.minzoom = t2.minzoom, this.maxzoom = t2.maxzoom, "background" !== t2.type && "sky" !== t2.type && (this.source = t2.source, this.sourceLayer = t2["source-layer"], this.filter = t2.filter), e2.layout && (this._unevaluatedLayout = new ps(e2.layout)), e2.paint)) {
            this._transitionablePaint = new us(e2.paint);
            for (const e3 in t2.paint)
              this.setPaintProperty(e3, t2.paint[e3], { validate: false });
            for (const e3 in t2.layout)
              this.setLayoutProperty(e3, t2.layout[e3], { validate: false });
            this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new fs(e2.paint);
          }
        }
        getCrossfadeParameters() {
          return this._crossfadeParameters;
        }
        getLayoutProperty(t2) {
          return "visibility" === t2 ? this.visibility : this._unevaluatedLayout.getValue(t2);
        }
        setLayoutProperty(t2, e2, r2 = {}) {
          null != e2 && this._validate(ti, `layers.${this.id}.layout.${t2}`, t2, e2, r2) || ("visibility" !== t2 ? this._unevaluatedLayout.setValue(t2, e2) : this.visibility = e2);
        }
        getPaintProperty(t2) {
          return I(t2, Fa) ? this._transitionablePaint.getTransition(t2.slice(0, -Fa.length)) : this._transitionablePaint.getValue(t2);
        }
        setPaintProperty(t2, e2, r2 = {}) {
          if (null != e2 && this._validate(Qn, `layers.${this.id}.paint.${t2}`, t2, e2, r2))
            return false;
          if (I(t2, Fa))
            return this._transitionablePaint.setTransition(t2.slice(0, -Fa.length), e2 || void 0), false;
          {
            const r3 = this._transitionablePaint._values[t2], n2 = "cross-faded-data-driven" === r3.property.specification["property-type"], i2 = r3.value.isDataDriven(), s2 = r3.value;
            this._transitionablePaint.setValue(t2, e2), this._handleSpecialPaintPropertyUpdate(t2);
            const a2 = this._transitionablePaint._values[t2].value;
            return a2.isDataDriven() || i2 || n2 || this._handleOverridablePaintPropertyUpdate(t2, s2, a2);
          }
        }
        _handleSpecialPaintPropertyUpdate(t2) {
        }
        getProgramIds() {
          return null;
        }
        getProgramConfiguration(t2) {
          return null;
        }
        _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
          return false;
        }
        isHidden(t2) {
          return !!(this.minzoom && t2 < this.minzoom) || !!(this.maxzoom && t2 >= this.maxzoom) || "none" === this.visibility;
        }
        updateTransitions(t2) {
          this._transitioningPaint = this._transitionablePaint.transitioned(t2, this._transitioningPaint);
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(t2, e2) {
          t2.getCrossfadeParameters && (this._crossfadeParameters = t2.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t2, void 0, e2)), this.paint = this._transitioningPaint.possiblyEvaluate(t2, void 0, e2);
        }
        serialize() {
          const t2 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
          return this.visibility && (t2.layout = t2.layout || {}, t2.layout.visibility = this.visibility), T(t2, (t3, e2) => !(void 0 === t3 || "layout" === e2 && !Object.keys(t3).length || "paint" === e2 && !Object.keys(t3).length));
        }
        _validate(t2, e2, r2, n2, i2 = {}) {
          return (!i2 || false !== i2.validate) && ei(this, t2.call(Hn, { key: e2, layerType: this.type, objectKey: r2, value: n2, styleSpec: Rt, style: { glyphs: true, sprite: true } }));
        }
        is3D() {
          return false;
        }
        isSky() {
          return false;
        }
        isTileClipped() {
          return false;
        }
        hasOffscreenPass() {
          return false;
        }
        resize() {
        }
        isStateDependent() {
          for (const t2 in this.paint._values) {
            const e2 = this.paint.get(t2);
            if (e2 instanceof ds && Yr(e2.property.specification) && ("source" === e2.value.kind || "composite" === e2.value.kind) && e2.value.isStateDependent)
              return true;
          }
          return false;
        }
      }
      const $a = Ss([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Ua } = $a;
      class Oa {
        constructor(t2 = []) {
          this.segments = t2;
        }
        prepareSegment(t2, e2, r2, n2) {
          let i2 = this.segments[this.segments.length - 1];
          return t2 > Oa.MAX_VERTEX_ARRAY_LENGTH && C(`Max vertices per segment is ${Oa.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t2}`), (!i2 || i2.vertexLength + t2 > Oa.MAX_VERTEX_ARRAY_LENGTH || i2.sortKey !== n2) && (i2 = { vertexOffset: e2.length, primitiveOffset: r2.length, vertexLength: 0, primitiveLength: 0 }, void 0 !== n2 && (i2.sortKey = n2), this.segments.push(i2)), i2;
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const t2 of this.segments)
            for (const e2 in t2.vaos)
              t2.vaos[e2].destroy();
        }
        static simpleSegment(t2, e2, r2, n2) {
          return new Oa([{ vertexOffset: t2, primitiveOffset: e2, vertexLength: r2, primitiveLength: n2, vaos: {}, sortKey: 0 }]);
        }
      }
      Oa.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, oi("SegmentVector", Oa);
      var qa = 8192;
      const ja = Math.pow(2, 14) - 1, Na = -ja - 1;
      function Za(t2) {
        const e2 = qa / t2.extent, r2 = t2.loadGeometry();
        for (let t3 = 0; t3 < r2.length; t3++) {
          const n2 = r2[t3];
          for (let t4 = 0; t4 < n2.length; t4++) {
            const r3 = n2[t4], i2 = Math.round(r3.x * e2), s2 = Math.round(r3.y * e2);
            r3.x = y(i2, Na, ja), r3.y = y(s2, Na, ja), (i2 < r3.x || i2 > r3.x + 1 || s2 < r3.y || s2 > r3.y + 1) && C("Geometry exceeds allowed extent, reduce your vector tile buffer size");
          }
        }
        return r2;
      }
      function Ga(t2, e2) {
        return { type: t2.type, id: t2.id, properties: t2.properties, geometry: e2 ? Za(t2) : [] };
      }
      function Xa(t2, e2, r2, n2, i2) {
        t2.emplaceBack(2 * e2 + (n2 + 1) / 2, 2 * r2 + (i2 + 1) / 2);
      }
      class Ka {
        constructor(t2) {
          this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.layoutVertexArray = new zs(), this.indexArray = new $s(), this.segments = new Oa(), this.programConfigurations = new Ca(t2.layers, t2.zoom), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
        }
        populate(t2, e2, r2) {
          const n2 = this.layers[0], i2 = [];
          let s2 = null;
          "circle" === n2.type && (s2 = n2.layout.get("circle-sort-key"));
          for (const { feature: e3, id: n3, index: a2, sourceLayerIndex: o2 } of t2) {
            const t3 = this.layers[0]._featureFilter.needGeometry, l2 = Ga(e3, t3);
            if (!this.layers[0]._featureFilter.filter(new as(this.zoom), l2, r2))
              continue;
            const u2 = s2 ? s2.evaluate(l2, {}, r2) : void 0, c2 = { id: n3, properties: e3.properties, type: e3.type, sourceLayerIndex: o2, index: a2, geometry: t3 ? l2.geometry : Za(e3), patterns: {}, sortKey: u2 };
            i2.push(c2);
          }
          s2 && i2.sort((t3, e3) => t3.sortKey - e3.sortKey);
          for (const n3 of i2) {
            const { geometry: i3, index: s3, sourceLayerIndex: a2 } = n3, o2 = t2[s3].feature;
            this.addFeature(n3, i3, s3, r2), e2.featureIndex.insert(o2, i3, s3, a2, this.index);
          }
        }
        update(t2, e2, r2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t2) {
          this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Ua), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        addFeature(t2, e2, r2, n2) {
          for (const r3 of e2)
            for (const e3 of r3) {
              const r4 = e3.x, n3 = e3.y;
              if (r4 < 0 || r4 >= qa || n3 < 0 || n3 >= qa)
                continue;
              const i2 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t2.sortKey), s2 = i2.vertexLength;
              Xa(this.layoutVertexArray, r4, n3, -1, -1), Xa(this.layoutVertexArray, r4, n3, 1, -1), Xa(this.layoutVertexArray, r4, n3, 1, 1), Xa(this.layoutVertexArray, r4, n3, -1, 1), this.indexArray.emplaceBack(s2, s2 + 1, s2 + 2), this.indexArray.emplaceBack(s2, s2 + 3, s2 + 2), i2.vertexLength += 4, i2.primitiveLength += 2;
            }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, {}, n2);
        }
      }
      function Ya(t2, e2) {
        for (let r2 = 0; r2 < t2.length; r2++)
          if (io(e2, t2[r2]))
            return true;
        for (let r2 = 0; r2 < e2.length; r2++)
          if (io(t2, e2[r2]))
            return true;
        return !!Qa(t2, e2);
      }
      function Ha(t2, e2, r2) {
        return !!io(t2, e2) || !!eo(e2, t2, r2);
      }
      function Ja(t2, e2) {
        if (1 === t2.length)
          return no(e2, t2[0]);
        for (let r2 = 0; r2 < e2.length; r2++) {
          const n2 = e2[r2];
          for (let e3 = 0; e3 < n2.length; e3++)
            if (io(t2, n2[e3]))
              return true;
        }
        for (let r2 = 0; r2 < t2.length; r2++)
          if (no(e2, t2[r2]))
            return true;
        for (let r2 = 0; r2 < e2.length; r2++)
          if (Qa(t2, e2[r2]))
            return true;
        return false;
      }
      function Wa(t2, e2, r2) {
        if (t2.length > 1) {
          if (Qa(t2, e2))
            return true;
          for (let n2 = 0; n2 < e2.length; n2++)
            if (eo(e2[n2], t2, r2))
              return true;
        }
        for (let n2 = 0; n2 < t2.length; n2++)
          if (eo(t2[n2], e2, r2))
            return true;
        return false;
      }
      function Qa(t2, e2) {
        if (0 === t2.length || 0 === e2.length)
          return false;
        for (let r2 = 0; r2 < t2.length - 1; r2++) {
          const n2 = t2[r2], i2 = t2[r2 + 1];
          for (let t3 = 0; t3 < e2.length - 1; t3++)
            if (to(n2, i2, e2[t3], e2[t3 + 1]))
              return true;
        }
        return false;
      }
      function to(t2, e2, r2, n2) {
        return B(t2, r2, n2) !== B(e2, r2, n2) && B(t2, e2, r2) !== B(t2, e2, n2);
      }
      function eo(t2, e2, r2) {
        const n2 = r2 * r2;
        if (1 === e2.length)
          return t2.distSqr(e2[0]) < n2;
        for (let r3 = 1; r3 < e2.length; r3++)
          if (ro(t2, e2[r3 - 1], e2[r3]) < n2)
            return true;
        return false;
      }
      function ro(t2, e2, r2) {
        const n2 = e2.distSqr(r2);
        if (0 === n2)
          return t2.distSqr(e2);
        const i2 = ((t2.x - e2.x) * (r2.x - e2.x) + (t2.y - e2.y) * (r2.y - e2.y)) / n2;
        return t2.distSqr(i2 < 0 ? e2 : i2 > 1 ? r2 : r2.sub(e2)._mult(i2)._add(e2));
      }
      function no(t2, e2) {
        let r2, n2, i2, s2 = false;
        for (let a2 = 0; a2 < t2.length; a2++) {
          r2 = t2[a2];
          for (let t3 = 0, a3 = r2.length - 1; t3 < r2.length; a3 = t3++)
            n2 = r2[t3], i2 = r2[a3], n2.y > e2.y != i2.y > e2.y && e2.x < (i2.x - n2.x) * (e2.y - n2.y) / (i2.y - n2.y) + n2.x && (s2 = !s2);
        }
        return s2;
      }
      function io(t2, e2) {
        let r2 = false;
        for (let n2 = 0, i2 = t2.length - 1; n2 < t2.length; i2 = n2++) {
          const s2 = t2[n2], a2 = t2[i2];
          s2.y > e2.y != a2.y > e2.y && e2.x < (a2.x - s2.x) * (e2.y - s2.y) / (a2.y - s2.y) + s2.x && (r2 = !r2);
        }
        return r2;
      }
      function so(t2, e2, r2, n2, s2) {
        for (const i2 of t2)
          if (e2 <= i2.x && r2 <= i2.y && n2 >= i2.x && s2 >= i2.y)
            return true;
        const a2 = [new i(e2, r2), new i(e2, s2), new i(n2, s2), new i(n2, r2)];
        if (t2.length > 2) {
          for (const e3 of a2)
            if (io(t2, e3))
              return true;
        }
        for (let e3 = 0; e3 < t2.length - 1; e3++)
          if (ao(t2[e3], t2[e3 + 1], a2))
            return true;
        return false;
      }
      function ao(t2, e2, r2) {
        const n2 = r2[0], i2 = r2[2];
        if (t2.x < n2.x && e2.x < n2.x || t2.x > i2.x && e2.x > i2.x || t2.y < n2.y && e2.y < n2.y || t2.y > i2.y && e2.y > i2.y)
          return false;
        const s2 = B(t2, e2, r2[0]);
        return s2 !== B(t2, e2, r2[1]) || s2 !== B(t2, e2, r2[2]) || s2 !== B(t2, e2, r2[3]);
      }
      function oo(t2, e2, r2) {
        const n2 = e2.paint.get(t2).value;
        return "constant" === n2.kind ? n2.value : r2.programConfigurations.get(e2.id).getMaxValue(t2);
      }
      function lo(t2) {
        return Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]);
      }
      function uo(t2, e2, r2, n2, s2) {
        if (!e2[0] && !e2[1])
          return t2;
        const a2 = i.convert(e2)._mult(s2);
        "viewport" === r2 && a2._rotate(-n2);
        const o2 = [];
        for (let e3 = 0; e3 < t2.length; e3++)
          o2.push(t2[e3].sub(a2));
        return o2;
      }
      function co(t2, e2, r2, n2) {
        const s2 = i.convert(t2)._mult(n2);
        return "viewport" === e2 && s2._rotate(-r2), s2;
      }
      oi("CircleBucket", Ka, { omit: ["layers"] });
      const ho = new bs({ "circle-sort-key": new ms(Rt.layout_circle["circle-sort-key"]) });
      var po = { paint: new bs({ "circle-radius": new ms(Rt.paint_circle["circle-radius"]), "circle-color": new ms(Rt.paint_circle["circle-color"]), "circle-blur": new ms(Rt.paint_circle["circle-blur"]), "circle-opacity": new ms(Rt.paint_circle["circle-opacity"]), "circle-translate": new ys(Rt.paint_circle["circle-translate"]), "circle-translate-anchor": new ys(Rt.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new ys(Rt.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new ys(Rt.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new ms(Rt.paint_circle["circle-stroke-width"]), "circle-stroke-color": new ms(Rt.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new ms(Rt.paint_circle["circle-stroke-opacity"]) }), layout: ho }, fo = "undefined" != typeof Float32Array ? Float32Array : Array;
      function yo() {
        var t2 = new fo(9);
        return fo != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0), t2[0] = 1, t2[4] = 1, t2[8] = 1, t2;
      }
      function mo(t2) {
        return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
      }
      function go(t2, e2, r2) {
        var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], d2 = e2[10], f2 = e2[11], y2 = e2[12], m2 = e2[13], g2 = e2[14], x2 = e2[15], v2 = r2[0], b2 = r2[1], w2 = r2[2], _2 = r2[3];
        return t2[0] = v2 * n2 + b2 * o2 + w2 * h2 + _2 * y2, t2[1] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[2] = v2 * s2 + b2 * u2 + w2 * d2 + _2 * g2, t2[3] = v2 * a2 + b2 * c2 + w2 * f2 + _2 * x2, t2[4] = (v2 = r2[4]) * n2 + (b2 = r2[5]) * o2 + (w2 = r2[6]) * h2 + (_2 = r2[7]) * y2, t2[5] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[6] = v2 * s2 + b2 * u2 + w2 * d2 + _2 * g2, t2[7] = v2 * a2 + b2 * c2 + w2 * f2 + _2 * x2, t2[8] = (v2 = r2[8]) * n2 + (b2 = r2[9]) * o2 + (w2 = r2[10]) * h2 + (_2 = r2[11]) * y2, t2[9] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[10] = v2 * s2 + b2 * u2 + w2 * d2 + _2 * g2, t2[11] = v2 * a2 + b2 * c2 + w2 * f2 + _2 * x2, t2[12] = (v2 = r2[12]) * n2 + (b2 = r2[13]) * o2 + (w2 = r2[14]) * h2 + (_2 = r2[15]) * y2, t2[13] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[14] = v2 * s2 + b2 * u2 + w2 * d2 + _2 * g2, t2[15] = v2 * a2 + b2 * c2 + w2 * f2 + _2 * x2, t2;
      }
      Math.hypot || (Math.hypot = function() {
        for (var t2 = 0, e2 = arguments.length; e2--; )
          t2 += arguments[e2] * arguments[e2];
        return Math.sqrt(t2);
      });
      var xo = go;
      function vo() {
        var t2 = new fo(3);
        return fo != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2;
      }
      function bo(t2) {
        return Math.hypot(t2[0], t2[1], t2[2]);
      }
      function wo(t2, e2, r2) {
        var n2 = new fo(3);
        return n2[0] = t2, n2[1] = e2, n2[2] = r2, n2;
      }
      function _o(t2, e2, r2) {
        return t2[0] = e2[0] - r2[0], t2[1] = e2[1] - r2[1], t2[2] = e2[2] - r2[2], t2;
      }
      function Ao(t2, e2, r2) {
        return t2[0] = e2[0] * r2[0], t2[1] = e2[1] * r2[1], t2[2] = e2[2] * r2[2], t2;
      }
      function ko(t2, e2, r2, n2) {
        return t2[0] = e2[0] + r2[0] * n2, t2[1] = e2[1] + r2[1] * n2, t2[2] = e2[2] + r2[2] * n2, t2;
      }
      function So(t2, e2) {
        var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = r2 * r2 + n2 * n2 + i2 * i2;
        return s2 > 0 && (s2 = 1 / Math.sqrt(s2)), t2[0] = e2[0] * s2, t2[1] = e2[1] * s2, t2[2] = e2[2] * s2, t2;
      }
      function Io(t2, e2, r2) {
        var n2 = r2[0], i2 = r2[1], s2 = r2[2], a2 = e2[0], o2 = e2[1], l2 = e2[2], u2 = i2 * l2 - s2 * o2, c2 = s2 * a2 - n2 * l2, h2 = n2 * o2 - i2 * a2, p2 = i2 * h2 - s2 * c2, d2 = s2 * u2 - n2 * h2, f2 = n2 * c2 - i2 * u2, y2 = 2 * r2[3];
        return c2 *= y2, h2 *= y2, d2 *= 2, f2 *= 2, t2[0] = a2 + (u2 *= y2) + (p2 *= 2), t2[1] = o2 + c2 + d2, t2[2] = l2 + h2 + f2, t2;
      }
      var zo, To = _o, Mo = Ao, Eo = bo;
      function Co(t2, e2, r2) {
        var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3];
        return t2[0] = r2[0] * n2 + r2[4] * i2 + r2[8] * s2 + r2[12] * a2, t2[1] = r2[1] * n2 + r2[5] * i2 + r2[9] * s2 + r2[13] * a2, t2[2] = r2[2] * n2 + r2[6] * i2 + r2[10] * s2 + r2[14] * a2, t2[3] = r2[3] * n2 + r2[7] * i2 + r2[11] * s2 + r2[15] * a2, t2;
      }
      function Bo() {
        var t2 = new fo(4);
        return fo != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2[3] = 1, t2;
      }
      function Do(t2) {
        return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2;
      }
      function Po(t2, e2, r2) {
        r2 *= 0.5;
        var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = Math.sin(r2), l2 = Math.cos(r2);
        return t2[0] = n2 * l2 + a2 * o2, t2[1] = i2 * l2 + s2 * o2, t2[2] = s2 * l2 - i2 * o2, t2[3] = a2 * l2 - n2 * o2, t2;
      }
      function Vo(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
        if (s2 && t2.queryGeometry.isAboveHorizon)
          return false;
        s2 && (l2 *= t2.pixelToTileUnitsFactor);
        for (const u2 of e2)
          for (const e3 of u2) {
            const u3 = e3.add(o2), c2 = i2 && r2.elevation ? r2.elevation.exaggeration() * i2.getElevationAt(u3.x, u3.y, true) : 0, h2 = s2 ? u3 : Lo(u3, c2, n2), p2 = s2 ? t2.tilespaceRays.map((t3) => $o(t3, c2)) : t2.queryGeometry.screenGeometry, d2 = Co([], [e3.x, e3.y, c2, 1], n2);
            if (!a2 && s2 ? l2 *= d2[3] / r2.cameraToCenterDistance : a2 && !s2 && (l2 *= r2.cameraToCenterDistance / d2[3]), Ha(p2, h2, l2))
              return true;
          }
        return false;
      }
      function Lo(t2, e2, r2) {
        const n2 = Co([], [t2.x, t2.y, e2, 1], r2);
        return new i(n2[0] / n2[3], n2[1] / n2[3]);
      }
      vo(), zo = new fo(4), fo != Float32Array && (zo[0] = 0, zo[1] = 0, zo[2] = 0, zo[3] = 0), vo(), wo(1, 0, 0), wo(0, 1, 0), Bo(), Bo(), yo();
      const Fo = wo(0, 0, 0), Ro = wo(0, 0, 1);
      function $o(t2, e2) {
        const r2 = vo();
        return Fo[2] = e2, t2.intersectsPlane(Fo, Ro, r2), new i(r2[0], r2[1]);
      }
      class Uo extends Ka {
      }
      function Oo(t2, { width: e2, height: r2 }, n2, i2) {
        if (i2) {
          if (i2 instanceof Uint8ClampedArray)
            i2 = new Uint8Array(i2.buffer);
          else if (i2.length !== e2 * r2 * n2)
            throw new RangeError("mismatched image size");
        } else
          i2 = new Uint8Array(e2 * r2 * n2);
        return t2.width = e2, t2.height = r2, t2.data = i2, t2;
      }
      function qo(t2, { width: e2, height: r2 }, n2) {
        if (e2 === t2.width && r2 === t2.height)
          return;
        const i2 = Oo({}, { width: e2, height: r2 }, n2);
        jo(t2, i2, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t2.width, e2), height: Math.min(t2.height, r2) }, n2), t2.width = e2, t2.height = r2, t2.data = i2.data;
      }
      function jo(t2, e2, r2, n2, i2, s2) {
        if (0 === i2.width || 0 === i2.height)
          return e2;
        if (i2.width > t2.width || i2.height > t2.height || r2.x > t2.width - i2.width || r2.y > t2.height - i2.height)
          throw new RangeError("out of range source coordinates for image copy");
        if (i2.width > e2.width || i2.height > e2.height || n2.x > e2.width - i2.width || n2.y > e2.height - i2.height)
          throw new RangeError("out of range destination coordinates for image copy");
        const a2 = t2.data, o2 = e2.data;
        for (let l2 = 0; l2 < i2.height; l2++) {
          const u2 = ((r2.y + l2) * t2.width + r2.x) * s2, c2 = ((n2.y + l2) * e2.width + n2.x) * s2;
          for (let t3 = 0; t3 < i2.width * s2; t3++)
            o2[c2 + t3] = a2[u2 + t3];
        }
        return e2;
      }
      oi("HeatmapBucket", Uo, { omit: ["layers"] });
      class No {
        constructor(t2, e2) {
          Oo(this, t2, 1, e2);
        }
        resize(t2) {
          qo(this, t2, 1);
        }
        clone() {
          return new No({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(t2, e2, r2, n2, i2) {
          jo(t2, e2, r2, n2, i2, 1);
        }
      }
      class Zo {
        constructor(t2, e2) {
          Oo(this, t2, 4, e2);
        }
        resize(t2) {
          qo(this, t2, 4);
        }
        replace(t2, e2) {
          e2 ? this.data.set(t2) : this.data = t2 instanceof Uint8ClampedArray ? new Uint8Array(t2.buffer) : t2;
        }
        clone() {
          return new Zo({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(t2, e2, r2, n2, i2) {
          jo(t2, e2, r2, n2, i2, 4);
        }
      }
      oi("AlphaImage", No), oi("RGBAImage", Zo);
      var Go = { paint: new bs({ "heatmap-radius": new ms(Rt.paint_heatmap["heatmap-radius"]), "heatmap-weight": new ms(Rt.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new ys(Rt.paint_heatmap["heatmap-intensity"]), "heatmap-color": new vs(Rt.paint_heatmap["heatmap-color"]), "heatmap-opacity": new ys(Rt.paint_heatmap["heatmap-opacity"]) }) };
      function Xo(t2) {
        const e2 = {}, r2 = t2.resolution || 256, n2 = t2.clips ? t2.clips.length : 1, i2 = t2.image || new Zo({ width: r2, height: n2 }), s2 = (r3, n3, s3) => {
          e2[t2.evaluationKey] = s3;
          const a2 = t2.expression.evaluate(e2);
          i2.data[r3 + n3 + 0] = Math.floor(255 * a2.r / a2.a), i2.data[r3 + n3 + 1] = Math.floor(255 * a2.g / a2.a), i2.data[r3 + n3 + 2] = Math.floor(255 * a2.b / a2.a), i2.data[r3 + n3 + 3] = Math.floor(255 * a2.a);
        };
        if (t2.clips)
          for (let e3 = 0, i3 = 0; e3 < n2; ++e3, i3 += 4 * r2)
            for (let n3 = 0, a2 = 0; n3 < r2; n3++, a2 += 4) {
              const o2 = n3 / (r2 - 1), { start: l2, end: u2 } = t2.clips[e3];
              s2(i3, a2, l2 * (1 - o2) + u2 * o2);
            }
        else
          for (let t3 = 0, e3 = 0; t3 < r2; t3++, e3 += 4)
            s2(0, e3, t3 / (r2 - 1));
        return i2;
      }
      var Ko = { paint: new bs({ "hillshade-illumination-direction": new ys(Rt.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new ys(Rt.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new ys(Rt.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new ys(Rt.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new ys(Rt.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new ys(Rt.paint_hillshade["hillshade-accent-color"]) }) };
      const Yo = Ss([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Ho } = Yo;
      var Jo = Qo, Wo = Qo;
      function Qo(t2, e2, r2) {
        r2 = r2 || 2;
        var n2, i2, s2, a2, o2, l2, u2, c2 = e2 && e2.length, h2 = c2 ? e2[0] * r2 : t2.length, p2 = tl(t2, 0, h2, r2, true), d2 = [];
        if (!p2 || p2.next === p2.prev)
          return d2;
        if (c2 && (p2 = function(t3, e3, r3, n3) {
          var i3, s3, a3, o3 = [];
          for (i3 = 0, s3 = e3.length; i3 < s3; i3++)
            (a3 = tl(t3, e3[i3] * n3, i3 < s3 - 1 ? e3[i3 + 1] * n3 : t3.length, n3, false)) === a3.next && (a3.steiner = true), o3.push(hl(a3));
          for (o3.sort(ol), i3 = 0; i3 < o3.length; i3++)
            ll(o3[i3], r3), r3 = el(r3, r3.next);
          return r3;
        }(t2, e2, p2, r2)), t2.length > 80 * r2) {
          n2 = s2 = t2[0], i2 = a2 = t2[1];
          for (var f2 = r2; f2 < h2; f2 += r2)
            (o2 = t2[f2]) < n2 && (n2 = o2), (l2 = t2[f2 + 1]) < i2 && (i2 = l2), o2 > s2 && (s2 = o2), l2 > a2 && (a2 = l2);
          u2 = 0 !== (u2 = Math.max(s2 - n2, a2 - i2)) ? 1 / u2 : 0;
        }
        return rl(p2, d2, r2, n2, i2, u2), d2;
      }
      function tl(t2, e2, r2, n2, i2) {
        var s2, a2;
        if (i2 === kl(t2, e2, r2, n2) > 0)
          for (s2 = e2; s2 < r2; s2 += n2)
            a2 = wl(s2, t2[s2], t2[s2 + 1], a2);
        else
          for (s2 = r2 - n2; s2 >= e2; s2 -= n2)
            a2 = wl(s2, t2[s2], t2[s2 + 1], a2);
        return a2 && yl(a2, a2.next) && (_l(a2), a2 = a2.next), a2;
      }
      function el(t2, e2) {
        if (!t2)
          return t2;
        e2 || (e2 = t2);
        var r2, n2 = t2;
        do {
          if (r2 = false, n2.steiner || !yl(n2, n2.next) && 0 !== fl(n2.prev, n2, n2.next))
            n2 = n2.next;
          else {
            if (_l(n2), (n2 = e2 = n2.prev) === n2.next)
              break;
            r2 = true;
          }
        } while (r2 || n2 !== e2);
        return e2;
      }
      function rl(t2, e2, r2, n2, i2, s2, a2) {
        if (t2) {
          !a2 && s2 && function(t3, e3, r3, n3) {
            var i3 = t3;
            do {
              null === i3.z && (i3.z = cl(i3.x, i3.y, e3, r3, n3)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
            } while (i3 !== t3);
            i3.prevZ.nextZ = null, i3.prevZ = null, function(t4) {
              var e4, r4, n4, i4, s3, a3, o3, l3, u3 = 1;
              do {
                for (r4 = t4, t4 = null, s3 = null, a3 = 0; r4; ) {
                  for (a3++, n4 = r4, o3 = 0, e4 = 0; e4 < u3 && (o3++, n4 = n4.nextZ); e4++)
                    ;
                  for (l3 = u3; o3 > 0 || l3 > 0 && n4; )
                    0 !== o3 && (0 === l3 || !n4 || r4.z <= n4.z) ? (i4 = r4, r4 = r4.nextZ, o3--) : (i4 = n4, n4 = n4.nextZ, l3--), s3 ? s3.nextZ = i4 : t4 = i4, i4.prevZ = s3, s3 = i4;
                  r4 = n4;
                }
                s3.nextZ = null, u3 *= 2;
              } while (a3 > 1);
            }(i3);
          }(t2, n2, i2, s2);
          for (var o2, l2, u2 = t2; t2.prev !== t2.next; )
            if (o2 = t2.prev, l2 = t2.next, s2 ? il(t2, n2, i2, s2) : nl(t2))
              e2.push(o2.i / r2), e2.push(t2.i / r2), e2.push(l2.i / r2), _l(t2), t2 = l2.next, u2 = l2.next;
            else if ((t2 = l2) === u2) {
              a2 ? 1 === a2 ? rl(t2 = sl(el(t2), e2, r2), e2, r2, n2, i2, s2, 2) : 2 === a2 && al(t2, e2, r2, n2, i2, s2) : rl(el(t2), e2, r2, n2, i2, s2, 1);
              break;
            }
        }
      }
      function nl(t2) {
        var e2 = t2.prev, r2 = t2, n2 = t2.next;
        if (fl(e2, r2, n2) >= 0)
          return false;
        for (var i2 = t2.next.next; i2 !== t2.prev; ) {
          if (pl(e2.x, e2.y, r2.x, r2.y, n2.x, n2.y, i2.x, i2.y) && fl(i2.prev, i2, i2.next) >= 0)
            return false;
          i2 = i2.next;
        }
        return true;
      }
      function il(t2, e2, r2, n2) {
        var i2 = t2.prev, s2 = t2, a2 = t2.next;
        if (fl(i2, s2, a2) >= 0)
          return false;
        for (var o2 = i2.x > s2.x ? i2.x > a2.x ? i2.x : a2.x : s2.x > a2.x ? s2.x : a2.x, l2 = i2.y > s2.y ? i2.y > a2.y ? i2.y : a2.y : s2.y > a2.y ? s2.y : a2.y, u2 = cl(i2.x < s2.x ? i2.x < a2.x ? i2.x : a2.x : s2.x < a2.x ? s2.x : a2.x, i2.y < s2.y ? i2.y < a2.y ? i2.y : a2.y : s2.y < a2.y ? s2.y : a2.y, e2, r2, n2), c2 = cl(o2, l2, e2, r2, n2), h2 = t2.prevZ, p2 = t2.nextZ; h2 && h2.z >= u2 && p2 && p2.z <= c2; ) {
          if (h2 !== t2.prev && h2 !== t2.next && pl(i2.x, i2.y, s2.x, s2.y, a2.x, a2.y, h2.x, h2.y) && fl(h2.prev, h2, h2.next) >= 0)
            return false;
          if (h2 = h2.prevZ, p2 !== t2.prev && p2 !== t2.next && pl(i2.x, i2.y, s2.x, s2.y, a2.x, a2.y, p2.x, p2.y) && fl(p2.prev, p2, p2.next) >= 0)
            return false;
          p2 = p2.nextZ;
        }
        for (; h2 && h2.z >= u2; ) {
          if (h2 !== t2.prev && h2 !== t2.next && pl(i2.x, i2.y, s2.x, s2.y, a2.x, a2.y, h2.x, h2.y) && fl(h2.prev, h2, h2.next) >= 0)
            return false;
          h2 = h2.prevZ;
        }
        for (; p2 && p2.z <= c2; ) {
          if (p2 !== t2.prev && p2 !== t2.next && pl(i2.x, i2.y, s2.x, s2.y, a2.x, a2.y, p2.x, p2.y) && fl(p2.prev, p2, p2.next) >= 0)
            return false;
          p2 = p2.nextZ;
        }
        return true;
      }
      function sl(t2, e2, r2) {
        var n2 = t2;
        do {
          var i2 = n2.prev, s2 = n2.next.next;
          !yl(i2, s2) && ml(i2, n2, n2.next, s2) && vl(i2, s2) && vl(s2, i2) && (e2.push(i2.i / r2), e2.push(n2.i / r2), e2.push(s2.i / r2), _l(n2), _l(n2.next), n2 = t2 = s2), n2 = n2.next;
        } while (n2 !== t2);
        return el(n2);
      }
      function al(t2, e2, r2, n2, i2, s2) {
        var a2 = t2;
        do {
          for (var o2 = a2.next.next; o2 !== a2.prev; ) {
            if (a2.i !== o2.i && dl(a2, o2)) {
              var l2 = bl(a2, o2);
              return a2 = el(a2, a2.next), l2 = el(l2, l2.next), rl(a2, e2, r2, n2, i2, s2), void rl(l2, e2, r2, n2, i2, s2);
            }
            o2 = o2.next;
          }
          a2 = a2.next;
        } while (a2 !== t2);
      }
      function ol(t2, e2) {
        return t2.x - e2.x;
      }
      function ll(t2, e2) {
        if (e2 = function(t3, e3) {
          var r3, n2 = e3, i2 = t3.x, s2 = t3.y, a2 = -1 / 0;
          do {
            if (s2 <= n2.y && s2 >= n2.next.y && n2.next.y !== n2.y) {
              var o2 = n2.x + (s2 - n2.y) * (n2.next.x - n2.x) / (n2.next.y - n2.y);
              if (o2 <= i2 && o2 > a2) {
                if (a2 = o2, o2 === i2) {
                  if (s2 === n2.y)
                    return n2;
                  if (s2 === n2.next.y)
                    return n2.next;
                }
                r3 = n2.x < n2.next.x ? n2 : n2.next;
              }
            }
            n2 = n2.next;
          } while (n2 !== e3);
          if (!r3)
            return null;
          if (i2 === a2)
            return r3;
          var l2, u2 = r3, c2 = r3.x, h2 = r3.y, p2 = 1 / 0;
          n2 = r3;
          do {
            i2 >= n2.x && n2.x >= c2 && i2 !== n2.x && pl(s2 < h2 ? i2 : a2, s2, c2, h2, s2 < h2 ? a2 : i2, s2, n2.x, n2.y) && (l2 = Math.abs(s2 - n2.y) / (i2 - n2.x), vl(n2, t3) && (l2 < p2 || l2 === p2 && (n2.x > r3.x || n2.x === r3.x && ul(r3, n2))) && (r3 = n2, p2 = l2)), n2 = n2.next;
          } while (n2 !== u2);
          return r3;
        }(t2, e2)) {
          var r2 = bl(e2, t2);
          el(e2, e2.next), el(r2, r2.next);
        }
      }
      function ul(t2, e2) {
        return fl(t2.prev, t2, e2.prev) < 0 && fl(e2.next, t2, t2.next) < 0;
      }
      function cl(t2, e2, r2, n2, i2) {
        return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = 32767 * (t2 - r2) * i2) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = 32767 * (e2 - n2) * i2) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
      }
      function hl(t2) {
        var e2 = t2, r2 = t2;
        do {
          (e2.x < r2.x || e2.x === r2.x && e2.y < r2.y) && (r2 = e2), e2 = e2.next;
        } while (e2 !== t2);
        return r2;
      }
      function pl(t2, e2, r2, n2, i2, s2, a2, o2) {
        return (i2 - a2) * (e2 - o2) - (t2 - a2) * (s2 - o2) >= 0 && (t2 - a2) * (n2 - o2) - (r2 - a2) * (e2 - o2) >= 0 && (r2 - a2) * (s2 - o2) - (i2 - a2) * (n2 - o2) >= 0;
      }
      function dl(t2, e2) {
        return t2.next.i !== e2.i && t2.prev.i !== e2.i && !function(t3, e3) {
          var r2 = t3;
          do {
            if (r2.i !== t3.i && r2.next.i !== t3.i && r2.i !== e3.i && r2.next.i !== e3.i && ml(r2, r2.next, t3, e3))
              return true;
            r2 = r2.next;
          } while (r2 !== t3);
          return false;
        }(t2, e2) && (vl(t2, e2) && vl(e2, t2) && function(t3, e3) {
          var r2 = t3, n2 = false, i2 = (t3.x + e3.x) / 2, s2 = (t3.y + e3.y) / 2;
          do {
            r2.y > s2 != r2.next.y > s2 && r2.next.y !== r2.y && i2 < (r2.next.x - r2.x) * (s2 - r2.y) / (r2.next.y - r2.y) + r2.x && (n2 = !n2), r2 = r2.next;
          } while (r2 !== t3);
          return n2;
        }(t2, e2) && (fl(t2.prev, t2, e2.prev) || fl(t2, e2.prev, e2)) || yl(t2, e2) && fl(t2.prev, t2, t2.next) > 0 && fl(e2.prev, e2, e2.next) > 0);
      }
      function fl(t2, e2, r2) {
        return (e2.y - t2.y) * (r2.x - e2.x) - (e2.x - t2.x) * (r2.y - e2.y);
      }
      function yl(t2, e2) {
        return t2.x === e2.x && t2.y === e2.y;
      }
      function ml(t2, e2, r2, n2) {
        var i2 = xl(fl(t2, e2, r2)), s2 = xl(fl(t2, e2, n2)), a2 = xl(fl(r2, n2, t2)), o2 = xl(fl(r2, n2, e2));
        return i2 !== s2 && a2 !== o2 || !(0 !== i2 || !gl(t2, r2, e2)) || !(0 !== s2 || !gl(t2, n2, e2)) || !(0 !== a2 || !gl(r2, t2, n2)) || !(0 !== o2 || !gl(r2, e2, n2));
      }
      function gl(t2, e2, r2) {
        return e2.x <= Math.max(t2.x, r2.x) && e2.x >= Math.min(t2.x, r2.x) && e2.y <= Math.max(t2.y, r2.y) && e2.y >= Math.min(t2.y, r2.y);
      }
      function xl(t2) {
        return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
      }
      function vl(t2, e2) {
        return fl(t2.prev, t2, t2.next) < 0 ? fl(t2, e2, t2.next) >= 0 && fl(t2, t2.prev, e2) >= 0 : fl(t2, e2, t2.prev) < 0 || fl(t2, t2.next, e2) < 0;
      }
      function bl(t2, e2) {
        var r2 = new Al(t2.i, t2.x, t2.y), n2 = new Al(e2.i, e2.x, e2.y), i2 = t2.next, s2 = e2.prev;
        return t2.next = e2, e2.prev = t2, r2.next = i2, i2.prev = r2, n2.next = r2, r2.prev = n2, s2.next = n2, n2.prev = s2, n2;
      }
      function wl(t2, e2, r2, n2) {
        var i2 = new Al(t2, e2, r2);
        return n2 ? (i2.next = n2.next, i2.prev = n2, n2.next.prev = i2, n2.next = i2) : (i2.prev = i2, i2.next = i2), i2;
      }
      function _l(t2) {
        t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
      }
      function Al(t2, e2, r2) {
        this.i = t2, this.x = e2, this.y = r2, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
      }
      function kl(t2, e2, r2, n2) {
        for (var i2 = 0, s2 = e2, a2 = r2 - n2; s2 < r2; s2 += n2)
          i2 += (t2[a2] - t2[s2]) * (t2[s2 + 1] + t2[a2 + 1]), a2 = s2;
        return i2;
      }
      function Sl(t2, e2, r2, n2, i2) {
        Il(t2, e2, r2 || 0, n2 || t2.length - 1, i2 || Tl);
      }
      function Il(t2, e2, r2, n2, i2) {
        for (; n2 > r2; ) {
          if (n2 - r2 > 600) {
            var s2 = n2 - r2 + 1, a2 = e2 - r2 + 1, o2 = Math.log(s2), l2 = 0.5 * Math.exp(2 * o2 / 3), u2 = 0.5 * Math.sqrt(o2 * l2 * (s2 - l2) / s2) * (a2 - s2 / 2 < 0 ? -1 : 1);
            Il(t2, e2, Math.max(r2, Math.floor(e2 - a2 * l2 / s2 + u2)), Math.min(n2, Math.floor(e2 + (s2 - a2) * l2 / s2 + u2)), i2);
          }
          var c2 = t2[e2], h2 = r2, p2 = n2;
          for (zl(t2, r2, e2), i2(t2[n2], c2) > 0 && zl(t2, r2, n2); h2 < p2; ) {
            for (zl(t2, h2, p2), h2++, p2--; i2(t2[h2], c2) < 0; )
              h2++;
            for (; i2(t2[p2], c2) > 0; )
              p2--;
          }
          0 === i2(t2[r2], c2) ? zl(t2, r2, p2) : zl(t2, ++p2, n2), p2 <= e2 && (r2 = p2 + 1), e2 <= p2 && (n2 = p2 - 1);
        }
      }
      function zl(t2, e2, r2) {
        var n2 = t2[e2];
        t2[e2] = t2[r2], t2[r2] = n2;
      }
      function Tl(t2, e2) {
        return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
      }
      function Ml(t2, e2) {
        const r2 = t2.length;
        if (r2 <= 1)
          return [t2];
        const n2 = [];
        let i2, s2;
        for (let e3 = 0; e3 < r2; e3++) {
          const r3 = D(t2[e3]);
          0 !== r3 && (t2[e3].area = Math.abs(r3), void 0 === s2 && (s2 = r3 < 0), s2 === r3 < 0 ? (i2 && n2.push(i2), i2 = [t2[e3]]) : i2.push(t2[e3]));
        }
        if (i2 && n2.push(i2), e2 > 1)
          for (let t3 = 0; t3 < n2.length; t3++)
            n2[t3].length <= e2 || (Sl(n2[t3], e2, 1, n2[t3].length - 1, El), n2[t3] = n2[t3].slice(0, e2));
        return n2;
      }
      function El(t2, e2) {
        return e2.area - t2.area;
      }
      function Cl(t2, e2, r2) {
        const n2 = r2.patternDependencies;
        let i2 = false;
        for (const r3 of e2) {
          const e3 = r3.paint.get(`${t2}-pattern`);
          e3.isConstant() || (i2 = true);
          const s2 = e3.constantOr(null);
          s2 && (i2 = true, n2[s2.to] = true, n2[s2.from] = true);
        }
        return i2;
      }
      function Bl(t2, e2, r2, n2, i2) {
        const s2 = i2.patternDependencies;
        for (const a2 of e2) {
          const e3 = a2.paint.get(`${t2}-pattern`).value;
          if ("constant" !== e3.kind) {
            let t3 = e3.evaluate({ zoom: n2 - 1 }, r2, {}, i2.availableImages), o2 = e3.evaluate({ zoom: n2 }, r2, {}, i2.availableImages), l2 = e3.evaluate({ zoom: n2 + 1 }, r2, {}, i2.availableImages);
            t3 = t3 && t3.name ? t3.name : t3, o2 = o2 && o2.name ? o2.name : o2, l2 = l2 && l2.name ? l2.name : l2, s2[t3] = true, s2[o2] = true, s2[l2] = true, r2.patterns[a2.id] = { min: t3, mid: o2, max: l2 };
          }
        }
        return r2;
      }
      Qo.deviation = function(t2, e2, r2, n2) {
        var i2 = e2 && e2.length, s2 = Math.abs(kl(t2, 0, i2 ? e2[0] * r2 : t2.length, r2));
        if (i2)
          for (var a2 = 0, o2 = e2.length; a2 < o2; a2++)
            s2 -= Math.abs(kl(t2, e2[a2] * r2, a2 < o2 - 1 ? e2[a2 + 1] * r2 : t2.length, r2));
        var l2 = 0;
        for (a2 = 0; a2 < n2.length; a2 += 3) {
          var u2 = n2[a2] * r2, c2 = n2[a2 + 1] * r2, h2 = n2[a2 + 2] * r2;
          l2 += Math.abs((t2[u2] - t2[h2]) * (t2[c2 + 1] - t2[u2 + 1]) - (t2[u2] - t2[c2]) * (t2[h2 + 1] - t2[u2 + 1]));
        }
        return 0 === s2 && 0 === l2 ? 0 : Math.abs((l2 - s2) / s2);
      }, Qo.flatten = function(t2) {
        for (var e2 = t2[0][0].length, r2 = { vertices: [], holes: [], dimensions: e2 }, n2 = 0, i2 = 0; i2 < t2.length; i2++) {
          for (var s2 = 0; s2 < t2[i2].length; s2++)
            for (var a2 = 0; a2 < e2; a2++)
              r2.vertices.push(t2[i2][s2][a2]);
          i2 > 0 && r2.holes.push(n2 += t2[i2 - 1].length);
        }
        return r2;
      }, Jo.default = Wo;
      class Dl {
        constructor(t2) {
          this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new zs(), this.indexArray = new $s(), this.indexArray2 = new Zs(), this.programConfigurations = new Ca(t2.layers, t2.zoom), this.segments = new Oa(), this.segments2 = new Oa(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
        }
        populate(t2, e2, r2) {
          this.hasPattern = Cl("fill", this.layers, e2);
          const n2 = this.layers[0].layout.get("fill-sort-key"), i2 = [];
          for (const { feature: s2, id: a2, index: o2, sourceLayerIndex: l2 } of t2) {
            const t3 = this.layers[0]._featureFilter.needGeometry, u2 = Ga(s2, t3);
            if (!this.layers[0]._featureFilter.filter(new as(this.zoom), u2, r2))
              continue;
            const c2 = n2 ? n2.evaluate(u2, {}, r2, e2.availableImages) : void 0, h2 = { id: a2, properties: s2.properties, type: s2.type, sourceLayerIndex: l2, index: o2, geometry: t3 ? u2.geometry : Za(s2), patterns: {}, sortKey: c2 };
            i2.push(h2);
          }
          n2 && i2.sort((t3, e3) => t3.sortKey - e3.sortKey);
          for (const n3 of i2) {
            const { geometry: i3, index: s2, sourceLayerIndex: a2 } = n3;
            if (this.hasPattern) {
              const t3 = Bl("fill", this.layers, n3, this.zoom, e2);
              this.patternFeatures.push(t3);
            } else
              this.addFeature(n3, i3, s2, r2, {});
            e2.featureIndex.insert(t2[s2].feature, i3, s2, a2, this.index);
          }
        }
        update(t2, e2, r2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
        }
        addFeatures(t2, e2, r2) {
          for (const t3 of this.patternFeatures)
            this.addFeature(t3, t3.geometry, t3.index, e2, r2);
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t2) {
          this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Ho), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.indexBuffer2 = t2.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t2), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }
        addFeature(t2, e2, r2, n2, i2) {
          for (const t3 of Ml(e2, 500)) {
            let e3 = 0;
            for (const r4 of t3)
              e3 += r4.length;
            const r3 = this.segments.prepareSegment(e3, this.layoutVertexArray, this.indexArray), n3 = r3.vertexLength, i3 = [], s2 = [];
            for (const e4 of t3) {
              if (0 === e4.length)
                continue;
              e4 !== t3[0] && s2.push(i3.length / 2);
              const r4 = this.segments2.prepareSegment(e4.length, this.layoutVertexArray, this.indexArray2), n4 = r4.vertexLength;
              this.layoutVertexArray.emplaceBack(e4[0].x, e4[0].y), this.indexArray2.emplaceBack(n4 + e4.length - 1, n4), i3.push(e4[0].x), i3.push(e4[0].y);
              for (let t4 = 1; t4 < e4.length; t4++)
                this.layoutVertexArray.emplaceBack(e4[t4].x, e4[t4].y), this.indexArray2.emplaceBack(n4 + t4 - 1, n4 + t4), i3.push(e4[t4].x), i3.push(e4[t4].y);
              r4.vertexLength += e4.length, r4.primitiveLength += e4.length;
            }
            const a2 = Jo(i3, s2);
            for (let t4 = 0; t4 < a2.length; t4 += 3)
              this.indexArray.emplaceBack(n3 + a2[t4], n3 + a2[t4 + 1], n3 + a2[t4 + 2]);
            r3.vertexLength += e3, r3.primitiveLength += a2.length / 3;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
        }
      }
      oi("FillBucket", Dl, { omit: ["layers", "patternFeatures"] });
      const Pl = new bs({ "fill-sort-key": new ms(Rt.layout_fill["fill-sort-key"]) });
      var Vl = { paint: new bs({ "fill-antialias": new ys(Rt.paint_fill["fill-antialias"]), "fill-opacity": new ms(Rt.paint_fill["fill-opacity"]), "fill-color": new ms(Rt.paint_fill["fill-color"]), "fill-outline-color": new ms(Rt.paint_fill["fill-outline-color"]), "fill-translate": new ys(Rt.paint_fill["fill-translate"]), "fill-translate-anchor": new ys(Rt.paint_fill["fill-translate-anchor"]), "fill-pattern": new gs(Rt.paint_fill["fill-pattern"]) }), layout: Pl };
      const Ll = Ss([{ name: "a_pos_normal_ed", components: 4, type: "Int16" }]), Fl = Ss([{ name: "a_centroid_pos", components: 2, type: "Uint16" }]), { members: Rl } = Ll;
      var $l = Ul;
      function Ul(t2, e2, r2, n2, i2) {
        this.properties = {}, this.extent = r2, this.type = 0, this._pbf = t2, this._geometry = -1, this._keys = n2, this._values = i2, t2.readFields(Ol, this, e2);
      }
      function Ol(t2, e2, r2) {
        1 == t2 ? e2.id = r2.readVarint() : 2 == t2 ? function(t3, e3) {
          for (var r3 = t3.readVarint() + t3.pos; t3.pos < r3; ) {
            var n2 = e3._keys[t3.readVarint()], i2 = e3._values[t3.readVarint()];
            e3.properties[n2] = i2;
          }
        }(r2, e2) : 3 == t2 ? e2.type = r2.readVarint() : 4 == t2 && (e2._geometry = r2.pos);
      }
      function ql(t2) {
        for (var e2, r2, n2 = 0, i2 = 0, s2 = t2.length, a2 = s2 - 1; i2 < s2; a2 = i2++)
          n2 += ((r2 = t2[a2]).x - (e2 = t2[i2]).x) * (e2.y + r2.y);
        return n2;
      }
      Ul.types = ["Unknown", "Point", "LineString", "Polygon"], Ul.prototype.loadGeometry = function() {
        var t2 = this._pbf;
        t2.pos = this._geometry;
        for (var e2, r2 = t2.readVarint() + t2.pos, n2 = 1, s2 = 0, a2 = 0, o2 = 0, l2 = []; t2.pos < r2; ) {
          if (s2 <= 0) {
            var u2 = t2.readVarint();
            n2 = 7 & u2, s2 = u2 >> 3;
          }
          if (s2--, 1 === n2 || 2 === n2)
            a2 += t2.readSVarint(), o2 += t2.readSVarint(), 1 === n2 && (e2 && l2.push(e2), e2 = []), e2.push(new i(a2, o2));
          else {
            if (7 !== n2)
              throw new Error("unknown command " + n2);
            e2 && e2.push(e2[0].clone());
          }
        }
        return e2 && l2.push(e2), l2;
      }, Ul.prototype.bbox = function() {
        var t2 = this._pbf;
        t2.pos = this._geometry;
        for (var e2 = t2.readVarint() + t2.pos, r2 = 1, n2 = 0, i2 = 0, s2 = 0, a2 = 1 / 0, o2 = -1 / 0, l2 = 1 / 0, u2 = -1 / 0; t2.pos < e2; ) {
          if (n2 <= 0) {
            var c2 = t2.readVarint();
            r2 = 7 & c2, n2 = c2 >> 3;
          }
          if (n2--, 1 === r2 || 2 === r2)
            (i2 += t2.readSVarint()) < a2 && (a2 = i2), i2 > o2 && (o2 = i2), (s2 += t2.readSVarint()) < l2 && (l2 = s2), s2 > u2 && (u2 = s2);
          else if (7 !== r2)
            throw new Error("unknown command " + r2);
        }
        return [a2, l2, o2, u2];
      }, Ul.prototype.toGeoJSON = function(t2, e2, r2) {
        var n2, i2, s2 = this.extent * Math.pow(2, r2), a2 = this.extent * t2, o2 = this.extent * e2, l2 = this.loadGeometry(), u2 = Ul.types[this.type];
        function c2(t3) {
          for (var e3 = 0; e3 < t3.length; e3++) {
            var r3 = t3[e3];
            t3[e3] = [360 * (r3.x + a2) / s2 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r3.y + o2) / s2) * Math.PI / 180)) - 90];
          }
        }
        switch (this.type) {
          case 1:
            var h2 = [];
            for (n2 = 0; n2 < l2.length; n2++)
              h2[n2] = l2[n2][0];
            c2(l2 = h2);
            break;
          case 2:
            for (n2 = 0; n2 < l2.length; n2++)
              c2(l2[n2]);
            break;
          case 3:
            for (l2 = function(t3) {
              var e3 = t3.length;
              if (e3 <= 1)
                return [t3];
              for (var r3, n3, i3 = [], s3 = 0; s3 < e3; s3++) {
                var a3 = ql(t3[s3]);
                0 !== a3 && (void 0 === n3 && (n3 = a3 < 0), n3 === a3 < 0 ? (r3 && i3.push(r3), r3 = [t3[s3]]) : r3.push(t3[s3]));
              }
              return r3 && i3.push(r3), i3;
            }(l2), n2 = 0; n2 < l2.length; n2++)
              for (i2 = 0; i2 < l2[n2].length; i2++)
                c2(l2[n2][i2]);
        }
        1 === l2.length ? l2 = l2[0] : u2 = "Multi" + u2;
        var p2 = { type: "Feature", geometry: { type: u2, coordinates: l2 }, properties: this.properties };
        return "id" in this && (p2.id = this.id), p2;
      };
      var jl = Nl;
      function Nl(t2, e2) {
        this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t2, this._keys = [], this._values = [], this._features = [], t2.readFields(Zl, this, e2), this.length = this._features.length;
      }
      function Zl(t2, e2, r2) {
        15 === t2 ? e2.version = r2.readVarint() : 1 === t2 ? e2.name = r2.readString() : 5 === t2 ? e2.extent = r2.readVarint() : 2 === t2 ? e2._features.push(r2.pos) : 3 === t2 ? e2._keys.push(r2.readString()) : 4 === t2 && e2._values.push(function(t3) {
          for (var e3 = null, r3 = t3.readVarint() + t3.pos; t3.pos < r3; ) {
            var n2 = t3.readVarint() >> 3;
            e3 = 1 === n2 ? t3.readString() : 2 === n2 ? t3.readFloat() : 3 === n2 ? t3.readDouble() : 4 === n2 ? t3.readVarint64() : 5 === n2 ? t3.readVarint() : 6 === n2 ? t3.readSVarint() : 7 === n2 ? t3.readBoolean() : null;
          }
          return e3;
        }(r2));
      }
      function Gl(t2, e2, r2) {
        if (3 === t2) {
          var n2 = new jl(r2, r2.readVarint() + r2.pos);
          n2.length && (e2[n2.name] = n2);
        }
      }
      Nl.prototype.feature = function(t2) {
        if (t2 < 0 || t2 >= this._features.length)
          throw new Error("feature index out of bounds");
        this._pbf.pos = this._features[t2];
        var e2 = this._pbf.readVarint() + this._pbf.pos;
        return new $l(this._pbf, e2, this.extent, this._keys, this._values);
      };
      var Xl = { VectorTile: function(t2, e2) {
        this.layers = t2.readFields(Gl, {}, e2);
      }, VectorTileFeature: $l, VectorTileLayer: jl };
      const Kl = Xl.VectorTileFeature.types, Yl = Math.pow(2, 13);
      function Hl(t2, e2, r2, n2, i2, s2, a2, o2) {
        t2.emplaceBack((e2 << 1) + a2, (r2 << 1) + s2, (Math.floor(n2 * Yl) << 1) + i2, Math.round(o2));
      }
      class Jl {
        constructor() {
          this.acc = new i(0, 0), this.polyCount = [];
        }
        startRing(t2) {
          this.currentPolyCount = { edges: 0, top: 0 }, this.polyCount.push(this.currentPolyCount), this.min || (this.min = new i(t2.x, t2.y), this.max = new i(t2.x, t2.y));
        }
        append(t2, e2) {
          this.currentPolyCount.edges++, this.acc._add(t2);
          let r2 = !!this.borders;
          const n2 = this.min, i2 = this.max;
          t2.x < n2.x ? (n2.x = t2.x, r2 = true) : t2.x > i2.x && (i2.x = t2.x, r2 = true), t2.y < n2.y ? (n2.y = t2.y, r2 = true) : t2.y > i2.y && (i2.y = t2.y, r2 = true), ((0 === t2.x || t2.x === qa) && t2.x === e2.x) != ((0 === t2.y || t2.y === qa) && t2.y === e2.y) && this.processBorderOverlap(t2, e2), r2 && this.checkBorderIntersection(t2, e2);
        }
        checkBorderIntersection(t2, e2) {
          e2.x < 0 != t2.x < 0 && this.addBorderIntersection(0, rr(e2.y, t2.y, (0 - e2.x) / (t2.x - e2.x))), e2.x > qa != t2.x > qa && this.addBorderIntersection(1, rr(e2.y, t2.y, (qa - e2.x) / (t2.x - e2.x))), e2.y < 0 != t2.y < 0 && this.addBorderIntersection(2, rr(e2.x, t2.x, (0 - e2.y) / (t2.y - e2.y))), e2.y > qa != t2.y > qa && this.addBorderIntersection(3, rr(e2.x, t2.x, (qa - e2.y) / (t2.y - e2.y)));
        }
        addBorderIntersection(t2, e2) {
          this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
          const r2 = this.borders[t2];
          e2 < r2[0] && (r2[0] = e2), e2 > r2[1] && (r2[1] = e2);
        }
        processBorderOverlap(t2, e2) {
          if (t2.x === e2.x) {
            if (t2.y === e2.y)
              return;
            const r2 = 0 === t2.x ? 0 : 1;
            this.addBorderIntersection(r2, e2.y), this.addBorderIntersection(r2, t2.y);
          } else {
            const r2 = 0 === t2.y ? 2 : 3;
            this.addBorderIntersection(r2, e2.x), this.addBorderIntersection(r2, t2.x);
          }
        }
        centroid() {
          const t2 = this.polyCount.reduce((t3, e2) => t3 + e2.edges, 0);
          return 0 !== t2 ? this.acc.div(t2)._round() : new i(0, 0);
        }
        span() {
          return new i(this.max.x - this.min.x, this.max.y - this.min.y);
        }
        intersectsCount() {
          return this.borders.reduce((t2, e2) => t2 + +(e2[0] !== Number.MAX_VALUE), 0);
        }
      }
      class Wl {
        constructor(t2) {
          this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.layoutVertexArray = new Ts(), this.centroidVertexArray = new oa(), this.indexArray = new $s(), this.programConfigurations = new Ca(t2.layers, t2.zoom), this.segments = new Oa(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.enableTerrain = t2.enableTerrain;
        }
        populate(t2, e2, r2) {
          this.features = [], this.hasPattern = Cl("fill-extrusion", this.layers, e2), this.featuresOnBorder = [], this.borders = [[], [], [], []], this.borderDone = [false, false, false, false], this.tileToMeter = function(t3) {
            const e3 = Math.exp(Math.PI * (1 - t3.y / (1 << t3.z) * 2));
            return 80150034 * e3 / (e3 * e3 + 1) / qa / (1 << t3.z);
          }(r2);
          for (const { feature: n2, id: i2, index: s2, sourceLayerIndex: a2 } of t2) {
            const t3 = this.layers[0]._featureFilter.needGeometry, o2 = Ga(n2, t3);
            if (!this.layers[0]._featureFilter.filter(new as(this.zoom), o2, r2))
              continue;
            const l2 = { id: i2, sourceLayerIndex: a2, index: s2, geometry: t3 ? o2.geometry : Za(n2), properties: n2.properties, type: n2.type, patterns: {} }, u2 = this.layoutVertexArray.length;
            this.hasPattern ? this.features.push(Bl("fill-extrusion", this.layers, l2, this.zoom, e2)) : this.addFeature(l2, l2.geometry, s2, r2, {}), e2.featureIndex.insert(n2, l2.geometry, s2, a2, this.index, u2);
          }
          this.sortBorders();
        }
        addFeatures(t2, e2, r2) {
          for (const t3 of this.features) {
            const { geometry: n2 } = t3;
            this.addFeature(t3, n2, t3.index, e2, r2);
          }
          this.sortBorders();
        }
        update(t2, e2, r2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t2) {
          this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Rl), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
        }
        uploadCentroid(t2) {
          0 !== this.centroidVertexArray.length && (this.centroidVertexBuffer ? this.needsCentroidUpdate && this.centroidVertexBuffer.updateData(this.centroidVertexArray) : this.centroidVertexBuffer = t2.createVertexBuffer(this.centroidVertexArray, Fl.members, true), this.needsCentroidUpdate = false);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        addFeature(t2, e2, r2, n2, i2) {
          const s2 = this.enableTerrain ? new Jl() : null;
          for (const r3 of Ml(e2, 500)) {
            let e3 = 0, n3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
            if (0 === r3.length || (a2 = r3[0]).every((t3) => t3.x <= 0) || a2.every((t3) => t3.x >= qa) || a2.every((t3) => t3.y <= 0) || a2.every((t3) => t3.y >= qa))
              continue;
            for (let t3 = 0; t3 < r3.length; t3++) {
              const i4 = r3[t3];
              if (0 === i4.length)
                continue;
              e3 += i4.length;
              let a3 = 0;
              s2 && s2.startRing(i4[0]);
              for (let t4 = 0; t4 < i4.length; t4++) {
                const e4 = i4[t4];
                if (t4 >= 1) {
                  const r4 = i4[t4 - 1];
                  if (!Ql(e4, r4)) {
                    s2 && s2.append(e4, r4), n3.vertexLength + 4 > Oa.MAX_VERTEX_ARRAY_LENGTH && (n3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                    const t5 = e4.sub(r4)._perp(), i5 = t5.x / (Math.abs(t5.x) + Math.abs(t5.y)), o3 = t5.y > 0 ? 1 : 0, l3 = r4.dist(e4);
                    a3 + l3 > 32768 && (a3 = 0), Hl(this.layoutVertexArray, e4.x, e4.y, i5, o3, 0, 0, a3), Hl(this.layoutVertexArray, e4.x, e4.y, i5, o3, 0, 1, a3), a3 += l3, Hl(this.layoutVertexArray, r4.x, r4.y, i5, o3, 0, 0, a3), Hl(this.layoutVertexArray, r4.x, r4.y, i5, o3, 0, 1, a3);
                    const u3 = n3.vertexLength;
                    this.indexArray.emplaceBack(u3, u3 + 2, u3 + 1), this.indexArray.emplaceBack(u3 + 1, u3 + 2, u3 + 3), n3.vertexLength += 4, n3.primitiveLength += 2;
                  }
                }
              }
            }
            if (n3.vertexLength + e3 > Oa.MAX_VERTEX_ARRAY_LENGTH && (n3 = this.segments.prepareSegment(e3, this.layoutVertexArray, this.indexArray)), "Polygon" !== Kl[t2.type])
              continue;
            const i3 = [], o2 = [], l2 = n3.vertexLength;
            for (let t3 = 0; t3 < r3.length; t3++) {
              const e4 = r3[t3];
              if (0 !== e4.length) {
                e4 !== r3[0] && o2.push(i3.length / 2);
                for (let t4 = 0; t4 < e4.length; t4++) {
                  const r4 = e4[t4];
                  Hl(this.layoutVertexArray, r4.x, r4.y, 0, 0, 1, 1, 0), i3.push(r4.x), i3.push(r4.y), s2 && s2.currentPolyCount.top++;
                }
              }
            }
            const u2 = Jo(i3, o2);
            for (let t3 = 0; t3 < u2.length; t3 += 3)
              this.indexArray.emplaceBack(l2 + u2[t3], l2 + u2[t3 + 2], l2 + u2[t3 + 1]);
            n3.primitiveLength += u2.length / 3, n3.vertexLength += e3;
          }
          var a2;
          if (s2 && s2.polyCount.length > 0) {
            if (s2.borders) {
              s2.vertexArrayOffset = this.centroidVertexArray.length;
              const t3 = s2.borders, e3 = this.featuresOnBorder.push(s2) - 1;
              for (let r3 = 0; r3 < 4; r3++)
                t3[r3][0] !== Number.MAX_VALUE && this.borders[r3].push(e3);
            }
            this.encodeCentroid(s2.borders ? void 0 : s2.centroid(), s2);
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
        }
        sortBorders() {
          for (let t2 = 0; t2 < 4; t2++)
            this.borders[t2].sort((e2, r2) => this.featuresOnBorder[e2].borders[t2][0] - this.featuresOnBorder[r2].borders[t2][0]);
        }
        encodeCentroid(t2, e2, r2 = true) {
          let n2, i2;
          if (t2)
            if (0 !== t2.y) {
              const r3 = e2.span()._mult(this.tileToMeter);
              n2 = (Math.max(t2.x, 1) << 3) + Math.min(7, Math.round(r3.x / 10)), i2 = (Math.max(t2.y, 1) << 3) + Math.min(7, Math.round(r3.y / 10));
            } else
              n2 = Math.ceil(7 * (t2.x + 450)), i2 = 0;
          else
            n2 = 0, i2 = +r2;
          let s2 = r2 ? this.centroidVertexArray.length : e2.vertexArrayOffset;
          for (const t3 of e2.polyCount) {
            r2 && this.centroidVertexArray.resize(this.centroidVertexArray.length + 4 * t3.edges + t3.top);
            for (let e3 = 0; e3 < 2 * t3.edges; e3++)
              this.centroidVertexArray.emplace(s2++, 0, i2), this.centroidVertexArray.emplace(s2++, n2, i2);
            for (let e3 = 0; e3 < t3.top; e3++)
              this.centroidVertexArray.emplace(s2++, n2, i2);
          }
        }
      }
      function Ql(t2, e2) {
        return t2.x === e2.x && (t2.x < 0 || t2.x > qa) || t2.y === e2.y && (t2.y < 0 || t2.y > qa);
      }
      oi("FillExtrusionBucket", Wl, { omit: ["layers", "features"] }), oi("PartMetadata", Jl);
      var tu = { paint: new bs({ "fill-extrusion-opacity": new ys(Rt["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new ms(Rt["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new ys(Rt["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new ys(Rt["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new gs(Rt["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new ms(Rt["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new ms(Rt["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new ys(Rt["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) }) };
      function eu(t2, e2) {
        return t2.x * e2.x + t2.y * e2.y;
      }
      function ru(t2, e2) {
        if (1 === t2.length) {
          let r2 = 0;
          const n2 = e2[r2++];
          let i2;
          for (; !i2 || n2.equals(i2); )
            if (i2 = e2[r2++], !i2)
              return 1 / 0;
          for (; r2 < e2.length; r2++) {
            const s2 = e2[r2], a2 = t2[0], o2 = i2.sub(n2), l2 = s2.sub(n2), u2 = a2.sub(n2), c2 = eu(o2, o2), h2 = eu(o2, l2), p2 = eu(l2, l2), d2 = eu(u2, o2), f2 = eu(u2, l2), y2 = c2 * p2 - h2 * h2, m2 = (p2 * d2 - h2 * f2) / y2, g2 = (c2 * f2 - h2 * d2) / y2, x2 = n2.z * (1 - m2 - g2) + i2.z * m2 + s2.z * g2;
            if (isFinite(x2))
              return x2;
          }
          return 1 / 0;
        }
        {
          let t3 = 1 / 0;
          for (const r2 of e2)
            t3 = Math.min(t3, r2.z);
          return t3;
        }
      }
      function nu(t2) {
        const e2 = new i(t2[0], t2[1]);
        return e2.z = t2[2], e2;
      }
      function iu(t2, e2, r2, n2, i2, s2, a2, o2) {
        const l2 = a2 * i2.getElevationAt(t2, e2, true, true), u2 = 0 !== s2[0], c2 = u2 ? 0 === s2[1] ? a2 * (s2[0] / 7 - 450) : a2 * function(t3, e3, r3) {
          const n3 = Math.floor(e3[0] / 8), i3 = Math.floor(e3[1] / 8), s3 = 10 * (e3[0] - 8 * n3), a3 = 10 * (e3[1] - 8 * i3), o3 = t3.getElevationAt(n3, i3, true, true), l3 = t3.getMeterToDEM(r3), u3 = Math.floor(0.5 * (s3 * l3 - 1)), c3 = Math.floor(0.5 * (a3 * l3 - 1)), h2 = t3.tileCoordToPixel(n3, i3), p2 = 2 * u3 + 1, d2 = 2 * c3 + 1, f2 = function(t4, e4, r4, n4, i4) {
            return [t4.getElevationAtPixel(e4, r4, true), t4.getElevationAtPixel(e4 + i4, r4, true), t4.getElevationAtPixel(e4, r4 + i4, true), t4.getElevationAtPixel(e4 + n4, r4 + i4, true)];
          }(t3, h2.x - u3, h2.y - c3, p2, d2), y2 = Math.abs(f2[0] - f2[1]), m2 = Math.abs(f2[2] - f2[3]), g2 = Math.abs(f2[0] - f2[2]) + Math.abs(f2[1] - f2[3]), x2 = Math.min(0.25, 0.5 * l3 * (y2 + m2) / p2), v2 = Math.min(0.25, 0.5 * l3 * g2 / d2);
          return o3 + Math.max(x2 * s3, v2 * a3);
        }(i2, s2, o2) : l2;
        return { base: l2 + (0 === r2) ? -1 : r2, top: u2 ? Math.max(c2 + n2, l2 + r2 + 2) : l2 + n2 };
      }
      const su = Ss([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }, { name: "a_linesofar", components: 1, type: "Float32" }], 4), { members: au } = su, ou = Ss([{ name: "a_packed", components: 3, type: "Float32" }]), { members: lu } = ou, uu = Xl.VectorTileFeature.types, cu = Math.cos(Math.PI / 180 * 37.5);
      class hu {
        constructor(t2) {
          this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t3) => {
            this.gradients[t3.id] = {};
          }), this.layoutVertexArray = new Ms(), this.layoutVertexArray2 = new Es(), this.indexArray = new $s(), this.programConfigurations = new Ca(t2.layers, t2.zoom), this.segments = new Oa(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
        }
        populate(t2, e2, r2) {
          this.hasPattern = Cl("line", this.layers, e2);
          const n2 = this.layers[0].layout.get("line-sort-key"), i2 = [];
          for (const { feature: e3, id: s3, index: a3, sourceLayerIndex: o3 } of t2) {
            const t3 = this.layers[0]._featureFilter.needGeometry, l2 = Ga(e3, t3);
            if (!this.layers[0]._featureFilter.filter(new as(this.zoom), l2, r2))
              continue;
            const u2 = n2 ? n2.evaluate(l2, {}, r2) : void 0, c2 = { id: s3, properties: e3.properties, type: e3.type, sourceLayerIndex: o3, index: a3, geometry: t3 ? l2.geometry : Za(e3), patterns: {}, sortKey: u2 };
            i2.push(c2);
          }
          n2 && i2.sort((t3, e3) => t3.sortKey - e3.sortKey);
          const { lineAtlas: s2, featureIndex: a2 } = e2, o2 = this.addConstantDashes(s2);
          for (const n3 of i2) {
            const { geometry: i3, index: l2, sourceLayerIndex: u2 } = n3;
            if (o2 && this.addFeatureDashes(n3, s2), this.hasPattern) {
              const t3 = Bl("line", this.layers, n3, this.zoom, e2);
              this.patternFeatures.push(t3);
            } else
              this.addFeature(n3, i3, l2, r2, s2.positions);
            a2.insert(t2[l2].feature, i3, l2, u2, this.index);
          }
        }
        addConstantDashes(t2) {
          let e2 = false;
          for (const r2 of this.layers) {
            const n2 = r2.paint.get("line-dasharray").value, i2 = r2.layout.get("line-cap").value;
            if ("constant" !== n2.kind || "constant" !== i2.kind)
              e2 = true;
            else {
              const e3 = i2.value, r3 = n2.value;
              if (!r3)
                continue;
              t2.addDash(r3.from, e3), t2.addDash(r3.to, e3), r3.other && t2.addDash(r3.other, e3);
            }
          }
          return e2;
        }
        addFeatureDashes(t2, e2) {
          const r2 = this.zoom;
          for (const n2 of this.layers) {
            const i2 = n2.paint.get("line-dasharray").value, s2 = n2.layout.get("line-cap").value;
            if ("constant" === i2.kind && "constant" === s2.kind)
              continue;
            let a2, o2, l2, u2, c2, h2;
            if ("constant" === i2.kind) {
              const t3 = i2.value;
              if (!t3)
                continue;
              a2 = t3.other || t3.to, o2 = t3.to, l2 = t3.from;
            } else
              a2 = i2.evaluate({ zoom: r2 - 1 }, t2), o2 = i2.evaluate({ zoom: r2 }, t2), l2 = i2.evaluate({ zoom: r2 + 1 }, t2);
            "constant" === s2.kind ? u2 = c2 = h2 = s2.value : (u2 = s2.evaluate({ zoom: r2 - 1 }, t2), c2 = s2.evaluate({ zoom: r2 }, t2), h2 = s2.evaluate({ zoom: r2 + 1 }, t2)), e2.addDash(a2, u2), e2.addDash(o2, c2), e2.addDash(l2, h2);
            const p2 = e2.getKey(a2, u2), d2 = e2.getKey(o2, c2), f2 = e2.getKey(l2, h2);
            t2.patterns[n2.id] = { min: p2, mid: d2, max: f2 };
          }
        }
        update(t2, e2, r2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
        }
        addFeatures(t2, e2, r2) {
          for (const t3 of this.patternFeatures)
            this.addFeature(t3, t3.geometry, t3.index, e2, r2);
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t2) {
          this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t2.createVertexBuffer(this.layoutVertexArray2, lu)), this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, au), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        lineFeatureClips(t2) {
          if (t2.properties && t2.properties.hasOwnProperty("mapbox_clip_start") && t2.properties.hasOwnProperty("mapbox_clip_end"))
            return { start: +t2.properties.mapbox_clip_start, end: +t2.properties.mapbox_clip_end };
        }
        addFeature(t2, e2, r2, n2, i2) {
          const s2 = this.layers[0].layout, a2 = s2.get("line-join").evaluate(t2, {}), o2 = s2.get("line-cap").evaluate(t2, {}), l2 = s2.get("line-miter-limit"), u2 = s2.get("line-round-limit");
          this.lineClips = this.lineFeatureClips(t2);
          for (const r3 of e2)
            this.addLine(r3, t2, a2, o2, l2, u2);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
        }
        addLine(t2, e2, r2, n2, i2, s2) {
          if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineSoFar = 0, this.lineClips) {
            this.lineClipsArray.push(this.lineClips);
            for (let e3 = 0; e3 < t2.length - 1; e3++)
              this.totalDistance += t2[e3].dist(t2[e3 + 1]);
            this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
          }
          const a2 = "Polygon" === uu[e2.type];
          let o2 = t2.length;
          for (; o2 >= 2 && t2[o2 - 1].equals(t2[o2 - 2]); )
            o2--;
          let l2 = 0;
          for (; l2 < o2 - 1 && t2[l2].equals(t2[l2 + 1]); )
            l2++;
          if (o2 < (a2 ? 3 : 2))
            return;
          "bevel" === r2 && (i2 = 1.05);
          const u2 = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, c2 = this.segments.prepareSegment(10 * o2, this.layoutVertexArray, this.indexArray);
          let h2, p2, d2, f2, y2;
          this.e1 = this.e2 = -1, a2 && (h2 = t2[o2 - 2], y2 = t2[l2].sub(h2)._unit()._perp());
          for (let e3 = l2; e3 < o2; e3++) {
            if (d2 = e3 === o2 - 1 ? a2 ? t2[l2 + 1] : void 0 : t2[e3 + 1], d2 && t2[e3].equals(d2))
              continue;
            y2 && (f2 = y2), h2 && (p2 = h2), h2 = t2[e3], y2 = d2 ? d2.sub(h2)._unit()._perp() : f2, f2 = f2 || y2;
            let m2 = f2.add(y2);
            0 === m2.x && 0 === m2.y || m2._unit();
            const g2 = f2.x * y2.x + f2.y * y2.y, x2 = m2.x * y2.x + m2.y * y2.y, v2 = 0 !== x2 ? 1 / x2 : 1 / 0, b2 = 2 * Math.sqrt(2 - 2 * x2), w2 = x2 < cu && p2 && d2, _2 = f2.x * y2.y - f2.y * y2.x > 0;
            if (w2 && e3 > l2) {
              const t3 = h2.dist(p2);
              if (t3 > 2 * u2) {
                const e4 = h2.sub(h2.sub(p2)._mult(u2 / t3)._round());
                this.updateDistance(p2, e4), this.addCurrentVertex(e4, f2, 0, 0, c2), p2 = e4;
              }
            }
            const A2 = p2 && d2;
            let k2 = A2 ? r2 : a2 ? "butt" : n2;
            if (A2 && "round" === k2 && (v2 < s2 ? k2 = "miter" : v2 <= 2 && (k2 = "fakeround")), "miter" === k2 && v2 > i2 && (k2 = "bevel"), "bevel" === k2 && (v2 > 2 && (k2 = "flipbevel"), v2 < i2 && (k2 = "miter")), p2 && this.updateDistance(p2, h2), "miter" === k2)
              m2._mult(v2), this.addCurrentVertex(h2, m2, 0, 0, c2);
            else if ("flipbevel" === k2) {
              if (v2 > 100)
                m2 = y2.mult(-1);
              else {
                const t3 = v2 * f2.add(y2).mag() / f2.sub(y2).mag();
                m2._perp()._mult(t3 * (_2 ? -1 : 1));
              }
              this.addCurrentVertex(h2, m2, 0, 0, c2), this.addCurrentVertex(h2, m2.mult(-1), 0, 0, c2);
            } else if ("bevel" === k2 || "fakeround" === k2) {
              const t3 = -Math.sqrt(v2 * v2 - 1), e4 = _2 ? t3 : 0, r3 = _2 ? 0 : t3;
              if (p2 && this.addCurrentVertex(h2, f2, e4, r3, c2), "fakeround" === k2) {
                const t4 = Math.round(180 * b2 / Math.PI / 20);
                for (let e5 = 1; e5 < t4; e5++) {
                  let r4 = e5 / t4;
                  if (0.5 !== r4) {
                    const t5 = r4 - 0.5;
                    r4 += r4 * t5 * (r4 - 1) * ((1.0904 + g2 * (g2 * (3.55645 - 1.43519 * g2) - 3.2452)) * t5 * t5 + (0.848013 + g2 * (0.215638 * g2 - 1.06021)));
                  }
                  const n3 = y2.sub(f2)._mult(r4)._add(f2)._unit()._mult(_2 ? -1 : 1);
                  this.addHalfVertex(h2, n3.x, n3.y, false, _2, 0, c2);
                }
              }
              d2 && this.addCurrentVertex(h2, y2, -e4, -r3, c2);
            } else if ("butt" === k2)
              this.addCurrentVertex(h2, m2, 0, 0, c2);
            else if ("square" === k2) {
              const t3 = p2 ? 1 : -1;
              p2 || this.addCurrentVertex(h2, m2, t3, t3, c2), this.addCurrentVertex(h2, m2, 0, 0, c2), p2 && this.addCurrentVertex(h2, m2, t3, t3, c2);
            } else
              "round" === k2 && (p2 && (this.addCurrentVertex(h2, f2, 0, 0, c2), this.addCurrentVertex(h2, f2, 1, 1, c2, true)), d2 && (this.addCurrentVertex(h2, y2, -1, -1, c2, true), this.addCurrentVertex(h2, y2, 0, 0, c2)));
            if (w2 && e3 < o2 - 1) {
              const t3 = h2.dist(d2);
              if (t3 > 2 * u2) {
                const e4 = h2.add(d2.sub(h2)._mult(u2 / t3)._round());
                this.updateDistance(h2, e4), this.addCurrentVertex(e4, y2, 0, 0, c2), h2 = e4;
              }
            }
          }
        }
        addCurrentVertex(t2, e2, r2, n2, i2, s2 = false) {
          const a2 = e2.y * n2 - e2.x, o2 = -e2.y - e2.x * n2;
          this.addHalfVertex(t2, e2.x + e2.y * r2, e2.y - e2.x * r2, s2, false, r2, i2), this.addHalfVertex(t2, a2, o2, s2, true, -n2, i2);
        }
        addHalfVertex({ x: t2, y: e2 }, r2, n2, i2, s2, a2, o2) {
          this.layoutVertexArray.emplaceBack((t2 << 1) + (i2 ? 1 : 0), (e2 << 1) + (s2 ? 1 : 0), Math.round(63 * r2) + 128, Math.round(63 * n2) + 128, 1 + (0 === a2 ? 0 : a2 < 0 ? -1 : 1), 0, this.lineSoFar), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineSoFar);
          const l2 = o2.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l2), o2.primitiveLength++), s2 ? this.e2 = l2 : this.e1 = l2;
        }
        updateScaledDistance() {
          if (this.lineClips) {
            const t2 = this.totalDistance / (this.lineClips.end - this.lineClips.start);
            this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t2 * this.lineClips.start + this.distance;
          } else
            this.lineSoFar = this.distance;
        }
        updateDistance(t2, e2) {
          this.distance += t2.dist(e2), this.updateScaledDistance();
        }
      }
      oi("LineBucket", hu, { omit: ["layers", "patternFeatures"] });
      const pu = new bs({ "line-cap": new ms(Rt.layout_line["line-cap"]), "line-join": new ms(Rt.layout_line["line-join"]), "line-miter-limit": new ys(Rt.layout_line["line-miter-limit"]), "line-round-limit": new ys(Rt.layout_line["line-round-limit"]), "line-sort-key": new ms(Rt.layout_line["line-sort-key"]) });
      var du = { paint: new bs({ "line-opacity": new ms(Rt.paint_line["line-opacity"]), "line-color": new ms(Rt.paint_line["line-color"]), "line-translate": new ys(Rt.paint_line["line-translate"]), "line-translate-anchor": new ys(Rt.paint_line["line-translate-anchor"]), "line-width": new ms(Rt.paint_line["line-width"]), "line-gap-width": new ms(Rt.paint_line["line-gap-width"]), "line-offset": new ms(Rt.paint_line["line-offset"]), "line-blur": new ms(Rt.paint_line["line-blur"]), "line-dasharray": new gs(Rt.paint_line["line-dasharray"]), "line-pattern": new gs(Rt.paint_line["line-pattern"]), "line-gradient": new vs(Rt.paint_line["line-gradient"]) }), layout: pu };
      const fu = new class extends ms {
        possiblyEvaluate(t2, e2) {
          return e2 = new as(Math.floor(e2.zoom), { now: e2.now, fadeDuration: e2.fadeDuration, zoomHistory: e2.zoomHistory, transition: e2.transition }), super.possiblyEvaluate(t2, e2);
        }
        evaluate(t2, e2, r2, n2) {
          return e2 = v({}, e2, { zoom: Math.floor(e2.zoom) }), super.evaluate(t2, e2, r2, n2);
        }
      }(du.paint.properties["line-width"].specification);
      function yu(t2, e2) {
        return e2 > 0 ? e2 + 2 * t2 : t2;
      }
      fu.useIntegerZoom = true;
      const mu = Ss([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_tex_size", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }, { name: "a_z_tile_anchor", components: 4, type: "Int16" }], 4), gu = Ss([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
      Ss([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
      const xu = Ss([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]), vu = Ss([{ name: "a_size_scale", components: 1, type: "Float32" }, { name: "a_padding", components: 2, type: "Float32" }]);
      Ss([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "tileAnchorX" }, { type: "Int16", name: "tileAnchorY" }, { type: "Float32", name: "x1" }, { type: "Float32", name: "y1" }, { type: "Float32", name: "x2" }, { type: "Float32", name: "y2" }, { type: "Int16", name: "padding" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
      const bu = Ss([{ name: "a_pos", components: 3, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), wu = Ss([{ name: "a_pos_2f", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      Ss([{ name: "triangle", components: 3, type: "Uint16" }]), Ss([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }, { type: "Uint8", name: "flipState" }]), Ss([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]), Ss([{ type: "Float32", name: "offsetX" }]), Ss([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]);
      var _u = 24;
      const Au = 128;
      function ku(t2, e2) {
        const { expression: r2 } = e2;
        if ("constant" === r2.kind)
          return { kind: "constant", layoutSize: r2.evaluate(new as(t2 + 1)) };
        if ("source" === r2.kind)
          return { kind: "source" };
        {
          const { zoomStops: e3, interpolationType: n2 } = r2;
          let i2 = 0;
          for (; i2 < e3.length && e3[i2] <= t2; )
            i2++;
          i2 = Math.max(0, i2 - 1);
          let s2 = i2;
          for (; s2 < e3.length && e3[s2] < t2 + 1; )
            s2++;
          s2 = Math.min(e3.length - 1, s2);
          const a2 = e3[i2], o2 = e3[s2];
          return "composite" === r2.kind ? { kind: "composite", minZoom: a2, maxZoom: o2, interpolationType: n2 } : { kind: "camera", minZoom: a2, maxZoom: o2, minSize: r2.evaluate(new as(a2)), maxSize: r2.evaluate(new as(o2)), interpolationType: n2 };
        }
      }
      function Su(t2, { uSize: e2, uSizeT: r2 }, { lowerSize: n2, upperSize: i2 }) {
        return "source" === t2.kind ? n2 / Au : "composite" === t2.kind ? rr(n2 / Au, i2 / Au, r2) : e2;
      }
      function Iu(t2, e2) {
        let r2 = 0, n2 = 0;
        if ("constant" === t2.kind)
          n2 = t2.layoutSize;
        else if ("source" !== t2.kind) {
          const { interpolationType: i2, minZoom: s2, maxZoom: a2 } = t2, o2 = i2 ? y(wr.interpolationFactor(i2, e2, s2, a2), 0, 1) : 0;
          "camera" === t2.kind ? n2 = rr(t2.minSize, t2.maxSize, o2) : r2 = o2;
        }
        return { uSizeT: r2, uSize: n2 };
      }
      var zu = Object.freeze({ __proto__: null, getSizeData: ku, evaluateSizeForFeature: Su, evaluateSizeForZoom: Iu, SIZE_PACK_FACTOR: Au });
      function Tu(t2, e2, r2) {
        return t2.sections.forEach((t3) => {
          t3.text = function(t4, e3, r3) {
            const n2 = e3.layout.get("text-transform").evaluate(r3, {});
            return "uppercase" === n2 ? t4 = t4.toLocaleUpperCase() : "lowercase" === n2 && (t4 = t4.toLocaleLowerCase()), ss.applyArabicShaping && (t4 = ss.applyArabicShaping(t4)), t4;
          }(t3.text, e2, r2);
        }), t2;
      }
      const Mu = { "!": "", "#": "", $: "", "%": "", "&": "", "(": "", ")": "", "*": "", "+": "", ",": "", "-": "", ".": "", "/": "", ":": "", ";": "", "<": "", "=": "", ">": "", "?": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "" };
      function Eu(t2) {
        return "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2;
      }
      function Cu(t2) {
        return "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2 || "" === t2;
      }
      var Bu = function(t2, e2, r2, n2, i2) {
        var s2, a2, o2 = 8 * i2 - n2 - 1, l2 = (1 << o2) - 1, u2 = l2 >> 1, c2 = -7, h2 = r2 ? i2 - 1 : 0, p2 = r2 ? -1 : 1, d2 = t2[e2 + h2];
        for (h2 += p2, s2 = d2 & (1 << -c2) - 1, d2 >>= -c2, c2 += o2; c2 > 0; s2 = 256 * s2 + t2[e2 + h2], h2 += p2, c2 -= 8)
          ;
        for (a2 = s2 & (1 << -c2) - 1, s2 >>= -c2, c2 += n2; c2 > 0; a2 = 256 * a2 + t2[e2 + h2], h2 += p2, c2 -= 8)
          ;
        if (0 === s2)
          s2 = 1 - u2;
        else {
          if (s2 === l2)
            return a2 ? NaN : 1 / 0 * (d2 ? -1 : 1);
          a2 += Math.pow(2, n2), s2 -= u2;
        }
        return (d2 ? -1 : 1) * a2 * Math.pow(2, s2 - n2);
      }, Du = function(t2, e2, r2, n2, i2, s2) {
        var a2, o2, l2, u2 = 8 * s2 - i2 - 1, c2 = (1 << u2) - 1, h2 = c2 >> 1, p2 = 23 === i2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d2 = n2 ? 0 : s2 - 1, f2 = n2 ? 1 : -1, y2 = e2 < 0 || 0 === e2 && 1 / e2 < 0 ? 1 : 0;
        for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (o2 = isNaN(e2) ? 1 : 0, a2 = c2) : (a2 = Math.floor(Math.log(e2) / Math.LN2), e2 * (l2 = Math.pow(2, -a2)) < 1 && (a2--, l2 *= 2), (e2 += a2 + h2 >= 1 ? p2 / l2 : p2 * Math.pow(2, 1 - h2)) * l2 >= 2 && (a2++, l2 /= 2), a2 + h2 >= c2 ? (o2 = 0, a2 = c2) : a2 + h2 >= 1 ? (o2 = (e2 * l2 - 1) * Math.pow(2, i2), a2 += h2) : (o2 = e2 * Math.pow(2, h2 - 1) * Math.pow(2, i2), a2 = 0)); i2 >= 8; t2[r2 + d2] = 255 & o2, d2 += f2, o2 /= 256, i2 -= 8)
          ;
        for (a2 = a2 << i2 | o2, u2 += i2; u2 > 0; t2[r2 + d2] = 255 & a2, d2 += f2, a2 /= 256, u2 -= 8)
          ;
        t2[r2 + d2 - f2] |= 128 * y2;
      }, Pu = Vu;
      function Vu(t2) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t2) ? t2 : new Uint8Array(t2 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
      }
      Vu.Varint = 0, Vu.Fixed64 = 1, Vu.Bytes = 2, Vu.Fixed32 = 5;
      var Lu = 4294967296, Fu = 1 / Lu, Ru = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
      function $u(t2) {
        return t2.type === Vu.Bytes ? t2.readVarint() + t2.pos : t2.pos + 1;
      }
      function Uu(t2, e2, r2) {
        return r2 ? 4294967296 * e2 + (t2 >>> 0) : 4294967296 * (e2 >>> 0) + (t2 >>> 0);
      }
      function Ou(t2, e2, r2) {
        var n2 = e2 <= 16383 ? 1 : e2 <= 2097151 ? 2 : e2 <= 268435455 ? 3 : Math.floor(Math.log(e2) / (7 * Math.LN2));
        r2.realloc(n2);
        for (var i2 = r2.pos - 1; i2 >= t2; i2--)
          r2.buf[i2 + n2] = r2.buf[i2];
      }
      function qu(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2.writeVarint(t2[r2]);
      }
      function ju(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2.writeSVarint(t2[r2]);
      }
      function Nu(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2.writeFloat(t2[r2]);
      }
      function Zu(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2.writeDouble(t2[r2]);
      }
      function Gu(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2.writeBoolean(t2[r2]);
      }
      function Xu(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2.writeFixed32(t2[r2]);
      }
      function Ku(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2.writeSFixed32(t2[r2]);
      }
      function Yu(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2.writeFixed64(t2[r2]);
      }
      function Hu(t2, e2) {
        for (var r2 = 0; r2 < t2.length; r2++)
          e2.writeSFixed64(t2[r2]);
      }
      function Ju(t2, e2) {
        return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + 16777216 * t2[e2 + 3];
      }
      function Wu(t2, e2, r2) {
        t2[r2] = e2, t2[r2 + 1] = e2 >>> 8, t2[r2 + 2] = e2 >>> 16, t2[r2 + 3] = e2 >>> 24;
      }
      function Qu(t2, e2) {
        return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + (t2[e2 + 3] << 24);
      }
      function tc(t2, e2, r2) {
        e2.glyphs = [], 1 === t2 && r2.readMessage(ec, e2);
      }
      function ec(t2, e2, r2) {
        if (3 === t2) {
          const { id: t3, bitmap: n2, width: i2, height: s2, left: a2, top: o2, advance: l2 } = r2.readMessage(rc, {});
          e2.glyphs.push({ id: t3, bitmap: new No({ width: i2 + 6, height: s2 + 6 }, n2), metrics: { width: i2, height: s2, left: a2, top: o2, advance: l2 } });
        } else
          4 === t2 ? e2.ascender = r2.readSVarint() : 5 === t2 && (e2.descender = r2.readSVarint());
      }
      function rc(t2, e2, r2) {
        1 === t2 ? e2.id = r2.readVarint() : 2 === t2 ? e2.bitmap = r2.readBytes() : 3 === t2 ? e2.width = r2.readVarint() : 4 === t2 ? e2.height = r2.readVarint() : 5 === t2 ? e2.left = r2.readSVarint() : 6 === t2 ? e2.top = r2.readSVarint() : 7 === t2 && (e2.advance = r2.readVarint());
      }
      function nc(t2) {
        let e2 = 0, r2 = 0;
        for (const n3 of t2)
          e2 += n3.w * n3.h, r2 = Math.max(r2, n3.w);
        t2.sort((t3, e3) => e3.h - t3.h);
        const n2 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e2 / 0.95)), r2), h: 1 / 0 }];
        let i2 = 0, s2 = 0;
        for (const e3 of t2)
          for (let t3 = n2.length - 1; t3 >= 0; t3--) {
            const r3 = n2[t3];
            if (!(e3.w > r3.w || e3.h > r3.h)) {
              if (e3.x = r3.x, e3.y = r3.y, s2 = Math.max(s2, e3.y + e3.h), i2 = Math.max(i2, e3.x + e3.w), e3.w === r3.w && e3.h === r3.h) {
                const e4 = n2.pop();
                t3 < n2.length && (n2[t3] = e4);
              } else
                e3.h === r3.h ? (r3.x += e3.w, r3.w -= e3.w) : e3.w === r3.w ? (r3.y += e3.h, r3.h -= e3.h) : (n2.push({ x: r3.x + e3.w, y: r3.y, w: r3.w - e3.w, h: e3.h }), r3.y += e3.h, r3.h -= e3.h);
              break;
            }
          }
        return { w: i2, h: s2, fill: e2 / (i2 * s2) || 0 };
      }
      Vu.prototype = { destroy: function() {
        this.buf = null;
      }, readFields: function(t2, e2, r2) {
        for (r2 = r2 || this.length; this.pos < r2; ) {
          var n2 = this.readVarint(), i2 = n2 >> 3, s2 = this.pos;
          this.type = 7 & n2, t2(i2, e2, this), this.pos === s2 && this.skip(n2);
        }
        return e2;
      }, readMessage: function(t2, e2) {
        return this.readFields(t2, e2, this.readVarint() + this.pos);
      }, readFixed32: function() {
        var t2 = Ju(this.buf, this.pos);
        return this.pos += 4, t2;
      }, readSFixed32: function() {
        var t2 = Qu(this.buf, this.pos);
        return this.pos += 4, t2;
      }, readFixed64: function() {
        var t2 = Ju(this.buf, this.pos) + Ju(this.buf, this.pos + 4) * Lu;
        return this.pos += 8, t2;
      }, readSFixed64: function() {
        var t2 = Ju(this.buf, this.pos) + Qu(this.buf, this.pos + 4) * Lu;
        return this.pos += 8, t2;
      }, readFloat: function() {
        var t2 = Bu(this.buf, this.pos, true, 23, 4);
        return this.pos += 4, t2;
      }, readDouble: function() {
        var t2 = Bu(this.buf, this.pos, true, 52, 8);
        return this.pos += 8, t2;
      }, readVarint: function(t2) {
        var e2, r2, n2 = this.buf;
        return e2 = 127 & (r2 = n2[this.pos++]), r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 7, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 14, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 21, r2 < 128 ? e2 : function(t3, e3, r3) {
          var n3, i2, s2 = r3.buf;
          if (n3 = (112 & (i2 = s2[r3.pos++])) >> 4, i2 < 128)
            return Uu(t3, n3, e3);
          if (n3 |= (127 & (i2 = s2[r3.pos++])) << 3, i2 < 128)
            return Uu(t3, n3, e3);
          if (n3 |= (127 & (i2 = s2[r3.pos++])) << 10, i2 < 128)
            return Uu(t3, n3, e3);
          if (n3 |= (127 & (i2 = s2[r3.pos++])) << 17, i2 < 128)
            return Uu(t3, n3, e3);
          if (n3 |= (127 & (i2 = s2[r3.pos++])) << 24, i2 < 128)
            return Uu(t3, n3, e3);
          if (n3 |= (1 & (i2 = s2[r3.pos++])) << 31, i2 < 128)
            return Uu(t3, n3, e3);
          throw new Error("Expected varint not more than 10 bytes");
        }(e2 |= (15 & (r2 = n2[this.pos])) << 28, t2, this))));
      }, readVarint64: function() {
        return this.readVarint(true);
      }, readSVarint: function() {
        var t2 = this.readVarint();
        return t2 % 2 == 1 ? (t2 + 1) / -2 : t2 / 2;
      }, readBoolean: function() {
        return Boolean(this.readVarint());
      }, readString: function() {
        var t2 = this.readVarint() + this.pos, e2 = this.pos;
        return this.pos = t2, t2 - e2 >= 12 && Ru ? function(t3, e3, r2) {
          return Ru.decode(t3.subarray(e3, r2));
        }(this.buf, e2, t2) : function(t3, e3, r2) {
          for (var n2 = "", i2 = e3; i2 < r2; ) {
            var s2, a2, o2, l2 = t3[i2], u2 = null, c2 = l2 > 239 ? 4 : l2 > 223 ? 3 : l2 > 191 ? 2 : 1;
            if (i2 + c2 > r2)
              break;
            1 === c2 ? l2 < 128 && (u2 = l2) : 2 === c2 ? 128 == (192 & (s2 = t3[i2 + 1])) && (u2 = (31 & l2) << 6 | 63 & s2) <= 127 && (u2 = null) : 3 === c2 ? (a2 = t3[i2 + 2], 128 == (192 & (s2 = t3[i2 + 1])) && 128 == (192 & a2) && ((u2 = (15 & l2) << 12 | (63 & s2) << 6 | 63 & a2) <= 2047 || u2 >= 55296 && u2 <= 57343) && (u2 = null)) : 4 === c2 && (a2 = t3[i2 + 2], o2 = t3[i2 + 3], 128 == (192 & (s2 = t3[i2 + 1])) && 128 == (192 & a2) && 128 == (192 & o2) && ((u2 = (15 & l2) << 18 | (63 & s2) << 12 | (63 & a2) << 6 | 63 & o2) <= 65535 || u2 >= 1114112) && (u2 = null)), null === u2 ? (u2 = 65533, c2 = 1) : u2 > 65535 && (u2 -= 65536, n2 += String.fromCharCode(u2 >>> 10 & 1023 | 55296), u2 = 56320 | 1023 & u2), n2 += String.fromCharCode(u2), i2 += c2;
          }
          return n2;
        }(this.buf, e2, t2);
      }, readBytes: function() {
        var t2 = this.readVarint() + this.pos, e2 = this.buf.subarray(this.pos, t2);
        return this.pos = t2, e2;
      }, readPackedVarint: function(t2, e2) {
        if (this.type !== Vu.Bytes)
          return t2.push(this.readVarint(e2));
        var r2 = $u(this);
        for (t2 = t2 || []; this.pos < r2; )
          t2.push(this.readVarint(e2));
        return t2;
      }, readPackedSVarint: function(t2) {
        if (this.type !== Vu.Bytes)
          return t2.push(this.readSVarint());
        var e2 = $u(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readSVarint());
        return t2;
      }, readPackedBoolean: function(t2) {
        if (this.type !== Vu.Bytes)
          return t2.push(this.readBoolean());
        var e2 = $u(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readBoolean());
        return t2;
      }, readPackedFloat: function(t2) {
        if (this.type !== Vu.Bytes)
          return t2.push(this.readFloat());
        var e2 = $u(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readFloat());
        return t2;
      }, readPackedDouble: function(t2) {
        if (this.type !== Vu.Bytes)
          return t2.push(this.readDouble());
        var e2 = $u(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readDouble());
        return t2;
      }, readPackedFixed32: function(t2) {
        if (this.type !== Vu.Bytes)
          return t2.push(this.readFixed32());
        var e2 = $u(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readFixed32());
        return t2;
      }, readPackedSFixed32: function(t2) {
        if (this.type !== Vu.Bytes)
          return t2.push(this.readSFixed32());
        var e2 = $u(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readSFixed32());
        return t2;
      }, readPackedFixed64: function(t2) {
        if (this.type !== Vu.Bytes)
          return t2.push(this.readFixed64());
        var e2 = $u(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readFixed64());
        return t2;
      }, readPackedSFixed64: function(t2) {
        if (this.type !== Vu.Bytes)
          return t2.push(this.readSFixed64());
        var e2 = $u(this);
        for (t2 = t2 || []; this.pos < e2; )
          t2.push(this.readSFixed64());
        return t2;
      }, skip: function(t2) {
        var e2 = 7 & t2;
        if (e2 === Vu.Varint)
          for (; this.buf[this.pos++] > 127; )
            ;
        else if (e2 === Vu.Bytes)
          this.pos = this.readVarint() + this.pos;
        else if (e2 === Vu.Fixed32)
          this.pos += 4;
        else {
          if (e2 !== Vu.Fixed64)
            throw new Error("Unimplemented type: " + e2);
          this.pos += 8;
        }
      }, writeTag: function(t2, e2) {
        this.writeVarint(t2 << 3 | e2);
      }, realloc: function(t2) {
        for (var e2 = this.length || 16; e2 < this.pos + t2; )
          e2 *= 2;
        if (e2 !== this.length) {
          var r2 = new Uint8Array(e2);
          r2.set(this.buf), this.buf = r2, this.length = e2;
        }
      }, finish: function() {
        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
      }, writeFixed32: function(t2) {
        this.realloc(4), Wu(this.buf, t2, this.pos), this.pos += 4;
      }, writeSFixed32: function(t2) {
        this.realloc(4), Wu(this.buf, t2, this.pos), this.pos += 4;
      }, writeFixed64: function(t2) {
        this.realloc(8), Wu(this.buf, -1 & t2, this.pos), Wu(this.buf, Math.floor(t2 * Fu), this.pos + 4), this.pos += 8;
      }, writeSFixed64: function(t2) {
        this.realloc(8), Wu(this.buf, -1 & t2, this.pos), Wu(this.buf, Math.floor(t2 * Fu), this.pos + 4), this.pos += 8;
      }, writeVarint: function(t2) {
        (t2 = +t2 || 0) > 268435455 || t2 < 0 ? function(t3, e2) {
          var r2, n2;
          if (t3 >= 0 ? (r2 = t3 % 4294967296 | 0, n2 = t3 / 4294967296 | 0) : (n2 = ~(-t3 / 4294967296), 4294967295 ^ (r2 = ~(-t3 % 4294967296)) ? r2 = r2 + 1 | 0 : (r2 = 0, n2 = n2 + 1 | 0)), t3 >= 18446744073709552e3 || t3 < -18446744073709552e3)
            throw new Error("Given varint doesn't fit into 10 bytes");
          e2.realloc(10), function(t4, e3, r3) {
            r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, r3.buf[r3.pos] = 127 & (t4 >>>= 7);
          }(r2, 0, e2), function(t4, e3) {
            var r3 = (7 & t4) << 4;
            e3.buf[e3.pos++] |= r3 | ((t4 >>>= 3) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4)))));
          }(n2, e2);
        }(t2, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t2 | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = t2 >>> 7 & 127))));
      }, writeSVarint: function(t2) {
        this.writeVarint(t2 < 0 ? 2 * -t2 - 1 : 2 * t2);
      }, writeBoolean: function(t2) {
        this.writeVarint(Boolean(t2));
      }, writeString: function(t2) {
        t2 = String(t2), this.realloc(4 * t2.length), this.pos++;
        var e2 = this.pos;
        this.pos = function(t3, e3, r3) {
          for (var n2, i2, s2 = 0; s2 < e3.length; s2++) {
            if ((n2 = e3.charCodeAt(s2)) > 55295 && n2 < 57344) {
              if (!i2) {
                n2 > 56319 || s2 + 1 === e3.length ? (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189) : i2 = n2;
                continue;
              }
              if (n2 < 56320) {
                t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = n2;
                continue;
              }
              n2 = i2 - 55296 << 10 | n2 - 56320 | 65536, i2 = null;
            } else
              i2 && (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = null);
            n2 < 128 ? t3[r3++] = n2 : (n2 < 2048 ? t3[r3++] = n2 >> 6 | 192 : (n2 < 65536 ? t3[r3++] = n2 >> 12 | 224 : (t3[r3++] = n2 >> 18 | 240, t3[r3++] = n2 >> 12 & 63 | 128), t3[r3++] = n2 >> 6 & 63 | 128), t3[r3++] = 63 & n2 | 128);
          }
          return r3;
        }(this.buf, t2, this.pos);
        var r2 = this.pos - e2;
        r2 >= 128 && Ou(e2, r2, this), this.pos = e2 - 1, this.writeVarint(r2), this.pos += r2;
      }, writeFloat: function(t2) {
        this.realloc(4), Du(this.buf, t2, this.pos, true, 23, 4), this.pos += 4;
      }, writeDouble: function(t2) {
        this.realloc(8), Du(this.buf, t2, this.pos, true, 52, 8), this.pos += 8;
      }, writeBytes: function(t2) {
        var e2 = t2.length;
        this.writeVarint(e2), this.realloc(e2);
        for (var r2 = 0; r2 < e2; r2++)
          this.buf[this.pos++] = t2[r2];
      }, writeRawMessage: function(t2, e2) {
        this.pos++;
        var r2 = this.pos;
        t2(e2, this);
        var n2 = this.pos - r2;
        n2 >= 128 && Ou(r2, n2, this), this.pos = r2 - 1, this.writeVarint(n2), this.pos += n2;
      }, writeMessage: function(t2, e2, r2) {
        this.writeTag(t2, Vu.Bytes), this.writeRawMessage(e2, r2);
      }, writePackedVarint: function(t2, e2) {
        e2.length && this.writeMessage(t2, qu, e2);
      }, writePackedSVarint: function(t2, e2) {
        e2.length && this.writeMessage(t2, ju, e2);
      }, writePackedBoolean: function(t2, e2) {
        e2.length && this.writeMessage(t2, Gu, e2);
      }, writePackedFloat: function(t2, e2) {
        e2.length && this.writeMessage(t2, Nu, e2);
      }, writePackedDouble: function(t2, e2) {
        e2.length && this.writeMessage(t2, Zu, e2);
      }, writePackedFixed32: function(t2, e2) {
        e2.length && this.writeMessage(t2, Xu, e2);
      }, writePackedSFixed32: function(t2, e2) {
        e2.length && this.writeMessage(t2, Ku, e2);
      }, writePackedFixed64: function(t2, e2) {
        e2.length && this.writeMessage(t2, Yu, e2);
      }, writePackedSFixed64: function(t2, e2) {
        e2.length && this.writeMessage(t2, Hu, e2);
      }, writeBytesField: function(t2, e2) {
        this.writeTag(t2, Vu.Bytes), this.writeBytes(e2);
      }, writeFixed32Field: function(t2, e2) {
        this.writeTag(t2, Vu.Fixed32), this.writeFixed32(e2);
      }, writeSFixed32Field: function(t2, e2) {
        this.writeTag(t2, Vu.Fixed32), this.writeSFixed32(e2);
      }, writeFixed64Field: function(t2, e2) {
        this.writeTag(t2, Vu.Fixed64), this.writeFixed64(e2);
      }, writeSFixed64Field: function(t2, e2) {
        this.writeTag(t2, Vu.Fixed64), this.writeSFixed64(e2);
      }, writeVarintField: function(t2, e2) {
        this.writeTag(t2, Vu.Varint), this.writeVarint(e2);
      }, writeSVarintField: function(t2, e2) {
        this.writeTag(t2, Vu.Varint), this.writeSVarint(e2);
      }, writeStringField: function(t2, e2) {
        this.writeTag(t2, Vu.Bytes), this.writeString(e2);
      }, writeFloatField: function(t2, e2) {
        this.writeTag(t2, Vu.Fixed32), this.writeFloat(e2);
      }, writeDoubleField: function(t2, e2) {
        this.writeTag(t2, Vu.Fixed64), this.writeDouble(e2);
      }, writeBooleanField: function(t2, e2) {
        this.writeVarintField(t2, Boolean(e2));
      } };
      class ic {
        constructor(t2, { pixelRatio: e2, version: r2, stretchX: n2, stretchY: i2, content: s2 }) {
          this.paddedRect = t2, this.pixelRatio = e2, this.stretchX = n2, this.stretchY = i2, this.content = s2, this.version = r2;
        }
        get tl() {
          return [this.paddedRect.x + 1, this.paddedRect.y + 1];
        }
        get br() {
          return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
        }
        get displaySize() {
          return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
        }
      }
      class sc {
        constructor(t2, e2) {
          const r2 = {}, n2 = {};
          this.haveRenderCallbacks = [];
          const i2 = [];
          this.addImages(t2, r2, i2), this.addImages(e2, n2, i2);
          const { w: s2, h: a2 } = nc(i2), o2 = new Zo({ width: s2 || 1, height: a2 || 1 });
          for (const e3 in t2) {
            const n3 = t2[e3], i3 = r2[e3].paddedRect;
            Zo.copy(n3.data, o2, { x: 0, y: 0 }, { x: i3.x + 1, y: i3.y + 1 }, n3.data);
          }
          for (const t3 in e2) {
            const r3 = e2[t3], i3 = n2[t3].paddedRect, s3 = i3.x + 1, a3 = i3.y + 1, l2 = r3.data.width, u2 = r3.data.height;
            Zo.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 }, r3.data), Zo.copy(r3.data, o2, { x: 0, y: u2 - 1 }, { x: s3, y: a3 - 1 }, { width: l2, height: 1 }), Zo.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 + u2 }, { width: l2, height: 1 }), Zo.copy(r3.data, o2, { x: l2 - 1, y: 0 }, { x: s3 - 1, y: a3 }, { width: 1, height: u2 }), Zo.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3 + l2, y: a3 }, { width: 1, height: u2 });
          }
          this.image = o2, this.iconPositions = r2, this.patternPositions = n2;
        }
        addImages(t2, e2, r2) {
          for (const n2 in t2) {
            const i2 = t2[n2], s2 = { x: 0, y: 0, w: i2.data.width + 2, h: i2.data.height + 2 };
            r2.push(s2), e2[n2] = new ic(s2, i2), i2.hasRenderCallback && this.haveRenderCallbacks.push(n2);
          }
        }
        patchUpdatedImages(t2, e2) {
          t2.dispatchRenderCallbacks(this.haveRenderCallbacks);
          for (const r2 in t2.updatedImages)
            this.patchUpdatedImage(this.iconPositions[r2], t2.getImage(r2), e2), this.patchUpdatedImage(this.patternPositions[r2], t2.getImage(r2), e2);
        }
        patchUpdatedImage(t2, e2, r2) {
          if (!t2 || !e2)
            return;
          if (t2.version === e2.version)
            return;
          t2.version = e2.version;
          const [n2, i2] = t2.tl;
          r2.update(e2.data, void 0, { x: n2, y: i2 });
        }
      }
      oi("ImagePosition", ic), oi("ImageAtlas", sc);
      const ac = { horizontal: 1, vertical: 2, horizontalOnly: 3 };
      class oc {
        constructor() {
          this.scale = 1, this.fontStack = "", this.imageName = null;
        }
        static forText(t2, e2) {
          const r2 = new oc();
          return r2.scale = t2 || 1, r2.fontStack = e2, r2;
        }
        static forImage(t2) {
          const e2 = new oc();
          return e2.imageName = t2, e2;
        }
      }
      class lc {
        constructor() {
          this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
        }
        static fromFeature(t2, e2) {
          const r2 = new lc();
          for (let n2 = 0; n2 < t2.sections.length; n2++) {
            const i2 = t2.sections[n2];
            i2.image ? r2.addImageSection(i2) : r2.addTextSection(i2, e2);
          }
          return r2;
        }
        length() {
          return this.text.length;
        }
        getSection(t2) {
          return this.sections[this.sectionIndex[t2]];
        }
        getSections() {
          return this.sections;
        }
        getSectionIndex(t2) {
          return this.sectionIndex[t2];
        }
        getCharCode(t2) {
          return this.text.charCodeAt(t2);
        }
        verticalizePunctuation(t2) {
          this.text = function(t3, e2) {
            let r2 = "";
            for (let n2 = 0; n2 < t3.length; n2++) {
              const i2 = t3.charCodeAt(n2 + 1) || null, s2 = t3.charCodeAt(n2 - 1) || null;
              r2 += !e2 && (i2 && Ni(i2) && !Mu[t3[n2 + 1]] || s2 && Ni(s2) && !Mu[t3[n2 - 1]]) || !Mu[t3[n2]] ? t3[n2] : Mu[t3[n2]];
            }
            return r2;
          }(this.text, t2);
        }
        trim() {
          let t2 = 0;
          for (let e3 = 0; e3 < this.text.length && cc[this.text.charCodeAt(e3)]; e3++)
            t2++;
          let e2 = this.text.length;
          for (let r2 = this.text.length - 1; r2 >= 0 && r2 >= t2 && cc[this.text.charCodeAt(r2)]; r2--)
            e2--;
          this.text = this.text.substring(t2, e2), this.sectionIndex = this.sectionIndex.slice(t2, e2);
        }
        substring(t2, e2) {
          const r2 = new lc();
          return r2.text = this.text.substring(t2, e2), r2.sectionIndex = this.sectionIndex.slice(t2, e2), r2.sections = this.sections, r2;
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce((t2, e2) => Math.max(t2, this.sections[e2].scale), 0);
        }
        addTextSection(t2, e2) {
          this.text += t2.text, this.sections.push(oc.forText(t2.scale, t2.fontStack || e2));
          const r2 = this.sections.length - 1;
          for (let e3 = 0; e3 < t2.text.length; ++e3)
            this.sectionIndex.push(r2);
        }
        addImageSection(t2) {
          const e2 = t2.image ? t2.image.name : "";
          if (0 === e2.length)
            return void C("Can't add FormattedSection with an empty image.");
          const r2 = this.getNextImageSectionCharCode();
          r2 ? (this.text += String.fromCharCode(r2), this.sections.push(oc.forImage(e2)), this.sectionIndex.push(this.sections.length - 1)) : C("Reached maximum number of images 6401");
        }
        getNextImageSectionCharCode() {
          return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
        }
      }
      function uc(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, y2) {
        const m2 = lc.fromFeature(t2, i2);
        let g2;
        h2 === ac.vertical && m2.verticalizePunctuation(p2);
        const { processBidirectionalText: x2, processStyledBidirectionalText: v2 } = ss;
        if (x2 && 1 === m2.sections.length) {
          g2 = [];
          const t3 = x2(m2.toString(), gc(m2, u2, s2, e2, n2, d2, f2));
          for (const e3 of t3) {
            const t4 = new lc();
            t4.text = e3, t4.sections = m2.sections;
            for (let r3 = 0; r3 < e3.length; r3++)
              t4.sectionIndex.push(0);
            g2.push(t4);
          }
        } else if (v2) {
          g2 = [];
          const t3 = v2(m2.text, m2.sectionIndex, gc(m2, u2, s2, e2, n2, d2, f2));
          for (const e3 of t3) {
            const t4 = new lc();
            t4.text = e3[0], t4.sectionIndex = e3[1], t4.sections = m2.sections, g2.push(t4);
          }
        } else
          g2 = function(t3, e3) {
            const r3 = [], n3 = t3.text;
            let i3 = 0;
            for (const n4 of e3)
              r3.push(t3.substring(i3, n4)), i3 = n4;
            return i3 < n3.length && r3.push(t3.substring(i3, n3.length)), r3;
          }(m2, gc(m2, u2, s2, e2, n2, d2, f2));
        const b2 = [], w2 = { positionedLines: b2, text: m2.toString(), top: c2[1], bottom: c2[1], left: c2[0], right: c2[0], writingMode: h2, iconsInText: false, verticalizable: false, hasBaseline: false };
        return function(t3, e3, r3, n3, i3, s3, a3, o3, l3, u3, c3, h3) {
          let p3 = 0, d3 = 0, f3 = 0;
          const y3 = "right" === o3 ? 1 : "left" === o3 ? 0 : 0.5;
          let m3 = false;
          for (const t4 of i3) {
            const r4 = t4.getSections();
            for (const t5 of r4) {
              if (t5.imageName)
                continue;
              const r5 = e3[t5.fontStack];
              if (r5 && (m3 = void 0 !== r5.ascender && void 0 !== r5.descender, !m3))
                break;
            }
            if (!m3)
              break;
          }
          let g3 = 0;
          for (const a4 of i3) {
            a4.trim();
            const i4 = a4.getMaxScale(), o4 = (i4 - 1) * _u, v4 = { positionedGlyphs: [], lineOffset: 0 };
            t3.positionedLines[g3] = v4;
            const b4 = v4.positionedGlyphs;
            let w4 = 0;
            if (!a4.length()) {
              d3 += s3, ++g3;
              continue;
            }
            let _2 = 0, A2 = 0;
            for (let s4 = 0; s4 < a4.length(); s4++) {
              const o5 = a4.getSection(s4), f4 = a4.getSectionIndex(s4), y4 = a4.getCharCode(s4);
              let g4 = o5.scale, v5 = null, k3 = null, S2 = null, I2 = _u, z2 = 0;
              const T2 = !(l3 === ac.horizontal || !c3 && !ji(y4) || c3 && (cc[y4] || (x3 = y4, di(x3) || fi(x3) || yi(x3) || Pi(x3) || Ri(x3))));
              if (o5.imageName) {
                const e4 = n3[o5.imageName];
                if (!e4)
                  continue;
                S2 = o5.imageName, t3.iconsInText = t3.iconsInText || true, k3 = e4.paddedRect;
                const r4 = e4.displaySize;
                g4 = g4 * _u / h3, v5 = { width: r4[0], height: r4[1], left: 1, top: -3, advance: T2 ? r4[1] : r4[0], localGlyph: false }, z2 = m3 ? -v5.height * g4 : i4 * _u - 17 - r4[1] * g4, I2 = v5.advance;
                const s5 = (T2 ? r4[0] : r4[1]) * g4 - _u * i4;
                s5 > 0 && s5 > w4 && (w4 = s5);
              } else {
                const t4 = r3[o5.fontStack];
                if (!t4)
                  continue;
                t4[y4] && (k3 = t4[y4]);
                const n4 = e3[o5.fontStack];
                if (!n4)
                  continue;
                const s5 = n4.glyphs[y4];
                if (!s5)
                  continue;
                if (v5 = s5.metrics, I2 = 8203 !== y4 ? _u : 0, m3) {
                  const t5 = void 0 !== n4.ascender ? Math.abs(n4.ascender) : 0, e4 = void 0 !== n4.descender ? Math.abs(n4.descender) : 0, r4 = (t5 + e4) * g4;
                  _2 < r4 && (_2 = r4, A2 = (t5 - e4) / 2 * g4), z2 = -t5 * g4;
                } else
                  z2 = (i4 - g4) * _u - 17;
              }
              T2 ? (t3.verticalizable = true, b4.push({ glyph: y4, imageName: S2, x: p3, y: d3 + z2, vertical: T2, scale: g4, localGlyph: v5.localGlyph, fontStack: o5.fontStack, sectionIndex: f4, metrics: v5, rect: k3 }), p3 += I2 * g4 + u3) : (b4.push({ glyph: y4, imageName: S2, x: p3, y: d3 + z2, vertical: T2, scale: g4, localGlyph: v5.localGlyph, fontStack: o5.fontStack, sectionIndex: f4, metrics: v5, rect: k3 }), p3 += v5.advance * g4 + u3);
            }
            0 !== b4.length && (f3 = Math.max(p3 - u3, f3), m3 ? vc(b4, y3, w4, A2, s3 * i4 / 2) : vc(b4, y3, w4, 0, s3 / 2)), p3 = 0;
            const k2 = s3 * i4 + w4;
            v4.lineOffset = Math.max(w4, o4), d3 += k2, ++g3;
          }
          var x3;
          const v3 = d3, { horizontalAlign: b3, verticalAlign: w3 } = xc(a3);
          (function(t4, e4, r4, n4, i4, s4) {
            const a4 = (e4 - r4) * i4, o4 = -s4 * n4;
            for (const e5 of t4)
              for (const t5 of e5.positionedGlyphs)
                t5.x += a4, t5.y += o4;
          })(t3.positionedLines, y3, b3, w3, f3, v3), t3.top += -w3 * v3, t3.bottom = t3.top + v3, t3.left += -b3 * f3, t3.right = t3.left + f3, t3.hasBaseline = m3;
        }(w2, e2, r2, n2, g2, a2, o2, l2, h2, u2, p2, y2), !function(t3) {
          for (const e3 of t3)
            if (0 !== e3.positionedGlyphs.length)
              return false;
          return true;
        }(b2) && w2;
      }
      const cc = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, hc = { 10: true, 32: true, 38: true, 40: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true };
      function pc(t2, e2, r2, n2, i2, s2) {
        if (e2.imageName) {
          const t3 = n2[e2.imageName];
          return t3 ? t3.displaySize[0] * e2.scale * _u / s2 + i2 : 0;
        }
        {
          const n3 = r2[e2.fontStack], s3 = n3 && n3.glyphs[t2];
          return s3 ? s3.metrics.advance * e2.scale + i2 : 0;
        }
      }
      function dc(t2, e2, r2, n2) {
        const i2 = Math.pow(t2 - e2, 2);
        return n2 ? t2 < e2 ? i2 / 2 : 2 * i2 : i2 + Math.abs(r2) * r2;
      }
      function fc(t2, e2, r2) {
        let n2 = 0;
        return 10 === t2 && (n2 -= 1e4), r2 && (n2 += 150), 40 !== t2 && 65288 !== t2 || (n2 += 50), 41 !== e2 && 65289 !== e2 || (n2 += 50), n2;
      }
      function yc(t2, e2, r2, n2, i2, s2) {
        let a2 = null, o2 = dc(e2, r2, i2, s2);
        for (const t3 of n2) {
          const n3 = dc(e2 - t3.x, r2, i2, s2) + t3.badness;
          n3 <= o2 && (a2 = t3, o2 = n3);
        }
        return { index: t2, x: e2, priorBreak: a2, badness: o2 };
      }
      function mc(t2) {
        return t2 ? mc(t2.priorBreak).concat(t2.index) : [];
      }
      function gc(t2, e2, r2, n2, i2, s2, a2) {
        if ("point" !== s2)
          return [];
        if (!t2)
          return [];
        const o2 = [], l2 = function(t3, e3, r3, n3, i3, s3) {
          let a3 = 0;
          for (let r4 = 0; r4 < t3.length(); r4++) {
            const o3 = t3.getSection(r4);
            a3 += pc(t3.getCharCode(r4), o3, n3, i3, e3, s3);
          }
          return a3 / Math.max(1, Math.ceil(a3 / r3));
        }(t2, e2, r2, n2, i2, a2), u2 = t2.text.indexOf("") >= 0;
        let c2 = 0;
        for (let r3 = 0; r3 < t2.length(); r3++) {
          const s3 = t2.getSection(r3), p2 = t2.getCharCode(r3);
          if (cc[p2] || (c2 += pc(p2, s3, n2, i2, e2, a2)), r3 < t2.length() - 1) {
            const e3 = !((h2 = p2) < 11904 || !(Ai(h2) || _i(h2) || Li(h2) || Di(h2) || zi(h2) || mi(h2) || ki(h2) || vi(h2) || Ti(h2) || Mi(h2) || Ii(h2) || $i(h2) || bi(h2) || xi(h2) || gi(h2) || Si(h2) || wi(h2) || Vi(h2) || Ci(h2) || Ei(h2)));
            (hc[p2] || e3 || s3.imageName) && o2.push(yc(r3 + 1, c2, l2, o2, fc(p2, t2.getCharCode(r3 + 1), e3 && u2), false));
          }
        }
        var h2;
        return mc(yc(t2.length(), c2, l2, o2, 0, true));
      }
      function xc(t2) {
        let e2 = 0.5, r2 = 0.5;
        switch (t2) {
          case "right":
          case "top-right":
          case "bottom-right":
            e2 = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            e2 = 0;
        }
        switch (t2) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            r2 = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            r2 = 0;
        }
        return { horizontalAlign: e2, verticalAlign: r2 };
      }
      function vc(t2, e2, r2, n2, i2) {
        if (!(e2 || r2 || n2 || i2))
          return;
        const s2 = t2.length - 1, a2 = t2[s2], o2 = (a2.x + a2.metrics.advance * a2.scale) * e2;
        for (let e3 = 0; e3 <= s2; e3++)
          t2[e3].x -= o2, t2[e3].y += r2 + n2 + i2;
      }
      function bc(t2, e2, r2) {
        const { horizontalAlign: n2, verticalAlign: i2 } = xc(r2), s2 = e2[0] - t2.displaySize[0] * n2, a2 = e2[1] - t2.displaySize[1] * i2;
        return { image: t2, top: a2, bottom: a2 + t2.displaySize[1], left: s2, right: s2 + t2.displaySize[0] };
      }
      function wc(t2, e2, r2, n2, i2, s2) {
        const a2 = t2.image;
        let o2;
        if (a2.content) {
          const t3 = a2.content, e3 = a2.pixelRatio || 1;
          o2 = [t3[0] / e3, t3[1] / e3, a2.displaySize[0] - t3[2] / e3, a2.displaySize[1] - t3[3] / e3];
        }
        const l2 = e2.left * s2, u2 = e2.right * s2;
        let c2, h2, p2, d2;
        "width" === r2 || "both" === r2 ? (d2 = i2[0] + l2 - n2[3], h2 = i2[0] + u2 + n2[1]) : (d2 = i2[0] + (l2 + u2 - a2.displaySize[0]) / 2, h2 = d2 + a2.displaySize[0]);
        const f2 = e2.top * s2, y2 = e2.bottom * s2;
        return "height" === r2 || "both" === r2 ? (c2 = i2[1] + f2 - n2[0], p2 = i2[1] + y2 + n2[2]) : (c2 = i2[1] + (f2 + y2 - a2.displaySize[1]) / 2, p2 = c2 + a2.displaySize[1]), { image: a2, top: c2, right: h2, bottom: p2, left: d2, collisionPadding: o2 };
      }
      class _c extends i {
        constructor(t2, e2, r2, n2, i2) {
          super(t2, e2), this.angle = n2, this.z = r2, void 0 !== i2 && (this.segment = i2);
        }
        clone() {
          return new _c(this.x, this.y, this.z, this.angle, this.segment);
        }
      }
      function Ac(t2, e2, r2, n2, i2) {
        if (void 0 === e2.segment)
          return true;
        let s2 = e2, a2 = e2.segment + 1, o2 = 0;
        for (; o2 > -r2 / 2; ) {
          if (a2--, a2 < 0)
            return false;
          o2 -= t2[a2].dist(s2), s2 = t2[a2];
        }
        o2 += t2[a2].dist(t2[a2 + 1]), a2++;
        const l2 = [];
        let u2 = 0;
        for (; o2 < r2 / 2; ) {
          const e3 = t2[a2], r3 = t2[a2 + 1];
          if (!r3)
            return false;
          let s3 = t2[a2 - 1].angleTo(e3) - e3.angleTo(r3);
          for (s3 = Math.abs((s3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l2.push({ distance: o2, angleDelta: s3 }), u2 += s3; o2 - l2[0].distance > n2; )
            u2 -= l2.shift().angleDelta;
          if (u2 > i2)
            return false;
          a2++, o2 += e3.dist(r3);
        }
        return true;
      }
      function kc(t2) {
        let e2 = 0;
        for (let r2 = 0; r2 < t2.length - 1; r2++)
          e2 += t2[r2].dist(t2[r2 + 1]);
        return e2;
      }
      function Sc(t2, e2, r2) {
        return t2 ? 0.6 * e2 * r2 : 0;
      }
      function Ic(t2, e2) {
        return Math.max(t2 ? t2.right - t2.left : 0, e2 ? e2.right - e2.left : 0);
      }
      function zc(t2, e2, r2, n2, i2, s2) {
        const a2 = Sc(r2, i2, s2), o2 = Ic(r2, n2) * s2;
        let l2 = 0;
        const u2 = kc(t2) / 2;
        for (let r3 = 0; r3 < t2.length - 1; r3++) {
          const n3 = t2[r3], i3 = t2[r3 + 1], s3 = n3.dist(i3);
          if (l2 + s3 > u2) {
            const c2 = (u2 - l2) / s3, h2 = rr(n3.x, i3.x, c2), p2 = rr(n3.y, i3.y, c2), d2 = new _c(h2, p2, 0, i3.angleTo(n3), r3);
            return !a2 || Ac(t2, d2, o2, a2, e2) ? d2 : void 0;
          }
          l2 += s3;
        }
      }
      function Tc(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
        const u2 = Sc(n2, s2, a2), c2 = Ic(n2, i2), h2 = c2 * a2, p2 = 0 === t2[0].x || t2[0].x === l2 || 0 === t2[0].y || t2[0].y === l2;
        return e2 - h2 < e2 / 4 && (e2 = h2 + e2 / 4), Mc(t2, p2 ? e2 / 2 * o2 % e2 : (c2 / 2 + 2 * s2) * a2 * o2 % e2, e2, u2, r2, h2, p2, false, l2);
      }
      function Mc(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
        const u2 = s2 / 2, c2 = kc(t2);
        let h2 = 0, p2 = e2 - r2, d2 = [];
        for (let e3 = 0; e3 < t2.length - 1; e3++) {
          const a3 = t2[e3], o3 = t2[e3 + 1], f2 = a3.dist(o3), y2 = o3.angleTo(a3);
          for (; p2 + r2 < h2 + f2; ) {
            p2 += r2;
            const m2 = (p2 - h2) / f2, g2 = rr(a3.x, o3.x, m2), x2 = rr(a3.y, o3.y, m2);
            if (g2 >= 0 && g2 < l2 && x2 >= 0 && x2 < l2 && p2 - u2 >= 0 && p2 + u2 <= c2) {
              const r3 = new _c(g2, x2, 0, y2, e3);
              r3._round(), n2 && !Ac(t2, r3, s2, n2, i2) || d2.push(r3);
            }
          }
          h2 += f2;
        }
        return o2 || d2.length || a2 || (d2 = Mc(t2, h2 / 2, r2, n2, i2, s2, a2, true, l2)), d2;
      }
      function Ec(t2, e2, r2, n2, s2) {
        const a2 = [];
        for (let o2 = 0; o2 < t2.length; o2++) {
          const l2 = t2[o2];
          let u2;
          for (let t3 = 0; t3 < l2.length - 1; t3++) {
            let o3 = l2[t3], c2 = l2[t3 + 1];
            o3.x < e2 && c2.x < e2 || (o3.x < e2 ? o3 = new i(e2, o3.y + (e2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round() : c2.x < e2 && (c2 = new i(e2, o3.y + (e2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round()), o3.y < r2 && c2.y < r2 || (o3.y < r2 ? o3 = new i(o3.x + (r2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), r2)._round() : c2.y < r2 && (c2 = new i(o3.x + (r2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), r2)._round()), o3.x >= n2 && c2.x >= n2 || (o3.x >= n2 ? o3 = new i(n2, o3.y + (n2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round() : c2.x >= n2 && (c2 = new i(n2, o3.y + (n2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round()), o3.y >= s2 && c2.y >= s2 || (o3.y >= s2 ? o3 = new i(o3.x + (s2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), s2)._round() : c2.y >= s2 && (c2 = new i(o3.x + (s2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), s2)._round()), u2 && o3.equals(u2[u2.length - 1]) || (u2 = [o3], a2.push(u2)), u2.push(c2)))));
          }
        }
        return a2;
      }
      oi("Anchor", _c);
      const Cc = 1e20;
      function Bc(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
        for (let u2 = e2; u2 < e2 + n2; u2++)
          Dc(t2, r2 * s2 + u2, s2, i2, a2, o2, l2);
        for (let u2 = r2; u2 < r2 + i2; u2++)
          Dc(t2, u2 * s2 + e2, 1, n2, a2, o2, l2);
      }
      function Dc(t2, e2, r2, n2, i2, s2, a2) {
        s2[0] = 0, a2[0] = -Cc, a2[1] = Cc, i2[0] = t2[e2];
        for (let o2 = 1, l2 = 0, u2 = 0; o2 < n2; o2++) {
          i2[o2] = t2[e2 + o2 * r2];
          const n3 = o2 * o2;
          do {
            const t3 = s2[l2];
            u2 = (i2[o2] - i2[t3] + n3 - t3 * t3) / (o2 - t3) / 2;
          } while (u2 <= a2[l2] && --l2 > -1);
          l2++, s2[l2] = o2, a2[l2] = u2, a2[l2 + 1] = Cc;
        }
        for (let o2 = 0, l2 = 0; o2 < n2; o2++) {
          for (; a2[l2 + 1] < o2; )
            l2++;
          const n3 = s2[l2], u2 = o2 - n3;
          t2[e2 + o2 * r2] = i2[n3] + u2 * u2;
        }
      }
      const Pc = { none: 0, ideographs: 1, all: 2 };
      class Vc {
        constructor(t2, e2, r2) {
          this.requestManager = t2, this.localGlyphMode = e2, this.localFontFamily = r2, this.entries = {}, this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} };
        }
        setURL(t2) {
          this.url = t2;
        }
        getGlyphs(t2, e2) {
          const r2 = [];
          for (const e3 in t2)
            for (const n2 of t2[e3])
              r2.push({ stack: e3, id: n2 });
          g(r2, ({ stack: t3, id: e3 }, r3) => {
            let n2 = this.entries[t3];
            n2 || (n2 = this.entries[t3] = { glyphs: {}, requests: {}, ranges: {}, ascender: void 0, descender: void 0 });
            let i2 = n2.glyphs[e3];
            if (void 0 !== i2)
              return void r3(null, { stack: t3, id: e3, glyph: i2 });
            if (i2 = this._tinySDF(n2, t3, e3), i2)
              return n2.glyphs[e3] = i2, void r3(null, { stack: t3, id: e3, glyph: i2 });
            const s2 = Math.floor(e3 / 256);
            if (256 * s2 > 65535)
              return void r3(new Error("glyphs > 65535 not supported"));
            if (n2.ranges[s2])
              return void r3(null, { stack: t3, id: e3, glyph: i2 });
            let a2 = n2.requests[s2];
            a2 || (a2 = n2.requests[s2] = [], Vc.loadGlyphRange(t3, s2, this.url, this.requestManager, (t4, e4) => {
              if (e4) {
                n2.ascender = e4.ascender, n2.descender = e4.descender;
                for (const t5 in e4.glyphs)
                  this._doesCharSupportLocalGlyph(+t5) || (n2.glyphs[+t5] = e4.glyphs[+t5]);
                n2.ranges[s2] = true;
              }
              for (const r4 of a2)
                r4(t4, e4);
              delete n2.requests[s2];
            })), a2.push((n3, i3) => {
              n3 ? r3(n3) : i3 && r3(null, { stack: t3, id: e3, glyph: i3.glyphs[e3] || null });
            });
          }, (t3, r3) => {
            if (t3)
              e2(t3);
            else if (r3) {
              const t4 = {};
              for (const { stack: e3, id: n2, glyph: i2 } of r3)
                void 0 === t4[e3] && (t4[e3] = {}), void 0 === t4[e3].glyphs && (t4[e3].glyphs = {}), t4[e3].glyphs[n2] = i2 && { id: i2.id, bitmap: i2.bitmap.clone(), metrics: i2.metrics }, t4[e3].ascender = this.entries[e3].ascender, t4[e3].descender = this.entries[e3].descender;
              e2(null, t4);
            }
          });
        }
        _doesCharSupportLocalGlyph(t2) {
          return this.localGlyphMode !== Pc.none && (this.localGlyphMode === Pc.all ? !!this.localFontFamily : !!this.localFontFamily && (Mi(t2) || Bi(t2) || bi(t2) || wi(t2)) || vi(t2));
        }
        _tinySDF(t2, e2, r2) {
          const n2 = this.localFontFamily;
          if (!n2 || !this._doesCharSupportLocalGlyph(r2))
            return;
          let i2 = t2.tinySDF;
          if (!i2) {
            let r3 = "400";
            /bold/i.test(e2) ? r3 = "900" : /medium/i.test(e2) ? r3 = "500" : /light/i.test(e2) && (r3 = "200"), i2 = t2.tinySDF = new Vc.TinySDF({ fontFamily: n2, fontWeight: r3, fontSize: 48, buffer: 6, radius: 16 }), i2.fontWeight = r3;
          }
          if (this.localGlyphs[i2.fontWeight][r2])
            return this.localGlyphs[i2.fontWeight][r2];
          const s2 = String.fromCharCode(r2), { data: a2, width: o2, height: l2, glyphWidth: u2, glyphHeight: c2, glyphLeft: h2, glyphTop: p2, glyphAdvance: d2 } = i2.draw(s2);
          return this.localGlyphs[i2.fontWeight][r2] = { id: r2, bitmap: new No({ width: o2, height: l2 }, a2), metrics: { width: u2 / 2, height: c2 / 2, left: h2 / 2, top: p2 / 2 - 27, advance: d2 / 2, localGlyph: true } };
        }
      }
      function Lc(t2, e2, r2, n2) {
        const s2 = [], a2 = t2.image, o2 = a2.pixelRatio, l2 = a2.paddedRect.w - 2, u2 = a2.paddedRect.h - 2, c2 = t2.right - t2.left, h2 = t2.bottom - t2.top, p2 = a2.stretchX || [[0, l2]], d2 = a2.stretchY || [[0, u2]], f2 = (t3, e3) => t3 + e3[1] - e3[0], y2 = p2.reduce(f2, 0), m2 = d2.reduce(f2, 0), g2 = l2 - y2, x2 = u2 - m2;
        let v2 = 0, b2 = y2, w2 = 0, _2 = m2, A2 = 0, k2 = g2, S2 = 0, I2 = x2;
        if (a2.content && n2) {
          const t3 = a2.content;
          v2 = Fc(p2, 0, t3[0]), w2 = Fc(d2, 0, t3[1]), b2 = Fc(p2, t3[0], t3[2]), _2 = Fc(d2, t3[1], t3[3]), A2 = t3[0] - v2, S2 = t3[1] - w2, k2 = t3[2] - t3[0] - b2, I2 = t3[3] - t3[1] - _2;
        }
        const z2 = (n3, s3, l3, u3) => {
          const p3 = $c(n3.stretch - v2, b2, c2, t2.left), d3 = Uc(n3.fixed - A2, k2, n3.stretch, y2), f3 = $c(s3.stretch - w2, _2, h2, t2.top), g3 = Uc(s3.fixed - S2, I2, s3.stretch, m2), x3 = $c(l3.stretch - v2, b2, c2, t2.left), z3 = Uc(l3.fixed - A2, k2, l3.stretch, y2), T2 = $c(u3.stretch - w2, _2, h2, t2.top), M2 = Uc(u3.fixed - S2, I2, u3.stretch, m2), E2 = new i(p3, f3), C2 = new i(x3, f3), B2 = new i(x3, T2), D2 = new i(p3, T2), P2 = new i(d3 / o2, g3 / o2), V2 = new i(z3 / o2, M2 / o2), L2 = e2 * Math.PI / 180;
          if (L2) {
            const t3 = Math.sin(L2), e3 = Math.cos(L2), r3 = [e3, -t3, t3, e3];
            E2._matMult(r3), C2._matMult(r3), D2._matMult(r3), B2._matMult(r3);
          }
          const F2 = n3.stretch + n3.fixed, R2 = s3.stretch + s3.fixed;
          return { tl: E2, tr: C2, bl: D2, br: B2, tex: { x: a2.paddedRect.x + 1 + F2, y: a2.paddedRect.y + 1 + R2, w: l3.stretch + l3.fixed - F2, h: u3.stretch + u3.fixed - R2 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: P2, pixelOffsetBR: V2, minFontScaleX: k2 / o2 / c2, minFontScaleY: I2 / o2 / h2, isSDF: r2 };
        };
        if (n2 && (a2.stretchX || a2.stretchY)) {
          const t3 = Rc(p2, g2, y2), e3 = Rc(d2, x2, m2);
          for (let r3 = 0; r3 < t3.length - 1; r3++) {
            const n3 = t3[r3], i2 = t3[r3 + 1];
            for (let t4 = 0; t4 < e3.length - 1; t4++)
              s2.push(z2(n3, e3[t4], i2, e3[t4 + 1]));
          }
        } else
          s2.push(z2({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: l2 + 1 }, { fixed: 0, stretch: u2 + 1 }));
        return s2;
      }
      function Fc(t2, e2, r2) {
        let n2 = 0;
        for (const i2 of t2)
          n2 += Math.max(e2, Math.min(r2, i2[1])) - Math.max(e2, Math.min(r2, i2[0]));
        return n2;
      }
      function Rc(t2, e2, r2) {
        const n2 = [{ fixed: -1, stretch: 0 }];
        for (const [e3, r3] of t2) {
          const t3 = n2[n2.length - 1];
          n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch }), n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch + (r3 - e3) });
        }
        return n2.push({ fixed: e2 + 1, stretch: r2 }), n2;
      }
      function $c(t2, e2, r2, n2) {
        return t2 / e2 * r2 + n2;
      }
      function Uc(t2, e2, r2, n2) {
        return t2 - e2 * r2 / n2;
      }
      function Oc(t2, e2, r2, n2) {
        const i2 = e2 + t2.positionedLines[n2].lineOffset;
        return 0 === n2 ? r2 + i2 / 2 : r2 + (i2 + (e2 + t2.positionedLines[n2 - 1].lineOffset)) / 2;
      }
      Vc.loadGlyphRange = function(t2, e2, r2, n2, i2) {
        const s2 = 256 * e2, a2 = s2 + 255, o2 = n2.transformRequest(n2.normalizeGlyphsURL(r2).replace("{fontstack}", t2).replace("{range}", `${s2}-${a2}`), wt.Glyphs);
        St(o2, (t3, e3) => {
          if (t3)
            i2(t3);
          else if (e3) {
            const t4 = {}, r3 = function(t5) {
              return new Pu(t5).readFields(tc, {});
            }(e3);
            for (const e4 of r3.glyphs)
              t4[e4.id] = e4;
            i2(null, { glyphs: t4, ascender: r3.ascender, descender: r3.descender });
          }
        });
      }, Vc.TinySDF = class {
        constructor({ fontSize: t2 = 24, buffer: e2 = 3, radius: r2 = 8, cutoff: n2 = 0.25, fontFamily: i2 = "sans-serif", fontWeight: s2 = "normal", fontStyle: a2 = "normal" }) {
          this.buffer = e2, this.cutoff = n2, this.radius = r2;
          const o2 = this.size = t2 + 4 * e2, l2 = this._createCanvas(o2), u2 = this.ctx = l2.getContext("2d", { willReadFrequently: true });
          u2.font = `${a2} ${s2} ${t2}px ${i2}`, u2.textBaseline = "alphabetic", u2.textAlign = "left", u2.fillStyle = "black", this.gridOuter = new Float64Array(o2 * o2), this.gridInner = new Float64Array(o2 * o2), this.f = new Float64Array(o2), this.z = new Float64Array(o2 + 1), this.v = new Uint16Array(o2);
        }
        _createCanvas(t2) {
          const e2 = document.createElement("canvas");
          return e2.width = e2.height = t2, e2;
        }
        draw(t2) {
          const { width: e2, actualBoundingBoxAscent: r2, actualBoundingBoxDescent: n2, actualBoundingBoxLeft: i2, actualBoundingBoxRight: s2 } = this.ctx.measureText(t2), a2 = Math.floor(r2), o2 = Math.min(this.size - this.buffer, Math.ceil(s2 - i2)), l2 = Math.min(this.size - this.buffer, Math.ceil(r2) + Math.ceil(n2)), u2 = o2 + 2 * this.buffer, c2 = l2 + 2 * this.buffer, h2 = u2 * c2, p2 = new Uint8ClampedArray(h2), d2 = { data: p2, width: u2, height: c2, glyphWidth: o2, glyphHeight: l2, glyphTop: a2, glyphLeft: 0, glyphAdvance: e2 };
          if (0 === o2 || 0 === l2)
            return d2;
          const { ctx: f2, buffer: y2, gridInner: m2, gridOuter: g2 } = this;
          f2.clearRect(y2, y2, o2, l2), f2.fillText(t2, y2, y2 + a2 + 1);
          const x2 = f2.getImageData(y2, y2, o2, l2);
          g2.fill(Cc, 0, h2), m2.fill(0, 0, h2);
          for (let t3 = 0; t3 < l2; t3++)
            for (let e3 = 0; e3 < o2; e3++) {
              const r3 = x2.data[4 * (t3 * o2 + e3) + 3] / 255;
              if (0 === r3)
                continue;
              const n3 = (t3 + y2) * u2 + e3 + y2;
              if (1 === r3)
                g2[n3] = 0, m2[n3] = Cc;
              else {
                const t4 = 0.5 - r3;
                g2[n3] = t4 > 0 ? t4 * t4 : 0, m2[n3] = t4 < 0 ? t4 * t4 : 0;
              }
            }
          Bc(g2, 0, 0, u2, c2, u2, this.f, this.v, this.z), Bc(m2, y2, y2, o2, l2, u2, this.f, this.v, this.z);
          for (let t3 = 0; t3 < h2; t3++) {
            const e3 = Math.sqrt(g2[t3]) - Math.sqrt(m2[t3]);
            p2[t3] = Math.round(255 - 255 * (e3 / this.radius + this.cutoff));
          }
          return d2;
        }
      };
      class qc {
        constructor(t2 = [], e2 = jc) {
          if (this.data = t2, this.length = this.data.length, this.compare = e2, this.length > 0)
            for (let t3 = (this.length >> 1) - 1; t3 >= 0; t3--)
              this._down(t3);
        }
        push(t2) {
          this.data.push(t2), this.length++, this._up(this.length - 1);
        }
        pop() {
          if (0 === this.length)
            return;
          const t2 = this.data[0], e2 = this.data.pop();
          return this.length--, this.length > 0 && (this.data[0] = e2, this._down(0)), t2;
        }
        peek() {
          return this.data[0];
        }
        _up(t2) {
          const { data: e2, compare: r2 } = this, n2 = e2[t2];
          for (; t2 > 0; ) {
            const i2 = t2 - 1 >> 1, s2 = e2[i2];
            if (r2(n2, s2) >= 0)
              break;
            e2[t2] = s2, t2 = i2;
          }
          e2[t2] = n2;
        }
        _down(t2) {
          const { data: e2, compare: r2 } = this, n2 = this.length >> 1, i2 = e2[t2];
          for (; t2 < n2; ) {
            let n3 = 1 + (t2 << 1), s2 = e2[n3];
            const a2 = n3 + 1;
            if (a2 < this.length && r2(e2[a2], s2) < 0 && (n3 = a2, s2 = e2[a2]), r2(s2, i2) >= 0)
              break;
            e2[t2] = s2, t2 = n3;
          }
          e2[t2] = i2;
        }
      }
      function jc(t2, e2) {
        return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
      }
      function Nc(t2, e2 = 1, r2 = false) {
        let n2 = 1 / 0, s2 = 1 / 0, a2 = -1 / 0, o2 = -1 / 0;
        const l2 = t2[0];
        for (let t3 = 0; t3 < l2.length; t3++) {
          const e3 = l2[t3];
          (!t3 || e3.x < n2) && (n2 = e3.x), (!t3 || e3.y < s2) && (s2 = e3.y), (!t3 || e3.x > a2) && (a2 = e3.x), (!t3 || e3.y > o2) && (o2 = e3.y);
        }
        const u2 = Math.min(a2 - n2, o2 - s2);
        let c2 = u2 / 2;
        const h2 = new qc([], Zc);
        if (0 === u2)
          return new i(n2, s2);
        for (let e3 = n2; e3 < a2; e3 += u2)
          for (let r3 = s2; r3 < o2; r3 += u2)
            h2.push(new Gc(e3 + c2, r3 + c2, c2, t2));
        let p2 = function(t3) {
          let e3 = 0, r3 = 0, n3 = 0;
          const i2 = t3[0];
          for (let t4 = 0, s3 = i2.length, a3 = s3 - 1; t4 < s3; a3 = t4++) {
            const s4 = i2[t4], o3 = i2[a3], l3 = s4.x * o3.y - o3.x * s4.y;
            r3 += (s4.x + o3.x) * l3, n3 += (s4.y + o3.y) * l3, e3 += 3 * l3;
          }
          return new Gc(r3 / e3, n3 / e3, 0, t3);
        }(t2), d2 = h2.length;
        for (; h2.length; ) {
          const n3 = h2.pop();
          (n3.d > p2.d || !p2.d) && (p2 = n3, r2 && console.log("found best %d after %d probes", Math.round(1e4 * n3.d) / 1e4, d2)), n3.max - p2.d <= e2 || (c2 = n3.h / 2, h2.push(new Gc(n3.p.x - c2, n3.p.y - c2, c2, t2)), h2.push(new Gc(n3.p.x + c2, n3.p.y - c2, c2, t2)), h2.push(new Gc(n3.p.x - c2, n3.p.y + c2, c2, t2)), h2.push(new Gc(n3.p.x + c2, n3.p.y + c2, c2, t2)), d2 += 4);
        }
        return r2 && (console.log(`num probes: ${d2}`), console.log(`best distance: ${p2.d}`)), p2.p;
      }
      function Zc(t2, e2) {
        return e2.max - t2.max;
      }
      function Gc(t2, e2, r2, n2) {
        this.p = new i(t2, e2), this.h = r2, this.d = function(t3, e3) {
          let r3 = false, n3 = 1 / 0;
          for (let i2 = 0; i2 < e3.length; i2++) {
            const s2 = e3[i2];
            for (let e4 = 0, i3 = s2.length, a2 = i3 - 1; e4 < i3; a2 = e4++) {
              const i4 = s2[e4], o2 = s2[a2];
              i4.y > t3.y != o2.y > t3.y && t3.x < (o2.x - i4.x) * (t3.y - i4.y) / (o2.y - i4.y) + i4.x && (r3 = !r3), n3 = Math.min(n3, ro(t3, i4, o2));
            }
          }
          return (r3 ? 1 : -1) * Math.sqrt(n3);
        }(this.p, n2), this.max = this.d + this.h * Math.SQRT2;
      }
      const Xc = Number.POSITIVE_INFINITY, Kc = Math.sqrt(2);
      function Yc(t2, e2) {
        return e2[1] !== Xc ? function(t3, e3, r2) {
          let n2 = 0, i2 = 0;
          switch (e3 = Math.abs(e3), r2 = Math.abs(r2), t3) {
            case "top-right":
            case "top-left":
            case "top":
              i2 = r2 - 7;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              i2 = 7 - r2;
          }
          switch (t3) {
            case "top-right":
            case "bottom-right":
            case "right":
              n2 = -e3;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              n2 = e3;
          }
          return [n2, i2];
        }(t2, e2[0], e2[1]) : function(t3, e3) {
          let r2 = 0, n2 = 0;
          e3 < 0 && (e3 = 0);
          const i2 = e3 / Kc;
          switch (t3) {
            case "top-right":
            case "top-left":
              n2 = i2 - 7;
              break;
            case "bottom-right":
            case "bottom-left":
              n2 = 7 - i2;
              break;
            case "bottom":
              n2 = 7 - e3;
              break;
            case "top":
              n2 = e3 - 7;
          }
          switch (t3) {
            case "top-right":
            case "bottom-right":
              r2 = -i2;
              break;
            case "top-left":
            case "bottom-left":
              r2 = i2;
              break;
            case "left":
              r2 = e3;
              break;
            case "right":
              r2 = -e3;
          }
          return [r2, n2];
        }(t2, e2[0]);
      }
      function Hc(t2, e2, r2, n2, i2, s2, a2, o2) {
        t2.createArrays(), t2.tilePixelRatio = qa / (512 * t2.overscaling), t2.compareText = {}, t2.iconsNeedLinear = false;
        const l2 = t2.layers[0].layout, u2 = t2.layers[0]._unevaluatedLayout._values, c2 = {};
        if ("composite" === t2.textSizeData.kind) {
          const { minZoom: e3, maxZoom: r3 } = t2.textSizeData;
          c2.compositeTextSizes = [u2["text-size"].possiblyEvaluate(new as(e3), a2), u2["text-size"].possiblyEvaluate(new as(r3), a2)];
        }
        if ("composite" === t2.iconSizeData.kind) {
          const { minZoom: e3, maxZoom: r3 } = t2.iconSizeData;
          c2.compositeIconSizes = [u2["icon-size"].possiblyEvaluate(new as(e3), a2), u2["icon-size"].possiblyEvaluate(new as(r3), a2)];
        }
        c2.layoutTextSize = u2["text-size"].possiblyEvaluate(new as(o2 + 1), a2), c2.layoutIconSize = u2["icon-size"].possiblyEvaluate(new as(o2 + 1), a2), c2.textMaxSize = u2["text-size"].possiblyEvaluate(new as(18), a2);
        const h2 = "map" === l2.get("text-rotation-alignment") && "point" !== l2.get("symbol-placement"), p2 = l2.get("text-size");
        for (const s3 of t2.features) {
          const o3 = l2.get("text-font").evaluate(s3, {}, a2).join(","), u3 = p2.evaluate(s3, {}, a2), d2 = c2.layoutTextSize.evaluate(s3, {}, a2), f2 = (c2.layoutIconSize.evaluate(s3, {}, a2), { horizontal: {}, vertical: void 0 }), y2 = s3.text;
          let m2, g2 = [0, 0];
          if (y2) {
            const n3 = y2.toString(), c3 = l2.get("text-letter-spacing").evaluate(s3, {}, a2) * _u, p3 = l2.get("text-line-height").evaluate(s3, {}, a2) * _u, m3 = Oi(n3) ? c3 : 0, x3 = l2.get("text-anchor").evaluate(s3, {}, a2), v3 = l2.get("text-variable-anchor");
            if (!v3) {
              const t3 = l2.get("text-radial-offset").evaluate(s3, {}, a2);
              g2 = t3 ? Yc(x3, [t3 * _u, Xc]) : l2.get("text-offset").evaluate(s3, {}, a2).map((t4) => t4 * _u);
            }
            let b2 = h2 ? "center" : l2.get("text-justify").evaluate(s3, {}, a2);
            const w2 = l2.get("symbol-placement"), _2 = "point" === w2, A2 = "point" === w2 ? l2.get("text-max-width").evaluate(s3, {}, a2) * _u : 0, k2 = (s4) => {
              t2.allowVerticalPlacement && Ui(n3) && (f2.vertical = uc(y2, e2, r2, i2, o3, A2, p3, x3, s4, m3, g2, ac.vertical, true, w2, d2, u3));
            };
            if (!h2 && v3) {
              const t3 = "auto" === b2 ? v3.map((t4) => Jc(t4)) : [b2];
              let n4 = false;
              for (let s4 = 0; s4 < t3.length; s4++) {
                const a3 = t3[s4];
                if (!f2.horizontal[a3])
                  if (n4)
                    f2.horizontal[a3] = f2.horizontal[0];
                  else {
                    const t4 = uc(y2, e2, r2, i2, o3, A2, p3, "center", a3, m3, g2, ac.horizontal, false, w2, d2, u3);
                    t4 && (f2.horizontal[a3] = t4, n4 = 1 === t4.positionedLines.length);
                  }
              }
              k2("left");
            } else {
              if ("auto" === b2 && (b2 = Jc(x3)), _2 || l2.get("text-writing-mode").indexOf("horizontal") >= 0 || !Ui(n3)) {
                const t3 = uc(y2, e2, r2, i2, o3, A2, p3, x3, b2, m3, g2, ac.horizontal, false, w2, d2, u3);
                t3 && (f2.horizontal[b2] = t3);
              }
              k2("point" === w2 ? "left" : b2);
            }
          }
          let x2 = false;
          if (s3.icon && s3.icon.name) {
            const e3 = n2[s3.icon.name];
            e3 && (m2 = bc(i2[s3.icon.name], l2.get("icon-offset").evaluate(s3, {}, a2), l2.get("icon-anchor").evaluate(s3, {}, a2)), x2 = e3.sdf, void 0 === t2.sdfIcons ? t2.sdfIcons = e3.sdf : t2.sdfIcons !== e3.sdf && C("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (e3.pixelRatio !== t2.pixelRatio || 0 !== l2.get("icon-rotate").constantOr(1)) && (t2.iconsNeedLinear = true));
          }
          const v2 = eh(f2.horizontal) || f2.vertical;
          t2.iconsInText || (t2.iconsInText = !!v2 && v2.iconsInText), (v2 || m2) && Wc(t2, s3, f2, m2, n2, c2, d2, 0, g2, x2, a2);
        }
        s2 && t2.generateCollisionDebugBuffers(o2, t2.collisionBoxArray);
      }
      function Jc(t2) {
        switch (t2) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function Wc(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, h2) {
        let p2 = s2.textMaxSize.evaluate(e2, {}, h2);
        void 0 === p2 && (p2 = a2);
        const d2 = t2.layers[0].layout, f2 = d2.get("icon-offset").evaluate(e2, {}, h2), y2 = eh(r2.horizontal) || r2.vertical, m2 = a2 / 24, g2 = t2.tilePixelRatio * p2 / 24, x2 = t2.tilePixelRatio * d2.get("symbol-spacing"), v2 = d2.get("text-padding") * t2.tilePixelRatio, b2 = d2.get("icon-padding") * t2.tilePixelRatio, w2 = c(d2.get("text-max-angle")), _2 = "map" === d2.get("text-rotation-alignment") && "point" !== d2.get("symbol-placement"), A2 = "map" === d2.get("icon-rotation-alignment") && "point" !== d2.get("symbol-placement"), k2 = d2.get("symbol-placement"), S2 = x2 / 2, I2 = d2.get("icon-text-fit");
        let z2;
        n2 && "none" !== I2 && (t2.allowVerticalPlacement && r2.vertical && (z2 = wc(n2, r2.vertical, I2, d2.get("icon-text-fit-padding"), f2, m2)), y2 && (n2 = wc(n2, y2, I2, d2.get("icon-text-fit-padding"), f2, m2)));
        const T2 = (a3, o3) => {
          o3.x < 0 || o3.x >= qa || o3.y < 0 || o3.y >= qa || function(t3, e3, r3, n3, i3, s3, a4, o4, l3, u3, c2, h3, p3, d3, f3, y3, m3, g3, x3, v3, b3, w3, _3, A3) {
            const k3 = t3.addToLineVertexArray(e3, n3);
            let S3, I3, z3, T3, M2, E2, B2, D2 = 0, P2 = 0, V2 = 0, L2 = 0, F2 = -1, R2 = -1;
            const $2 = {};
            let U2 = pa(""), O2 = 0, q2 = 0;
            if (void 0 === l3._unevaluatedLayout.getValue("text-radial-offset") ? [O2, q2] = l3.layout.get("text-offset").evaluate(b3, {}, A3).map((t4) => t4 * _u) : (O2 = l3.layout.get("text-radial-offset").evaluate(b3, {}, A3) * _u, q2 = Xc), t3.allowVerticalPlacement && i3.vertical) {
              const t4 = i3.vertical;
              if (f3)
                E2 = nh(t4), o4 && (B2 = nh(o4));
              else {
                const n4 = l3.layout.get("text-rotate").evaluate(b3, {}, A3) + 90;
                z3 = rh(u3, r3, e3, c2, h3, p3, t4, d3, n4, y3), o4 && (T3 = rh(u3, r3, e3, c2, h3, p3, o4, g3, n4));
              }
            }
            if (s3) {
              const n4 = l3.layout.get("icon-rotate").evaluate(b3, {}, A3), i4 = "none" !== l3.layout.get("icon-text-fit"), a5 = Lc(s3, n4, _3, i4), d4 = o4 ? Lc(o4, n4, _3, i4) : void 0;
              I3 = rh(u3, r3, e3, c2, h3, p3, s3, g3, n4), D2 = 4 * a5.length;
              const f4 = t3.iconSizeData;
              let y4 = null;
              "source" === f4.kind ? (y4 = [Au * l3.layout.get("icon-size").evaluate(b3, {}, A3)], y4[0] > Qc && C(`${t3.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : "composite" === f4.kind && (y4 = [Au * w3.compositeIconSizes[0].evaluate(b3, {}, A3), Au * w3.compositeIconSizes[1].evaluate(b3, {}, A3)], (y4[0] > Qc || y4[1] > Qc) && C(`${t3.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), t3.addSymbols(t3.icon, a5, y4, v3, x3, b3, false, r3, e3, k3.lineStartIndex, k3.lineLength, -1, A3), F2 = t3.icon.placedSymbolArray.length - 1, d4 && (P2 = 4 * d4.length, t3.addSymbols(t3.icon, d4, y4, v3, x3, b3, ac.vertical, r3, e3, k3.lineStartIndex, k3.lineLength, -1, A3), R2 = t3.icon.placedSymbolArray.length - 1);
            }
            for (const n4 in i3.horizontal) {
              const s4 = i3.horizontal[n4];
              S3 || (U2 = pa(s4.text), f3 ? M2 = nh(s4) : S3 = rh(u3, r3, e3, c2, h3, p3, s4, d3, l3.layout.get("text-rotate").evaluate(b3, {}, A3), y3));
              const o5 = 1 === s4.positionedLines.length;
              if (V2 += th(t3, r3, e3, s4, a4, l3, f3, b3, y3, k3, i3.vertical ? ac.horizontal : ac.horizontalOnly, o5 ? Object.keys(i3.horizontal) : [n4], $2, F2, w3, A3), o5)
                break;
            }
            i3.vertical && (L2 += th(t3, r3, e3, i3.vertical, a4, l3, f3, b3, y3, k3, ac.vertical, ["vertical"], $2, R2, w3, A3));
            let j2 = -1;
            const N2 = (t4, e4) => t4 ? Math.max(t4, e4) : e4;
            j2 = N2(M2, j2), j2 = N2(E2, j2), j2 = N2(B2, j2);
            const Z2 = j2 > -1 ? 1 : 0;
            t3.glyphOffsetArray.length >= ph.MAX_GLYPHS && C("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== b3.sortKey && t3.addToSortKeyRanges(t3.symbolInstances.length, b3.sortKey), t3.symbolInstances.emplaceBack(r3.x, r3.y, r3.z, e3.x, e3.y, $2.right >= 0 ? $2.right : -1, $2.center >= 0 ? $2.center : -1, $2.left >= 0 ? $2.left : -1, $2.vertical >= 0 ? $2.vertical : -1, F2, R2, U2, void 0 !== S3 ? S3 : t3.collisionBoxArray.length, void 0 !== S3 ? S3 + 1 : t3.collisionBoxArray.length, void 0 !== z3 ? z3 : t3.collisionBoxArray.length, void 0 !== z3 ? z3 + 1 : t3.collisionBoxArray.length, void 0 !== I3 ? I3 : t3.collisionBoxArray.length, void 0 !== I3 ? I3 + 1 : t3.collisionBoxArray.length, T3 || t3.collisionBoxArray.length, T3 ? T3 + 1 : t3.collisionBoxArray.length, c2, V2, L2, D2, P2, Z2, 0, O2, q2, j2);
          }(t2, o3, o3, a3, r2, n2, i2, z2, t2.layers[0], t2.collisionBoxArray, e2.index, e2.sourceLayerIndex, t2.index, v2, _2, l2, 0, b2, A2, f2, e2, s2, u2, h2);
        };
        if ("line" === k2)
          for (const i3 of Ec(e2.geometry, 0, 0, qa, qa)) {
            const e3 = Tc(i3, x2, w2, r2.vertical || y2, n2, 24, g2, t2.overscaling, qa);
            for (const r3 of e3) {
              const e4 = y2;
              e4 && ih(t2, e4.text, S2, r3) || T2(i3, r3);
            }
          }
        else if ("line-center" === k2) {
          for (const t3 of e2.geometry)
            if (t3.length > 1) {
              const e3 = zc(t3, w2, r2.vertical || y2, n2, 24, g2);
              e3 && T2(t3, e3);
            }
        } else if ("Polygon" === e2.type)
          for (const t3 of Ml(e2.geometry, 0)) {
            const e3 = Nc(t3, 16);
            T2(t3[0], new _c(e3.x, e3.y, 0, 0, void 0));
          }
        else if ("LineString" === e2.type)
          for (const t3 of e2.geometry)
            T2(t3, new _c(t3[0].x, t3[0].y, 0, 0, void 0));
        else if ("Point" === e2.type)
          for (const t3 of e2.geometry)
            for (const e3 of t3)
              T2([e3], new _c(e3.x, e3.y, 0, 0, void 0));
      }
      const Qc = 32640;
      function th(t2, e2, r2, n2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, y2, m2) {
        const g2 = function(t3, e3, r3, n3, s3, a3, o3, l3) {
          const u3 = [];
          if (0 === e3.positionedLines.length)
            return u3;
          const c3 = n3.layout.get("text-rotate").evaluate(a3, {}) * Math.PI / 180, h3 = function(t4) {
            const e4 = t4[0], r4 = t4[1], n4 = e4 * r4;
            return n4 > 0 ? [e4, -r4] : n4 < 0 ? [-e4, r4] : 0 === e4 ? [r4, e4] : [r4, -e4];
          }(r3);
          let p3 = Math.abs(e3.top - e3.bottom);
          for (const t4 of e3.positionedLines)
            p3 -= t4.lineOffset;
          const d3 = e3.positionedLines.length, f3 = p3 / d3;
          let y3 = e3.top - r3[1];
          for (let t4 = 0; t4 < d3; ++t4) {
            const n4 = e3.positionedLines[t4];
            y3 = Oc(e3, f3, y3, t4);
            for (const t5 of n4.positionedGlyphs) {
              if (!t5.rect)
                continue;
              const n5 = t5.rect || {};
              let a4 = 4, p4 = true, d4 = 1, f4 = 0;
              if (t5.imageName) {
                const e4 = o3[t5.imageName];
                if (!e4)
                  continue;
                if (e4.sdf) {
                  C("SDF images are not supported in formatted text and will be ignored.");
                  continue;
                }
                p4 = false, d4 = e4.pixelRatio, a4 = 1 / d4;
              }
              const m3 = (s3 || l3) && t5.vertical, g3 = t5.metrics.advance * t5.scale / 2, x3 = t5.metrics, v3 = t5.rect;
              if (null === v3)
                continue;
              l3 && e3.verticalizable && (f4 = t5.imageName ? g3 - t5.metrics.width * t5.scale / 2 : 0);
              const b2 = s3 ? [t5.x + g3, t5.y] : [0, 0];
              let w2 = [0, 0], _2 = [0, 0], A2 = false;
              s3 || (m3 ? (_2 = [t5.x + g3 + h3[0], t5.y + h3[1] - f4], A2 = true) : w2 = [t5.x + g3 + r3[0], t5.y + r3[1] - f4]);
              const k2 = v3.w * t5.scale / (d4 * (t5.localGlyph ? 2 : 1)), S2 = v3.h * t5.scale / (d4 * (t5.localGlyph ? 2 : 1));
              let I2, z2, T2, M2;
              if (m3) {
                const e4 = t5.y - y3, r4 = new i(-g3, g3 - e4), n6 = -Math.PI / 2, s4 = new i(..._2);
                I2 = new i(-g3 + w2[0], w2[1]), I2._rotateAround(n6, r4)._add(s4), I2.x += -e4 + g3, I2.y -= (x3.left - a4) * t5.scale;
                const o4 = t5.imageName ? x3.advance * t5.scale : _u * t5.scale, l4 = String.fromCharCode(t5.glyph);
                Eu(l4) ? I2.x += (1 - a4) * t5.scale : Cu(l4) ? I2.x += o4 - x3.height * t5.scale + (-a4 - 1) * t5.scale : I2.x += t5.imageName || x3.width + 2 * a4 === v3.w && x3.height + 2 * a4 === v3.h ? (o4 - S2) / 2 : (o4 - (x3.height + 2 * a4) * t5.scale) / 2, z2 = new i(I2.x, I2.y - k2), T2 = new i(I2.x + S2, I2.y), M2 = new i(I2.x + S2, I2.y - k2);
              } else {
                const e4 = (x3.left - a4) * t5.scale - g3 + w2[0], r4 = (-x3.top - a4) * t5.scale + w2[1], n6 = e4 + k2, s4 = r4 + S2;
                I2 = new i(e4, r4), z2 = new i(n6, r4), T2 = new i(e4, s4), M2 = new i(n6, s4);
              }
              if (c3) {
                let t6;
                t6 = s3 ? new i(0, 0) : A2 ? new i(h3[0], h3[1]) : new i(r3[0], r3[1]), I2._rotateAround(c3, t6), z2._rotateAround(c3, t6), T2._rotateAround(c3, t6), M2._rotateAround(c3, t6);
              }
              const E2 = new i(0, 0), B2 = new i(0, 0);
              u3.push({ tl: I2, tr: z2, bl: T2, br: M2, tex: n5, writingMode: e3.writingMode, glyphOffset: b2, sectionIndex: t5.sectionIndex, isSDF: p4, pixelOffsetTL: E2, pixelOffsetBR: B2, minFontScaleX: 0, minFontScaleY: 0 });
            }
          }
          return u3;
        }(0, n2, u2, a2, o2, l2, s2, t2.allowVerticalPlacement), x2 = t2.textSizeData;
        let v2 = null;
        "source" === x2.kind ? (v2 = [Au * a2.layout.get("text-size").evaluate(l2, {}, m2)], v2[0] > Qc && C(`${t2.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : "composite" === x2.kind && (v2 = [Au * y2.compositeTextSizes[0].evaluate(l2, {}, m2), Au * y2.compositeTextSizes[1].evaluate(l2, {}, m2)], (v2[0] > Qc || v2[1] > Qc) && C(`${t2.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), t2.addSymbols(t2.text, g2, v2, u2, o2, l2, h2, e2, r2, c2.lineStartIndex, c2.lineLength, f2, m2);
        for (const e3 of p2)
          d2[e3] = t2.text.placedSymbolArray.length - 1;
        return 4 * g2.length;
      }
      function eh(t2) {
        for (const e2 in t2)
          return t2[e2];
        return null;
      }
      function rh(t2, e2, r2, n2, s2, a2, o2, l2, u2, h2) {
        let p2 = o2.top, d2 = o2.bottom, f2 = o2.left, y2 = o2.right;
        const m2 = o2.collisionPadding;
        if (m2 && (f2 -= m2[0], p2 -= m2[1], y2 += m2[2], d2 += m2[3]), u2) {
          const t3 = new i(f2, p2), e3 = new i(y2, p2), r3 = new i(f2, d2), n3 = new i(y2, d2), s3 = c(u2);
          let a3 = new i(0, 0);
          h2 && (a3 = new i(h2[0], h2[1])), t3._rotateAround(s3, a3), e3._rotateAround(s3, a3), r3._rotateAround(s3, a3), n3._rotateAround(s3, a3), f2 = Math.min(t3.x, e3.x, r3.x, n3.x), y2 = Math.max(t3.x, e3.x, r3.x, n3.x), p2 = Math.min(t3.y, e3.y, r3.y, n3.y), d2 = Math.max(t3.y, e3.y, r3.y, n3.y);
        }
        return t2.emplaceBack(e2.x, e2.y, e2.z, r2.x, r2.y, f2, p2, y2, d2, l2, n2, s2, a2), t2.length - 1;
      }
      function nh(t2) {
        t2.collisionPadding && (t2.top -= t2.collisionPadding[1], t2.bottom += t2.collisionPadding[3]);
        const e2 = t2.bottom - t2.top;
        return e2 > 0 ? Math.max(10, e2) : null;
      }
      function ih(t2, e2, r2, n2) {
        const i2 = t2.compareText;
        if (e2 in i2) {
          const t3 = i2[e2];
          for (let e3 = t3.length - 1; e3 >= 0; e3--)
            if (n2.dist(t3[e3]) < r2)
              return true;
        } else
          i2[e2] = [];
        return i2[e2].push(n2), false;
      }
      const sh = Xl.VectorTileFeature.types, ah = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function oh(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, y2) {
        const m2 = c2 ? Math.min(Qc, Math.round(c2[0])) : 0, g2 = c2 ? Math.min(Qc, Math.round(c2[1])) : 0;
        t2.emplaceBack(e2, r2, Math.round(32 * a2), Math.round(32 * o2), l2, u2, (m2 << 1) + (h2 ? 1 : 0), g2, 16 * p2, 16 * d2, 256 * f2, 256 * y2, n2, i2, s2, 0);
      }
      function lh(t2, e2, r2) {
        t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2);
      }
      function uh(t2) {
        for (const e2 of t2.sections)
          if (Xi(e2.text))
            return true;
        return false;
      }
      class ch {
        constructor(t2) {
          this.layoutVertexArray = new Ds(), this.indexArray = new $s(), this.programConfigurations = t2, this.segments = new Oa(), this.dynamicLayoutVertexArray = new Es(), this.opacityVertexArray = new Ps(), this.placedSymbolArray = new Qs();
        }
        isEmpty() {
          return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
        }
        upload(t2, e2, r2, n2) {
          this.isEmpty() || (r2 && (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, mu.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray, e2), this.dynamicLayoutVertexBuffer = t2.createVertexBuffer(this.dynamicLayoutVertexArray, gu.members, true), this.opacityVertexBuffer = t2.createVertexBuffer(this.opacityVertexArray, ah, true), this.opacityVertexBuffer.itemSize = 1), (r2 || n2) && this.programConfigurations.upload(t2));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
        }
      }
      oi("SymbolBuffers", ch);
      class hh {
        constructor(t2, e2, r2) {
          this.layoutVertexArray = new t2(), this.layoutAttributes = e2, this.indexArray = new r2(), this.segments = new Oa(), this.collisionVertexArray = new Rs(), this.collisionVertexArrayExt = new Es();
        }
        upload(t2) {
          this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t2.createVertexBuffer(this.collisionVertexArray, xu.members, true), this.collisionVertexBufferExt = t2.createVertexBuffer(this.collisionVertexArrayExt, vu.members, true);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
        }
      }
      oi("CollisionBuffers", hh);
      class ph {
        constructor(t2) {
          this.collisionBoxArray = t2.collisionBoxArray, this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.pixelRatio = t2.pixelRatio, this.sourceLayerIndex = t2.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = mo([]), this.placementViewportMatrix = mo([]);
          const e2 = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = ku(this.zoom, e2["text-size"]), this.iconSizeData = ku(this.zoom, e2["icon-size"]);
          const r2 = this.layers[0].layout, n2 = r2.get("symbol-sort-key"), i2 = r2.get("symbol-z-order");
          this.canOverlap = r2.get("text-allow-overlap") || r2.get("icon-allow-overlap") || r2.get("text-ignore-placement") || r2.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== i2 && void 0 !== n2.constantOr(1), this.sortFeaturesByY = ("viewport-y" === i2 || "auto" === i2 && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = r2.get("text-writing-mode").map((t3) => ac[t3]), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.sourceID = t2.sourceID;
        }
        createArrays() {
          this.text = new ch(new Ca(this.layers, this.zoom, (t2) => /^text/.test(t2))), this.icon = new ch(new Ca(this.layers, this.zoom, (t2) => /^icon/.test(t2))), this.glyphOffsetArray = new ra(), this.lineVertexArray = new na(), this.symbolInstances = new ea();
        }
        calculateGlyphDependencies(t2, e2, r2, n2, i2) {
          for (let r3 = 0; r3 < t2.length; r3++)
            if (e2[t2.charCodeAt(r3)] = true, n2 && i2) {
              const n3 = Mu[t2.charAt(r3)];
              n3 && (e2[n3.charCodeAt(0)] = true);
            }
        }
        populate(t2, e2, r2) {
          const n2 = this.layers[0], i2 = n2.layout, s2 = i2.get("text-font"), a2 = i2.get("text-field"), o2 = i2.get("icon-image"), l2 = ("constant" !== a2.value.kind || a2.value.value instanceof de && !a2.value.value.isEmpty() || a2.value.value.toString().length > 0) && ("constant" !== s2.value.kind || s2.value.value.length > 0), u2 = "constant" !== o2.value.kind || !!o2.value.value || Object.keys(o2.parameters).length > 0, c2 = i2.get("symbol-sort-key");
          if (this.features = [], !l2 && !u2)
            return;
          const h2 = e2.iconDependencies, p2 = e2.glyphDependencies, d2 = e2.availableImages, f2 = new as(this.zoom);
          for (const { feature: e3, id: a3, index: o3, sourceLayerIndex: y2 } of t2) {
            const t3 = n2._featureFilter.needGeometry, m2 = Ga(e3, t3);
            if (!n2._featureFilter.filter(f2, m2, r2))
              continue;
            let g2, x2;
            if (t3 || (m2.geometry = Za(e3)), l2) {
              const t4 = n2.getValueAndResolveTokens("text-field", m2, r2, d2), e4 = de.factory(t4);
              uh(e4) && (this.hasRTLText = true), (!this.hasRTLText || "unavailable" === ns() || this.hasRTLText && ss.isParsed()) && (g2 = Tu(e4, n2, m2));
            }
            if (u2) {
              const t4 = n2.getValueAndResolveTokens("icon-image", m2, r2, d2);
              x2 = t4 instanceof fe ? t4 : fe.fromString(t4);
            }
            if (!g2 && !x2)
              continue;
            const v2 = this.sortFeaturesByKey ? c2.evaluate(m2, {}, r2) : void 0;
            if (this.features.push({ id: a3, text: g2, icon: x2, index: o3, sourceLayerIndex: y2, geometry: m2.geometry, properties: e3.properties, type: sh[e3.type], sortKey: v2 }), x2 && (h2[x2.name] = true), g2) {
              const t4 = s2.evaluate(m2, {}, r2).join(","), e4 = "map" === i2.get("text-rotation-alignment") && "point" !== i2.get("symbol-placement");
              this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(ac.vertical) >= 0;
              for (const r3 of g2.sections)
                if (r3.image)
                  h2[r3.image.name] = true;
                else {
                  const n3 = Ui(g2.toString()), i3 = r3.fontStack || t4, s3 = p2[i3] = p2[i3] || {};
                  this.calculateGlyphDependencies(r3.text, s3, e4, this.allowVerticalPlacement, n3);
                }
            }
          }
          "line" === i2.get("symbol-placement") && (this.features = function(t3) {
            const e3 = {}, r3 = {}, n3 = [];
            let i3 = 0;
            function s3(e4) {
              n3.push(t3[e4]), i3++;
            }
            function a3(t4, e4, i4) {
              const s4 = r3[t4];
              return delete r3[t4], r3[e4] = s4, n3[s4].geometry[0].pop(), n3[s4].geometry[0] = n3[s4].geometry[0].concat(i4[0]), s4;
            }
            function o3(t4, r4, i4) {
              const s4 = e3[r4];
              return delete e3[r4], e3[t4] = s4, n3[s4].geometry[0].shift(), n3[s4].geometry[0] = i4[0].concat(n3[s4].geometry[0]), s4;
            }
            function l3(t4, e4, r4) {
              const n4 = r4 ? e4[0][e4[0].length - 1] : e4[0][0];
              return `${t4}:${n4.x}:${n4.y}`;
            }
            for (let u3 = 0; u3 < t3.length; u3++) {
              const c3 = t3[u3], h3 = c3.geometry, p3 = c3.text ? c3.text.toString() : null;
              if (!p3) {
                s3(u3);
                continue;
              }
              const d3 = l3(p3, h3), f3 = l3(p3, h3, true);
              if (d3 in r3 && f3 in e3 && r3[d3] !== e3[f3]) {
                const t4 = o3(d3, f3, h3), i4 = a3(d3, f3, n3[t4].geometry);
                delete e3[d3], delete r3[f3], r3[l3(p3, n3[i4].geometry, true)] = i4, n3[t4].geometry = null;
              } else
                d3 in r3 ? a3(d3, f3, h3) : f3 in e3 ? o3(d3, f3, h3) : (s3(u3), e3[d3] = i3 - 1, r3[f3] = i3 - 1);
            }
            return n3.filter((t4) => t4.geometry);
          }(this.features)), this.sortFeaturesByKey && this.features.sort((t3, e3) => t3.sortKey - e3.sortKey);
        }
        update(t2, e2, r2) {
          this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2), this.icon.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2));
        }
        isEmpty() {
          return 0 === this.symbolInstances.length && !this.hasRTLText;
        }
        uploadPending() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }
        upload(t2) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t2), this.iconCollisionBox.upload(t2)), this.text.upload(t2, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t2, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
        }
        destroyDebugData() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }
        destroy() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }
        addToLineVertexArray(t2, e2) {
          const r2 = this.lineVertexArray.length;
          if (void 0 !== t2.segment) {
            let r3 = t2.dist(e2[t2.segment + 1]), n2 = t2.dist(e2[t2.segment]);
            const i2 = {};
            for (let n3 = t2.segment + 1; n3 < e2.length; n3++)
              i2[n3] = { x: e2[n3].x, y: e2[n3].y, tileUnitDistanceFromAnchor: r3 }, n3 < e2.length - 1 && (r3 += e2[n3 + 1].dist(e2[n3]));
            for (let r4 = t2.segment || 0; r4 >= 0; r4--)
              i2[r4] = { x: e2[r4].x, y: e2[r4].y, tileUnitDistanceFromAnchor: n2 }, r4 > 0 && (n2 += e2[r4 - 1].dist(e2[r4]));
            for (let t3 = 0; t3 < e2.length; t3++) {
              const e3 = i2[t3];
              this.lineVertexArray.emplaceBack(e3.x, e3.y, e3.tileUnitDistanceFromAnchor);
            }
          }
          return { lineStartIndex: r2, lineLength: this.lineVertexArray.length - r2 };
        }
        addSymbols(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
          const d2 = t2.indexArray, f2 = t2.layoutVertexArray, y2 = t2.segments.prepareSegment(4 * e2.length, f2, d2, this.canOverlap ? s2.sortKey : void 0), m2 = this.glyphOffsetArray.length, g2 = y2.vertexLength, x2 = this.allowVerticalPlacement && a2 === ac.vertical ? Math.PI / 2 : 0, v2 = s2.text && s2.text.sections;
          for (let n3 = 0; n3 < e2.length; n3++) {
            const { tl: i3, tr: a3, bl: u3, br: c3, tex: h3, pixelOffsetTL: m3, pixelOffsetBR: g3, minFontScaleX: b2, minFontScaleY: w2, glyphOffset: _2, isSDF: A2, sectionIndex: k2 } = e2[n3], S2 = y2.vertexLength, I2 = _2[1];
            oh(f2, o2.x, o2.y, o2.z, l2.x, l2.y, i3.x, I2 + i3.y, h3.x, h3.y, r2, A2, m3.x, m3.y, b2, w2), oh(f2, o2.x, o2.y, o2.z, l2.x, l2.y, a3.x, I2 + a3.y, h3.x + h3.w, h3.y, r2, A2, g3.x, m3.y, b2, w2), oh(f2, o2.x, o2.y, o2.z, l2.x, l2.y, u3.x, I2 + u3.y, h3.x, h3.y + h3.h, r2, A2, m3.x, g3.y, b2, w2), oh(f2, o2.x, o2.y, o2.z, l2.x, l2.y, c3.x, I2 + c3.y, h3.x + h3.w, h3.y + h3.h, r2, A2, g3.x, g3.y, b2, w2), lh(t2.dynamicLayoutVertexArray, o2, x2), d2.emplaceBack(S2, S2 + 1, S2 + 2), d2.emplaceBack(S2 + 1, S2 + 2, S2 + 3), y2.vertexLength += 4, y2.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(_2[0]), n3 !== e2.length - 1 && k2 === e2[n3 + 1].sectionIndex || t2.programConfigurations.populatePaintArrays(f2.length, s2, s2.index, {}, p2, v2 && v2[k2]);
          }
          t2.placedSymbolArray.emplaceBack(o2.x, o2.y, o2.z, l2.x, l2.y, m2, this.glyphOffsetArray.length - m2, g2, u2, c2, l2.segment, r2 ? r2[0] : 0, r2 ? r2[1] : 0, n2[0], n2[1], a2, 0, false, 0, h2, 0);
        }
        _commitLayoutVertex(t2, e2, r2, n2, i2, s2, a2) {
          t2.emplaceBack(e2, r2, n2, i2, s2, Math.round(a2.x), Math.round(a2.y));
        }
        _addCollisionDebugVertices(t2, e2, r2, n2, s2, a2, o2) {
          const l2 = r2.segments.prepareSegment(4, r2.layoutVertexArray, r2.indexArray), u2 = l2.vertexLength, c2 = o2.tileAnchorX, h2 = o2.tileAnchorY;
          for (let t3 = 0; t3 < 4; t3++)
            r2.collisionVertexArray.emplaceBack(0, 0, 0, 0);
          r2.collisionVertexArrayExt.emplaceBack(e2, -t2.padding, -t2.padding), r2.collisionVertexArrayExt.emplaceBack(e2, t2.padding, -t2.padding), r2.collisionVertexArrayExt.emplaceBack(e2, t2.padding, t2.padding), r2.collisionVertexArrayExt.emplaceBack(e2, -t2.padding, t2.padding), this._commitLayoutVertex(r2.layoutVertexArray, n2, s2, a2, c2, h2, new i(t2.x1, t2.y1)), this._commitLayoutVertex(r2.layoutVertexArray, n2, s2, a2, c2, h2, new i(t2.x2, t2.y1)), this._commitLayoutVertex(r2.layoutVertexArray, n2, s2, a2, c2, h2, new i(t2.x2, t2.y2)), this._commitLayoutVertex(r2.layoutVertexArray, n2, s2, a2, c2, h2, new i(t2.x1, t2.y2)), l2.vertexLength += 4;
          const p2 = r2.indexArray;
          p2.emplaceBack(u2, u2 + 1), p2.emplaceBack(u2 + 1, u2 + 2), p2.emplaceBack(u2 + 2, u2 + 3), p2.emplaceBack(u2 + 3, u2), l2.primitiveLength += 4;
        }
        _addTextDebugCollisionBoxes(t2, e2, r2, n2, i2, s2) {
          for (let a2 = n2; a2 < i2; a2++) {
            const n3 = r2.get(a2), i3 = this.getSymbolInstanceTextSize(t2, s2, e2, a2);
            this._addCollisionDebugVertices(n3, i3, this.textCollisionBox, n3.projectedAnchorX, n3.projectedAnchorY, n3.projectedAnchorZ, s2);
          }
        }
        _addIconDebugCollisionBoxes(t2, e2, r2, n2, i2, s2) {
          for (let a2 = n2; a2 < i2; a2++) {
            const n3 = r2.get(a2), i3 = this.getSymbolInstanceIconSize(t2, e2, a2);
            this._addCollisionDebugVertices(n3, i3, this.iconCollisionBox, n3.projectedAnchorX, n3.projectedAnchorY, n3.projectedAnchorZ, s2);
          }
        }
        generateCollisionDebugBuffers(t2, e2) {
          this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new hh(Ls, bu.members, Zs), this.iconCollisionBox = new hh(Ls, bu.members, Zs);
          const r2 = Iu(this.iconSizeData, t2), n2 = Iu(this.textSizeData, t2);
          for (let i2 = 0; i2 < this.symbolInstances.length; i2++) {
            const s2 = this.symbolInstances.get(i2);
            this._addTextDebugCollisionBoxes(n2, t2, e2, s2.textBoxStartIndex, s2.textBoxEndIndex, s2), this._addTextDebugCollisionBoxes(n2, t2, e2, s2.verticalTextBoxStartIndex, s2.verticalTextBoxEndIndex, s2), this._addIconDebugCollisionBoxes(r2, t2, e2, s2.iconBoxStartIndex, s2.iconBoxEndIndex, s2), this._addIconDebugCollisionBoxes(r2, t2, e2, s2.verticalIconBoxStartIndex, s2.verticalIconBoxEndIndex, s2);
          }
        }
        getSymbolInstanceTextSize(t2, e2, r2, n2) {
          const i2 = this.text.placedSymbolArray.get(e2.rightJustifiedTextSymbolIndex >= 0 ? e2.rightJustifiedTextSymbolIndex : e2.centerJustifiedTextSymbolIndex >= 0 ? e2.centerJustifiedTextSymbolIndex : e2.leftJustifiedTextSymbolIndex >= 0 ? e2.leftJustifiedTextSymbolIndex : e2.verticalPlacedTextSymbolIndex >= 0 ? e2.verticalPlacedTextSymbolIndex : n2), s2 = Su(this.textSizeData, t2, i2) / _u;
          return this.tilePixelRatio * s2;
        }
        getSymbolInstanceIconSize(t2, e2, r2) {
          const n2 = this.icon.placedSymbolArray.get(r2), i2 = Su(this.iconSizeData, t2, n2);
          return this.tilePixelRatio * i2;
        }
        _commitDebugCollisionVertexUpdate(t2, e2, r2) {
          t2.emplaceBack(e2, -r2, -r2), t2.emplaceBack(e2, r2, -r2), t2.emplaceBack(e2, r2, r2), t2.emplaceBack(e2, -r2, r2);
        }
        _updateTextDebugCollisionBoxes(t2, e2, r2, n2, i2, s2) {
          for (let a2 = n2; a2 < i2; a2++) {
            const n3 = r2.get(a2), i3 = this.getSymbolInstanceTextSize(t2, s2, e2, a2);
            this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i3, n3.padding);
          }
        }
        _updateIconDebugCollisionBoxes(t2, e2, r2, n2, i2) {
          for (let s2 = n2; s2 < i2; s2++) {
            const n3 = r2.get(s2), i3 = this.getSymbolInstanceIconSize(t2, e2, s2);
            this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i3, n3.padding);
          }
        }
        updateCollisionDebugBuffers(t2, e2) {
          if (!this.hasDebugData())
            return;
          this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
          const r2 = Iu(this.iconSizeData, t2), n2 = Iu(this.textSizeData, t2);
          for (let i2 = 0; i2 < this.symbolInstances.length; i2++) {
            const s2 = this.symbolInstances.get(i2);
            this._updateTextDebugCollisionBoxes(n2, t2, e2, s2.textBoxStartIndex, s2.textBoxEndIndex, s2), this._updateTextDebugCollisionBoxes(n2, t2, e2, s2.verticalTextBoxStartIndex, s2.verticalTextBoxEndIndex, s2), this._updateIconDebugCollisionBoxes(r2, t2, e2, s2.iconBoxStartIndex, s2.iconBoxEndIndex), this._updateIconDebugCollisionBoxes(r2, t2, e2, s2.verticalIconBoxStartIndex, s2.verticalIconBoxEndIndex);
          }
          this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
        }
        _deserializeCollisionBoxesForSymbol(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
          const u2 = {};
          for (let n3 = e2; n3 < r2; n3++) {
            const e3 = t2.get(n3);
            u2.textBox = { x1: e3.x1, y1: e3.y1, x2: e3.x2, y2: e3.y2, padding: e3.padding, projectedAnchorX: e3.projectedAnchorX, projectedAnchorY: e3.projectedAnchorY, projectedAnchorZ: e3.projectedAnchorZ, tileAnchorX: e3.tileAnchorX, tileAnchorY: e3.tileAnchorY }, u2.textFeatureIndex = e3.featureIndex;
            break;
          }
          for (let e3 = n2; e3 < i2; e3++) {
            const r3 = t2.get(e3);
            u2.verticalTextBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, padding: r3.padding, projectedAnchorX: r3.projectedAnchorX, projectedAnchorY: r3.projectedAnchorY, projectedAnchorZ: r3.projectedAnchorZ, tileAnchorX: r3.tileAnchorX, tileAnchorY: r3.tileAnchorY }, u2.verticalTextFeatureIndex = r3.featureIndex;
            break;
          }
          for (let e3 = s2; e3 < a2; e3++) {
            const r3 = t2.get(e3);
            u2.iconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, padding: r3.padding, projectedAnchorX: r3.projectedAnchorX, projectedAnchorY: r3.projectedAnchorY, projectedAnchorZ: r3.projectedAnchorZ, tileAnchorX: r3.tileAnchorX, tileAnchorY: r3.tileAnchorY }, u2.iconFeatureIndex = r3.featureIndex;
            break;
          }
          for (let e3 = o2; e3 < l2; e3++) {
            const r3 = t2.get(e3);
            u2.verticalIconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, padding: r3.padding, projectedAnchorX: r3.projectedAnchorX, projectedAnchorY: r3.projectedAnchorY, projectedAnchorZ: r3.projectedAnchorZ, tileAnchorX: r3.tileAnchorX, tileAnchorY: r3.tileAnchorY }, u2.verticalIconFeatureIndex = r3.featureIndex;
            break;
          }
          return u2;
        }
        deserializeCollisionBoxes(t2) {
          this.collisionArrays = [];
          for (let e2 = 0; e2 < this.symbolInstances.length; e2++) {
            const r2 = this.symbolInstances.get(e2);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t2, r2.textBoxStartIndex, r2.textBoxEndIndex, r2.verticalTextBoxStartIndex, r2.verticalTextBoxEndIndex, r2.iconBoxStartIndex, r2.iconBoxEndIndex, r2.verticalIconBoxStartIndex, r2.verticalIconBoxEndIndex));
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }
        hasIconCollisionBoxData() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }
        addIndicesForPlacedSymbol(t2, e2) {
          const r2 = t2.placedSymbolArray.get(e2), n2 = r2.vertexStartIndex + 4 * r2.numGlyphs;
          for (let e3 = r2.vertexStartIndex; e3 < n2; e3 += 4)
            t2.indexArray.emplaceBack(e3, e3 + 1, e3 + 2), t2.indexArray.emplaceBack(e3 + 1, e3 + 2, e3 + 3);
        }
        getSortedSymbolIndexes(t2) {
          if (this.sortedAngle === t2 && void 0 !== this.symbolInstanceIndexes)
            return this.symbolInstanceIndexes;
          const e2 = Math.sin(t2), r2 = Math.cos(t2), n2 = [], i2 = [], s2 = [];
          for (let t3 = 0; t3 < this.symbolInstances.length; ++t3) {
            s2.push(t3);
            const a2 = this.symbolInstances.get(t3);
            n2.push(0 | Math.round(e2 * a2.tileAnchorX + r2 * a2.tileAnchorY)), i2.push(a2.featureIndex);
          }
          return s2.sort((t3, e3) => n2[t3] - n2[e3] || i2[e3] - i2[t3]), s2;
        }
        addToSortKeyRanges(t2, e2) {
          const r2 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          r2 && r2.sortKey === e2 ? r2.symbolInstanceEnd = t2 + 1 : this.sortKeyRanges.push({ sortKey: e2, symbolInstanceStart: t2, symbolInstanceEnd: t2 + 1 });
        }
        sortFeatures(t2) {
          if (this.sortFeaturesByY && this.sortedAngle !== t2 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t2), this.sortedAngle = t2, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (const t3 of this.symbolInstanceIndexes) {
              const e2 = this.symbolInstances.get(t3);
              this.featureSortOrder.push(e2.featureIndex), [e2.rightJustifiedTextSymbolIndex, e2.centerJustifiedTextSymbolIndex, e2.leftJustifiedTextSymbolIndex].forEach((t4, e3, r2) => {
                t4 >= 0 && r2.indexOf(t4) === e3 && this.addIndicesForPlacedSymbol(this.text, t4);
              }), e2.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e2.verticalPlacedTextSymbolIndex), e2.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.placedIconSymbolIndex), e2.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.verticalPlacedIconSymbolIndex);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }
      }
      oi("SymbolBucket", ph, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), ph.MAX_GLYPHS = 65535, ph.addDynamicAttributes = lh;
      const dh = new bs({ "symbol-placement": new ys(Rt.layout_symbol["symbol-placement"]), "symbol-spacing": new ys(Rt.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new ys(Rt.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new ms(Rt.layout_symbol["symbol-sort-key"]), "symbol-z-order": new ys(Rt.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new ys(Rt.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new ys(Rt.layout_symbol["icon-ignore-placement"]), "icon-optional": new ys(Rt.layout_symbol["icon-optional"]), "icon-rotation-alignment": new ys(Rt.layout_symbol["icon-rotation-alignment"]), "icon-size": new ms(Rt.layout_symbol["icon-size"]), "icon-text-fit": new ys(Rt.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new ys(Rt.layout_symbol["icon-text-fit-padding"]), "icon-image": new ms(Rt.layout_symbol["icon-image"]), "icon-rotate": new ms(Rt.layout_symbol["icon-rotate"]), "icon-padding": new ys(Rt.layout_symbol["icon-padding"]), "icon-keep-upright": new ys(Rt.layout_symbol["icon-keep-upright"]), "icon-offset": new ms(Rt.layout_symbol["icon-offset"]), "icon-anchor": new ms(Rt.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new ys(Rt.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new ys(Rt.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new ys(Rt.layout_symbol["text-rotation-alignment"]), "text-field": new ms(Rt.layout_symbol["text-field"]), "text-font": new ms(Rt.layout_symbol["text-font"]), "text-size": new ms(Rt.layout_symbol["text-size"]), "text-max-width": new ms(Rt.layout_symbol["text-max-width"]), "text-line-height": new ms(Rt.layout_symbol["text-line-height"]), "text-letter-spacing": new ms(Rt.layout_symbol["text-letter-spacing"]), "text-justify": new ms(Rt.layout_symbol["text-justify"]), "text-radial-offset": new ms(Rt.layout_symbol["text-radial-offset"]), "text-variable-anchor": new ys(Rt.layout_symbol["text-variable-anchor"]), "text-anchor": new ms(Rt.layout_symbol["text-anchor"]), "text-max-angle": new ys(Rt.layout_symbol["text-max-angle"]), "text-writing-mode": new ys(Rt.layout_symbol["text-writing-mode"]), "text-rotate": new ms(Rt.layout_symbol["text-rotate"]), "text-padding": new ys(Rt.layout_symbol["text-padding"]), "text-keep-upright": new ys(Rt.layout_symbol["text-keep-upright"]), "text-transform": new ms(Rt.layout_symbol["text-transform"]), "text-offset": new ms(Rt.layout_symbol["text-offset"]), "text-allow-overlap": new ys(Rt.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new ys(Rt.layout_symbol["text-ignore-placement"]), "text-optional": new ys(Rt.layout_symbol["text-optional"]) });
      var fh = { paint: new bs({ "icon-opacity": new ms(Rt.paint_symbol["icon-opacity"]), "icon-color": new ms(Rt.paint_symbol["icon-color"]), "icon-halo-color": new ms(Rt.paint_symbol["icon-halo-color"]), "icon-halo-width": new ms(Rt.paint_symbol["icon-halo-width"]), "icon-halo-blur": new ms(Rt.paint_symbol["icon-halo-blur"]), "icon-translate": new ys(Rt.paint_symbol["icon-translate"]), "icon-translate-anchor": new ys(Rt.paint_symbol["icon-translate-anchor"]), "text-opacity": new ms(Rt.paint_symbol["text-opacity"]), "text-color": new ms(Rt.paint_symbol["text-color"], { runtimeType: Ht, getOverride: (t2) => t2.textColor, hasOverride: (t2) => !!t2.textColor }), "text-halo-color": new ms(Rt.paint_symbol["text-halo-color"]), "text-halo-width": new ms(Rt.paint_symbol["text-halo-width"]), "text-halo-blur": new ms(Rt.paint_symbol["text-halo-blur"]), "text-translate": new ys(Rt.paint_symbol["text-translate"]), "text-translate-anchor": new ys(Rt.paint_symbol["text-translate-anchor"]) }), layout: dh };
      class yh {
        constructor(t2) {
          this.type = t2.property.overrides ? t2.property.overrides.runtimeType : Gt, this.defaultValue = t2;
        }
        evaluate(t2) {
          if (t2.formattedSection) {
            const e2 = this.defaultValue.property.overrides;
            if (e2 && e2.hasOverride(t2.formattedSection))
              return e2.getOverride(t2.formattedSection);
          }
          return t2.feature && t2.featureState ? this.defaultValue.evaluate(t2.feature, t2.featureState) : this.defaultValue.property.specification.default;
        }
        eachChild(t2) {
          this.defaultValue.isConstant() || t2(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return null;
        }
      }
      oi("FormatSectionOverride", yh, { omit: ["defaultValue"] });
      class mh extends Ra {
        constructor(t2) {
          super(t2, fh);
        }
        recalculate(t2, e2) {
          super.recalculate(t2, e2), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
          const r2 = this.layout.get("text-writing-mode");
          if (r2) {
            const t3 = [];
            for (const e3 of r2)
              t3.indexOf(e3) < 0 && t3.push(e3);
            this.layout._values["text-writing-mode"] = t3;
          } else
            this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? ["horizontal"] : ["horizontal", "vertical"];
          this._setPaintOverrides();
        }
        getValueAndResolveTokens(t2, e2, r2, n2) {
          const i2 = this.layout.get(t2).evaluate(e2, {}, r2, n2), s2 = this._unevaluatedLayout._values[t2];
          return s2.isDataDriven() || un(s2.value) || !i2 ? i2 : function(t3, e3) {
            return e3.replace(/{([^{}]+)}/g, (e4, r3) => r3 in t3 ? String(t3[r3]) : "");
          }(e2.properties, i2);
        }
        createBucket(t2) {
          return new ph(t2);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return false;
        }
        _setPaintOverrides() {
          for (const t2 of fh.paint.overridableProperties) {
            if (!mh.hasPaintOverride(this.layout, t2))
              continue;
            const e2 = this.paint.get(t2), r2 = new yh(e2), n2 = new ln(r2, e2.property.specification);
            let i2 = null;
            i2 = "constant" === e2.value.kind || "source" === e2.value.kind ? new hn("source", n2) : new pn("composite", n2, e2.value.zoomStops, e2.value._interpolationType), this.paint._values[t2] = new ds(e2.property, i2, e2.parameters);
          }
        }
        _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
          return !(!this.layout || e2.isDataDriven() || r2.isDataDriven()) && mh.hasPaintOverride(this.layout, t2);
        }
        static hasPaintOverride(t2, e2) {
          const r2 = t2.get("text-field"), n2 = fh.paint.properties[e2];
          let i2 = false;
          const s2 = (t3) => {
            for (const e3 of t3)
              if (n2.overrides && n2.overrides.hasOverride(e3))
                return void (i2 = true);
          };
          if ("constant" === r2.value.kind && r2.value.value instanceof de)
            s2(r2.value.value.sections);
          else if ("source" === r2.value.kind) {
            const t3 = (e4) => {
              i2 || (e4 instanceof ve && ge(e4.value) === te ? s2(e4.value.sections) : e4 instanceof Ae ? s2(e4.sections) : e4.eachChild(t3));
            }, e3 = r2.value;
            e3._styleExpression && t3(e3._styleExpression.expression);
          }
          return i2;
        }
        getProgramConfiguration(t2) {
          return new Ea(this, t2);
        }
      }
      var gh = { paint: new bs({ "background-color": new ys(Rt.paint_background["background-color"]), "background-pattern": new xs(Rt.paint_background["background-pattern"]), "background-opacity": new ys(Rt.paint_background["background-opacity"]) }) }, xh = { paint: new bs({ "raster-opacity": new ys(Rt.paint_raster["raster-opacity"]), "raster-hue-rotate": new ys(Rt.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new ys(Rt.paint_raster["raster-brightness-min"]), "raster-brightness-max": new ys(Rt.paint_raster["raster-brightness-max"]), "raster-saturation": new ys(Rt.paint_raster["raster-saturation"]), "raster-contrast": new ys(Rt.paint_raster["raster-contrast"]), "raster-resampling": new ys(Rt.paint_raster["raster-resampling"]), "raster-fade-duration": new ys(Rt.paint_raster["raster-fade-duration"]) }) };
      class vh extends Ra {
        constructor(t2) {
          super(t2, {}), this.implementation = t2;
        }
        is3D() {
          return "3d" === this.implementation.renderingMode;
        }
        hasOffscreenPass() {
          return void 0 !== this.implementation.prerender;
        }
        recalculate() {
        }
        updateTransitions() {
        }
        hasTransition() {
        }
        serialize() {
        }
        onAdd(t2) {
          this.implementation.onAdd && this.implementation.onAdd(t2, t2.painter.context.gl);
        }
        onRemove(t2) {
          this.implementation.onRemove && this.implementation.onRemove(t2, t2.painter.context.gl);
        }
      }
      var bh = { paint: new bs({ "sky-type": new ys(Rt.paint_sky["sky-type"]), "sky-atmosphere-sun": new ys(Rt.paint_sky["sky-atmosphere-sun"]), "sky-atmosphere-sun-intensity": new ys(Rt.paint_sky["sky-atmosphere-sun-intensity"]), "sky-gradient-center": new ys(Rt.paint_sky["sky-gradient-center"]), "sky-gradient-radius": new ys(Rt.paint_sky["sky-gradient-radius"]), "sky-gradient": new vs(Rt.paint_sky["sky-gradient"]), "sky-atmosphere-halo-color": new ys(Rt.paint_sky["sky-atmosphere-halo-color"]), "sky-atmosphere-color": new ys(Rt.paint_sky["sky-atmosphere-color"]), "sky-opacity": new ys(Rt.paint_sky["sky-opacity"]) }) };
      function wh(t2, e2, r2) {
        const n2 = wo(0, 0, 1), i2 = Do(Bo());
        return function(t3, e3, r3) {
          r3 *= 0.5;
          var n3 = e3[0], i3 = e3[1], s2 = e3[2], a2 = e3[3], o2 = Math.sin(r3), l2 = Math.cos(r3);
          t3[0] = n3 * l2 - s2 * o2, t3[1] = i3 * l2 + a2 * o2, t3[2] = s2 * l2 + n3 * o2, t3[3] = a2 * l2 - i3 * o2;
        }(i2, i2, r2 ? -c(t2) + Math.PI : c(t2)), Po(i2, i2, -c(e2)), Io(n2, n2, i2), So(n2, n2);
      }
      const _h = { circle: class extends Ra {
        constructor(t2) {
          super(t2, po);
        }
        createBucket(t2) {
          return new Ka(t2);
        }
        queryRadius(t2) {
          const e2 = t2;
          return oo("circle-radius", this, e2) + oo("circle-stroke-width", this, e2) + lo(this.paint.get("circle-translate"));
        }
        queryIntersectsFeature(t2, e2, r2, n2, i2, s2, a2, o2) {
          const l2 = co(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), u2 = this.paint.get("circle-radius").evaluate(e2, r2) + this.paint.get("circle-stroke-width").evaluate(e2, r2);
          return Vo(t2, n2, s2, a2, o2, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l2, u2);
        }
        getProgramIds() {
          return ["circle"];
        }
        getProgramConfiguration(t2) {
          return new Ea(this, t2);
        }
      }, heatmap: class extends Ra {
        createBucket(t2) {
          return new Uo(t2);
        }
        constructor(t2) {
          super(t2, Go), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(t2) {
          "heatmap-color" === t2 && this._updateColorRamp();
        }
        _updateColorRamp() {
          this.colorRamp = Xo({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }
        resize() {
          this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
        }
        queryRadius(t2) {
          return oo("heatmap-radius", this, t2);
        }
        queryIntersectsFeature(t2, e2, r2, n2, s2, a2, o2, l2) {
          const u2 = this.paint.get("heatmap-radius").evaluate(e2, r2);
          return Vo(t2, n2, a2, o2, l2, true, true, new i(0, 0), u2);
        }
        hasOffscreenPass() {
          return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
        }
        getProgramIds() {
          return ["heatmap", "heatmapTexture"];
        }
        getProgramConfiguration(t2) {
          return new Ea(this, t2);
        }
      }, hillshade: class extends Ra {
        constructor(t2) {
          super(t2, Ko);
        }
        hasOffscreenPass() {
          return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
        }
        getProgramIds() {
          return ["hillshade", "hillshadePrepare"];
        }
        getProgramConfiguration(t2) {
          return new Ea(this, t2);
        }
      }, fill: class extends Ra {
        constructor(t2) {
          super(t2, Vl);
        }
        getProgramIds() {
          const t2 = this.paint.get("fill-pattern"), e2 = t2 && t2.constantOr(1), r2 = [e2 ? "fillPattern" : "fill"];
          return this.paint.get("fill-antialias") && r2.push(e2 && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r2;
        }
        getProgramConfiguration(t2) {
          return new Ea(this, t2);
        }
        recalculate(t2, e2) {
          super.recalculate(t2, e2);
          const r2 = this.paint._values["fill-outline-color"];
          "constant" === r2.value.kind && void 0 === r2.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }
        createBucket(t2) {
          return new Dl(t2);
        }
        queryRadius() {
          return lo(this.paint.get("fill-translate"));
        }
        queryIntersectsFeature(t2, e2, r2, n2, i2, s2) {
          return !t2.queryGeometry.isAboveHorizon && Ja(uo(t2.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), n2);
        }
        isTileClipped() {
          return true;
        }
      }, "fill-extrusion": class extends Ra {
        constructor(t2) {
          super(t2, tu);
        }
        createBucket(t2) {
          return new Wl(t2);
        }
        queryRadius() {
          return lo(this.paint.get("fill-extrusion-translate"));
        }
        is3D() {
          return true;
        }
        getProgramIds() {
          return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"];
        }
        getProgramConfiguration(t2) {
          return new Ea(this, t2);
        }
        queryIntersectsFeature(t2, e2, r2, n2, s2, a2, o2, l2, u2) {
          const c2 = co(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), a2.angle, t2.pixelToTileUnitsFactor), h2 = this.paint.get("fill-extrusion-height").evaluate(e2, r2), p2 = this.paint.get("fill-extrusion-base").evaluate(e2, r2), d2 = [0, 0], f2 = l2 && a2.elevation, y2 = a2.elevation ? a2.elevation.exaggeration() : 1;
          if (f2) {
            const e3 = t2.tile.getBucket(this).centroidVertexArray, r3 = u2 + 1;
            if (r3 < e3.length) {
              const t3 = e3.get(r3);
              d2[0] = t3.a_centroid_pos0, d2[1] = t3.a_centroid_pos1;
            }
          }
          if (0 === d2[0] && 1 === d2[1])
            return false;
          const m2 = function(t3, e3, r3, n3, s3, a3, o3, l3, u3) {
            return a3 ? function(t4, e4, r4, n4, i2, s4, a4, o4, l4) {
              const u4 = [], c3 = [], h3 = [0, 0, 0, 1];
              for (const p3 of t4) {
                const t5 = [], d3 = [];
                for (const u5 of p3) {
                  const c4 = u5.x + n4.x, p4 = u5.y + n4.y, f3 = iu(c4, p4, e4, r4, s4, a4, o4, l4);
                  h3[0] = c4, h3[1] = p4, h3[2] = f3.base, h3[3] = 1, Co(h3, h3, i2), h3[3] = Math.max(h3[3], 1e-5);
                  const y3 = nu([h3[0] / h3[3], h3[1] / h3[3], h3[2] / h3[3]]);
                  h3[0] = c4, h3[1] = p4, h3[2] = f3.top, h3[3] = 1, Co(h3, h3, i2), h3[3] = Math.max(h3[3], 1e-5);
                  const m3 = nu([h3[0] / h3[3], h3[1] / h3[3], h3[2] / h3[3]]);
                  t5.push(y3), d3.push(m3);
                }
                u4.push(t5), c3.push(d3);
              }
              return [u4, c3];
            }(t3, e3, r3, n3, s3, a3, o3, l3, u3) : function(t4, e4, r4, n4, s4) {
              const a4 = [], o4 = [], l4 = s4[8] * e4, u4 = s4[9] * e4, c3 = s4[10] * e4, h3 = s4[11] * e4, p3 = s4[8] * r4, d3 = s4[9] * r4, f3 = s4[10] * r4, y3 = s4[11] * r4;
              for (const e5 of t4) {
                const t5 = [], r5 = [];
                for (const a5 of e5) {
                  const e6 = a5.x + n4.x, o5 = a5.y + n4.y, m3 = s4[0] * e6 + s4[4] * o5 + s4[12], g3 = s4[1] * e6 + s4[5] * o5 + s4[13], x2 = s4[2] * e6 + s4[6] * o5 + s4[14], v2 = s4[3] * e6 + s4[7] * o5 + s4[15], b2 = m3 + l4, w2 = g3 + u4, _2 = x2 + c3, A2 = Math.max(v2 + h3, 1e-5), k2 = m3 + p3, S2 = g3 + d3, I2 = x2 + f3, z2 = Math.max(v2 + y3, 1e-5), T2 = new i(b2 / A2, w2 / A2);
                  T2.z = _2 / A2, t5.push(T2);
                  const M2 = new i(k2 / z2, S2 / z2);
                  M2.z = I2 / z2, r5.push(M2);
                }
                a4.push(t5), o4.push(r5);
              }
              return [a4, o4];
            }(t3, e3, r3, n3, s3);
          }(n2, p2, h2, c2, o2, f2 ? l2 : null, d2, y2, a2.center.lat), g2 = t2.queryGeometry;
          return function(t3, e3, r3) {
            let n3 = 1 / 0;
            Ja(r3, e3) && (n3 = ru(r3, e3[0]));
            for (let i2 = 0; i2 < e3.length; i2++) {
              const s3 = e3[i2], a3 = t3[i2];
              for (let t4 = 0; t4 < s3.length - 1; t4++) {
                const e4 = s3[t4], i3 = [e4, s3[t4 + 1], a3[t4 + 1], a3[t4], e4];
                Ya(r3, i3) && (n3 = Math.min(n3, ru(r3, i3)));
              }
            }
            return n3 !== 1 / 0 && n3;
          }(m2[0], m2[1], g2.isPointQuery() ? g2.screenBounds : g2.screenGeometry);
        }
      }, line: class extends Ra {
        constructor(t2) {
          super(t2, du), this.gradientVersion = 0;
        }
        _handleSpecialPaintPropertyUpdate(t2) {
          if ("line-gradient" === t2) {
            const t3 = this._transitionablePaint._values["line-gradient"].value.expression;
            this.stepInterpolant = t3._styleExpression && t3._styleExpression.expression instanceof er, this.gradientVersion = (this.gradientVersion + 1) % o;
          }
        }
        gradientExpression() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }
        recalculate(t2, e2) {
          super.recalculate(t2, e2), this.paint._values["line-floorwidth"] = fu.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t2);
        }
        createBucket(t2) {
          return new hu(t2);
        }
        getProgramIds() {
          return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"];
        }
        getProgramConfiguration(t2) {
          return new Ea(this, t2);
        }
        queryRadius(t2) {
          const e2 = t2, r2 = yu(oo("line-width", this, e2), oo("line-gap-width", this, e2)), n2 = oo("line-offset", this, e2);
          return r2 / 2 + Math.abs(n2) + lo(this.paint.get("line-translate"));
        }
        queryIntersectsFeature(t2, e2, r2, n2, s2, a2) {
          if (t2.queryGeometry.isAboveHorizon)
            return false;
          const o2 = uo(t2.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), a2.angle, t2.pixelToTileUnitsFactor), l2 = t2.pixelToTileUnitsFactor / 2 * yu(this.paint.get("line-width").evaluate(e2, r2), this.paint.get("line-gap-width").evaluate(e2, r2)), u2 = this.paint.get("line-offset").evaluate(e2, r2);
          return u2 && (n2 = function(t3, e3) {
            const r3 = [], n3 = new i(0, 0);
            for (let i2 = 0; i2 < t3.length; i2++) {
              const s3 = t3[i2], a3 = [];
              for (let t4 = 0; t4 < s3.length; t4++) {
                const r4 = s3[t4 - 1], i3 = s3[t4], o3 = s3[t4 + 1], l3 = 0 === t4 ? n3 : i3.sub(r4)._unit()._perp(), u3 = t4 === s3.length - 1 ? n3 : o3.sub(i3)._unit()._perp(), c2 = l3._add(u3)._unit();
                c2._mult(1 / (c2.x * u3.x + c2.y * u3.y)), a3.push(c2._mult(e3)._add(i3));
              }
              r3.push(a3);
            }
            return r3;
          }(n2, u2 * t2.pixelToTileUnitsFactor)), function(t3, e3, r3) {
            for (let n3 = 0; n3 < e3.length; n3++) {
              const i2 = e3[n3];
              if (t3.length >= 3) {
                for (let e4 = 0; e4 < i2.length; e4++)
                  if (io(t3, i2[e4]))
                    return true;
              }
              if (Wa(t3, i2, r3))
                return true;
            }
            return false;
          }(o2, n2, l2);
        }
        isTileClipped() {
          return true;
        }
      }, symbol: mh, background: class extends Ra {
        constructor(t2) {
          super(t2, gh);
        }
        getProgramIds() {
          return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"];
        }
      }, raster: class extends Ra {
        constructor(t2) {
          super(t2, xh);
        }
        getProgramIds() {
          return ["raster"];
        }
      }, sky: class extends Ra {
        constructor(t2) {
          super(t2, bh), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(t2) {
          "sky-gradient" === t2 ? this._updateColorRamp() : "sky-atmosphere-sun" !== t2 && "sky-atmosphere-halo-color" !== t2 && "sky-atmosphere-color" !== t2 && "sky-atmosphere-sun-intensity" !== t2 || (this._skyboxInvalidated = true);
        }
        _updateColorRamp() {
          this.colorRamp = Xo({ expression: this._transitionablePaint._values["sky-gradient"].value.expression, evaluationKey: "skyRadialProgress" }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
        }
        needsSkyboxCapture(t2) {
          if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry)
            return true;
          if (!this.paint.get("sky-atmosphere-sun")) {
            const e2 = t2.style.light.properties.get("position");
            return this._lightPosition.azimuthal !== e2.azimuthal || this._lightPosition.polar !== e2.polar;
          }
        }
        getCenter(t2, e2) {
          const r2 = this.paint.get("sky-type");
          if ("atmosphere" === r2) {
            const r3 = this.paint.get("sky-atmosphere-sun"), n2 = !r3, i2 = t2.style.light, s2 = i2.properties.get("position");
            return n2 && "viewport" === i2.properties.get("anchor") && C("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), n2 ? wh(s2.azimuthal, 90 - s2.polar, e2) : wh(r3[0], 90 - r3[1], e2);
          }
          if ("gradient" === r2) {
            const t3 = this.paint.get("sky-gradient-center");
            return wh(t3[0], 90 - t3[1], e2);
          }
        }
        is3D() {
          return false;
        }
        isSky() {
          return true;
        }
        markSkyboxValid(t2) {
          this._skyboxInvalidated = false, this._lightPosition = t2.style.light.properties.get("position");
        }
        hasOffscreenPass() {
          return true;
        }
        getProgramIds() {
          const t2 = this.paint.get("sky-type");
          return "atmosphere" === t2 ? ["skyboxCapture", "skybox"] : "gradient" === t2 ? ["skyboxGradient"] : null;
        }
      } }, { HTMLImageElement: Ah, HTMLCanvasElement: kh, HTMLVideoElement: Sh, ImageData: Ih, ImageBitmap: zh } = a;
      class Th {
        constructor(t2, e2, r2, n2) {
          this.context = t2, this.format = r2, this.texture = t2.gl.createTexture(), this.update(e2, n2);
        }
        update(t2, e2, r2) {
          const { width: n2, height: i2 } = t2, s2 = !(this.size && this.size[0] === n2 && this.size[1] === i2 || r2), { context: a2 } = this, { gl: o2 } = a2;
          if (this.useMipmap = Boolean(e2 && e2.useMipmap), o2.bindTexture(o2.TEXTURE_2D, this.texture), a2.pixelStoreUnpackFlipY.set(false), a2.pixelStoreUnpack.set(1), a2.pixelStoreUnpackPremultiplyAlpha.set(this.format === o2.RGBA && (!e2 || false !== e2.premultiply)), s2)
            this.size = [n2, i2], t2 instanceof Ah || t2 instanceof kh || t2 instanceof Sh || t2 instanceof Ih || zh && t2 instanceof zh ? o2.texImage2D(o2.TEXTURE_2D, 0, this.format, this.format, o2.UNSIGNED_BYTE, t2) : o2.texImage2D(o2.TEXTURE_2D, 0, this.format, n2, i2, 0, this.format, o2.UNSIGNED_BYTE, t2.data);
          else {
            const { x: e3, y: s3 } = r2 || { x: 0, y: 0 };
            t2 instanceof Ah || t2 instanceof kh || t2 instanceof Sh || t2 instanceof Ih || zh && t2 instanceof zh ? o2.texSubImage2D(o2.TEXTURE_2D, 0, e3, s3, o2.RGBA, o2.UNSIGNED_BYTE, t2) : o2.texSubImage2D(o2.TEXTURE_2D, 0, e3, s3, n2, i2, o2.RGBA, o2.UNSIGNED_BYTE, t2.data);
          }
          this.useMipmap && this.isSizePowerOfTwo() && o2.generateMipmap(o2.TEXTURE_2D);
        }
        bind(t2, e2, r2) {
          const { context: n2 } = this, { gl: i2 } = n2;
          i2.bindTexture(i2.TEXTURE_2D, this.texture), r2 !== i2.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (r2 = i2.LINEAR), t2 !== this.filter && (i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MAG_FILTER, t2), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MIN_FILTER, r2 || t2), this.filter = t2), e2 !== this.wrap && (i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_S, e2), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_T, e2), this.wrap = e2);
        }
        isSizePowerOfTwo() {
          return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
        }
        destroy() {
          const { gl: t2 } = this.context;
          t2.deleteTexture(this.texture), this.texture = null;
        }
      }
      class Mh {
        constructor(t2, e2) {
          t2 && (e2 ? this.setSouthWest(t2).setNorthEast(e2) : 4 === t2.length ? this.setSouthWest([t2[0], t2[1]]).setNorthEast([t2[2], t2[3]]) : this.setSouthWest(t2[0]).setNorthEast(t2[1]));
        }
        setNorthEast(t2) {
          return this._ne = t2 instanceof Ch ? new Ch(t2.lng, t2.lat) : Ch.convert(t2), this;
        }
        setSouthWest(t2) {
          return this._sw = t2 instanceof Ch ? new Ch(t2.lng, t2.lat) : Ch.convert(t2), this;
        }
        extend(t2) {
          const e2 = this._sw, r2 = this._ne;
          let n2, i2;
          if (t2 instanceof Ch)
            n2 = t2, i2 = t2;
          else {
            if (!(t2 instanceof Mh))
              return Array.isArray(t2) ? 4 === t2.length || t2.every(Array.isArray) ? this.extend(Mh.convert(t2)) : this.extend(Ch.convert(t2)) : this;
            if (n2 = t2._sw, i2 = t2._ne, !n2 || !i2)
              return this;
          }
          return e2 || r2 ? (e2.lng = Math.min(n2.lng, e2.lng), e2.lat = Math.min(n2.lat, e2.lat), r2.lng = Math.max(i2.lng, r2.lng), r2.lat = Math.max(i2.lat, r2.lat)) : (this._sw = new Ch(n2.lng, n2.lat), this._ne = new Ch(i2.lng, i2.lat)), this;
        }
        getCenter() {
          return new Ch((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }
        getSouthWest() {
          return this._sw;
        }
        getNorthEast() {
          return this._ne;
        }
        getNorthWest() {
          return new Ch(this.getWest(), this.getNorth());
        }
        getSouthEast() {
          return new Ch(this.getEast(), this.getSouth());
        }
        getWest() {
          return this._sw.lng;
        }
        getSouth() {
          return this._sw.lat;
        }
        getEast() {
          return this._ne.lng;
        }
        getNorth() {
          return this._ne.lat;
        }
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        toString() {
          return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
        }
        isEmpty() {
          return !(this._sw && this._ne);
        }
        contains(t2) {
          const { lng: e2, lat: r2 } = Ch.convert(t2);
          let n2 = this._sw.lng <= e2 && e2 <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (n2 = this._sw.lng >= e2 && e2 >= this._ne.lng), this._sw.lat <= r2 && r2 <= this._ne.lat && n2;
        }
        static convert(t2) {
          return !t2 || t2 instanceof Mh ? t2 : new Mh(t2);
        }
      }
      const Eh = 63710088e-1;
      class Ch {
        constructor(t2, e2) {
          if (isNaN(t2) || isNaN(e2))
            throw new Error(`Invalid LngLat object: (${t2}, ${e2})`);
          if (this.lng = +t2, this.lat = +e2, this.lat > 90 || this.lat < -90)
            throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        }
        wrap() {
          return new Ch(m(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        distanceTo(t2) {
          const e2 = Math.PI / 180, r2 = this.lat * e2, n2 = t2.lat * e2, i2 = Math.sin(r2) * Math.sin(n2) + Math.cos(r2) * Math.cos(n2) * Math.cos((t2.lng - this.lng) * e2);
          return Eh * Math.acos(Math.min(i2, 1));
        }
        toBounds(t2 = 0) {
          const e2 = 360 * t2 / 40075017, r2 = e2 / Math.cos(Math.PI / 180 * this.lat);
          return new Mh(new Ch(this.lng - r2, this.lat - e2), new Ch(this.lng + r2, this.lat + e2));
        }
        static convert(t2) {
          if (t2 instanceof Ch)
            return t2;
          if (Array.isArray(t2) && (2 === t2.length || 3 === t2.length))
            return new Ch(Number(t2[0]), Number(t2[1]));
          if (!Array.isArray(t2) && "object" == typeof t2 && null !== t2)
            return new Ch(Number("lng" in t2 ? t2.lng : t2.lon), Number(t2.lat));
          throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        }
      }
      const Bh = 2 * Math.PI * Eh;
      function Dh(t2) {
        return Bh * Math.cos(t2 * Math.PI / 180);
      }
      function Ph(t2) {
        return (180 + t2) / 360;
      }
      function Vh(t2) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2 * Math.PI / 360))) / 360;
      }
      function Lh(t2, e2) {
        return t2 / Dh(e2);
      }
      function Fh(t2) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t2) * Math.PI / 180)) - 90;
      }
      function Rh(t2, e2) {
        return t2 * Dh(Fh(e2));
      }
      class $h {
        constructor(t2, e2, r2 = 0) {
          this.x = +t2, this.y = +e2, this.z = +r2;
        }
        static fromLngLat(t2, e2 = 0) {
          const r2 = Ch.convert(t2);
          return new $h(Ph(r2.lng), Vh(r2.lat), Lh(e2, r2.lat));
        }
        toLngLat() {
          return new Ch(360 * this.x - 180, Fh(this.y));
        }
        toAltitude() {
          return Rh(this.z, this.y);
        }
        meterInMercatorCoordinateUnits() {
          return 1 / Bh * (t2 = Fh(this.y), 1 / Math.cos(t2 * Math.PI / 180));
          var t2;
        }
      }
      class Uh {
        constructor(t2, e2) {
          this.width = t2, this.height = e2, this.nextRow = 0, this.image = new No({ width: t2, height: e2 }), this.positions = {}, this.uploaded = false;
        }
        getDash(t2, e2) {
          const r2 = this.getKey(t2, e2);
          return this.positions[r2];
        }
        trim() {
          const t2 = this.width, e2 = this.height = A(this.nextRow);
          this.image.resize({ width: t2, height: e2 });
        }
        getKey(t2, e2) {
          return t2.join(",") + e2;
        }
        getDashRanges(t2, e2, r2) {
          const n2 = [];
          let i2 = t2.length % 2 == 1 ? -t2[t2.length - 1] * r2 : 0, s2 = t2[0] * r2, a2 = true;
          n2.push({ left: i2, right: s2, isDash: a2, zeroLength: 0 === t2[0] });
          let o2 = t2[0];
          for (let e3 = 1; e3 < t2.length; e3++) {
            a2 = !a2;
            const l2 = t2[e3];
            i2 = o2 * r2, o2 += l2, s2 = o2 * r2, n2.push({ left: i2, right: s2, isDash: a2, zeroLength: 0 === l2 });
          }
          return n2;
        }
        addRoundDash(t2, e2, r2) {
          const n2 = e2 / 2;
          for (let e3 = -r2; e3 <= r2; e3++) {
            const i2 = this.width * (this.nextRow + r2 + e3);
            let s2 = 0, a2 = t2[s2];
            for (let o2 = 0; o2 < this.width; o2++) {
              o2 / a2.right > 1 && (a2 = t2[++s2]);
              const l2 = Math.abs(o2 - a2.left), u2 = Math.abs(o2 - a2.right), c2 = Math.min(l2, u2);
              let h2;
              const p2 = e3 / r2 * (n2 + 1);
              if (a2.isDash) {
                const t3 = n2 - Math.abs(p2);
                h2 = Math.sqrt(c2 * c2 + t3 * t3);
              } else
                h2 = n2 - Math.sqrt(c2 * c2 + p2 * p2);
              this.image.data[i2 + o2] = Math.max(0, Math.min(255, h2 + 128));
            }
          }
        }
        addRegularDash(t2, e2) {
          for (let e3 = t2.length - 1; e3 >= 0; --e3) {
            const r3 = t2[e3], n3 = t2[e3 + 1];
            r3.zeroLength ? t2.splice(e3, 1) : n3 && n3.isDash === r3.isDash && (n3.left = r3.left, t2.splice(e3, 1));
          }
          const r2 = t2[0], n2 = t2[t2.length - 1];
          r2.isDash === n2.isDash && (r2.left = n2.left - this.width, n2.right = r2.right + this.width);
          const i2 = this.width * this.nextRow;
          let s2 = 0, a2 = t2[s2];
          for (let r3 = 0; r3 < this.width; r3++) {
            r3 / a2.right > 1 && (a2 = t2[++s2]);
            const n3 = Math.abs(r3 - a2.left), o2 = Math.abs(r3 - a2.right), l2 = Math.min(n3, o2);
            this.image.data[i2 + r3] = Math.max(0, Math.min(255, (a2.isDash ? l2 : -l2) + e2 + 128));
          }
        }
        addDash(t2, e2) {
          const r2 = this.getKey(t2, e2);
          if (this.positions[r2])
            return this.positions[r2];
          const n2 = "round" === e2, i2 = n2 ? 7 : 0, s2 = 2 * i2 + 1;
          if (this.nextRow + s2 > this.height)
            return C("LineAtlas out of space"), null;
          0 === t2.length && t2.push(1);
          let a2 = 0;
          for (let e3 = 0; e3 < t2.length; e3++)
            t2[e3] < 0 && (C("Negative value is found in line dasharray, replacing values with 0"), t2[e3] = 0), a2 += t2[e3];
          if (0 !== a2) {
            const r3 = this.width / a2, s3 = this.getDashRanges(t2, this.width, r3);
            n2 ? this.addRoundDash(s3, r3, i2) : this.addRegularDash(s3, "square" === e2 ? 0.5 * r3 : 0);
          }
          const o2 = this.nextRow + i2;
          this.nextRow += s2;
          const l2 = { tl: [o2, i2], br: [a2, 0] };
          return this.positions[r2] = l2, l2;
        }
      }
      oi("LineAtlas", Uh);
      class Oh {
        constructor(t2) {
          this._callback = t2, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
            this._triggered = false, this._callback();
          });
        }
        trigger() {
          this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
            this._triggered = false, this._callback();
          }, 0));
        }
        remove() {
          delete this._channel, this._callback = () => {
          };
        }
      }
      const qh = a.performance;
      function jh(t2) {
        const e2 = t2 ? t2.url.toString() : void 0;
        return qh.getEntriesByName(e2);
      }
      class Nh {
        constructor() {
          this.tasks = {}, this.taskQueue = [], S(["process"], this), this.invoker = new Oh(this.process), this.nextId = 0;
        }
        add(t2, e2) {
          const r2 = this.nextId++, n2 = function({ type: t3, isSymbolTile: e3, zoom: r3 }) {
            return r3 = r3 || 0, "message" === t3 ? 0 : "maybePrepare" !== t3 || e3 ? "parseTile" !== t3 || e3 ? "parseTile" === t3 && e3 ? 300 - r3 : "maybePrepare" === t3 && e3 ? 400 - r3 : 500 : 200 - r3 : 100 - r3;
          }(e2);
          if (0 === n2) {
            P();
            try {
              t2();
            } finally {
            }
            return { cancel: () => {
            } };
          }
          return this.tasks[r2] = { fn: t2, metadata: e2, priority: n2, id: r2 }, this.taskQueue.push(r2), this.invoker.trigger(), { cancel: () => {
            delete this.tasks[r2];
          } };
        }
        process() {
          P();
          try {
            if (this.taskQueue = this.taskQueue.filter((t3) => !!this.tasks[t3]), !this.taskQueue.length)
              return;
            const t2 = this.pick();
            if (null === t2)
              return;
            const e2 = this.tasks[t2];
            if (delete this.tasks[t2], this.taskQueue.length && this.invoker.trigger(), !e2)
              return;
            e2.fn();
          } finally {
          }
        }
        pick() {
          let t2 = null, e2 = 1 / 0;
          for (let r3 = 0; r3 < this.taskQueue.length; r3++) {
            const n2 = this.tasks[this.taskQueue[r3]];
            n2.priority < e2 && (e2 = n2.priority, t2 = r3);
          }
          if (null === t2)
            return null;
          const r2 = this.taskQueue[t2];
          return this.taskQueue.splice(t2, 1), r2;
        }
        remove() {
          this.invoker.remove();
        }
      }
      function Zh(t2, e2, r2) {
        var n2 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r2);
        return [t2 * n2 - 2 * Math.PI * 6378137 / 2, e2 * n2 - 2 * Math.PI * 6378137 / 2];
      }
      class Gh {
        constructor(t2, e2, r2) {
          this.z = t2, this.x = e2, this.y = r2, this.key = Yh(0, t2, t2, e2, r2);
        }
        equals(t2) {
          return this.z === t2.z && this.x === t2.x && this.y === t2.y;
        }
        url(t2, e2) {
          const r2 = (i2 = this.y, s2 = this.z, a2 = Zh(256 * (n2 = this.x), 256 * (i2 = Math.pow(2, s2) - i2 - 1), s2), o2 = Zh(256 * (n2 + 1), 256 * (i2 + 1), s2), a2[0] + "," + a2[1] + "," + o2[0] + "," + o2[1]);
          var n2, i2, s2, a2, o2;
          const l2 = function(t3, e3, r3) {
            let n3, i3 = "";
            for (let s3 = t3; s3 > 0; s3--)
              n3 = 1 << s3 - 1, i3 += (e3 & n3 ? 1 : 0) + (r3 & n3 ? 2 : 0);
            return i3;
          }(this.z, this.x, this.y);
          return t2[(this.x + this.y) % t2.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace("{z}", String(this.z)).replace("{x}", String(this.x)).replace("{y}", String("tms" === e2 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", l2).replace("{bbox-epsg-3857}", r2);
        }
        getTilePoint(t2) {
          const e2 = Math.pow(2, this.z);
          return new i((t2.x * e2 - this.x) * qa, (t2.y * e2 - this.y) * qa);
        }
        getTileVec3(t2) {
          const e2 = Math.pow(2, this.z);
          return wo((t2.x * e2 - this.x) * qa, (t2.y * e2 - this.y) * qa, Rh(t2.z, t2.y));
        }
        toString() {
          return `${this.z}/${this.x}/${this.y}`;
        }
      }
      class Xh {
        constructor(t2, e2) {
          this.wrap = t2, this.canonical = e2, this.key = Yh(t2, e2.z, e2.z, e2.x, e2.y);
        }
      }
      class Kh {
        constructor(t2, e2, r2, n2, i2) {
          this.overscaledZ = t2, this.wrap = e2, this.canonical = new Gh(r2, +n2, +i2), this.key = 0 === e2 && t2 === r2 ? this.canonical.key : Yh(e2, t2, r2, n2, i2);
        }
        equals(t2) {
          return this.overscaledZ === t2.overscaledZ && this.wrap === t2.wrap && this.canonical.equals(t2.canonical);
        }
        scaledTo(t2) {
          const e2 = this.canonical.z - t2;
          return t2 > this.canonical.z ? new Kh(t2, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Kh(t2, this.wrap, t2, this.canonical.x >> e2, this.canonical.y >> e2);
        }
        calculateScaledKey(t2, e2 = true) {
          if (this.overscaledZ === t2 && e2)
            return this.key;
          if (t2 > this.canonical.z)
            return Yh(this.wrap * +e2, t2, this.canonical.z, this.canonical.x, this.canonical.y);
          {
            const r2 = this.canonical.z - t2;
            return Yh(this.wrap * +e2, t2, t2, this.canonical.x >> r2, this.canonical.y >> r2);
          }
        }
        isChildOf(t2) {
          if (t2.wrap !== this.wrap)
            return false;
          const e2 = this.canonical.z - t2.canonical.z;
          return 0 === t2.overscaledZ || t2.overscaledZ < this.overscaledZ && t2.canonical.x === this.canonical.x >> e2 && t2.canonical.y === this.canonical.y >> e2;
        }
        children(t2) {
          if (this.overscaledZ >= t2)
            return [new Kh(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          const e2 = this.canonical.z + 1, r2 = 2 * this.canonical.x, n2 = 2 * this.canonical.y;
          return [new Kh(e2, this.wrap, e2, r2, n2), new Kh(e2, this.wrap, e2, r2 + 1, n2), new Kh(e2, this.wrap, e2, r2, n2 + 1), new Kh(e2, this.wrap, e2, r2 + 1, n2 + 1)];
        }
        isLessThan(t2) {
          return this.wrap < t2.wrap || !(this.wrap > t2.wrap) && (this.overscaledZ < t2.overscaledZ || !(this.overscaledZ > t2.overscaledZ) && (this.canonical.x < t2.canonical.x || !(this.canonical.x > t2.canonical.x) && this.canonical.y < t2.canonical.y));
        }
        wrapped() {
          return new Kh(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        unwrapTo(t2) {
          return new Kh(this.overscaledZ, t2, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        overscaleFactor() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new Xh(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
        getTilePoint(t2) {
          return this.canonical.getTilePoint(new $h(t2.x - this.wrap, t2.y));
        }
        getTileVec3(t2) {
          return this.canonical.getTileVec3(new $h(t2.x - this.wrap, t2.y, t2.z));
        }
      }
      function Yh(t2, e2, r2, n2, i2) {
        const s2 = 1 << Math.min(r2, 22);
        let a2 = s2 * (i2 % s2) + n2 % s2;
        return t2 && r2 < 22 && (a2 += s2 * s2 * ((t2 < 0 ? -2 * t2 - 1 : 2 * t2) % (1 << 2 * (22 - r2)))), 16 * (32 * a2 + r2) + (e2 - r2);
      }
      oi("CanonicalTileID", Gh), oi("OverscaledTileID", Kh, { omit: ["projMatrix"] });
      class Hh {
        constructor(t2) {
          this._stringToNumber = {}, this._numberToString = [];
          for (let e2 = 0; e2 < t2.length; e2++) {
            const r2 = t2[e2];
            this._stringToNumber[r2] = e2, this._numberToString[e2] = r2;
          }
        }
        encode(t2) {
          return this._stringToNumber[t2];
        }
        decode(t2) {
          return this._numberToString[t2];
        }
      }
      class Jh {
        constructor(t2, e2, r2, n2, i2) {
          this.type = "Feature", this._vectorTileFeature = t2, t2._z = e2, t2._x = r2, t2._y = n2, this.properties = t2.properties, this.id = i2;
        }
        get geometry() {
          return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
        }
        set geometry(t2) {
          this._geometry = t2;
        }
        toJSON() {
          const t2 = { geometry: this.geometry };
          for (const e2 in this)
            "_geometry" !== e2 && "_vectorTileFeature" !== e2 && (t2[e2] = this[e2]);
          return t2;
        }
      }
      var Wh = Ss([{ name: "a_pos", type: "Int16", components: 2 }]);
      class Qh {
        constructor(t2, e2, r2) {
          this.tileID = t2, this.uid = w(), this.uses = 0, this.tileSize = e2, this.tileZoom = r2, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.expiredRequestCount = 0, this.state = "loading";
        }
        registerFadeDuration(t2) {
          const e2 = t2 + this.timeAdded;
          e2 < q.now() || this.fadeEndTime && e2 < this.fadeEndTime || (this.fadeEndTime = e2);
        }
        wasRequested() {
          return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
        }
        loadVectorData(t2, e2, r2) {
          if (this.hasData() && this.unloadVectorData(), this.state = "loaded", t2) {
            t2.featureIndex && (this.latestFeatureIndex = t2.featureIndex, t2.rawTileData ? (this.latestRawTileData = t2.rawTileData, this.latestFeatureIndex.rawTileData = t2.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t2.collisionBoxArray, this.buckets = function(t3, e3) {
              const r3 = {};
              if (!e3)
                return r3;
              for (const n2 of t3) {
                const t4 = n2.layerIds.map((t5) => e3.getLayer(t5)).filter(Boolean);
                if (0 !== t4.length) {
                  n2.layers = t4, n2.stateDependentLayerIds && (n2.stateDependentLayers = n2.stateDependentLayerIds.map((e4) => t4.filter((t5) => t5.id === e4)[0]));
                  for (const e4 of t4)
                    r3[e4.id] = n2;
                }
              }
              return r3;
            }(t2.buckets, e2.style), this.hasSymbolBuckets = false;
            for (const t3 in this.buckets) {
              const e3 = this.buckets[t3];
              if (e3 instanceof ph) {
                if (this.hasSymbolBuckets = true, !r2)
                  break;
                e3.justReloaded = true;
              }
            }
            if (this.hasRTLText = false, this.hasSymbolBuckets)
              for (const t3 in this.buckets) {
                const e3 = this.buckets[t3];
                if (e3 instanceof ph && e3.hasRTLText) {
                  this.hasRTLText = true, ss.isLoading() || ss.isLoaded() || "deferred" !== ns() || is();
                  break;
                }
              }
            this.queryPadding = 0;
            for (const t3 in this.buckets) {
              const r3 = this.buckets[t3];
              this.queryPadding = Math.max(this.queryPadding, e2.style.getLayer(t3).queryRadius(r3));
            }
            t2.imageAtlas && (this.imageAtlas = t2.imageAtlas), t2.glyphAtlasImage && (this.glyphAtlasImage = t2.glyphAtlasImage), t2.lineAtlas && (this.lineAtlas = t2.lineAtlas);
          } else
            this.collisionBoxArray = new Js();
        }
        unloadVectorData() {
          for (const t2 in this.buckets)
            this.buckets[t2].destroy();
          this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
        }
        getBucket(t2) {
          return this.buckets[t2.id];
        }
        upload(t2) {
          for (const e3 in this.buckets) {
            const r2 = this.buckets[e3];
            r2.uploadPending() && r2.upload(t2);
          }
          const e2 = t2.gl;
          this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new Th(t2, this.imageAtlas.image, e2.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new Th(t2, this.glyphAtlasImage, e2.ALPHA), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new Th(t2, this.lineAtlas.image, e2.ALPHA), this.lineAtlas.uploaded = true);
        }
        prepare(t2) {
          this.imageAtlas && this.imageAtlas.patchUpdatedImages(t2, this.imageAtlasTexture);
        }
        queryRenderedFeatures(t2, e2, r2, n2, i2, s2, a2, o2) {
          return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ tileResult: n2, pixelPosMatrix: a2, transform: s2, params: i2 }, t2, e2, r2) : {};
        }
        querySourceFeatures(t2, e2) {
          const r2 = this.latestFeatureIndex;
          if (!r2 || !r2.rawTileData)
            return;
          const n2 = r2.loadVTLayers(), i2 = e2 ? e2.sourceLayer : "", s2 = n2._geojsonTileLayer || n2[i2];
          if (!s2)
            return;
          const a2 = kn(e2 && e2.filter), { z: o2, x: l2, y: u2 } = this.tileID.canonical, c2 = { z: o2, x: l2, y: u2 };
          for (let e3 = 0; e3 < s2.length; e3++) {
            const n3 = s2.feature(e3);
            if (a2.needGeometry) {
              const t3 = Ga(n3, true);
              if (!a2.filter(new as(this.tileID.overscaledZ), t3, this.tileID.canonical))
                continue;
            } else if (!a2.filter(new as(this.tileID.overscaledZ), n3))
              continue;
            const h2 = r2.getId(n3, i2), p2 = new Jh(n3, o2, l2, u2, h2);
            p2.tile = c2, t2.push(p2);
          }
        }
        hasData() {
          return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
        }
        patternsLoaded() {
          return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }
        setExpiryData(t2) {
          const e2 = this.expirationTime;
          if (t2.cacheControl) {
            const e3 = V(t2.cacheControl);
            e3["max-age"] && (this.expirationTime = Date.now() + 1e3 * e3["max-age"]);
          } else
            t2.expires && (this.expirationTime = new Date(t2.expires).getTime());
          if (this.expirationTime) {
            const t3 = Date.now();
            let r2 = false;
            if (this.expirationTime > t3)
              r2 = false;
            else if (e2)
              if (this.expirationTime < e2)
                r2 = true;
              else {
                const n2 = this.expirationTime - e2;
                n2 ? this.expirationTime = t3 + Math.max(n2, 3e4) : r2 = true;
              }
            else
              r2 = true;
            r2 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
          }
        }
        getExpiryTimeout() {
          if (this.expirationTime)
            return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
        }
        setFeatureState(t2, e2) {
          if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(t2).length)
            return;
          const r2 = this.latestFeatureIndex.loadVTLayers();
          for (const n2 in this.buckets) {
            if (!e2.style.hasLayer(n2))
              continue;
            const i2 = this.buckets[n2], s2 = i2.layers[0].sourceLayer || "_geojsonTileLayer", a2 = r2[s2], o2 = t2[s2];
            if (!a2 || !o2 || 0 === Object.keys(o2).length)
              continue;
            i2.update(o2, a2, this.imageAtlas && this.imageAtlas.patternPositions || {});
            const l2 = e2 && e2.style && e2.style.getLayer(n2);
            l2 && (this.queryPadding = Math.max(this.queryPadding, l2.queryRadius(i2)));
          }
        }
        holdingForFade() {
          return void 0 !== this.symbolFadeHoldUntil;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < q.now();
        }
        clearFadeHold() {
          this.symbolFadeHoldUntil = void 0;
        }
        setHoldDuration(t2) {
          this.symbolFadeHoldUntil = q.now() + t2;
        }
        setDependencies(t2, e2) {
          const r2 = {};
          for (const t3 of e2)
            r2[t3] = true;
          this.dependencies[t2] = r2;
        }
        hasDependency(t2, e2) {
          for (const r2 of t2) {
            const t3 = this.dependencies[r2];
            if (t3) {
              for (const r3 of e2)
                if (t3[r3])
                  return true;
            }
          }
          return false;
        }
        clearQueryDebugViz() {
        }
      }
      class tp {
        constructor() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        }
        updateState(t2, e2, r2) {
          const n2 = String(e2);
          if (this.stateChanges[t2] = this.stateChanges[t2] || {}, this.stateChanges[t2][n2] = this.stateChanges[t2][n2] || {}, v(this.stateChanges[t2][n2], r2), null === this.deletedStates[t2]) {
            this.deletedStates[t2] = {};
            for (const e3 in this.state[t2])
              e3 !== n2 && (this.deletedStates[t2][e3] = null);
          } else if (this.deletedStates[t2] && null === this.deletedStates[t2][n2]) {
            this.deletedStates[t2][n2] = {};
            for (const e3 in this.state[t2][n2])
              r2[e3] || (this.deletedStates[t2][n2][e3] = null);
          } else
            for (const e3 in r2)
              this.deletedStates[t2] && this.deletedStates[t2][n2] && null === this.deletedStates[t2][n2][e3] && delete this.deletedStates[t2][n2][e3];
        }
        removeFeatureState(t2, e2, r2) {
          if (null === this.deletedStates[t2])
            return;
          const n2 = String(e2);
          if (this.deletedStates[t2] = this.deletedStates[t2] || {}, r2 && void 0 !== e2)
            null !== this.deletedStates[t2][n2] && (this.deletedStates[t2][n2] = this.deletedStates[t2][n2] || {}, this.deletedStates[t2][n2][r2] = null);
          else if (void 0 !== e2)
            if (this.stateChanges[t2] && this.stateChanges[t2][n2])
              for (r2 in this.deletedStates[t2][n2] = {}, this.stateChanges[t2][n2])
                this.deletedStates[t2][n2][r2] = null;
            else
              this.deletedStates[t2][n2] = null;
          else
            this.deletedStates[t2] = null;
        }
        getState(t2, e2) {
          const r2 = String(e2), n2 = v({}, (this.state[t2] || {})[r2], (this.stateChanges[t2] || {})[r2]);
          if (null === this.deletedStates[t2])
            return {};
          if (this.deletedStates[t2]) {
            const r3 = this.deletedStates[t2][e2];
            if (null === r3)
              return {};
            for (const t3 in r3)
              delete n2[t3];
          }
          return n2;
        }
        initializeTileState(t2, e2) {
          t2.setFeatureState(this.state, e2);
        }
        coalesceChanges(t2, e2) {
          const r2 = {};
          for (const t3 in this.stateChanges) {
            this.state[t3] = this.state[t3] || {};
            const e3 = {};
            for (const r3 in this.stateChanges[t3])
              this.state[t3][r3] || (this.state[t3][r3] = {}), v(this.state[t3][r3], this.stateChanges[t3][r3]), e3[r3] = this.state[t3][r3];
            r2[t3] = e3;
          }
          for (const t3 in this.deletedStates) {
            this.state[t3] = this.state[t3] || {};
            const e3 = {};
            if (null === this.deletedStates[t3])
              for (const r3 in this.state[t3])
                e3[r3] = {}, this.state[t3][r3] = {};
            else
              for (const r3 in this.deletedStates[t3]) {
                if (null === this.deletedStates[t3][r3])
                  this.state[t3][r3] = {};
                else
                  for (const e4 of Object.keys(this.deletedStates[t3][r3]))
                    delete this.state[t3][r3][e4];
                e3[r3] = this.state[t3][r3];
              }
            r2[t3] = r2[t3] || {}, v(r2[t3], e3);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(r2).length)
            for (const n2 in t2)
              t2[n2].setFeatureState(r2, e2);
        }
      }
      class ep {
        constructor(t2) {
          this.size = t2, this.minimums = [], this.maximums = [], this.leaves = [];
        }
        getElevation(t2, e2) {
          const r2 = this.toIdx(t2, e2);
          return { min: this.minimums[r2], max: this.maximums[r2] };
        }
        isLeaf(t2, e2) {
          return this.leaves[this.toIdx(t2, e2)];
        }
        toIdx(t2, e2) {
          return e2 * this.size + t2;
        }
      }
      function rp(t2, e2, r2, n2) {
        let i2 = 0, s2 = Number.MAX_VALUE;
        for (let a2 = 0; a2 < 3; a2++)
          if (Math.abs(n2[a2]) < 1e-15) {
            if (r2[a2] < t2[a2] || r2[a2] > e2[a2])
              return null;
          } else {
            const o2 = 1 / n2[a2];
            let l2 = (t2[a2] - r2[a2]) * o2, u2 = (e2[a2] - r2[a2]) * o2;
            if (l2 > u2) {
              const t3 = l2;
              l2 = u2, u2 = t3;
            }
            if (l2 > i2 && (i2 = l2), u2 < s2 && (s2 = u2), i2 > s2)
              return null;
          }
        return i2;
      }
      function np(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2) {
        const h2 = n2 - t2, p2 = i2 - e2, d2 = s2 - r2, f2 = a2 - t2, y2 = o2 - e2, m2 = l2 - r2, g2 = c2[1] * m2 - c2[2] * y2, x2 = c2[2] * f2 - c2[0] * m2, v2 = c2[0] * y2 - c2[1] * f2, b2 = h2 * g2 + p2 * x2 + d2 * v2;
        if (Math.abs(b2) < 1e-15)
          return null;
        const w2 = 1 / b2, _2 = u2[0] - t2, A2 = u2[1] - e2, k2 = u2[2] - r2, S2 = (_2 * g2 + A2 * x2 + k2 * v2) * w2;
        if (S2 < 0 || S2 > 1)
          return null;
        const I2 = A2 * d2 - k2 * p2, z2 = k2 * h2 - _2 * d2, T2 = _2 * p2 - A2 * h2, M2 = (c2[0] * I2 + c2[1] * z2 + c2[2] * T2) * w2;
        return M2 < 0 || S2 + M2 > 1 ? null : (f2 * I2 + y2 * z2 + m2 * T2) * w2;
      }
      function ip(t2, e2, r2) {
        return (t2 - e2) / (r2 - e2);
      }
      function sp(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
        const u2 = 1 << r2, c2 = s2 - n2, h2 = a2 - i2, p2 = (t2 + 1) / u2 * c2 + n2, d2 = (e2 + 0) / u2 * h2 + i2, f2 = (e2 + 1) / u2 * h2 + i2;
        o2[0] = (t2 + 0) / u2 * c2 + n2, o2[1] = d2, l2[0] = p2, l2[1] = f2;
      }
      class ap {
        constructor(t2) {
          if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t2, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem)
            return;
          const e2 = function(t3) {
            const e3 = Math.ceil(Math.log2(t3.dim / 8)), r3 = [];
            let n3 = Math.ceil(Math.pow(2, e3));
            const i2 = 1 / n3, s2 = (t4, e4, r4, n4, i3) => {
              const s3 = n4 ? 1 : 0, a3 = (t4 + 1) * r4 - s3, o3 = e4 * r4, l2 = (e4 + 1) * r4 - s3;
              i3[0] = t4 * r4, i3[1] = o3, i3[2] = a3, i3[3] = l2;
            };
            let a2 = new ep(n3);
            const o2 = [];
            for (let e4 = 0; e4 < n3 * n3; e4++) {
              s2(e4 % n3, Math.floor(e4 / n3), i2, false, o2);
              const r4 = lp(o2[0], o2[1], t3), l2 = lp(o2[2], o2[1], t3), u2 = lp(o2[2], o2[3], t3), c2 = lp(o2[0], o2[3], t3);
              a2.minimums.push(Math.min(r4, l2, u2, c2)), a2.maximums.push(Math.max(r4, l2, u2, c2)), a2.leaves.push(1);
            }
            for (r3.push(a2), n3 /= 2; n3 >= 1; n3 /= 2) {
              const t4 = r3[r3.length - 1];
              a2 = new ep(n3);
              for (let e4 = 0; e4 < n3 * n3; e4++) {
                s2(e4 % n3, Math.floor(e4 / n3), 2, true, o2);
                const r4 = t4.getElevation(o2[0], o2[1]), i3 = t4.getElevation(o2[2], o2[1]), l2 = t4.getElevation(o2[2], o2[3]), u2 = t4.getElevation(o2[0], o2[3]), c2 = t4.isLeaf(o2[0], o2[1]), h2 = t4.isLeaf(o2[2], o2[1]), p2 = t4.isLeaf(o2[2], o2[3]), d2 = t4.isLeaf(o2[0], o2[3]), f2 = Math.min(r4.min, i3.min, l2.min, u2.min), y2 = Math.max(r4.max, i3.max, l2.max, u2.max), m2 = c2 && h2 && p2 && d2;
                a2.maximums.push(y2), a2.minimums.push(f2), a2.leaves.push(y2 - f2 <= 5 && m2 ? 1 : 0);
              }
              r3.push(a2);
            }
            return r3;
          }(this.dem), r2 = e2.length - 1, n2 = e2[r2];
          this._addNode(n2.minimums[0], n2.maximums[0], n2.leaves[0]), this._construct(e2, 0, 0, r2, 0);
        }
        raycastRoot(t2, e2, r2, n2, i2, s2, a2 = 1) {
          return rp([t2, e2, -100], [r2, n2, this.maximums[0] * a2], i2, s2);
        }
        raycast(t2, e2, r2, n2, i2, s2, a2 = 1) {
          if (!this.nodeCount)
            return null;
          const o2 = this.raycastRoot(t2, e2, r2, n2, i2, s2, a2);
          if (null == o2)
            return null;
          const l2 = [], u2 = [], c2 = [], h2 = [], p2 = [{ idx: 0, t: o2, nodex: 0, nodey: 0, depth: 0 }];
          for (; p2.length > 0; ) {
            const { idx: o3, t: d2, nodex: f2, nodey: y2, depth: m2 } = p2.pop();
            if (this.leaves[o3]) {
              sp(f2, y2, m2, t2, e2, r2, n2, c2, h2);
              const o4 = 1 << m2, l3 = (f2 + 0) / o4, u3 = (f2 + 1) / o4, p3 = (y2 + 0) / o4, g3 = (y2 + 1) / o4, x2 = lp(l3, p3, this.dem) * a2, v2 = lp(u3, p3, this.dem) * a2, b2 = lp(u3, g3, this.dem) * a2, w2 = lp(l3, g3, this.dem) * a2, _2 = np(c2[0], c2[1], x2, h2[0], c2[1], v2, h2[0], h2[1], b2, i2, s2), A2 = np(h2[0], h2[1], b2, c2[0], h2[1], w2, c2[0], c2[1], x2, i2, s2), k2 = Math.min(null !== _2 ? _2 : Number.MAX_VALUE, null !== A2 ? A2 : Number.MAX_VALUE);
              if (k2 !== Number.MAX_VALUE)
                return k2;
              {
                const t3 = ko([], i2, s2, d2);
                if (op(x2, v2, w2, b2, ip(t3[0], c2[0], h2[0]), ip(t3[1], c2[1], h2[1])) >= t3[2])
                  return d2;
              }
              continue;
            }
            let g2 = 0;
            for (let p3 = 0; p3 < this._siblingOffset.length; p3++) {
              sp((f2 << 1) + this._siblingOffset[p3][0], (y2 << 1) + this._siblingOffset[p3][1], m2 + 1, t2, e2, r2, n2, c2, h2), c2[2] = -100, h2[2] = this.maximums[this.childOffsets[o3] + p3] * a2;
              const d3 = rp(c2, h2, i2, s2);
              if (null != d3) {
                const t3 = d3;
                l2[p3] = t3;
                let e3 = false;
                for (let r3 = 0; r3 < g2 && !e3; r3++)
                  t3 >= l2[u2[r3]] && (u2.splice(r3, 0, p3), e3 = true);
                e3 || (u2[g2] = p3), g2++;
              }
            }
            for (let t3 = 0; t3 < g2; t3++) {
              const e3 = u2[t3];
              p2.push({ idx: this.childOffsets[o3] + e3, t: l2[e3], nodex: (f2 << 1) + this._siblingOffset[e3][0], nodey: (y2 << 1) + this._siblingOffset[e3][1], depth: m2 + 1 });
            }
          }
          return null;
        }
        _addNode(t2, e2, r2) {
          return this.minimums.push(t2), this.maximums.push(e2), this.leaves.push(r2), this.childOffsets.push(0), this.nodeCount++;
        }
        _construct(t2, e2, r2, n2, i2) {
          if (1 === t2[n2].isLeaf(e2, r2))
            return;
          this.childOffsets[i2] || (this.childOffsets[i2] = this.nodeCount);
          const s2 = n2 - 1, a2 = t2[s2];
          let o2, l2 = 0;
          for (let t3 = 0; t3 < this._siblingOffset.length; t3++) {
            const n3 = 2 * e2 + this._siblingOffset[t3][0], i3 = 2 * r2 + this._siblingOffset[t3][1], s3 = a2.getElevation(n3, i3), u2 = a2.isLeaf(n3, i3), c2 = this._addNode(s3.min, s3.max, u2);
            u2 && (l2 |= 1 << t3), o2 || (o2 = c2);
          }
          for (let n3 = 0; n3 < this._siblingOffset.length; n3++)
            l2 & 1 << n3 || this._construct(t2, 2 * e2 + this._siblingOffset[n3][0], 2 * r2 + this._siblingOffset[n3][1], s2, o2 + n3);
        }
      }
      function op(t2, e2, r2, n2, i2, s2) {
        return rr(rr(t2, r2, s2), rr(e2, n2, s2), i2);
      }
      function lp(t2, e2, r2) {
        const n2 = r2.dim, i2 = y(t2 * n2 - 0.5, 0, n2 - 1), s2 = y(e2 * n2 - 0.5, 0, n2 - 1), a2 = Math.floor(i2), o2 = Math.floor(s2), l2 = Math.min(a2 + 1, n2 - 1), u2 = Math.min(o2 + 1, n2 - 1);
        return op(r2.get(a2, o2), r2.get(l2, o2), r2.get(a2, u2), r2.get(l2, u2), i2 - a2, s2 - o2);
      }
      const up = { mapbox: [6553.6, 25.6, 0.1, 1e4], terrarium: [256, 1, 1 / 256, 32768] };
      class cp {
        get tree() {
          return this._tree || this._buildQuadTree(), this._tree;
        }
        constructor(t2, e2, r2, n2 = false, i2 = false) {
          if (this.uid = t2, e2.height !== e2.width)
            throw new RangeError("DEM tiles must be square");
          if (r2 && "mapbox" !== r2 && "terrarium" !== r2)
            return C(`"${r2}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
          this.stride = e2.height;
          const s2 = this.dim = e2.height - 2;
          if (this.data = new Uint32Array(e2.data.buffer), this.encoding = r2 || "mapbox", this.borderReady = n2, !n2) {
            for (let t3 = 0; t3 < s2; t3++)
              this.data[this._idx(-1, t3)] = this.data[this._idx(0, t3)], this.data[this._idx(s2, t3)] = this.data[this._idx(s2 - 1, t3)], this.data[this._idx(t3, -1)] = this.data[this._idx(t3, 0)], this.data[this._idx(t3, s2)] = this.data[this._idx(t3, s2 - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(s2, -1)] = this.data[this._idx(s2 - 1, 0)], this.data[this._idx(-1, s2)] = this.data[this._idx(0, s2 - 1)], this.data[this._idx(s2, s2)] = this.data[this._idx(s2 - 1, s2 - 1)], i2 && this._buildQuadTree();
          }
        }
        _buildQuadTree() {
          this._tree = new ap(this);
        }
        get(t2, e2, r2 = false) {
          const n2 = new Uint8Array(this.data.buffer);
          r2 && (t2 = y(t2, -1, this.dim), e2 = y(e2, -1, this.dim));
          const i2 = 4 * this._idx(t2, e2);
          return ("terrarium" === this.encoding ? this._unpackTerrarium : this._unpackMapbox)(n2[i2], n2[i2 + 1], n2[i2 + 2]);
        }
        static getUnpackVector(t2) {
          return up[t2];
        }
        get unpackVector() {
          return up[this.encoding];
        }
        _idx(t2, e2) {
          if (t2 < -1 || t2 >= this.dim + 1 || e2 < -1 || e2 >= this.dim + 1)
            throw new RangeError("out of range source coordinates for DEM data");
          return (e2 + 1) * this.stride + (t2 + 1);
        }
        _unpackMapbox(t2, e2, r2) {
          return (256 * t2 * 256 + 256 * e2 + r2) / 10 - 1e4;
        }
        _unpackTerrarium(t2, e2, r2) {
          return 256 * t2 + e2 + r2 / 256 - 32768;
        }
        static pack(t2, e2) {
          const r2 = [0, 0, 0, 0], n2 = cp.getUnpackVector(e2);
          let i2 = Math.floor((t2 + n2[3]) / n2[2]);
          return r2[2] = i2 % 256, i2 = Math.floor(i2 / 256), r2[1] = i2 % 256, i2 = Math.floor(i2 / 256), r2[0] = i2, r2;
        }
        getPixels() {
          return new Zo({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
        }
        backfillBorder(t2, e2, r2) {
          if (this.dim !== t2.dim)
            throw new Error("dem dimension mismatch");
          let n2 = e2 * this.dim, i2 = e2 * this.dim + this.dim, s2 = r2 * this.dim, a2 = r2 * this.dim + this.dim;
          switch (e2) {
            case -1:
              n2 = i2 - 1;
              break;
            case 1:
              i2 = n2 + 1;
          }
          switch (r2) {
            case -1:
              s2 = a2 - 1;
              break;
            case 1:
              a2 = s2 + 1;
          }
          const o2 = -e2 * this.dim, l2 = -r2 * this.dim;
          for (let e3 = s2; e3 < a2; e3++)
            for (let r3 = n2; r3 < i2; r3++)
              this.data[this._idx(r3, e3)] = t2.data[this._idx(r3 + o2, e3 + l2)];
        }
        onDeserialize() {
          this._tree && (this._tree.dem = this);
        }
      }
      oi("DEMData", cp), oi("DemMinMaxQuadTree", ap, { omit: ["dem"] });
      class hp {
        constructor(t2, e2) {
          this.max = t2, this.onRemove = e2, this.reset();
        }
        reset() {
          for (const t2 in this.data)
            for (const e2 of this.data[t2])
              e2.timeout && clearTimeout(e2.timeout), this.onRemove(e2.value);
          return this.data = {}, this.order = [], this;
        }
        add(t2, e2, r2) {
          const n2 = t2.wrapped().key;
          void 0 === this.data[n2] && (this.data[n2] = []);
          const i2 = { value: e2, timeout: void 0 };
          if (void 0 !== r2 && (i2.timeout = setTimeout(() => {
            this.remove(t2, i2);
          }, r2)), this.data[n2].push(i2), this.order.push(n2), this.order.length > this.max) {
            const t3 = this._getAndRemoveByKey(this.order[0]);
            t3 && this.onRemove(t3);
          }
          return this;
        }
        has(t2) {
          return t2.wrapped().key in this.data;
        }
        getAndRemove(t2) {
          return this.has(t2) ? this._getAndRemoveByKey(t2.wrapped().key) : null;
        }
        _getAndRemoveByKey(t2) {
          const e2 = this.data[t2].shift();
          return e2.timeout && clearTimeout(e2.timeout), 0 === this.data[t2].length && delete this.data[t2], this.order.splice(this.order.indexOf(t2), 1), e2.value;
        }
        getByKey(t2) {
          const e2 = this.data[t2];
          return e2 ? e2[0].value : null;
        }
        get(t2) {
          return this.has(t2) ? this.data[t2.wrapped().key][0].value : null;
        }
        remove(t2, e2) {
          if (!this.has(t2))
            return this;
          const r2 = t2.wrapped().key, n2 = void 0 === e2 ? 0 : this.data[r2].indexOf(e2), i2 = this.data[r2][n2];
          return this.data[r2].splice(n2, 1), i2.timeout && clearTimeout(i2.timeout), 0 === this.data[r2].length && delete this.data[r2], this.onRemove(i2.value), this.order.splice(this.order.indexOf(r2), 1), this;
        }
        setMaxSize(t2) {
          for (this.max = t2; this.order.length > this.max; ) {
            const t3 = this._getAndRemoveByKey(this.order[0]);
            t3 && this.onRemove(t3);
          }
          return this;
        }
        filter(t2) {
          const e2 = [];
          for (const r2 in this.data)
            for (const n2 of this.data[r2])
              t2(n2.value) || e2.push(n2);
          for (const t3 of e2)
            this.remove(t3.value.tileID, t3);
        }
      }
      class pp {
        constructor(t2, e2, r2) {
          this.func = t2, this.mask = e2, this.range = r2;
        }
      }
      pp.ReadOnly = false, pp.ReadWrite = true, pp.disabled = new pp(519, pp.ReadOnly, [0, 1]);
      const dp = 7680;
      class fp {
        constructor(t2, e2, r2, n2, i2, s2) {
          this.test = t2, this.ref = e2, this.mask = r2, this.fail = n2, this.depthFail = i2, this.pass = s2;
        }
      }
      fp.disabled = new fp({ func: 519, mask: 0 }, 0, 0, dp, dp, dp);
      class yp {
        constructor(t2, e2, r2) {
          this.blendFunction = t2, this.blendColor = e2, this.mask = r2;
        }
      }
      yp.Replace = [1, 0], yp.disabled = new yp(yp.Replace, ce.transparent, [false, false, false, false]), yp.unblended = new yp(yp.Replace, ce.transparent, [true, true, true, true]), yp.alphaBlended = new yp([1, 771], ce.transparent, [true, true, true, true]);
      const mp = 1029, gp = 2305;
      class xp {
        constructor(t2, e2, r2) {
          this.enable = t2, this.mode = e2, this.frontFace = r2;
        }
      }
      xp.disabled = new xp(false, mp, gp), xp.backCCW = new xp(true, mp, gp), xp.backCW = new xp(true, mp, 2304), xp.frontCW = new xp(true, 1028, 2304), xp.frontCCW = new xp(true, 1028, gp);
      class vp extends Ft {
        constructor(t2, e2, r2) {
          super(), this.id = t2, this._onlySymbols = r2, e2.on("data", (t3) => {
            "source" === t3.dataType && "metadata" === t3.sourceDataType && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && "source" === t3.dataType && "content" === t3.sourceDataType && (this.reload(), this.transform && this.update(this.transform));
          }), e2.on("error", () => {
            this._sourceErrored = true;
          }), this._source = e2, this._tiles = {}, this._cache = new hp(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new tp();
        }
        onAdd(t2) {
          this.map = t2, this._maxTileCacheSize = t2 ? t2._maxTileCacheSize : null;
        }
        loaded() {
          if (this._sourceErrored)
            return true;
          if (!this._sourceLoaded)
            return false;
          if (!this._source.loaded())
            return false;
          for (const t2 in this._tiles) {
            const e2 = this._tiles[t2];
            if ("loaded" !== e2.state && "errored" !== e2.state)
              return false;
          }
          return true;
        }
        getSource() {
          return this._source;
        }
        pause() {
          this._paused = true;
        }
        resume() {
          if (!this._paused)
            return;
          const t2 = this._shouldReloadOnResume;
          this._paused = false, this._shouldReloadOnResume = false, t2 && this.reload(), this.transform && this.update(this.transform);
        }
        _loadTile(t2, e2) {
          return t2.isSymbolTile = this._onlySymbols, this._source.loadTile(t2, e2);
        }
        _unloadTile(t2) {
          if (this._source.unloadTile)
            return this._source.unloadTile(t2, () => {
            });
        }
        _abortTile(t2) {
          if (this._source.abortTile)
            return this._source.abortTile(t2, () => {
            });
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(t2) {
          this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
          for (const e2 in this._tiles) {
            const r2 = this._tiles[e2];
            r2.upload(t2), r2.prepare(this.map.style.imageManager);
          }
        }
        getIds() {
          return x(this._tiles).map((t2) => t2.tileID).sort(bp).map((t2) => t2.key);
        }
        getRenderableIds(t2) {
          const e2 = [];
          for (const r2 in this._tiles)
            this._isIdRenderable(+r2, t2) && e2.push(this._tiles[r2]);
          return t2 ? e2.sort((t3, e3) => {
            const r2 = t3.tileID, n2 = e3.tileID, s2 = new i(r2.canonical.x, r2.canonical.y)._rotate(this.transform.angle), a2 = new i(n2.canonical.x, n2.canonical.y)._rotate(this.transform.angle);
            return r2.overscaledZ - n2.overscaledZ || a2.y - s2.y || a2.x - s2.x;
          }).map((t3) => t3.tileID.key) : e2.map((t3) => t3.tileID).sort(bp).map((t3) => t3.key);
        }
        hasRenderableParent(t2) {
          const e2 = this.findLoadedParent(t2, 0);
          return !!e2 && this._isIdRenderable(e2.tileID.key);
        }
        _isIdRenderable(t2, e2) {
          return this._tiles[t2] && this._tiles[t2].hasData() && !this._coveredTiles[t2] && (e2 || !this._tiles[t2].holdingForFade());
        }
        reload() {
          if (this._paused)
            this._shouldReloadOnResume = true;
          else {
            this._cache.reset();
            for (const t2 in this._tiles)
              "errored" !== this._tiles[t2].state && this._reloadTile(+t2, "reloading");
          }
        }
        _reloadTile(t2, e2) {
          const r2 = this._tiles[t2];
          r2 && ("loading" !== r2.state && (r2.state = e2), this._loadTile(r2, this._tileLoaded.bind(this, r2, t2, e2)));
        }
        _tileLoaded(t2, e2, r2, n2) {
          if (n2)
            return t2.state = "errored", void (404 !== n2.status ? this._source.fire(new Lt(n2, { tile: t2 })) : this.update(this.transform));
          t2.timeAdded = q.now(), "expired" === r2 && (t2.refreshedUponExpiration = true), this._setTileReloadTimer(e2, t2), "raster-dem" === this.getSource().type && t2.dem && this._backfillDEM(t2), this._state.initializeTileState(t2, this.map ? this.map.painter : null), this._source.fire(new Vt("data", { dataType: "source", tile: t2, coord: t2.tileID, sourceCacheId: this.id }));
        }
        _backfillDEM(t2) {
          const e2 = this.getRenderableIds();
          for (let n2 = 0; n2 < e2.length; n2++) {
            const i2 = e2[n2];
            if (t2.neighboringTiles && t2.neighboringTiles[i2]) {
              const e3 = this.getTileByID(i2);
              r2(t2, e3), r2(e3, t2);
            }
          }
          function r2(t3, e3) {
            if (!t3.dem || t3.dem.borderReady)
              return;
            t3.needsHillshadePrepare = true, t3.needsDEMTextureUpload = true;
            let r3 = e3.tileID.canonical.x - t3.tileID.canonical.x;
            const n2 = e3.tileID.canonical.y - t3.tileID.canonical.y, i2 = Math.pow(2, t3.tileID.canonical.z), s2 = e3.tileID.key;
            0 === r3 && 0 === n2 || Math.abs(n2) > 1 || (Math.abs(r3) > 1 && (1 === Math.abs(r3 + i2) ? r3 += i2 : 1 === Math.abs(r3 - i2) && (r3 -= i2)), e3.dem && t3.dem && (t3.dem.backfillBorder(e3.dem, r3, n2), t3.neighboringTiles && t3.neighboringTiles[s2] && (t3.neighboringTiles[s2].backfilled = true)));
          }
        }
        getTile(t2) {
          return this.getTileByID(t2.key);
        }
        getTileByID(t2) {
          return this._tiles[t2];
        }
        _retainLoadedChildren(t2, e2, r2, n2) {
          for (const i2 in this._tiles) {
            let s2 = this._tiles[i2];
            if (n2[i2] || !s2.hasData() || s2.tileID.overscaledZ <= e2 || s2.tileID.overscaledZ > r2)
              continue;
            let a2 = s2.tileID;
            for (; s2 && s2.tileID.overscaledZ > e2 + 1; ) {
              const t3 = s2.tileID.scaledTo(s2.tileID.overscaledZ - 1);
              s2 = this._tiles[t3.key], s2 && s2.hasData() && (a2 = t3);
            }
            let o2 = a2;
            for (; o2.overscaledZ > e2; )
              if (o2 = o2.scaledTo(o2.overscaledZ - 1), t2[o2.key]) {
                n2[a2.key] = a2;
                break;
              }
          }
        }
        findLoadedParent(t2, e2) {
          if (t2.key in this._loadedParentTiles) {
            const r2 = this._loadedParentTiles[t2.key];
            return r2 && r2.tileID.overscaledZ >= e2 ? r2 : null;
          }
          for (let r2 = t2.overscaledZ - 1; r2 >= e2; r2--) {
            const e3 = t2.scaledTo(r2), n2 = this._getLoadedTile(e3);
            if (n2)
              return n2;
          }
        }
        _getLoadedTile(t2) {
          const e2 = this._tiles[t2.key];
          return e2 && e2.hasData() ? e2 : this._cache.getByKey(this._source.reparseOverscaled ? t2.wrapped().key : t2.canonical.key);
        }
        updateCacheSize(t2, e2) {
          e2 = e2 || this._source.tileSize;
          const r2 = Math.ceil(t2.width / e2) + 1, n2 = Math.ceil(t2.height / e2) + 1, i2 = Math.floor(r2 * n2 * 5), s2 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, i2) : i2;
          this._cache.setMaxSize(s2);
        }
        handleWrapJump(t2) {
          const e2 = Math.round((t2 - (void 0 === this._prevLng ? t2 : this._prevLng)) / 360);
          if (this._prevLng = t2, e2) {
            const t3 = {};
            for (const r2 in this._tiles) {
              const n2 = this._tiles[r2];
              n2.tileID = n2.tileID.unwrapTo(n2.tileID.wrap + e2), t3[n2.tileID.key] = n2;
            }
            this._tiles = t3;
            for (const t4 in this._timers)
              clearTimeout(this._timers[t4]), delete this._timers[t4];
            for (const t4 in this._tiles)
              this._setTileReloadTimer(+t4, this._tiles[t4]);
          }
        }
        update(t2, e2, r2) {
          if (this.transform = t2, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage)
            return;
          if (this.usedForTerrain && !r2)
            return;
          let n2;
          this.updateCacheSize(t2, e2), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? n2 = t2.getVisibleUnwrappedCoordinates(this._source.tileID).map((t3) => new Kh(t3.canonical.z, t3.wrap, t3.canonical.z, t3.canonical.x, t3.canonical.y)) : (n2 = t2.coveringTiles({ tileSize: e2 || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !r2, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain }), this._source.hasTile && (n2 = n2.filter((t3) => this._source.hasTile(t3)))) : n2 = [];
          const i2 = this._updateRetainedTiles(n2);
          if (wp(this._source.type) && 0 !== n2.length) {
            const t3 = {}, e3 = {}, r3 = Object.keys(i2);
            for (const n3 of r3) {
              const r4 = i2[n3], s4 = this._tiles[n3];
              if (!s4 || s4.fadeEndTime && s4.fadeEndTime <= q.now())
                continue;
              const a2 = this.findLoadedParent(r4, Math.max(r4.overscaledZ - vp.maxOverzooming, this._source.minzoom));
              a2 && (this._addTile(a2.tileID), t3[a2.tileID.key] = a2.tileID), e3[n3] = r4;
            }
            const s3 = n2[n2.length - 1].overscaledZ;
            for (const t4 in this._tiles) {
              const r4 = this._tiles[t4];
              if (i2[t4] || !r4.hasData())
                continue;
              let n3 = r4.tileID;
              for (; n3.overscaledZ > s3; ) {
                n3 = n3.scaledTo(n3.overscaledZ - 1);
                const s4 = this._tiles[n3.key];
                if (s4 && s4.hasData() && e3[n3.key]) {
                  i2[t4] = r4.tileID;
                  break;
                }
              }
            }
            for (const e4 in t3)
              i2[e4] || (this._coveredTiles[e4] = true, i2[e4] = t3[e4]);
          }
          for (const t3 in i2)
            this._tiles[t3].clearFadeHold();
          const s2 = function(t3, e3) {
            const r3 = [];
            for (const n3 in t3)
              n3 in e3 || r3.push(n3);
            return r3;
          }(this._tiles, i2);
          for (const t3 of s2) {
            const e3 = this._tiles[t3];
            e3.hasSymbolBuckets && !e3.holdingForFade() ? e3.setHoldDuration(this.map._fadeDuration) : e3.hasSymbolBuckets && !e3.symbolFadeFinished() || this._removeTile(+t3);
          }
          this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
        }
        releaseSymbolFadeTiles() {
          for (const t2 in this._tiles)
            this._tiles[t2].holdingForFade() && this._removeTile(+t2);
        }
        _updateRetainedTiles(t2) {
          const e2 = {};
          if (0 === t2.length)
            return e2;
          const r2 = {}, n2 = t2[t2.length - 1].overscaledZ, i2 = t2[0].overscaledZ, s2 = Math.max(i2 - vp.maxOverzooming, this._source.minzoom), a2 = Math.max(i2 + vp.maxUnderzooming, this._source.minzoom), o2 = {};
          for (const r3 of t2) {
            const t3 = this._addTile(r3);
            e2[r3.key] = r3, t3.hasData() || n2 < this._source.maxzoom && (o2[r3.key] = r3);
          }
          this._retainLoadedChildren(o2, n2, a2, e2);
          for (const n3 of t2) {
            let t3 = this._tiles[n3.key];
            if (t3.hasData())
              continue;
            if (n3.canonical.z >= this._source.maxzoom) {
              const t4 = n3.children(this._source.maxzoom)[0], r3 = this.getTile(t4);
              if (r3 && r3.hasData()) {
                e2[t4.key] = t4;
                continue;
              }
            } else {
              const t4 = n3.children(this._source.maxzoom);
              if (e2[t4[0].key] && e2[t4[1].key] && e2[t4[2].key] && e2[t4[3].key])
                continue;
            }
            let i3 = t3.wasRequested();
            for (let a3 = n3.overscaledZ - 1; a3 >= s2; --a3) {
              const s3 = n3.scaledTo(a3);
              if (r2[s3.key])
                break;
              if (r2[s3.key] = true, t3 = this.getTile(s3), !t3 && i3 && (t3 = this._addTile(s3)), t3 && (e2[s3.key] = s3, i3 = t3.wasRequested(), t3.hasData()))
                break;
            }
          }
          return e2;
        }
        _updateLoadedParentTileCache() {
          this._loadedParentTiles = {};
          for (const t2 in this._tiles) {
            const e2 = [];
            let r2, n2 = this._tiles[t2].tileID;
            for (; n2.overscaledZ > 0; ) {
              if (n2.key in this._loadedParentTiles) {
                r2 = this._loadedParentTiles[n2.key];
                break;
              }
              e2.push(n2.key);
              const t3 = n2.scaledTo(n2.overscaledZ - 1);
              if (r2 = this._getLoadedTile(t3), r2)
                break;
              n2 = t3;
            }
            for (const t3 of e2)
              this._loadedParentTiles[t3] = r2;
          }
        }
        _addTile(t2) {
          let e2 = this._tiles[t2.key];
          if (e2)
            return e2;
          e2 = this._cache.getAndRemove(t2), e2 && (this._setTileReloadTimer(t2.key, e2), e2.tileID = t2, this._state.initializeTileState(e2, this.map ? this.map.painter : null), this._cacheTimers[t2.key] && (clearTimeout(this._cacheTimers[t2.key]), delete this._cacheTimers[t2.key], this._setTileReloadTimer(t2.key, e2)));
          const r2 = Boolean(e2);
          return r2 || (e2 = new Qh(t2, this._source.tileSize * t2.overscaleFactor(), this.transform.tileZoom), this._loadTile(e2, this._tileLoaded.bind(this, e2, t2.key, e2.state))), e2 ? (e2.uses++, this._tiles[t2.key] = e2, r2 || this._source.fire(new Vt("dataloading", { tile: e2, coord: e2.tileID, dataType: "source" })), e2) : null;
        }
        _setTileReloadTimer(t2, e2) {
          t2 in this._timers && (clearTimeout(this._timers[t2]), delete this._timers[t2]);
          const r2 = e2.getExpiryTimeout();
          r2 && (this._timers[t2] = setTimeout(() => {
            this._reloadTile(t2, "expired"), delete this._timers[t2];
          }, r2));
        }
        _removeTile(t2) {
          const e2 = this._tiles[t2];
          e2 && (e2.uses--, delete this._tiles[t2], this._timers[t2] && (clearTimeout(this._timers[t2]), delete this._timers[t2]), e2.uses > 0 || (e2.hasData() && "reloading" !== e2.state ? this._cache.add(e2.tileID, e2, e2.getExpiryTimeout()) : (e2.aborted = true, this._abortTile(e2), this._unloadTile(e2))));
        }
        clearTiles() {
          this._shouldReloadOnResume = false, this._paused = false;
          for (const t2 in this._tiles)
            this._removeTile(+t2);
          this._cache.reset();
        }
        tilesIn(t2, e2, r2) {
          const n2 = [], i2 = this.transform;
          if (!i2)
            return n2;
          for (const s2 in this._tiles) {
            const a2 = this._tiles[s2];
            if (r2 && a2.clearQueryDebugViz(), a2.holdingForFade())
              continue;
            const o2 = t2.containsTile(a2, i2, e2);
            o2 && n2.push(o2);
          }
          return n2;
        }
        getVisibleCoordinates(t2) {
          const e2 = this.getRenderableIds(t2).map((t3) => this._tiles[t3].tileID);
          for (const t3 of e2)
            t3.projMatrix = this.transform.calculateProjMatrix(t3.toUnwrapped());
          return e2;
        }
        hasTransition() {
          if (this._source.hasTransition())
            return true;
          if (wp(this._source.type))
            for (const t2 in this._tiles) {
              const e2 = this._tiles[t2];
              if (void 0 !== e2.fadeEndTime && e2.fadeEndTime >= q.now())
                return true;
            }
          return false;
        }
        setFeatureState(t2, e2, r2) {
          this._state.updateState(t2 = t2 || "_geojsonTileLayer", e2, r2);
        }
        removeFeatureState(t2, e2, r2) {
          this._state.removeFeatureState(t2 = t2 || "_geojsonTileLayer", e2, r2);
        }
        getFeatureState(t2, e2) {
          return this._state.getState(t2 = t2 || "_geojsonTileLayer", e2);
        }
        setDependencies(t2, e2, r2) {
          const n2 = this._tiles[t2];
          n2 && n2.setDependencies(e2, r2);
        }
        reloadTilesForDependencies(t2, e2) {
          for (const r2 in this._tiles)
            this._tiles[r2].hasDependency(t2, e2) && this._reloadTile(+r2, "reloading");
          this._cache.filter((r2) => !r2.hasDependency(t2, e2));
        }
      }
      function bp(t2, e2) {
        const r2 = Math.abs(2 * t2.wrap) - +(t2.wrap < 0), n2 = Math.abs(2 * e2.wrap) - +(e2.wrap < 0);
        return t2.overscaledZ - e2.overscaledZ || n2 - r2 || e2.canonical.y - t2.canonical.y || e2.canonical.x - t2.canonical.x;
      }
      function wp(t2) {
        return "raster" === t2 || "image" === t2 || "video" === t2;
      }
      vp.maxOverzooming = 10, vp.maxUnderzooming = 3;
      class _p {
        constructor(t2, e2, r2) {
          this._demTile = t2, this._dem = this._demTile.dem, this._scale = e2, this._offset = r2;
        }
        static create(t2, e2, r2) {
          const n2 = r2 || t2.findDEMTileFor(e2);
          if (!n2 || !n2.dem)
            return;
          const i2 = n2.dem, s2 = n2.tileID, a2 = 1 << e2.canonical.z - s2.canonical.z;
          return new _p(n2, n2.tileSize / qa / a2, [(e2.canonical.x / a2 - s2.canonical.x) * i2.dim, (e2.canonical.y / a2 - s2.canonical.y) * i2.dim]);
        }
        tileCoordToPixel(t2, e2) {
          const r2 = e2 * this._scale + this._offset[1], n2 = Math.floor(t2 * this._scale + this._offset[0]), s2 = Math.floor(r2);
          return new i(n2, s2);
        }
        getElevationAt(t2, e2, r2, n2) {
          const i2 = t2 * this._scale + this._offset[0], s2 = e2 * this._scale + this._offset[1], a2 = Math.floor(i2), o2 = Math.floor(s2), l2 = this._dem;
          return n2 = !!n2, r2 ? rr(rr(l2.get(a2, o2, n2), l2.get(a2, o2 + 1, n2), s2 - o2), rr(l2.get(a2 + 1, o2, n2), l2.get(a2 + 1, o2 + 1, n2), s2 - o2), i2 - a2) : l2.get(a2, o2, n2);
        }
        getElevationAtPixel(t2, e2, r2) {
          return this._dem.get(t2, e2, !!r2);
        }
        getMeterToDEM(t2) {
          return (1 << this._demTile.tileID.canonical.z) * Lh(1, t2) * this._dem.stride;
        }
      }
      class Ap {
        constructor(t2, e2) {
          this.tileID = t2, this.x = t2.canonical.x, this.y = t2.canonical.y, this.z = t2.canonical.z, this.grid = new ri(qa, 16, 0), this.featureIndexArray = new sa(), this.promoteId = e2;
        }
        insert(t2, e2, r2, n2, i2, s2 = 0) {
          const a2 = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(r2, n2, i2, s2);
          const o2 = this.grid;
          for (let t3 = 0; t3 < e2.length; t3++) {
            const r3 = e2[t3], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let t4 = 0; t4 < r3.length; t4++) {
              const e3 = r3[t4];
              n3[0] = Math.min(n3[0], e3.x), n3[1] = Math.min(n3[1], e3.y), n3[2] = Math.max(n3[2], e3.x), n3[3] = Math.max(n3[3], e3.y);
            }
            n3[0] < qa && n3[1] < qa && n3[2] >= 0 && n3[3] >= 0 && o2.insert(a2, n3[0], n3[1], n3[2], n3[3]);
          }
        }
        loadVTLayers() {
          return this.vtLayers || (this.vtLayers = new Xl.VectorTile(new Pu(this.rawTileData)).layers, this.sourceLayerCoder = new Hh(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
        }
        query(t2, e2, r2, n2) {
          this.loadVTLayers();
          const i2 = t2.params || {}, s2 = kn(i2.filter), a2 = t2.tileResult, o2 = t2.transform, l2 = a2.bufferedTilespaceBounds, u2 = this.grid.query(l2.min.x, l2.min.y, l2.max.x, l2.max.y, (t3, e3, r3, n3) => so(a2.bufferedTilespaceGeometry, t3, e3, r3, n3));
          u2.sort(Sp);
          let c2 = null;
          o2.elevation && u2.length > 0 && (c2 = _p.create(o2.elevation, this.tileID));
          const h2 = {};
          let p2;
          for (let o3 = 0; o3 < u2.length; o3++) {
            const l3 = u2[o3];
            if (l3 === p2)
              continue;
            p2 = l3;
            const d2 = this.featureIndexArray.get(l3);
            let f2 = null;
            this.loadMatchingFeature(h2, d2, s2, i2.layers, i2.availableImages, e2, r2, n2, (e3, r3, n3, i3 = 0) => (f2 || (f2 = Za(e3)), r3.queryIntersectsFeature(a2, e3, n3, f2, this.z, t2.transform, t2.pixelPosMatrix, c2, i3)));
          }
          return h2;
        }
        loadMatchingFeature(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
          const { featureIndex: u2, bucketIndex: c2, sourceLayerIndex: h2, layoutVertexArrayOffset: p2 } = e2, d2 = this.bucketLayerIDs[c2];
          if (n2 && !function(t3, e3) {
            for (let r3 = 0; r3 < t3.length; r3++)
              if (e3.indexOf(t3[r3]) >= 0)
                return true;
            return false;
          }(n2, d2))
            return;
          const f2 = this.sourceLayerCoder.decode(h2), y2 = this.vtLayers[f2].feature(u2);
          if (r2.needGeometry) {
            const t3 = Ga(y2, true);
            if (!r2.filter(new as(this.tileID.overscaledZ), t3, this.tileID.canonical))
              return;
          } else if (!r2.filter(new as(this.tileID.overscaledZ), y2))
            return;
          const m2 = this.getId(y2, f2);
          for (let e3 = 0; e3 < d2.length; e3++) {
            const r3 = d2[e3];
            if (n2 && n2.indexOf(r3) < 0)
              continue;
            const c3 = s2[r3];
            if (!c3)
              continue;
            let h3 = {};
            void 0 !== m2 && o2 && (h3 = o2.getState(c3.sourceLayer || "_geojsonTileLayer", m2));
            const f3 = v({}, a2[r3]);
            f3.paint = kp(f3.paint, c3.paint, y2, h3, i2), f3.layout = kp(f3.layout, c3.layout, y2, h3, i2);
            const g2 = !l2 || l2(y2, c3, h3, p2);
            if (!g2)
              continue;
            const x2 = new Jh(y2, this.z, this.x, this.y, m2);
            x2.layer = f3;
            let b2 = t2[r3];
            void 0 === b2 && (b2 = t2[r3] = []), b2.push({ featureIndex: u2, feature: x2, intersectionZ: g2 });
          }
        }
        lookupSymbolFeatures(t2, e2, r2, n2, i2, s2, a2, o2) {
          const l2 = {};
          this.loadVTLayers();
          const u2 = kn(i2);
          for (const i3 of t2)
            this.loadMatchingFeature(l2, { bucketIndex: r2, sourceLayerIndex: n2, featureIndex: i3, layoutVertexArrayOffset: 0 }, u2, s2, a2, o2, e2);
          return l2;
        }
        hasLayer(t2) {
          for (const e2 of this.bucketLayerIDs)
            for (const r2 of e2)
              if (t2 === r2)
                return true;
          return false;
        }
        getId(t2, e2) {
          let r2 = t2.id;
          return this.promoteId && (r2 = t2.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e2]], "boolean" == typeof r2 && (r2 = Number(r2))), r2;
        }
      }
      function kp(t2, e2, r2, n2, i2) {
        return z(t2, (t3, s2) => {
          const a2 = e2 instanceof fs ? e2.get(s2) : null;
          return a2 && a2.evaluate ? a2.evaluate(r2, n2, i2) : a2;
        });
      }
      function Sp(t2, e2) {
        return e2 - t2;
      }
      oi("FeatureIndex", Ap, { omit: ["rawTileData", "sourceLayerCoder"] });
      class Ip {
        constructor(t2) {
          const e2 = {}, r2 = [];
          for (const n3 in t2) {
            const i3 = t2[n3], s3 = e2[n3] = {};
            for (const t3 in i3.glyphs) {
              const e3 = i3.glyphs[+t3];
              if (!e3 || 0 === e3.bitmap.width || 0 === e3.bitmap.height)
                continue;
              const n4 = e3.metrics.localGlyph ? 2 : 1, a2 = { x: 0, y: 0, w: e3.bitmap.width + 2 * n4, h: e3.bitmap.height + 2 * n4 };
              r2.push(a2), s3[t3] = a2;
            }
          }
          const { w: n2, h: i2 } = nc(r2), s2 = new No({ width: n2 || 1, height: i2 || 1 });
          for (const r3 in t2) {
            const n3 = t2[r3];
            for (const t3 in n3.glyphs) {
              const i3 = n3.glyphs[+t3];
              if (!i3 || 0 === i3.bitmap.width || 0 === i3.bitmap.height)
                continue;
              const a2 = e2[r3][t3], o2 = i3.metrics.localGlyph ? 2 : 1;
              No.copy(i3.bitmap, s2, { x: 0, y: 0 }, { x: a2.x + o2, y: a2.y + o2 }, i3.bitmap);
            }
          }
          this.image = s2, this.positions = e2;
        }
      }
      oi("GlyphAtlas", Ip);
      class zp {
        constructor(t2) {
          this.tileID = new Kh(t2.tileID.overscaledZ, t2.tileID.wrap, t2.tileID.canonical.z, t2.tileID.canonical.x, t2.tileID.canonical.y), this.tileZoom = t2.tileZoom, this.uid = t2.uid, this.zoom = t2.zoom, this.pixelRatio = t2.pixelRatio, this.tileSize = t2.tileSize, this.source = t2.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t2.showCollisionBoxes, this.collectResourceTiming = !!t2.collectResourceTiming, this.returnDependencies = !!t2.returnDependencies, this.promoteId = t2.promoteId, this.enableTerrain = !!t2.enableTerrain, this.isSymbolTile = t2.isSymbolTile;
        }
        parse(t2, e2, r2, n2, i2) {
          this.status = "parsing", this.data = t2, this.collisionBoxArray = new Js();
          const s2 = new Hh(Object.keys(t2.layers).sort()), a2 = new Ap(this.tileID, this.promoteId);
          a2.bucketLayerIDs = [];
          const o2 = {}, l2 = new Uh(256, 256), u2 = { featureIndex: a2, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, lineAtlas: l2, availableImages: r2 }, c2 = e2.familiesBySource[this.source];
          for (const e3 in c2) {
            const n3 = t2.layers[e3];
            if (!n3)
              continue;
            let i3 = false, l3 = false;
            for (const t3 of c2[e3])
              "symbol" === t3[0].type ? i3 = true : l3 = true;
            if (true === this.isSymbolTile && !i3)
              continue;
            if (false === this.isSymbolTile && !l3)
              continue;
            1 === n3.version && C(`Vector tile source "${this.source}" layer "${e3}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
            const h3 = s2.encode(e3), p3 = [];
            for (let t3 = 0; t3 < n3.length; t3++) {
              const r3 = n3.feature(t3), i4 = a2.getId(r3, e3);
              p3.push({ feature: r3, id: i4, index: t3, sourceLayerIndex: h3 });
            }
            for (const t3 of c2[e3]) {
              const e4 = t3[0];
              void 0 !== this.isSymbolTile && "symbol" === e4.type !== this.isSymbolTile || e4.minzoom && this.zoom < Math.floor(e4.minzoom) || e4.maxzoom && this.zoom >= e4.maxzoom || "none" !== e4.visibility && (Tp(t3, this.zoom, r2), (o2[e4.id] = e4.createBucket({ index: a2.bucketLayerIDs.length, layers: t3, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: h3, sourceID: this.source, enableTerrain: this.enableTerrain })).populate(p3, u2, this.tileID.canonical), a2.bucketLayerIDs.push(t3.map((t4) => t4.id)));
            }
          }
          let h2, p2, d2, f2;
          l2.trim();
          const y2 = { type: "maybePrepare", isSymbolTile: this.isSymbolTile, zoom: this.zoom }, m2 = z(u2.glyphDependencies, (t3) => Object.keys(t3).map(Number));
          Object.keys(m2).length ? n2.send("getGlyphs", { uid: this.uid, stacks: m2 }, (t3, e3) => {
            h2 || (h2 = t3, p2 = e3, b2.call(this));
          }, void 0, false, y2) : p2 = {};
          const g2 = Object.keys(u2.iconDependencies);
          g2.length ? n2.send("getImages", { icons: g2, source: this.source, tileID: this.tileID, type: "icons" }, (t3, e3) => {
            h2 || (h2 = t3, d2 = e3, b2.call(this));
          }, void 0, false, y2) : d2 = {};
          const v2 = Object.keys(u2.patternDependencies);
          function b2() {
            if (h2)
              return i2(h2);
            if (p2 && d2 && f2) {
              const t3 = new Ip(p2), e3 = new sc(d2, f2);
              for (const n3 in o2) {
                const i3 = o2[n3];
                i3 instanceof ph ? (Tp(i3.layers, this.zoom, r2), Hc(i3, p2, t3.positions, d2, e3.iconPositions, this.showCollisionBoxes, this.tileID.canonical, this.tileZoom)) : i3.hasPattern && (i3 instanceof hu || i3 instanceof Dl || i3 instanceof Wl) && (Tp(i3.layers, this.zoom, r2), i3.addFeatures(u2, this.tileID.canonical, e3.patternPositions));
              }
              this.status = "done", i2(null, { buckets: x(o2).filter((t4) => !t4.isEmpty()), featureIndex: a2, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: t3.image, lineAtlas: l2, imageAtlas: e3, glyphMap: this.returnDependencies ? p2 : null, iconMap: this.returnDependencies ? d2 : null, glyphPositions: this.returnDependencies ? t3.positions : null });
            }
          }
          v2.length ? n2.send("getImages", { icons: v2, source: this.source, tileID: this.tileID, type: "patterns" }, (t3, e3) => {
            h2 || (h2 = t3, f2 = e3, b2.call(this));
          }, void 0, false, y2) : f2 = {}, b2.call(this);
        }
      }
      function Tp(t2, e2, r2) {
        const n2 = new as(e2);
        for (const e3 of t2)
          e3.recalculate(n2, r2);
      }
      class Mp {
        constructor(t2) {
          this.entries = {}, this.scheduler = t2;
        }
        request(t2, e2, r2, n2) {
          const i2 = this.entries[t2] = this.entries[t2] || { callbacks: [] };
          if (i2.result) {
            const [t3, r3] = i2.result;
            return this.scheduler ? this.scheduler.add(() => {
              n2(t3, r3);
            }, e2) : n2(t3, r3), () => {
            };
          }
          return i2.callbacks.push(n2), i2.cancel || (i2.cancel = r2((r3, n3) => {
            i2.result = [r3, n3];
            for (const t3 of i2.callbacks)
              this.scheduler ? this.scheduler.add(() => {
                t3(r3, n3);
              }, e2) : t3(r3, n3);
            setTimeout(() => delete this.entries[t2], 3e3);
          })), () => {
            i2.result || (i2.callbacks = i2.callbacks.filter((t3) => t3 !== n2), i2.callbacks.length || (i2.cancel(), delete this.entries[t2]));
          };
        }
      }
      function Ep(t2, e2, r2) {
        const n2 = JSON.stringify(t2.request);
        return t2.data && (this.deduped.entries[n2] = { result: [null, t2.data] }), this.deduped.request(n2, { type: "parseTile", isSymbolTile: t2.isSymbolTile, zoom: t2.tileZoom }, (e3) => {
          const n3 = St(t2.request, (t3, n4, i2, s2) => {
            t3 ? e3(t3) : n4 && e3(null, { vectorTile: r2 ? void 0 : new Xl.VectorTile(new Pu(n4)), rawData: n4, cacheControl: i2, expires: s2 });
          });
          return () => {
            n3.cancel(), e3();
          };
        }, e2);
      }
      t.ARRAY_TYPE = fo, t.AUTH_ERR_MSG = W, t.Actor = class {
        constructor(t2, e2, r2) {
          this.target = t2, this.parent = e2, this.mapId = r2, this.callbacks = {}, this.cancelCallbacks = {}, S(["receive"], this), this.target.addEventListener("message", this.receive, false), this.globalScope = P() ? t2 : a, this.scheduler = new Nh();
        }
        send(t2, e2, r2, n2, i2 = false, s2) {
          const a2 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
          r2 && (r2.metadata = s2, this.callbacks[a2] = r2);
          const o2 = U(this.globalScope) ? void 0 : [];
          return this.target.postMessage({ id: a2, type: t2, hasCallback: !!r2, targetMapId: n2, mustQueue: i2, sourceMapId: this.mapId, data: ci(e2, o2) }, o2), { cancel: () => {
            r2 && delete this.callbacks[a2], this.target.postMessage({ id: a2, type: "<cancel>", targetMapId: n2, sourceMapId: this.mapId });
          } };
        }
        receive(t2) {
          const e2 = t2.data, r2 = e2.id;
          if (r2 && (!e2.targetMapId || this.mapId === e2.targetMapId))
            if ("<cancel>" === e2.type) {
              const t3 = this.cancelCallbacks[r2];
              delete this.cancelCallbacks[r2], t3 && t3.cancel();
            } else if (e2.mustQueue || P()) {
              const t3 = this.callbacks[r2];
              this.cancelCallbacks[r2] = this.scheduler.add(() => this.processTask(r2, e2), t3 && t3.metadata || { type: "message" });
            } else
              this.processTask(r2, e2);
        }
        processTask(t2, e2) {
          if ("<response>" === e2.type) {
            const r2 = this.callbacks[t2];
            delete this.callbacks[t2], r2 && (e2.error ? r2(hi(e2.error)) : r2(null, hi(e2.data)));
          } else {
            const r2 = U(this.globalScope) ? void 0 : [], n2 = e2.hasCallback ? (e3, n3) => {
              delete this.cancelCallbacks[t2], this.target.postMessage({ id: t2, type: "<response>", sourceMapId: this.mapId, error: e3 ? ci(e3) : null, data: ci(n3, r2) }, r2);
            } : (t3) => {
            }, i2 = hi(e2.data);
            if (this.parent[e2.type])
              this.parent[e2.type](e2.sourceMapId, i2, n2);
            else if (this.parent.getWorkerSource) {
              const t3 = e2.type.split(".");
              this.parent.getWorkerSource(e2.sourceMapId, t3[0], i2.source)[t3[1]](i2, n2);
            } else
              n2(new Error(`Could not find function ${e2.type}`));
          }
        }
        remove() {
          this.scheduler.remove(), this.target.removeEventListener("message", this.receive, false);
        }
      }, t.CanonicalTileID = Gh, t.Color = ce, t.ColorMode = yp, t.CullFaceMode = xp, t.DEMData = cp, t.DataConstantProperty = ys, t.DedupedRequest = Mp, t.DepthMode = pp, t.EXTENT = qa, t.Elevation = class {
        getAtPointOrZero(t2, e2 = 0) {
          return this.getAtPoint(t2, e2) || 0;
        }
        getAtPoint(t2, e2, r2 = true) {
          null == e2 && (e2 = null);
          const n2 = this._source();
          if (!n2)
            return e2;
          if (t2.y < 0 || t2.y > 1)
            return e2;
          const i2 = n2.getSource().maxzoom, s2 = 1 << i2, a2 = Math.floor(t2.x), o2 = t2.x - a2, l2 = new Kh(i2, a2, i2, Math.floor(o2 * s2), Math.floor(t2.y * s2)), u2 = this.findDEMTileFor(l2);
          if (!u2 || !u2.dem)
            return e2;
          const c2 = u2.dem, h2 = 1 << u2.tileID.canonical.z, p2 = (o2 * h2 - u2.tileID.canonical.x) * c2.dim, d2 = (t2.y * h2 - u2.tileID.canonical.y) * c2.dim, f2 = Math.floor(p2), y2 = Math.floor(d2);
          return (r2 ? this.exaggeration() : 1) * rr(rr(c2.get(f2, y2), c2.get(f2, y2 + 1), d2 - y2), rr(c2.get(f2 + 1, y2), c2.get(f2 + 1, y2 + 1), d2 - y2), p2 - f2);
        }
        getAtTileOffset(t2, e2, r2) {
          const n2 = 1 << t2.canonical.z;
          return this.getAtPointOrZero(new $h(t2.wrap + (t2.canonical.x + e2 / qa) / n2, (t2.canonical.y + r2 / qa) / n2));
        }
        getForTilePoints(t2, e2, r2, n2) {
          const i2 = _p.create(this, t2, n2);
          return !!i2 && (e2.forEach((t3) => {
            t3[2] = this.exaggeration() * i2.getElevationAt(t3[0], t3[1], r2);
          }), true);
        }
        getMinMaxForTile(t2) {
          const e2 = this.findDEMTileFor(t2);
          if (!e2 || !e2.dem)
            return null;
          const r2 = e2.dem.tree, n2 = e2.tileID, i2 = 1 << t2.canonical.z - n2.canonical.z;
          let s2 = t2.canonical.x / i2 - n2.canonical.x, a2 = t2.canonical.y / i2 - n2.canonical.y, o2 = 0;
          for (let e3 = 0; e3 < t2.canonical.z - n2.canonical.z && !r2.leaves[o2]; e3++) {
            s2 *= 2, a2 *= 2;
            const t3 = 2 * Math.floor(a2) + Math.floor(s2);
            o2 = r2.childOffsets[o2] + t3, s2 %= 1, a2 %= 1;
          }
          return { min: this.exaggeration() * r2.minimums[o2], max: this.exaggeration() * r2.maximums[o2] };
        }
        getMinElevationBelowMSL() {
          throw new Error("Pure virtual method called.");
        }
        raycast(t2, e2, r2) {
          throw new Error("Pure virtual method called.");
        }
        pointCoordinate(t2) {
          throw new Error("Pure virtual method called.");
        }
        _source() {
          throw new Error("Pure virtual method called.");
        }
        exaggeration() {
          throw new Error("Pure virtual method called.");
        }
        findDEMTileFor(t2) {
          throw new Error("Pure virtual method called.");
        }
        get visibleDemTiles() {
          throw new Error("Getter must be implemented in subclass.");
        }
      }, t.ErrorEvent = Lt, t.EvaluationParameters = as, t.Event = Vt, t.Evented = Ft, t.GlyphManager = Vc, t.ImagePosition = ic, t.LineAtlas = Uh, t.LngLat = Ch, t.LngLatBounds = Mh, t.LocalGlyphMode = Pc, t.MAX_SAFE_INTEGER = o, t.MercatorCoordinate = $h, t.ONE_EM = _u, t.OverscaledTileID = Kh, t.Properties = bs, t.RGBAImage = Zo, t.RequestManager = class {
        constructor(t2, e2, r2) {
          this._transformRequestFn = t2, this._customAccessToken = e2, this._silenceAuthErrors = !!r2, this._createSkuToken();
        }
        _createSkuToken() {
          const t2 = function() {
            let t3 = "";
            for (let e2 = 0; e2 < 10; e2++)
              t3 += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
            return { token: ["1", J, t3].join(""), tokenExpiresAt: Date.now() + 432e5 };
          }();
          this._skuToken = t2.token, this._skuTokenExpiresAt = t2.tokenExpiresAt;
        }
        _isSkuTokenExpired() {
          return Date.now() > this._skuTokenExpiresAt;
        }
        transformRequest(t2, e2) {
          return this._transformRequestFn && this._transformRequestFn(t2, e2) || { url: t2 };
        }
        normalizeStyleURL(t2, e2) {
          if (!Q(t2))
            return t2;
          const r2 = rt(t2);
          return r2.path = `/styles/v1${r2.path}`, this._makeAPIURL(r2, this._customAccessToken || e2);
        }
        normalizeGlyphsURL(t2, e2) {
          if (!Q(t2))
            return t2;
          const r2 = rt(t2);
          return r2.path = `/fonts/v1${r2.path}`, this._makeAPIURL(r2, this._customAccessToken || e2);
        }
        normalizeSourceURL(t2, e2) {
          if (!Q(t2))
            return t2;
          const r2 = rt(t2);
          return r2.path = `/v4/${r2.authority}.json`, r2.params.push("secure"), this._makeAPIURL(r2, this._customAccessToken || e2);
        }
        normalizeSpriteURL(t2, e2, r2, n2) {
          const i2 = rt(t2);
          return Q(t2) ? (i2.path = `/styles/v1${i2.path}/sprite${e2}${r2}`, this._makeAPIURL(i2, this._customAccessToken || n2)) : (i2.path += `${e2}${r2}`, nt(i2));
        }
        normalizeTileURL(t2, e2, r2) {
          if (this._isSkuTokenExpired() && this._createSkuToken(), t2 && !Q(t2))
            return t2;
          const n2 = rt(t2);
          n2.path = n2.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${e2 || r2 && "raster" !== n2.authority && 512 === r2 ? "@2x" : ""}${Z.supported ? ".webp" : "$1"}`), "raster" === n2.authority ? n2.path = `/${N.RASTER_URL_PREFIX}${n2.path}` : (n2.path = n2.path.replace(/^.+\/v4\//, "/"), n2.path = `/${N.TILE_URL_VERSION}${n2.path}`);
          const i2 = this._customAccessToken || function(t3) {
            for (const e3 of t3) {
              const t4 = e3.match(/^access_token=(.*)$/);
              if (t4)
                return t4[1];
            }
            return null;
          }(n2.params) || N.ACCESS_TOKEN;
          return N.REQUIRE_ACCESS_TOKEN && i2 && this._skuToken && n2.params.push(`sku=${this._skuToken}`), this._makeAPIURL(n2, i2);
        }
        canonicalizeTileURL(t2, e2) {
          const r2 = rt(t2);
          if (!r2.path.match(/^(\/v4\/|\/raster\/v1\/)/) || !r2.path.match(/\.[\w]+$/))
            return t2;
          let n2 = "mapbox://";
          r2.path.match(/^\/raster\/v1\//) ? n2 += `raster/${r2.path.replace(`/${N.RASTER_URL_PREFIX}/`, "")}` : n2 += `tiles/${r2.path.replace(`/${N.TILE_URL_VERSION}/`, "")}`;
          let i2 = r2.params;
          return e2 && (i2 = i2.filter((t3) => !t3.match(/^access_token=/))), i2.length && (n2 += `?${i2.join("&")}`), n2;
        }
        canonicalizeTileset(t2, e2) {
          const r2 = !!e2 && Q(e2), n2 = [];
          for (const e3 of t2.tiles || [])
            tt(e3) ? n2.push(this.canonicalizeTileURL(e3, r2)) : n2.push(e3);
          return n2;
        }
        _makeAPIURL(t2, e2) {
          const r2 = "See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes", n2 = rt(N.API_URL);
          if (t2.protocol = n2.protocol, t2.authority = n2.authority, "http" === t2.protocol) {
            const e3 = t2.params.indexOf("secure");
            e3 >= 0 && t2.params.splice(e3, 1);
          }
          if ("/" !== n2.path && (t2.path = `${n2.path}${t2.path}`), !N.REQUIRE_ACCESS_TOKEN)
            return nt(t2);
          if (e2 = e2 || N.ACCESS_TOKEN, !this._silenceAuthErrors) {
            if (!e2)
              throw new Error(`An API access token is required to use Mapbox GL. ${r2}`);
            if ("s" === e2[0])
              throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${r2}`);
          }
          return t2.params = t2.params.filter((t3) => -1 === t3.indexOf("access_token")), t2.params.push(`access_token=${e2 || ""}`), nt(t2);
        }
      }, t.ResourceType = wt, t.SegmentVector = Oa, t.SourceCache = vp, t.StencilMode = fp, t.StructArrayLayout1ui2 = Gs, t.StructArrayLayout2f1f2i16 = Fs, t.StructArrayLayout2i4 = zs, t.StructArrayLayout2ui4 = Zs, t.StructArrayLayout3f12 = Es, t.StructArrayLayout3ui6 = $s, t.StructArrayLayout4i8 = Ts, t.Texture = Th, t.Tile = Qh, t.Transitionable = us, t.Uniform1f = va, t.Uniform1i = class extends xa {
        constructor(t2, e2) {
          super(t2, e2), this.current = 0;
        }
        set(t2) {
          this.current !== t2 && (this.current = t2, this.gl.uniform1i(this.location, t2));
        }
      }, t.Uniform2f = class extends xa {
        constructor(t2, e2) {
          super(t2, e2), this.current = [0, 0];
        }
        set(t2) {
          t2[0] === this.current[0] && t2[1] === this.current[1] || (this.current = t2, this.gl.uniform2f(this.location, t2[0], t2[1]));
        }
      }, t.Uniform3f = class extends xa {
        constructor(t2, e2) {
          super(t2, e2), this.current = [0, 0, 0];
        }
        set(t2) {
          t2[0] === this.current[0] && t2[1] === this.current[1] && t2[2] === this.current[2] || (this.current = t2, this.gl.uniform3f(this.location, t2[0], t2[1], t2[2]));
        }
      }, t.Uniform4f = ba, t.UniformColor = wa, t.UniformMatrix3f = class extends xa {
        constructor(t2, e2) {
          super(t2, e2), this.current = Aa;
        }
        set(t2) {
          for (let e2 = 0; e2 < 9; e2++)
            if (t2[e2] !== this.current[e2]) {
              this.current = t2, this.gl.uniformMatrix3fv(this.location, false, t2);
              break;
            }
        }
      }, t.UniformMatrix4f = class extends xa {
        constructor(t2, e2) {
          super(t2, e2), this.current = _a;
        }
        set(t2) {
          if (t2[12] !== this.current[12] || t2[0] !== this.current[0])
            return this.current = t2, void this.gl.uniformMatrix4fv(this.location, false, t2);
          for (let e2 = 1; e2 < 16; e2++)
            if (t2[e2] !== this.current[e2]) {
              this.current = t2, this.gl.uniformMatrix4fv(this.location, false, t2);
              break;
            }
        }
      }, t.UnwrappedTileID = Xh, t.ValidationError = $t, t.VectorTileWorkerSource = class extends Ft {
        constructor(t2, e2, r2, n2, i2) {
          super(), this.actor = t2, this.layerIndex = e2, this.availableImages = r2, this.loadVectorData = i2 || Ep, this.loading = {}, this.loaded = {}, this.deduped = new Mp(t2.scheduler), this.isSpriteLoaded = n2, this.scheduler = t2.scheduler;
        }
        loadTile(t2, e2) {
          const r2 = t2.uid, n2 = t2 && t2.request, i2 = n2 && n2.collectResourceTiming, s2 = this.loading[r2] = new zp(t2);
          s2.abort = this.loadVectorData(t2, (a2, o2) => {
            const l2 = !this.loading[r2];
            if (delete this.loading[r2], l2 || a2 || !o2)
              return s2.status = "done", l2 || (this.loaded[r2] = s2), e2(a2);
            const u2 = o2.rawData, c2 = {};
            o2.expires && (c2.expires = o2.expires), o2.cacheControl && (c2.cacheControl = o2.cacheControl), s2.vectorTile = o2.vectorTile || new Xl.VectorTile(new Pu(u2));
            const h2 = () => {
              s2.parse(s2.vectorTile, this.layerIndex, this.availableImages, this.actor, (t3, r3) => {
                if (t3 || !r3)
                  return e2(t3);
                const s3 = {};
                if (i2) {
                  const t4 = jh(n2);
                  t4.length > 0 && (s3.resourceTiming = JSON.parse(JSON.stringify(t4)));
                }
                e2(null, v({ rawTileData: u2.slice(0) }, r3, c2, s3));
              });
            };
            this.isSpriteLoaded ? h2() : this.once("isSpriteLoaded", () => {
              this.scheduler ? this.scheduler.add(h2, { type: "parseTile", isSymbolTile: t2.isSymbolTile, zoom: t2.tileZoom }) : h2();
            }), this.loaded = this.loaded || {}, this.loaded[r2] = s2;
          });
        }
        reloadTile(t2, e2) {
          const r2 = this.loaded, n2 = t2.uid, i2 = this;
          if (r2 && r2[n2]) {
            const s2 = r2[n2];
            s2.showCollisionBoxes = t2.showCollisionBoxes, s2.enableTerrain = !!t2.enableTerrain;
            const a2 = (t3, r3) => {
              const n3 = s2.reloadCallback;
              n3 && (delete s2.reloadCallback, s2.parse(s2.vectorTile, i2.layerIndex, this.availableImages, i2.actor, n3)), e2(t3, r3);
            };
            "parsing" === s2.status ? s2.reloadCallback = a2 : "done" === s2.status && (s2.vectorTile ? s2.parse(s2.vectorTile, this.layerIndex, this.availableImages, this.actor, a2) : a2());
          }
        }
        abortTile(t2, e2) {
          const r2 = t2.uid, n2 = this.loading[r2];
          n2 && (n2.abort && n2.abort(), delete this.loading[r2]), e2();
        }
        removeTile(t2, e2) {
          const r2 = this.loaded, n2 = t2.uid;
          r2 && r2[n2] && delete r2[n2], e2();
        }
      }, t.WritingMode = ac, t.ZoomHistory = pi, t.add = function(t2, e2, r2) {
        return t2[0] = e2[0] + r2[0], t2[1] = e2[1] + r2[1], t2[2] = e2[2] + r2[2], t2;
      }, t.addDynamicAttributes = lh, t.altitudeFromMercatorZ = Rh, t.asyncAll = g, t.bezier = d, t.bindAll = S, t.bufferConvexPolygon = function(t2, e2) {
        const r2 = [];
        for (let n2 = 0; n2 < t2.length; n2++) {
          const i2 = m(n2 - 1, -1, t2.length - 1), s2 = m(n2 + 1, -1, t2.length - 1), a2 = t2[n2], o2 = t2[s2], l2 = t2[i2].sub(a2).unit(), u2 = o2.sub(a2).unit(), c2 = u2.angleWithSep(l2.x, l2.y), h2 = l2.add(u2).unit().mult(-1 * e2 / Math.sin(c2 / 2));
          r2.push(a2.add(h2));
        }
        return r2;
      }, t.cacheEntryPossiblyAdded = function(t2) {
        bt++, bt > gt && (t2.getActor().send("enforceCacheSizeLimit", mt), bt = 0);
      }, t.clamp = y, t.clearTileCache = function(t2) {
        const e2 = a.caches.delete(dt);
        t2 && e2.catch(t2).then(() => t2());
      }, t.clipLine = Ec, t.clone = function(t2) {
        var e2 = new fo(3);
        return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2;
      }, t.clone$1 = function(t2) {
        var e2 = new fo(16);
        return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2[3] = t2[3], e2[4] = t2[4], e2[5] = t2[5], e2[6] = t2[6], e2[7] = t2[7], e2[8] = t2[8], e2[9] = t2[9], e2[10] = t2[10], e2[11] = t2[11], e2[12] = t2[12], e2[13] = t2[13], e2[14] = t2[14], e2[15] = t2[15], e2;
      }, t.clone$2 = M, t.collisionCircleLayout = wu, t.config = N, t.conjugate = function(t2, e2) {
        return t2[0] = -e2[0], t2[1] = -e2[1], t2[2] = -e2[2], t2[3] = e2[3], t2;
      }, t.copy = function(t2, e2) {
        return t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2;
      }, t.create = vo, t.create$1 = function() {
        var t2 = new fo(16);
        return fo != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0), t2[0] = 1, t2[5] = 1, t2[10] = 1, t2[15] = 1, t2;
      }, t.create$2 = yo, t.createExpression = cn, t.createFilter = kn, t.createLayout = Ss, t.createStyleLayer = function(t2) {
        return "custom" === t2.type ? new vh(t2) : new _h[t2.type](t2);
      }, t.cross = function(t2, e2, r2) {
        var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = r2[0], o2 = r2[1], l2 = r2[2];
        return t2[0] = i2 * l2 - s2 * o2, t2[1] = s2 * a2 - n2 * l2, t2[2] = n2 * o2 - i2 * a2, t2;
      }, t.degToRad = c, t.div = function(t2, e2, r2) {
        return t2[0] = e2[0] / r2[0], t2[1] = e2[1] / r2[1], t2[2] = e2[2] / r2[2], t2;
      }, t.dot = function(t2, e2) {
        return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2];
      }, t.dot$1 = function(t2, e2) {
        return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2] + t2[3] * e2[3];
      }, t.ease = f, t.easeCubicInOut = p, t.emitValidationErrors = ei, t.endsWith = I, t.enforceCacheSizeLimit = function(t2) {
        xt(), ft && ft.then((e2) => {
          e2.keys().then((r2) => {
            for (let n2 = 0; n2 < r2.length - t2; n2++)
              e2.delete(r2[n2]);
          });
        });
      }, t.evaluateSizeForFeature = Su, t.evaluateSizeForZoom = Iu, t.evaluateVariableOffset = Yc, t.evented = rs, t.exactEquals = function(t2, e2) {
        return t2[0] === e2[0] && t2[1] === e2[1] && t2[2] === e2[2] && t2[3] === e2[3];
      }, t.exactEquals$1 = function(t2, e2) {
        return t2[0] === e2[0] && t2[1] === e2[1] && t2[2] === e2[2];
      }, t.exported = q, t.exported$1 = Z, t.extend = v, t.filterObject = T, t.fromMat4 = function(t2, e2) {
        return t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[4], t2[4] = e2[5], t2[5] = e2[6], t2[6] = e2[8], t2[7] = e2[9], t2[8] = e2[10], t2;
      }, t.fromQuat = function(t2, e2) {
        var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = r2 + r2, o2 = n2 + n2, l2 = i2 + i2, u2 = r2 * a2, c2 = n2 * a2, h2 = n2 * o2, p2 = i2 * a2, d2 = i2 * o2, f2 = i2 * l2, y2 = s2 * a2, m2 = s2 * o2, g2 = s2 * l2;
        return t2[0] = 1 - h2 - f2, t2[1] = c2 + g2, t2[2] = p2 - m2, t2[3] = 0, t2[4] = c2 - g2, t2[5] = 1 - u2 - f2, t2[6] = d2 + y2, t2[7] = 0, t2[8] = p2 + m2, t2[9] = d2 - y2, t2[10] = 1 - u2 - h2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
      }, t.fromRotation = function(t2, e2) {
        var r2 = Math.sin(e2), n2 = Math.cos(e2);
        return t2[0] = n2, t2[1] = r2, t2[2] = 0, t2[3] = -r2, t2[4] = n2, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
      }, t.fromScaling = function(t2, e2) {
        return t2[0] = e2[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = e2[1], t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = e2[2], t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
      }, t.furthestTileCorner = function(t2) {
        const e2 = Math.round((t2 + 45 + 360) % 360 / 90) % 4;
        return h[e2];
      }, t.getAABBPointSquareDist = function(t2, e2, r2) {
        let n2 = 0;
        for (let i2 = 0; i2 < 2; ++i2) {
          const s2 = r2 ? r2[i2] : 0;
          t2[i2] > s2 && (n2 += (t2[i2] - s2) * (t2[i2] - s2)), e2[i2] < s2 && (n2 += (s2 - e2[i2]) * (s2 - e2[i2]));
        }
        return n2;
      }, t.getAnchorAlignment = xc, t.getAnchorJustification = Jc, t.getBounds = function(t2) {
        let e2 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, s2 = -1 / 0;
        for (const i2 of t2)
          e2 = Math.min(e2, i2.x), r2 = Math.min(r2, i2.y), n2 = Math.max(n2, i2.x), s2 = Math.max(s2, i2.y);
        return { min: new i(e2, r2), max: new i(n2, s2) };
      }, t.getImage = Bt, t.getJSON = function(t2, e2) {
        return kt(v(t2, { type: "json" }), e2);
      }, t.getMapSessionAPI = ht, t.getPerformanceMeasurement = jh, t.getRTLTextPluginStatus = ns, t.getReferrer = At, t.getVideo = function(t2, e2) {
        const r2 = a.document.createElement("video");
        r2.muted = true, r2.onloadstart = function() {
          e2(null, r2);
        };
        for (let e3 = 0; e3 < t2.length; e3++) {
          const n2 = a.document.createElement("source");
          Tt(t2[e3]) || (r2.crossOrigin = "Anonymous"), n2.src = t2[e3], r2.appendChild(n2);
        }
        return { cancel: () => {
        } };
      }, t.identity = mo, t.identity$1 = Do, t.invert = function(t2, e2) {
        var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = e2[4], o2 = e2[5], l2 = e2[6], u2 = e2[7], c2 = e2[8], h2 = e2[9], p2 = e2[10], d2 = e2[11], f2 = e2[12], y2 = e2[13], m2 = e2[14], g2 = e2[15], x2 = r2 * o2 - n2 * a2, v2 = r2 * l2 - i2 * a2, b2 = r2 * u2 - s2 * a2, w2 = n2 * l2 - i2 * o2, _2 = n2 * u2 - s2 * o2, A2 = i2 * u2 - s2 * l2, k2 = c2 * y2 - h2 * f2, S2 = c2 * m2 - p2 * f2, I2 = c2 * g2 - d2 * f2, z2 = h2 * m2 - p2 * y2, T2 = h2 * g2 - d2 * y2, M2 = p2 * g2 - d2 * m2, E2 = x2 * M2 - v2 * T2 + b2 * z2 + w2 * I2 - _2 * S2 + A2 * k2;
        return E2 ? (t2[0] = (o2 * M2 - l2 * T2 + u2 * z2) * (E2 = 1 / E2), t2[1] = (i2 * T2 - n2 * M2 - s2 * z2) * E2, t2[2] = (y2 * A2 - m2 * _2 + g2 * w2) * E2, t2[3] = (p2 * _2 - h2 * A2 - d2 * w2) * E2, t2[4] = (l2 * I2 - a2 * M2 - u2 * S2) * E2, t2[5] = (r2 * M2 - i2 * I2 + s2 * S2) * E2, t2[6] = (m2 * b2 - f2 * A2 - g2 * v2) * E2, t2[7] = (c2 * A2 - p2 * b2 + d2 * v2) * E2, t2[8] = (a2 * T2 - o2 * I2 + u2 * k2) * E2, t2[9] = (n2 * I2 - r2 * T2 - s2 * k2) * E2, t2[10] = (f2 * _2 - y2 * b2 + g2 * x2) * E2, t2[11] = (h2 * b2 - c2 * _2 - d2 * x2) * E2, t2[12] = (o2 * S2 - a2 * z2 - l2 * k2) * E2, t2[13] = (r2 * z2 - n2 * S2 + i2 * k2) * E2, t2[14] = (y2 * v2 - f2 * w2 - m2 * x2) * E2, t2[15] = (c2 * w2 - h2 * v2 + p2 * x2) * E2, t2) : null;
      }, t.isMapAuthenticated = function(t2) {
        return pt.has(t2);
      }, t.isMapboxURL = Q, t.latFromMercatorY = Fh, t.len = Eo, t.length = bo, t.length$1 = function(t2) {
        return Math.hypot(t2[0], t2[1], t2[2], t2[3]);
      }, t.loadVectorTile = Ep, t.makeRequest = kt, t.mercatorXfromLng = Ph, t.mercatorYfromLat = Vh, t.mercatorZfromAltitude = Lh, t.mul = function(t2, e2, r2) {
        return t2[0] = e2[0] * r2[0], t2[1] = e2[1] * r2[1], t2[2] = e2[2] * r2[2], t2[3] = e2[3] * r2[3], t2;
      }, t.mul$1 = xo, t.mul$2 = Mo, t.multiply = go, t.multiply$1 = Ao, t.nextPowerOfTwo = A, t.normalize = So, t.normalize$1 = function(t2, e2) {
        var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = r2 * r2 + n2 * n2 + i2 * i2 + s2 * s2;
        return a2 > 0 && (a2 = 1 / Math.sqrt(a2)), t2[0] = r2 * a2, t2[1] = n2 * a2, t2[2] = i2 * a2, t2[3] = s2 * a2, t2;
      }, t.number = rr, t.ortho = function(t2, e2, r2, n2, i2, s2, a2) {
        var o2 = 1 / (e2 - r2), l2 = 1 / (n2 - i2), u2 = 1 / (s2 - a2);
        return t2[0] = -2 * o2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = -2 * l2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 2 * u2, t2[11] = 0, t2[12] = (e2 + r2) * o2, t2[13] = (i2 + n2) * l2, t2[14] = (a2 + s2) * u2, t2[15] = 1, t2;
      }, t.pbf = Pu, t.perspective = function(t2, e2, r2, n2, i2) {
        var s2, a2 = 1 / Math.tan(e2 / 2);
        return t2[0] = a2 / r2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = a2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, null != i2 && i2 !== 1 / 0 ? (t2[10] = (i2 + n2) * (s2 = 1 / (n2 - i2)), t2[14] = 2 * i2 * n2 * s2) : (t2[10] = -1, t2[14] = -2 * n2), t2;
      }, t.pick = function(t2, e2) {
        const r2 = {};
        for (let n2 = 0; n2 < e2.length; n2++) {
          const i2 = e2[n2];
          i2 in t2 && (r2[i2] = t2[i2]);
        }
        return r2;
      }, t.plugin = ss, t.pointGeometry = i, t.polygonIntersectsBox = so, t.polygonIntersectsPolygon = Ya, t.polygonizeBounds = function(t2, e2, r2 = 0, n2 = true) {
        const s2 = new i(r2, r2), a2 = t2.sub(s2), o2 = e2.add(s2), l2 = [a2, new i(o2.x, a2.y), o2, new i(a2.x, o2.y)];
        return n2 && l2.push(a2), l2;
      }, t.posAttributes = Wh, t.postMapLoadEvent = ut, t.postTurnstileEvent = ot, t.potpack = nc, t.prevPowerOfTwo = function(t2) {
        return t2 <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t2) / Math.LN2));
      }, t.radToDeg = function(t2) {
        return t2 * u;
      }, t.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t.registerForPluginStateChange = function(t2) {
        return t2({ pluginStatus: Wi, pluginURL: Qi }), rs.on("pluginStateChange", t2), t2;
      }, t.removeAuthState = function(t2) {
        pt.delete(t2);
      }, t.renderColorRamp = Xo, t.rotateX = function(t2, e2, r2) {
        var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[4], a2 = e2[5], o2 = e2[6], l2 = e2[7], u2 = e2[8], c2 = e2[9], h2 = e2[10], p2 = e2[11];
        return e2 !== t2 && (t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[4] = s2 * i2 + u2 * n2, t2[5] = a2 * i2 + c2 * n2, t2[6] = o2 * i2 + h2 * n2, t2[7] = l2 * i2 + p2 * n2, t2[8] = u2 * i2 - s2 * n2, t2[9] = c2 * i2 - a2 * n2, t2[10] = h2 * i2 - o2 * n2, t2[11] = p2 * i2 - l2 * n2, t2;
      }, t.rotateX$1 = Po, t.rotateY = function(t2, e2, r2) {
        var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[0], a2 = e2[1], o2 = e2[2], l2 = e2[3], u2 = e2[8], c2 = e2[9], h2 = e2[10], p2 = e2[11];
        return e2 !== t2 && (t2[4] = e2[4], t2[5] = e2[5], t2[6] = e2[6], t2[7] = e2[7], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = s2 * i2 - u2 * n2, t2[1] = a2 * i2 - c2 * n2, t2[2] = o2 * i2 - h2 * n2, t2[3] = l2 * i2 - p2 * n2, t2[8] = s2 * n2 + u2 * i2, t2[9] = a2 * n2 + c2 * i2, t2[10] = o2 * n2 + h2 * i2, t2[11] = l2 * n2 + p2 * i2, t2;
      }, t.rotateZ = function(t2, e2, r2) {
        var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[0], a2 = e2[1], o2 = e2[2], l2 = e2[3], u2 = e2[4], c2 = e2[5], h2 = e2[6], p2 = e2[7];
        return e2 !== t2 && (t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = s2 * i2 + u2 * n2, t2[1] = a2 * i2 + c2 * n2, t2[2] = o2 * i2 + h2 * n2, t2[3] = l2 * i2 + p2 * n2, t2[4] = u2 * i2 - s2 * n2, t2[5] = c2 * i2 - a2 * n2, t2[6] = h2 * i2 - o2 * n2, t2[7] = p2 * i2 - l2 * n2, t2;
      }, t.rotateZ$1 = function(t2, e2, r2) {
        r2 *= 0.5;
        var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = Math.sin(r2), l2 = Math.cos(r2);
        return t2[0] = n2 * l2 + i2 * o2, t2[1] = i2 * l2 - n2 * o2, t2[2] = s2 * l2 + a2 * o2, t2[3] = a2 * l2 - s2 * o2, t2;
      }, t.scale = function(t2, e2, r2) {
        return t2[0] = e2[0] * r2, t2[1] = e2[1] * r2, t2[2] = e2[2] * r2, t2;
      }, t.scale$1 = function(t2, e2, r2) {
        var n2 = r2[0], i2 = r2[1], s2 = r2[2];
        return t2[0] = e2[0] * n2, t2[1] = e2[1] * n2, t2[2] = e2[2] * n2, t2[3] = e2[3] * n2, t2[4] = e2[4] * i2, t2[5] = e2[5] * i2, t2[6] = e2[6] * i2, t2[7] = e2[7] * i2, t2[8] = e2[8] * s2, t2[9] = e2[9] * s2, t2[10] = e2[10] * s2, t2[11] = e2[11] * s2, t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
      }, t.scale$2 = function(t2, e2, r2) {
        return t2[0] = e2[0] * r2, t2[1] = e2[1] * r2, t2[2] = e2[2] * r2, t2[3] = e2[3] * r2, t2;
      }, t.scaleAndAdd = ko, t.setCacheLimits = function(t2, e2) {
        mt = t2, gt = e2;
      }, t.setRTLTextPlugin = function(t2, e2, r2 = false) {
        if (Wi === Ki || Wi === Yi || Wi === Hi)
          throw new Error("setRTLTextPlugin cannot be called multiple times.");
        Qi = q.resolveURL(t2), Wi = Ki, Ji = e2, es(), r2 || is();
      }, t.smoothstep = function(t2, e2, r2) {
        return (r2 = y((r2 - t2) / (e2 - t2), 0, 1)) * r2 * (3 - 2 * r2);
      }, t.spec = Rt, t.storeAuthState = function(t2, e2) {
        e2 ? pt.add(t2) : pt.delete(t2);
      }, t.sub = To, t.subtract = _o, t.symbolSize = zu, t.transformMat3 = function(t2, e2, r2) {
        var n2 = e2[0], i2 = e2[1], s2 = e2[2];
        return t2[0] = n2 * r2[0] + i2 * r2[3] + s2 * r2[6], t2[1] = n2 * r2[1] + i2 * r2[4] + s2 * r2[7], t2[2] = n2 * r2[2] + i2 * r2[5] + s2 * r2[8], t2;
      }, t.transformMat4 = Co, t.transformMat4$1 = function(t2, e2, r2) {
        var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = r2[3] * n2 + r2[7] * i2 + r2[11] * s2 + r2[15];
        return t2[0] = (r2[0] * n2 + r2[4] * i2 + r2[8] * s2 + r2[12]) / (a2 = a2 || 1), t2[1] = (r2[1] * n2 + r2[5] * i2 + r2[9] * s2 + r2[13]) / a2, t2[2] = (r2[2] * n2 + r2[6] * i2 + r2[10] * s2 + r2[14]) / a2, t2;
      }, t.transformQuat = Io, t.translate = function(t2, e2, r2) {
        var n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, d2, f2, y2 = r2[0], m2 = r2[1], g2 = r2[2];
        return e2 === t2 ? (t2[12] = e2[0] * y2 + e2[4] * m2 + e2[8] * g2 + e2[12], t2[13] = e2[1] * y2 + e2[5] * m2 + e2[9] * g2 + e2[13], t2[14] = e2[2] * y2 + e2[6] * m2 + e2[10] * g2 + e2[14], t2[15] = e2[3] * y2 + e2[7] * m2 + e2[11] * g2 + e2[15]) : (i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], d2 = e2[10], f2 = e2[11], t2[0] = n2 = e2[0], t2[1] = i2, t2[2] = s2, t2[3] = a2, t2[4] = o2, t2[5] = l2, t2[6] = u2, t2[7] = c2, t2[8] = h2, t2[9] = p2, t2[10] = d2, t2[11] = f2, t2[12] = n2 * y2 + o2 * m2 + h2 * g2 + e2[12], t2[13] = i2 * y2 + l2 * m2 + p2 * g2 + e2[13], t2[14] = s2 * y2 + u2 * m2 + d2 * g2 + e2[14], t2[15] = a2 * y2 + c2 * m2 + f2 * g2 + e2[15]), t2;
      }, t.triggerPluginCompletionEvent = ts, t.uniqueId = w, t.validateCustomStyleLayer = function(t2) {
        const e2 = [], r2 = t2.id;
        return void 0 === r2 && e2.push({ message: `layers.${r2}: missing required property "id"` }), void 0 === t2.render && e2.push({ message: `layers.${r2}: missing required method "render"` }), t2.renderingMode && "2d" !== t2.renderingMode && "3d" !== t2.renderingMode && e2.push({ message: `layers.${r2}: property "renderingMode" must be either "2d" or "3d"` }), e2;
      }, t.validateFog = Wn, t.validateLight = Jn, t.validateStyle = Hn, t.values = x, t.vectorTile = Xl, t.version = e, t.warnOnce = C, t.window = a, t.wrap = m;
    });
    define(["./shared"], function(e) {
      function t(e2) {
        const r2 = typeof e2;
        if ("number" === r2 || "boolean" === r2 || "string" === r2 || null == e2)
          return JSON.stringify(e2);
        if (Array.isArray(e2)) {
          let r3 = "[";
          for (const o3 of e2)
            r3 += `${t(o3)},`;
          return `${r3}]`;
        }
        const o2 = Object.keys(e2).sort();
        let n2 = "{";
        for (let r3 = 0; r3 < o2.length; r3++)
          n2 += `${JSON.stringify(o2[r3])}:${t(e2[o2[r3]])},`;
        return `${n2}}`;
      }
      function r(r2) {
        let o2 = "";
        for (const n2 of e.refProperties)
          o2 += `/${t(r2[n2])}`;
        return o2;
      }
      class o {
        constructor(e2) {
          this.keyCache = {}, e2 && this.replace(e2);
        }
        replace(e2) {
          this._layerConfigs = {}, this._layers = {}, this.update(e2, []);
        }
        update(t2, o2) {
          for (const r2 of t2) {
            this._layerConfigs[r2.id] = r2;
            const t3 = this._layers[r2.id] = e.createStyleLayer(r2);
            t3._featureFilter = e.createFilter(t3.filter), this.keyCache[r2.id] && delete this.keyCache[r2.id];
          }
          for (const e2 of o2)
            delete this.keyCache[e2], delete this._layerConfigs[e2], delete this._layers[e2];
          this.familiesBySource = {};
          const n2 = function(e2, t3) {
            const o3 = {};
            for (let n4 = 0; n4 < e2.length; n4++) {
              const i2 = t3 && t3[e2[n4].id] || r(e2[n4]);
              t3 && (t3[e2[n4].id] = i2);
              let s2 = o3[i2];
              s2 || (s2 = o3[i2] = []), s2.push(e2[n4]);
            }
            const n3 = [];
            for (const e3 in o3)
              n3.push(o3[e3]);
            return n3;
          }(e.values(this._layerConfigs), this.keyCache);
          for (const e2 of n2) {
            const t3 = e2.map((e3) => this._layers[e3.id]), r2 = t3[0];
            if ("none" === r2.visibility)
              continue;
            const o3 = r2.source || "";
            let n3 = this.familiesBySource[o3];
            n3 || (n3 = this.familiesBySource[o3] = {});
            const i2 = r2.sourceLayer || "_geojsonTileLayer";
            let s2 = n3[i2];
            s2 || (s2 = n3[i2] = []), s2.push(t3);
          }
        }
      }
      const { ImageBitmap: n } = e.window;
      class i {
        loadTile(t2, r2) {
          const { uid: o2, encoding: i2, rawImageData: s2, padding: a2, buildQuadTree: l2 } = t2, u2 = n && s2 instanceof n ? this.getImageData(s2, a2) : s2;
          r2(null, new e.DEMData(o2, u2, i2, a2 < 1, l2));
        }
        getImageData(t2, r2) {
          this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(t2.width, t2.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d")), this.offscreenCanvas.width = t2.width, this.offscreenCanvas.height = t2.height, this.offscreenCanvasContext.drawImage(t2, 0, 0, t2.width, t2.height);
          const o2 = this.offscreenCanvasContext.getImageData(-r2, -r2, t2.width + 2 * r2, t2.height + 2 * r2);
          return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), new e.RGBAImage({ width: o2.width, height: o2.height }, o2.data);
        }
      }
      var s = function e2(t2, r2) {
        var o2, n2 = t2 && t2.type;
        if ("FeatureCollection" === n2)
          for (o2 = 0; o2 < t2.features.length; o2++)
            e2(t2.features[o2], r2);
        else if ("GeometryCollection" === n2)
          for (o2 = 0; o2 < t2.geometries.length; o2++)
            e2(t2.geometries[o2], r2);
        else if ("Feature" === n2)
          e2(t2.geometry, r2);
        else if ("Polygon" === n2)
          a(t2.coordinates, r2);
        else if ("MultiPolygon" === n2)
          for (o2 = 0; o2 < t2.coordinates.length; o2++)
            a(t2.coordinates[o2], r2);
        return t2;
      };
      function a(e2, t2) {
        if (0 !== e2.length) {
          l(e2[0], t2);
          for (var r2 = 1; r2 < e2.length; r2++)
            l(e2[r2], !t2);
        }
      }
      function l(e2, t2) {
        for (var r2 = 0, o2 = 0, n2 = e2.length, i2 = n2 - 1; o2 < n2; i2 = o2++)
          r2 += (e2[o2][0] - e2[i2][0]) * (e2[i2][1] + e2[o2][1]);
        r2 >= 0 != !!t2 && e2.reverse();
      }
      const u = e.vectorTile.VectorTileFeature.prototype.toGeoJSON;
      class h {
        constructor(t2) {
          this._feature = t2, this.extent = e.EXTENT, this.type = t2.type, this.properties = t2.tags, "id" in t2 && !isNaN(t2.id) && (this.id = parseInt(t2.id, 10));
        }
        loadGeometry() {
          if (1 === this._feature.type) {
            const t2 = [];
            for (const r2 of this._feature.geometry)
              t2.push([new e.pointGeometry(r2[0], r2[1])]);
            return t2;
          }
          {
            const t2 = [];
            for (const r2 of this._feature.geometry) {
              const o2 = [];
              for (const t3 of r2)
                o2.push(new e.pointGeometry(t3[0], t3[1]));
              t2.push(o2);
            }
            return t2;
          }
        }
        toGeoJSON(e2, t2, r2) {
          return u.call(this, e2, t2, r2);
        }
      }
      class c {
        constructor(t2) {
          this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e.EXTENT, this.length = t2.length, this._features = t2;
        }
        feature(e2) {
          return new h(this._features[e2]);
        }
      }
      var f = e.vectorTile.VectorTileFeature, p = g;
      function g(e2, t2) {
        this.options = t2 || {}, this.features = e2, this.length = e2.length;
      }
      function d(e2, t2) {
        this.id = "number" == typeof e2.id ? e2.id : void 0, this.type = e2.type, this.rawGeometry = 1 === e2.type ? [e2.geometry] : e2.geometry, this.properties = e2.tags, this.extent = t2 || 4096;
      }
      g.prototype.feature = function(e2) {
        return new d(this.features[e2], this.options.extent);
      }, d.prototype.loadGeometry = function() {
        var t2 = this.rawGeometry;
        this.geometry = [];
        for (var r2 = 0; r2 < t2.length; r2++) {
          for (var o2 = t2[r2], n2 = [], i2 = 0; i2 < o2.length; i2++)
            n2.push(new e.pointGeometry(o2[i2][0], o2[i2][1]));
          this.geometry.push(n2);
        }
        return this.geometry;
      }, d.prototype.bbox = function() {
        this.geometry || this.loadGeometry();
        for (var e2 = this.geometry, t2 = 1 / 0, r2 = -1 / 0, o2 = 1 / 0, n2 = -1 / 0, i2 = 0; i2 < e2.length; i2++)
          for (var s2 = e2[i2], a2 = 0; a2 < s2.length; a2++) {
            var l2 = s2[a2];
            t2 = Math.min(t2, l2.x), r2 = Math.max(r2, l2.x), o2 = Math.min(o2, l2.y), n2 = Math.max(n2, l2.y);
          }
        return [t2, o2, r2, n2];
      }, d.prototype.toGeoJSON = f.prototype.toGeoJSON;
      var m = v, y = p;
      function v(t2) {
        var r2 = new e.pbf();
        return function(e2, t3) {
          for (var r3 in e2.layers)
            t3.writeMessage(3, x, e2.layers[r3]);
        }(t2, r2), r2.finish();
      }
      function x(e2, t2) {
        var r2;
        t2.writeVarintField(15, e2.version || 1), t2.writeStringField(1, e2.name || ""), t2.writeVarintField(5, e2.extent || 4096);
        var o2 = { keys: [], values: [], keycache: {}, valuecache: {} };
        for (r2 = 0; r2 < e2.length; r2++)
          o2.feature = e2.feature(r2), t2.writeMessage(2, w, o2);
        var n2 = o2.keys;
        for (r2 = 0; r2 < n2.length; r2++)
          t2.writeStringField(3, n2[r2]);
        var i2 = o2.values;
        for (r2 = 0; r2 < i2.length; r2++)
          t2.writeMessage(4, T, i2[r2]);
      }
      function w(e2, t2) {
        var r2 = e2.feature;
        void 0 !== r2.id && t2.writeVarintField(1, r2.id), t2.writeMessage(2, S, e2), t2.writeVarintField(3, r2.type), t2.writeMessage(4, b, r2);
      }
      function S(e2, t2) {
        var r2 = e2.feature, o2 = e2.keys, n2 = e2.values, i2 = e2.keycache, s2 = e2.valuecache;
        for (var a2 in r2.properties) {
          var l2 = i2[a2];
          void 0 === l2 && (o2.push(a2), i2[a2] = l2 = o2.length - 1), t2.writeVarint(l2);
          var u2 = r2.properties[a2], h2 = typeof u2;
          "string" !== h2 && "boolean" !== h2 && "number" !== h2 && (u2 = JSON.stringify(u2));
          var c2 = h2 + ":" + u2, f2 = s2[c2];
          void 0 === f2 && (n2.push(u2), s2[c2] = f2 = n2.length - 1), t2.writeVarint(f2);
        }
      }
      function M(e2, t2) {
        return (t2 << 3) + (7 & e2);
      }
      function P(e2) {
        return e2 << 1 ^ e2 >> 31;
      }
      function b(e2, t2) {
        for (var r2 = e2.loadGeometry(), o2 = e2.type, n2 = 0, i2 = 0, s2 = r2.length, a2 = 0; a2 < s2; a2++) {
          var l2 = r2[a2], u2 = 1;
          1 === o2 && (u2 = l2.length), t2.writeVarint(M(1, u2));
          for (var h2 = 3 === o2 ? l2.length - 1 : l2.length, c2 = 0; c2 < h2; c2++) {
            1 === c2 && 1 !== o2 && t2.writeVarint(M(2, h2 - 1));
            var f2 = l2[c2].x - n2, p2 = l2[c2].y - i2;
            t2.writeVarint(P(f2)), t2.writeVarint(P(p2)), n2 += f2, i2 += p2;
          }
          3 === o2 && t2.writeVarint(M(7, 1));
        }
      }
      function T(e2, t2) {
        var r2 = typeof e2;
        "string" === r2 ? t2.writeStringField(1, e2) : "boolean" === r2 ? t2.writeBooleanField(7, e2) : "number" === r2 && (e2 % 1 != 0 ? t2.writeDoubleField(3, e2) : e2 < 0 ? t2.writeSVarintField(6, e2) : t2.writeVarintField(5, e2));
      }
      function k(e2, t2, r2, o2, n2, i2) {
        if (n2 - o2 <= r2)
          return;
        const s2 = o2 + n2 >> 1;
        I(e2, t2, s2, o2, n2, i2 % 2), k(e2, t2, r2, o2, s2 - 1, i2 + 1), k(e2, t2, r2, s2 + 1, n2, i2 + 1);
      }
      function I(e2, t2, r2, o2, n2, i2) {
        for (; n2 > o2; ) {
          if (n2 - o2 > 600) {
            const s3 = n2 - o2 + 1, a3 = r2 - o2 + 1, l3 = Math.log(s3), u2 = 0.5 * Math.exp(2 * l3 / 3), h2 = 0.5 * Math.sqrt(l3 * u2 * (s3 - u2) / s3) * (a3 - s3 / 2 < 0 ? -1 : 1);
            I(e2, t2, r2, Math.max(o2, Math.floor(r2 - a3 * u2 / s3 + h2)), Math.min(n2, Math.floor(r2 + (s3 - a3) * u2 / s3 + h2)), i2);
          }
          const s2 = t2[2 * r2 + i2];
          let a2 = o2, l2 = n2;
          for (_(e2, t2, o2, r2), t2[2 * n2 + i2] > s2 && _(e2, t2, o2, n2); a2 < l2; ) {
            for (_(e2, t2, a2, l2), a2++, l2--; t2[2 * a2 + i2] < s2; )
              a2++;
            for (; t2[2 * l2 + i2] > s2; )
              l2--;
          }
          t2[2 * o2 + i2] === s2 ? _(e2, t2, o2, l2) : (l2++, _(e2, t2, l2, n2)), l2 <= r2 && (o2 = l2 + 1), r2 <= l2 && (n2 = l2 - 1);
        }
      }
      function _(e2, t2, r2, o2) {
        L(e2, r2, o2), L(t2, 2 * r2, 2 * o2), L(t2, 2 * r2 + 1, 2 * o2 + 1);
      }
      function L(e2, t2, r2) {
        const o2 = e2[t2];
        e2[t2] = e2[r2], e2[r2] = o2;
      }
      function C(e2, t2, r2, o2) {
        const n2 = e2 - r2, i2 = t2 - o2;
        return n2 * n2 + i2 * i2;
      }
      m.fromVectorTileJs = v, m.fromGeojsonVt = function(e2, t2) {
        t2 = t2 || {};
        var r2 = {};
        for (var o2 in e2)
          r2[o2] = new p(e2[o2].features, t2), r2[o2].name = o2, r2[o2].version = t2.version, r2[o2].extent = t2.extent;
        return v({ layers: r2 });
      }, m.GeoJSONWrapper = y;
      const O = (e2) => e2[0], z = (e2) => e2[1];
      class E {
        constructor(e2, t2 = O, r2 = z, o2 = 64, n2 = Float64Array) {
          this.nodeSize = o2, this.points = e2;
          const i2 = e2.length < 65536 ? Uint16Array : Uint32Array, s2 = this.ids = new i2(e2.length), a2 = this.coords = new n2(2 * e2.length);
          for (let o3 = 0; o3 < e2.length; o3++)
            s2[o3] = o3, a2[2 * o3] = t2(e2[o3]), a2[2 * o3 + 1] = r2(e2[o3]);
          k(s2, a2, o2, 0, s2.length - 1, 0);
        }
        range(e2, t2, r2, o2) {
          return function(e3, t3, r3, o3, n2, i2, s2) {
            const a2 = [0, e3.length - 1, 0], l2 = [];
            let u2, h2;
            for (; a2.length; ) {
              const c2 = a2.pop(), f2 = a2.pop(), p2 = a2.pop();
              if (f2 - p2 <= s2) {
                for (let s3 = p2; s3 <= f2; s3++)
                  u2 = t3[2 * s3], h2 = t3[2 * s3 + 1], u2 >= r3 && u2 <= n2 && h2 >= o3 && h2 <= i2 && l2.push(e3[s3]);
                continue;
              }
              const g2 = Math.floor((p2 + f2) / 2);
              u2 = t3[2 * g2], h2 = t3[2 * g2 + 1], u2 >= r3 && u2 <= n2 && h2 >= o3 && h2 <= i2 && l2.push(e3[g2]);
              const d2 = (c2 + 1) % 2;
              (0 === c2 ? r3 <= u2 : o3 <= h2) && (a2.push(p2), a2.push(g2 - 1), a2.push(d2)), (0 === c2 ? n2 >= u2 : i2 >= h2) && (a2.push(g2 + 1), a2.push(f2), a2.push(d2));
            }
            return l2;
          }(this.ids, this.coords, e2, t2, r2, o2, this.nodeSize);
        }
        within(e2, t2, r2) {
          return function(e3, t3, r3, o2, n2, i2) {
            const s2 = [0, e3.length - 1, 0], a2 = [], l2 = n2 * n2;
            for (; s2.length; ) {
              const u2 = s2.pop(), h2 = s2.pop(), c2 = s2.pop();
              if (h2 - c2 <= i2) {
                for (let n3 = c2; n3 <= h2; n3++)
                  C(t3[2 * n3], t3[2 * n3 + 1], r3, o2) <= l2 && a2.push(e3[n3]);
                continue;
              }
              const f2 = Math.floor((c2 + h2) / 2), p2 = t3[2 * f2], g2 = t3[2 * f2 + 1];
              C(p2, g2, r3, o2) <= l2 && a2.push(e3[f2]);
              const d2 = (u2 + 1) % 2;
              (0 === u2 ? r3 - n2 <= p2 : o2 - n2 <= g2) && (s2.push(c2), s2.push(f2 - 1), s2.push(d2)), (0 === u2 ? r3 + n2 >= p2 : o2 + n2 >= g2) && (s2.push(f2 + 1), s2.push(h2), s2.push(d2));
            }
            return a2;
          }(this.ids, this.coords, e2, t2, r2, this.nodeSize);
        }
      }
      const F = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e2) => e2 }, N = Math.fround || (Z = new Float32Array(1), (e2) => (Z[0] = +e2, Z[0]));
      var Z;
      class G {
        constructor(e2) {
          this.options = D(Object.create(F), e2), this.trees = new Array(this.options.maxZoom + 1);
        }
        load(e2) {
          const { log: t2, minZoom: r2, maxZoom: o2, nodeSize: n2 } = this.options;
          t2 && console.time("total time");
          const i2 = `prepare ${e2.length} points`;
          t2 && console.time(i2), this.points = e2;
          let s2 = [];
          for (let t3 = 0; t3 < e2.length; t3++)
            e2[t3].geometry && s2.push(Y(e2[t3], t3));
          this.trees[o2 + 1] = new E(s2, $, B, n2, Float32Array), t2 && console.timeEnd(i2);
          for (let e3 = o2; e3 >= r2; e3--) {
            const r3 = +Date.now();
            s2 = this._cluster(s2, e3), this.trees[e3] = new E(s2, $, B, n2, Float32Array), t2 && console.log("z%d: %d clusters in %dms", e3, s2.length, +Date.now() - r3);
          }
          return t2 && console.timeEnd("total time"), this;
        }
        getClusters(e2, t2) {
          let r2 = ((e2[0] + 180) % 360 + 360) % 360 - 180;
          const o2 = Math.max(-90, Math.min(90, e2[1]));
          let n2 = 180 === e2[2] ? 180 : ((e2[2] + 180) % 360 + 360) % 360 - 180;
          const i2 = Math.max(-90, Math.min(90, e2[3]));
          if (e2[2] - e2[0] >= 360)
            r2 = -180, n2 = 180;
          else if (r2 > n2) {
            const e3 = this.getClusters([r2, o2, 180, i2], t2), s3 = this.getClusters([-180, o2, n2, i2], t2);
            return e3.concat(s3);
          }
          const s2 = this.trees[this._limitZoom(t2)], a2 = s2.range(V(r2), j(i2), V(n2), j(o2)), l2 = [];
          for (const e3 of a2) {
            const t3 = s2.points[e3];
            l2.push(t3.numPoints ? W(t3) : this.points[t3.index]);
          }
          return l2;
        }
        getChildren(e2) {
          const t2 = this._getOriginId(e2), r2 = this._getOriginZoom(e2), o2 = "No cluster with the specified id.", n2 = this.trees[r2];
          if (!n2)
            throw new Error(o2);
          const i2 = n2.points[t2];
          if (!i2)
            throw new Error(o2);
          const s2 = this.options.radius / (this.options.extent * Math.pow(2, r2 - 1)), a2 = n2.within(i2.x, i2.y, s2), l2 = [];
          for (const t3 of a2) {
            const r3 = n2.points[t3];
            r3.parentId === e2 && l2.push(r3.numPoints ? W(r3) : this.points[r3.index]);
          }
          if (0 === l2.length)
            throw new Error(o2);
          return l2;
        }
        getLeaves(e2, t2, r2) {
          const o2 = [];
          return this._appendLeaves(o2, e2, t2 = t2 || 10, r2 = r2 || 0, 0), o2;
        }
        getTile(e2, t2, r2) {
          const o2 = this.trees[this._limitZoom(e2)], n2 = Math.pow(2, e2), { extent: i2, radius: s2 } = this.options, a2 = s2 / i2, l2 = (r2 - a2) / n2, u2 = (r2 + 1 + a2) / n2, h2 = { features: [] };
          return this._addTileFeatures(o2.range((t2 - a2) / n2, l2, (t2 + 1 + a2) / n2, u2), o2.points, t2, r2, n2, h2), 0 === t2 && this._addTileFeatures(o2.range(1 - a2 / n2, l2, 1, u2), o2.points, n2, r2, n2, h2), t2 === n2 - 1 && this._addTileFeatures(o2.range(0, l2, a2 / n2, u2), o2.points, -1, r2, n2, h2), h2.features.length ? h2 : null;
        }
        getClusterExpansionZoom(e2) {
          let t2 = this._getOriginZoom(e2) - 1;
          for (; t2 <= this.options.maxZoom; ) {
            const r2 = this.getChildren(e2);
            if (t2++, 1 !== r2.length)
              break;
            e2 = r2[0].properties.cluster_id;
          }
          return t2;
        }
        _appendLeaves(e2, t2, r2, o2, n2) {
          const i2 = this.getChildren(t2);
          for (const t3 of i2) {
            const i3 = t3.properties;
            if (i3 && i3.cluster ? n2 + i3.point_count <= o2 ? n2 += i3.point_count : n2 = this._appendLeaves(e2, i3.cluster_id, r2, o2, n2) : n2 < o2 ? n2++ : e2.push(t3), e2.length === r2)
              break;
          }
          return n2;
        }
        _addTileFeatures(e2, t2, r2, o2, n2, i2) {
          for (const s2 of e2) {
            const e3 = t2[s2], a2 = e3.numPoints;
            let l2, u2, h2;
            if (a2)
              l2 = X(e3), u2 = e3.x, h2 = e3.y;
            else {
              const t3 = this.points[e3.index];
              l2 = t3.properties, u2 = V(t3.geometry.coordinates[0]), h2 = j(t3.geometry.coordinates[1]);
            }
            const c2 = { type: 1, geometry: [[Math.round(this.options.extent * (u2 * n2 - r2)), Math.round(this.options.extent * (h2 * n2 - o2))]], tags: l2 };
            let f2;
            a2 ? f2 = e3.id : this.options.generateId ? f2 = e3.index : this.points[e3.index].id && (f2 = this.points[e3.index].id), void 0 !== f2 && (c2.id = f2), i2.features.push(c2);
          }
        }
        _limitZoom(e2) {
          return Math.max(this.options.minZoom, Math.min(+e2, this.options.maxZoom + 1));
        }
        _cluster(e2, t2) {
          const r2 = [], { radius: o2, extent: n2, reduce: i2, minPoints: s2 } = this.options, a2 = o2 / (n2 * Math.pow(2, t2));
          for (let o3 = 0; o3 < e2.length; o3++) {
            const n3 = e2[o3];
            if (n3.zoom <= t2)
              continue;
            n3.zoom = t2;
            const l2 = this.trees[t2 + 1], u2 = l2.within(n3.x, n3.y, a2), h2 = n3.numPoints || 1;
            let c2 = h2;
            for (const e3 of u2) {
              const r3 = l2.points[e3];
              r3.zoom > t2 && (c2 += r3.numPoints || 1);
            }
            if (c2 >= s2) {
              let e3 = n3.x * h2, s3 = n3.y * h2, a3 = i2 && h2 > 1 ? this._map(n3, true) : null;
              const f2 = (o3 << 5) + (t2 + 1) + this.points.length;
              for (const r3 of u2) {
                const o4 = l2.points[r3];
                if (o4.zoom <= t2)
                  continue;
                o4.zoom = t2;
                const u3 = o4.numPoints || 1;
                e3 += o4.x * u3, s3 += o4.y * u3, o4.parentId = f2, i2 && (a3 || (a3 = this._map(n3, true)), i2(a3, this._map(o4)));
              }
              n3.parentId = f2, r2.push(J(e3 / c2, s3 / c2, f2, c2, a3));
            } else if (r2.push(n3), c2 > 1)
              for (const e3 of u2) {
                const o4 = l2.points[e3];
                o4.zoom <= t2 || (o4.zoom = t2, r2.push(o4));
              }
          }
          return r2;
        }
        _getOriginId(e2) {
          return e2 - this.points.length >> 5;
        }
        _getOriginZoom(e2) {
          return (e2 - this.points.length) % 32;
        }
        _map(e2, t2) {
          if (e2.numPoints)
            return t2 ? D({}, e2.properties) : e2.properties;
          const r2 = this.points[e2.index].properties, o2 = this.options.map(r2);
          return t2 && o2 === r2 ? D({}, o2) : o2;
        }
      }
      function J(e2, t2, r2, o2, n2) {
        return { x: N(e2), y: N(t2), zoom: 1 / 0, id: r2, parentId: -1, numPoints: o2, properties: n2 };
      }
      function Y(e2, t2) {
        const [r2, o2] = e2.geometry.coordinates;
        return { x: N(V(r2)), y: N(j(o2)), zoom: 1 / 0, index: t2, parentId: -1 };
      }
      function W(e2) {
        return { type: "Feature", id: e2.id, properties: X(e2), geometry: { type: "Point", coordinates: [(t2 = e2.x, 360 * (t2 - 0.5)), A(e2.y)] } };
        var t2;
      }
      function X(e2) {
        const t2 = e2.numPoints, r2 = t2 >= 1e4 ? `${Math.round(t2 / 1e3)}k` : t2 >= 1e3 ? Math.round(t2 / 100) / 10 + "k" : t2;
        return D(D({}, e2.properties), { cluster: true, cluster_id: e2.id, point_count: t2, point_count_abbreviated: r2 });
      }
      function V(e2) {
        return e2 / 360 + 0.5;
      }
      function j(e2) {
        const t2 = Math.sin(e2 * Math.PI / 180), r2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
        return r2 < 0 ? 0 : r2 > 1 ? 1 : r2;
      }
      function A(e2) {
        const t2 = (180 - 360 * e2) * Math.PI / 180;
        return 360 * Math.atan(Math.exp(t2)) / Math.PI - 90;
      }
      function D(e2, t2) {
        for (const r2 in t2)
          e2[r2] = t2[r2];
        return e2;
      }
      function $(e2) {
        return e2.x;
      }
      function B(e2) {
        return e2.y;
      }
      function R(e2, t2, r2, o2) {
        for (var n2, i2 = o2, s2 = r2 - t2 >> 1, a2 = r2 - t2, l2 = e2[t2], u2 = e2[t2 + 1], h2 = e2[r2], c2 = e2[r2 + 1], f2 = t2 + 3; f2 < r2; f2 += 3) {
          var p2 = q(e2[f2], e2[f2 + 1], l2, u2, h2, c2);
          if (p2 > i2)
            n2 = f2, i2 = p2;
          else if (p2 === i2) {
            var g2 = Math.abs(f2 - s2);
            g2 < a2 && (n2 = f2, a2 = g2);
          }
        }
        i2 > o2 && (n2 - t2 > 3 && R(e2, t2, n2, o2), e2[n2 + 2] = i2, r2 - n2 > 3 && R(e2, n2, r2, o2));
      }
      function q(e2, t2, r2, o2, n2, i2) {
        var s2 = n2 - r2, a2 = i2 - o2;
        if (0 !== s2 || 0 !== a2) {
          var l2 = ((e2 - r2) * s2 + (t2 - o2) * a2) / (s2 * s2 + a2 * a2);
          l2 > 1 ? (r2 = n2, o2 = i2) : l2 > 0 && (r2 += s2 * l2, o2 += a2 * l2);
        }
        return (s2 = e2 - r2) * s2 + (a2 = t2 - o2) * a2;
      }
      function U(e2, t2, r2, o2) {
        var n2 = { id: void 0 === e2 ? null : e2, type: t2, geometry: r2, tags: o2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        return function(e3) {
          var t3 = e3.geometry, r3 = e3.type;
          if ("Point" === r3 || "MultiPoint" === r3 || "LineString" === r3)
            Q(e3, t3);
          else if ("Polygon" === r3 || "MultiLineString" === r3)
            for (var o3 = 0; o3 < t3.length; o3++)
              Q(e3, t3[o3]);
          else if ("MultiPolygon" === r3)
            for (o3 = 0; o3 < t3.length; o3++)
              for (var n3 = 0; n3 < t3[o3].length; n3++)
                Q(e3, t3[o3][n3]);
        }(n2), n2;
      }
      function Q(e2, t2) {
        for (var r2 = 0; r2 < t2.length; r2 += 3)
          e2.minX = Math.min(e2.minX, t2[r2]), e2.minY = Math.min(e2.minY, t2[r2 + 1]), e2.maxX = Math.max(e2.maxX, t2[r2]), e2.maxY = Math.max(e2.maxY, t2[r2 + 1]);
      }
      function H(e2, t2, r2, o2) {
        if (t2.geometry) {
          var n2 = t2.geometry.coordinates, i2 = t2.geometry.type, s2 = Math.pow(r2.tolerance / ((1 << r2.maxZoom) * r2.extent), 2), a2 = [], l2 = t2.id;
          if (r2.promoteId ? l2 = t2.properties[r2.promoteId] : r2.generateId && (l2 = o2 || 0), "Point" === i2)
            K(n2, a2);
          else if ("MultiPoint" === i2)
            for (var u2 = 0; u2 < n2.length; u2++)
              K(n2[u2], a2);
          else if ("LineString" === i2)
            ee(n2, a2, s2, false);
          else if ("MultiLineString" === i2) {
            if (r2.lineMetrics) {
              for (u2 = 0; u2 < n2.length; u2++)
                ee(n2[u2], a2 = [], s2, false), e2.push(U(l2, "LineString", a2, t2.properties));
              return;
            }
            te(n2, a2, s2, false);
          } else if ("Polygon" === i2)
            te(n2, a2, s2, true);
          else {
            if ("MultiPolygon" !== i2) {
              if ("GeometryCollection" === i2) {
                for (u2 = 0; u2 < t2.geometry.geometries.length; u2++)
                  H(e2, { id: l2, geometry: t2.geometry.geometries[u2], properties: t2.properties }, r2, o2);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (u2 = 0; u2 < n2.length; u2++) {
              var h2 = [];
              te(n2[u2], h2, s2, true), a2.push(h2);
            }
          }
          e2.push(U(l2, i2, a2, t2.properties));
        }
      }
      function K(e2, t2) {
        t2.push(re(e2[0])), t2.push(oe(e2[1])), t2.push(0);
      }
      function ee(e2, t2, r2, o2) {
        for (var n2, i2, s2 = 0, a2 = 0; a2 < e2.length; a2++) {
          var l2 = re(e2[a2][0]), u2 = oe(e2[a2][1]);
          t2.push(l2), t2.push(u2), t2.push(0), a2 > 0 && (s2 += o2 ? (n2 * u2 - l2 * i2) / 2 : Math.sqrt(Math.pow(l2 - n2, 2) + Math.pow(u2 - i2, 2))), n2 = l2, i2 = u2;
        }
        var h2 = t2.length - 3;
        t2[2] = 1, R(t2, 0, h2, r2), t2[h2 + 2] = 1, t2.size = Math.abs(s2), t2.start = 0, t2.end = t2.size;
      }
      function te(e2, t2, r2, o2) {
        for (var n2 = 0; n2 < e2.length; n2++) {
          var i2 = [];
          ee(e2[n2], i2, r2, o2), t2.push(i2);
        }
      }
      function re(e2) {
        return e2 / 360 + 0.5;
      }
      function oe(e2) {
        var t2 = Math.sin(e2 * Math.PI / 180), r2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
        return r2 < 0 ? 0 : r2 > 1 ? 1 : r2;
      }
      function ne(e2, t2, r2, o2, n2, i2, s2, a2) {
        if (o2 /= t2, i2 >= (r2 /= t2) && s2 < o2)
          return e2;
        if (s2 < r2 || i2 >= o2)
          return null;
        for (var l2 = [], u2 = 0; u2 < e2.length; u2++) {
          var h2 = e2[u2], c2 = h2.geometry, f2 = h2.type, p2 = 0 === n2 ? h2.minX : h2.minY, g2 = 0 === n2 ? h2.maxX : h2.maxY;
          if (p2 >= r2 && g2 < o2)
            l2.push(h2);
          else if (!(g2 < r2 || p2 >= o2)) {
            var d2 = [];
            if ("Point" === f2 || "MultiPoint" === f2)
              ie(c2, d2, r2, o2, n2);
            else if ("LineString" === f2)
              se(c2, d2, r2, o2, n2, false, a2.lineMetrics);
            else if ("MultiLineString" === f2)
              le(c2, d2, r2, o2, n2, false);
            else if ("Polygon" === f2)
              le(c2, d2, r2, o2, n2, true);
            else if ("MultiPolygon" === f2)
              for (var m2 = 0; m2 < c2.length; m2++) {
                var y2 = [];
                le(c2[m2], y2, r2, o2, n2, true), y2.length && d2.push(y2);
              }
            if (d2.length) {
              if (a2.lineMetrics && "LineString" === f2) {
                for (m2 = 0; m2 < d2.length; m2++)
                  l2.push(U(h2.id, f2, d2[m2], h2.tags));
                continue;
              }
              "LineString" !== f2 && "MultiLineString" !== f2 || (1 === d2.length ? (f2 = "LineString", d2 = d2[0]) : f2 = "MultiLineString"), "Point" !== f2 && "MultiPoint" !== f2 || (f2 = 3 === d2.length ? "Point" : "MultiPoint"), l2.push(U(h2.id, f2, d2, h2.tags));
            }
          }
        }
        return l2.length ? l2 : null;
      }
      function ie(e2, t2, r2, o2, n2) {
        for (var i2 = 0; i2 < e2.length; i2 += 3) {
          var s2 = e2[i2 + n2];
          s2 >= r2 && s2 <= o2 && (t2.push(e2[i2]), t2.push(e2[i2 + 1]), t2.push(e2[i2 + 2]));
        }
      }
      function se(e2, t2, r2, o2, n2, i2, s2) {
        for (var a2, l2, u2 = ae(e2), h2 = 0 === n2 ? he : ce, c2 = e2.start, f2 = 0; f2 < e2.length - 3; f2 += 3) {
          var p2 = e2[f2], g2 = e2[f2 + 1], d2 = e2[f2 + 2], m2 = e2[f2 + 3], y2 = e2[f2 + 4], v2 = 0 === n2 ? p2 : g2, x2 = 0 === n2 ? m2 : y2, w2 = false;
          s2 && (a2 = Math.sqrt(Math.pow(p2 - m2, 2) + Math.pow(g2 - y2, 2))), v2 < r2 ? x2 > r2 && (l2 = h2(u2, p2, g2, m2, y2, r2), s2 && (u2.start = c2 + a2 * l2)) : v2 > o2 ? x2 < o2 && (l2 = h2(u2, p2, g2, m2, y2, o2), s2 && (u2.start = c2 + a2 * l2)) : ue(u2, p2, g2, d2), x2 < r2 && v2 >= r2 && (l2 = h2(u2, p2, g2, m2, y2, r2), w2 = true), x2 > o2 && v2 <= o2 && (l2 = h2(u2, p2, g2, m2, y2, o2), w2 = true), !i2 && w2 && (s2 && (u2.end = c2 + a2 * l2), t2.push(u2), u2 = ae(e2)), s2 && (c2 += a2);
        }
        var S2 = e2.length - 3;
        p2 = e2[S2], g2 = e2[S2 + 1], d2 = e2[S2 + 2], (v2 = 0 === n2 ? p2 : g2) >= r2 && v2 <= o2 && ue(u2, p2, g2, d2), S2 = u2.length - 3, i2 && S2 >= 3 && (u2[S2] !== u2[0] || u2[S2 + 1] !== u2[1]) && ue(u2, u2[0], u2[1], u2[2]), u2.length && t2.push(u2);
      }
      function ae(e2) {
        var t2 = [];
        return t2.size = e2.size, t2.start = e2.start, t2.end = e2.end, t2;
      }
      function le(e2, t2, r2, o2, n2, i2) {
        for (var s2 = 0; s2 < e2.length; s2++)
          se(e2[s2], t2, r2, o2, n2, i2, false);
      }
      function ue(e2, t2, r2, o2) {
        e2.push(t2), e2.push(r2), e2.push(o2);
      }
      function he(e2, t2, r2, o2, n2, i2) {
        var s2 = (i2 - t2) / (o2 - t2);
        return e2.push(i2), e2.push(r2 + (n2 - r2) * s2), e2.push(1), s2;
      }
      function ce(e2, t2, r2, o2, n2, i2) {
        var s2 = (i2 - r2) / (n2 - r2);
        return e2.push(t2 + (o2 - t2) * s2), e2.push(i2), e2.push(1), s2;
      }
      function fe(e2, t2) {
        for (var r2 = [], o2 = 0; o2 < e2.length; o2++) {
          var n2, i2 = e2[o2], s2 = i2.type;
          if ("Point" === s2 || "MultiPoint" === s2 || "LineString" === s2)
            n2 = pe(i2.geometry, t2);
          else if ("MultiLineString" === s2 || "Polygon" === s2) {
            n2 = [];
            for (var a2 = 0; a2 < i2.geometry.length; a2++)
              n2.push(pe(i2.geometry[a2], t2));
          } else if ("MultiPolygon" === s2)
            for (n2 = [], a2 = 0; a2 < i2.geometry.length; a2++) {
              for (var l2 = [], u2 = 0; u2 < i2.geometry[a2].length; u2++)
                l2.push(pe(i2.geometry[a2][u2], t2));
              n2.push(l2);
            }
          r2.push(U(i2.id, s2, n2, i2.tags));
        }
        return r2;
      }
      function pe(e2, t2) {
        var r2 = [];
        r2.size = e2.size, void 0 !== e2.start && (r2.start = e2.start, r2.end = e2.end);
        for (var o2 = 0; o2 < e2.length; o2 += 3)
          r2.push(e2[o2] + t2, e2[o2 + 1], e2[o2 + 2]);
        return r2;
      }
      function ge(e2, t2) {
        if (e2.transformed)
          return e2;
        var r2, o2, n2, i2 = 1 << e2.z, s2 = e2.x, a2 = e2.y;
        for (r2 = 0; r2 < e2.features.length; r2++) {
          var l2 = e2.features[r2], u2 = l2.geometry, h2 = l2.type;
          if (l2.geometry = [], 1 === h2)
            for (o2 = 0; o2 < u2.length; o2 += 2)
              l2.geometry.push(de(u2[o2], u2[o2 + 1], t2, i2, s2, a2));
          else
            for (o2 = 0; o2 < u2.length; o2++) {
              var c2 = [];
              for (n2 = 0; n2 < u2[o2].length; n2 += 2)
                c2.push(de(u2[o2][n2], u2[o2][n2 + 1], t2, i2, s2, a2));
              l2.geometry.push(c2);
            }
        }
        return e2.transformed = true, e2;
      }
      function de(e2, t2, r2, o2, n2, i2) {
        return [Math.round(r2 * (e2 * o2 - n2)), Math.round(r2 * (t2 * o2 - i2))];
      }
      function me(e2, t2, r2, o2, n2) {
        for (var i2 = t2 === n2.maxZoom ? 0 : n2.tolerance / ((1 << t2) * n2.extent), s2 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: r2, y: o2, z: t2, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 }, a2 = 0; a2 < e2.length; a2++) {
          s2.numFeatures++, ye(s2, e2[a2], i2, n2);
          var l2 = e2[a2].minX, u2 = e2[a2].minY, h2 = e2[a2].maxX, c2 = e2[a2].maxY;
          l2 < s2.minX && (s2.minX = l2), u2 < s2.minY && (s2.minY = u2), h2 > s2.maxX && (s2.maxX = h2), c2 > s2.maxY && (s2.maxY = c2);
        }
        return s2;
      }
      function ye(e2, t2, r2, o2) {
        var n2 = t2.geometry, i2 = t2.type, s2 = [];
        if ("Point" === i2 || "MultiPoint" === i2)
          for (var a2 = 0; a2 < n2.length; a2 += 3)
            s2.push(n2[a2]), s2.push(n2[a2 + 1]), e2.numPoints++, e2.numSimplified++;
        else if ("LineString" === i2)
          ve(s2, n2, e2, r2, false, false);
        else if ("MultiLineString" === i2 || "Polygon" === i2)
          for (a2 = 0; a2 < n2.length; a2++)
            ve(s2, n2[a2], e2, r2, "Polygon" === i2, 0 === a2);
        else if ("MultiPolygon" === i2)
          for (var l2 = 0; l2 < n2.length; l2++) {
            var u2 = n2[l2];
            for (a2 = 0; a2 < u2.length; a2++)
              ve(s2, u2[a2], e2, r2, true, 0 === a2);
          }
        if (s2.length) {
          var h2 = t2.tags || null;
          if ("LineString" === i2 && o2.lineMetrics) {
            for (var c2 in h2 = {}, t2.tags)
              h2[c2] = t2.tags[c2];
            h2.mapbox_clip_start = n2.start / n2.size, h2.mapbox_clip_end = n2.end / n2.size;
          }
          var f2 = { geometry: s2, type: "Polygon" === i2 || "MultiPolygon" === i2 ? 3 : "LineString" === i2 || "MultiLineString" === i2 ? 2 : 1, tags: h2 };
          null !== t2.id && (f2.id = t2.id), e2.features.push(f2);
        }
      }
      function ve(e2, t2, r2, o2, n2, i2) {
        var s2 = o2 * o2;
        if (o2 > 0 && t2.size < (n2 ? s2 : o2))
          r2.numPoints += t2.length / 3;
        else {
          for (var a2 = [], l2 = 0; l2 < t2.length; l2 += 3)
            (0 === o2 || t2[l2 + 2] > s2) && (r2.numSimplified++, a2.push(t2[l2]), a2.push(t2[l2 + 1])), r2.numPoints++;
          n2 && function(e3, t3) {
            for (var r3 = 0, o3 = 0, n3 = e3.length, i3 = n3 - 2; o3 < n3; i3 = o3, o3 += 2)
              r3 += (e3[o3] - e3[i3]) * (e3[o3 + 1] + e3[i3 + 1]);
            if (r3 > 0 === t3)
              for (o3 = 0, n3 = e3.length; o3 < n3 / 2; o3 += 2) {
                var s3 = e3[o3], a3 = e3[o3 + 1];
                e3[o3] = e3[n3 - 2 - o3], e3[o3 + 1] = e3[n3 - 1 - o3], e3[n3 - 2 - o3] = s3, e3[n3 - 1 - o3] = a3;
              }
          }(a2, i2), e2.push(a2);
        }
      }
      function xe(e2, t2) {
        var r2 = (t2 = this.options = function(e3, t3) {
          for (var r3 in t3)
            e3[r3] = t3[r3];
          return e3;
        }(Object.create(this.options), t2)).debug;
        if (r2 && console.time("preprocess data"), t2.maxZoom < 0 || t2.maxZoom > 24)
          throw new Error("maxZoom should be in the 0-24 range");
        if (t2.promoteId && t2.generateId)
          throw new Error("promoteId and generateId cannot be used together.");
        var o2 = function(e3, t3) {
          var r3 = [];
          if ("FeatureCollection" === e3.type)
            for (var o3 = 0; o3 < e3.features.length; o3++)
              H(r3, e3.features[o3], t3, o3);
          else
            H(r3, "Feature" === e3.type ? e3 : { geometry: e3 }, t3);
          return r3;
        }(e2, t2);
        this.tiles = {}, this.tileCoords = [], r2 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t2.indexMaxZoom, t2.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), (o2 = function(e3, t3) {
          var r3 = t3.buffer / t3.extent, o3 = e3, n2 = ne(e3, 1, -1 - r3, r3, 0, -1, 2, t3), i2 = ne(e3, 1, 1 - r3, 2 + r3, 0, -1, 2, t3);
          return (n2 || i2) && (o3 = ne(e3, 1, -r3, 1 + r3, 0, -1, 2, t3) || [], n2 && (o3 = fe(n2, 1).concat(o3)), i2 && (o3 = o3.concat(fe(i2, -1)))), o3;
        }(o2, t2)).length && this.splitTile(o2, 0, 0, 0), r2 && (o2.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
      }
      function we(e2, t2, r2) {
        return 32 * ((1 << e2) * r2 + t2) + e2;
      }
      function Se(e2, t2) {
        const r2 = e2.tileID.canonical;
        if (!this._geoJSONIndex)
          return t2(null, null);
        const o2 = this._geoJSONIndex.getTile(r2.z, r2.x, r2.y);
        if (!o2)
          return t2(null, null);
        const n2 = new c(o2.features);
        let i2 = m(n2);
        0 === i2.byteOffset && i2.byteLength === i2.buffer.byteLength || (i2 = new Uint8Array(i2)), t2(null, { vectorTile: n2, rawData: i2.buffer });
      }
      xe.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 }, xe.prototype.splitTile = function(e2, t2, r2, o2, n2, i2, s2) {
        for (var a2 = [e2, t2, r2, o2], l2 = this.options, u2 = l2.debug; a2.length; ) {
          o2 = a2.pop(), r2 = a2.pop(), t2 = a2.pop(), e2 = a2.pop();
          var h2 = 1 << t2, c2 = we(t2, r2, o2), f2 = this.tiles[c2];
          if (!f2 && (u2 > 1 && console.time("creation"), f2 = this.tiles[c2] = me(e2, t2, r2, o2, l2), this.tileCoords.push({ z: t2, x: r2, y: o2 }), u2)) {
            u2 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t2, r2, o2, f2.numFeatures, f2.numPoints, f2.numSimplified), console.timeEnd("creation"));
            var p2 = "z" + t2;
            this.stats[p2] = (this.stats[p2] || 0) + 1, this.total++;
          }
          if (f2.source = e2, n2) {
            if (t2 === l2.maxZoom || t2 === n2)
              continue;
            var g2 = 1 << n2 - t2;
            if (r2 !== Math.floor(i2 / g2) || o2 !== Math.floor(s2 / g2))
              continue;
          } else if (t2 === l2.indexMaxZoom || f2.numPoints <= l2.indexMaxPoints)
            continue;
          if (f2.source = null, 0 !== e2.length) {
            u2 > 1 && console.time("clipping");
            var d2, m2, y2, v2, x2, w2, S2 = 0.5 * l2.buffer / l2.extent, M2 = 0.5 - S2, P2 = 0.5 + S2, b2 = 1 + S2;
            d2 = m2 = y2 = v2 = null, x2 = ne(e2, h2, r2 - S2, r2 + P2, 0, f2.minX, f2.maxX, l2), w2 = ne(e2, h2, r2 + M2, r2 + b2, 0, f2.minX, f2.maxX, l2), e2 = null, x2 && (d2 = ne(x2, h2, o2 - S2, o2 + P2, 1, f2.minY, f2.maxY, l2), m2 = ne(x2, h2, o2 + M2, o2 + b2, 1, f2.minY, f2.maxY, l2), x2 = null), w2 && (y2 = ne(w2, h2, o2 - S2, o2 + P2, 1, f2.minY, f2.maxY, l2), v2 = ne(w2, h2, o2 + M2, o2 + b2, 1, f2.minY, f2.maxY, l2), w2 = null), u2 > 1 && console.timeEnd("clipping"), a2.push(d2 || [], t2 + 1, 2 * r2, 2 * o2), a2.push(m2 || [], t2 + 1, 2 * r2, 2 * o2 + 1), a2.push(y2 || [], t2 + 1, 2 * r2 + 1, 2 * o2), a2.push(v2 || [], t2 + 1, 2 * r2 + 1, 2 * o2 + 1);
          }
        }
      }, xe.prototype.getTile = function(e2, t2, r2) {
        var o2 = this.options, n2 = o2.extent, i2 = o2.debug;
        if (e2 < 0 || e2 > 24)
          return null;
        var s2 = 1 << e2, a2 = we(e2, t2 = (t2 % s2 + s2) % s2, r2);
        if (this.tiles[a2])
          return ge(this.tiles[a2], n2);
        i2 > 1 && console.log("drilling down to z%d-%d-%d", e2, t2, r2);
        for (var l2, u2 = e2, h2 = t2, c2 = r2; !l2 && u2 > 0; )
          u2--, h2 = Math.floor(h2 / 2), c2 = Math.floor(c2 / 2), l2 = this.tiles[we(u2, h2, c2)];
        return l2 && l2.source ? (i2 > 1 && console.log("found parent tile z%d-%d-%d", u2, h2, c2), i2 > 1 && console.time("drilling down"), this.splitTile(l2.source, u2, h2, c2, e2, t2, r2), i2 > 1 && console.timeEnd("drilling down"), this.tiles[a2] ? ge(this.tiles[a2], n2) : null) : null;
      };
      class Me extends e.VectorTileWorkerSource {
        constructor(e2, t2, r2, o2, n2) {
          super(e2, t2, r2, o2, Se), n2 && (this.loadGeoJSON = n2);
        }
        loadData(t2, r2) {
          const o2 = t2 && t2.request, n2 = o2 && o2.collectResourceTiming;
          this.loadGeoJSON(t2, (i2, a2) => {
            if (i2 || !a2)
              return r2(i2);
            if ("object" != typeof a2)
              return r2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
            {
              s(a2, true);
              try {
                if (t2.filter) {
                  const r3 = e.createExpression(t2.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                  if ("error" === r3.result)
                    throw new Error(r3.value.map((e2) => `${e2.key}: ${e2.message}`).join(", "));
                  const o3 = a2.features.filter((e2) => r3.value.evaluate({ zoom: 0 }, e2));
                  a2 = { type: "FeatureCollection", features: o3 };
                }
                this._geoJSONIndex = t2.cluster ? new G(function({ superclusterOptions: t3, clusterProperties: r3 }) {
                  if (!r3 || !t3)
                    return t3;
                  const o3 = {}, n3 = {}, i3 = { accumulated: null, zoom: 0 }, s2 = { properties: null }, a3 = Object.keys(r3);
                  for (const t4 of a3) {
                    const [i4, s3] = r3[t4], a4 = e.createExpression(s3), l3 = e.createExpression("string" == typeof i4 ? [i4, ["accumulated"], ["get", t4]] : i4);
                    o3[t4] = a4.value, n3[t4] = l3.value;
                  }
                  return t3.map = (e2) => {
                    s2.properties = e2;
                    const t4 = {};
                    for (const e3 of a3)
                      t4[e3] = o3[e3].evaluate(i3, s2);
                    return t4;
                  }, t3.reduce = (e2, t4) => {
                    s2.properties = t4;
                    for (const t5 of a3)
                      i3.accumulated = e2[t5], e2[t5] = n3[t5].evaluate(i3, s2);
                  }, t3;
                }(t2)).load(a2.features) : function(e2, t3) {
                  return new xe(e2, t3);
                }(a2, t2.geojsonVtOptions);
              } catch (i3) {
                return r2(i3);
              }
              this.loaded = {};
              const l2 = {};
              if (n2) {
                const r3 = e.getPerformanceMeasurement(o2);
                r3 && (l2.resourceTiming = {}, l2.resourceTiming[t2.source] = JSON.parse(JSON.stringify(r3)));
              }
              r2(null, l2);
            }
          });
        }
        reloadTile(e2, t2) {
          const r2 = this.loaded;
          return r2 && r2[e2.uid] ? super.reloadTile(e2, t2) : this.loadTile(e2, t2);
        }
        loadGeoJSON(t2, r2) {
          if (t2.request)
            e.getJSON(t2.request, r2);
          else {
            if ("string" != typeof t2.data)
              return r2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
            try {
              return r2(null, JSON.parse(t2.data));
            } catch (e2) {
              return r2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
            }
          }
        }
        getClusterExpansionZoom(e2, t2) {
          try {
            t2(null, this._geoJSONIndex.getClusterExpansionZoom(e2.clusterId));
          } catch (e3) {
            t2(e3);
          }
        }
        getClusterChildren(e2, t2) {
          try {
            t2(null, this._geoJSONIndex.getChildren(e2.clusterId));
          } catch (e3) {
            t2(e3);
          }
        }
        getClusterLeaves(e2, t2) {
          try {
            t2(null, this._geoJSONIndex.getLeaves(e2.clusterId, e2.limit, e2.offset));
          } catch (e3) {
            t2(e3);
          }
        }
      }
      class Pe {
        constructor(t2) {
          this.self = t2, this.actor = new e.Actor(t2, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = false, this.workerSourceTypes = { vector: e.VectorTileWorkerSource, geojson: Me }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e2, t3) => {
            if (this.workerSourceTypes[e2])
              throw new Error(`Worker source with name "${e2}" already registered.`);
            this.workerSourceTypes[e2] = t3;
          }, this.self.registerRTLTextPlugin = (t3) => {
            if (e.plugin.isParsed())
              throw new Error("RTL text plugin already registered.");
            e.plugin.applyArabicShaping = t3.applyArabicShaping, e.plugin.processBidirectionalText = t3.processBidirectionalText, e.plugin.processStyledBidirectionalText = t3.processStyledBidirectionalText;
          };
        }
        checkIfReady(e2, t2, r2) {
          r2();
        }
        setReferrer(e2, t2) {
          this.referrer = t2;
        }
        spriteLoaded(t2, r2) {
          this.isSpriteLoaded = r2;
          for (const o2 in this.workerSources[t2]) {
            const n2 = this.workerSources[t2][o2];
            for (const t3 in n2)
              n2[t3] instanceof e.VectorTileWorkerSource && (n2[t3].isSpriteLoaded = r2, n2[t3].fire(new e.Event("isSpriteLoaded")));
          }
        }
        setImages(e2, t2, r2) {
          this.availableImages[e2] = t2;
          for (const r3 in this.workerSources[e2]) {
            const o2 = this.workerSources[e2][r3];
            for (const e3 in o2)
              o2[e3].availableImages = t2;
          }
          r2();
        }
        enableTerrain(e2, t2, r2) {
          this.terrain = t2, r2();
        }
        setLayers(e2, t2, r2) {
          this.getLayerIndex(e2).replace(t2), r2();
        }
        updateLayers(e2, t2, r2) {
          this.getLayerIndex(e2).update(t2.layers, t2.removedIds), r2();
        }
        loadTile(t2, r2, o2) {
          const n2 = this.enableTerrain ? e.extend({ enableTerrain: this.terrain }, r2) : r2;
          this.getWorkerSource(t2, r2.type, r2.source).loadTile(n2, o2);
        }
        loadDEMTile(t2, r2, o2) {
          const n2 = this.enableTerrain ? e.extend({ buildQuadTree: this.terrain }, r2) : r2;
          this.getDEMWorkerSource(t2, r2.source).loadTile(n2, o2);
        }
        reloadTile(t2, r2, o2) {
          const n2 = this.enableTerrain ? e.extend({ enableTerrain: this.terrain }, r2) : r2;
          this.getWorkerSource(t2, r2.type, r2.source).reloadTile(n2, o2);
        }
        abortTile(e2, t2, r2) {
          this.getWorkerSource(e2, t2.type, t2.source).abortTile(t2, r2);
        }
        removeTile(e2, t2, r2) {
          this.getWorkerSource(e2, t2.type, t2.source).removeTile(t2, r2);
        }
        removeSource(e2, t2, r2) {
          if (!this.workerSources[e2] || !this.workerSources[e2][t2.type] || !this.workerSources[e2][t2.type][t2.source])
            return;
          const o2 = this.workerSources[e2][t2.type][t2.source];
          delete this.workerSources[e2][t2.type][t2.source], void 0 !== o2.removeSource ? o2.removeSource(t2, r2) : r2();
        }
        loadWorkerSource(e2, t2, r2) {
          try {
            this.self.importScripts(t2.url), r2();
          } catch (e3) {
            r2(e3.toString());
          }
        }
        syncRTLPluginState(t2, r2, o2) {
          try {
            e.plugin.setState(r2);
            const t3 = e.plugin.getPluginURL();
            if (e.plugin.isLoaded() && !e.plugin.isParsed() && null != t3) {
              this.self.importScripts(t3);
              const r3 = e.plugin.isParsed();
              o2(r3 ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t3}`), r3);
            }
          } catch (e2) {
            o2(e2.toString());
          }
        }
        getAvailableImages(e2) {
          let t2 = this.availableImages[e2];
          return t2 || (t2 = []), t2;
        }
        getLayerIndex(e2) {
          let t2 = this.layerIndexes[e2];
          return t2 || (t2 = this.layerIndexes[e2] = new o()), t2;
        }
        getWorkerSource(e2, t2, r2) {
          return this.workerSources[e2] || (this.workerSources[e2] = {}), this.workerSources[e2][t2] || (this.workerSources[e2][t2] = {}), this.workerSources[e2][t2][r2] || (this.workerSources[e2][t2][r2] = new this.workerSourceTypes[t2]({ send: (t3, r3, o2, n2, i2, s2) => {
            this.actor.send(t3, r3, o2, e2, i2, s2);
          }, scheduler: this.actor.scheduler }, this.getLayerIndex(e2), this.getAvailableImages(e2), this.isSpriteLoaded)), this.workerSources[e2][t2][r2];
        }
        getDEMWorkerSource(e2, t2) {
          return this.demWorkerSources[e2] || (this.demWorkerSources[e2] = {}), this.demWorkerSources[e2][t2] || (this.demWorkerSources[e2][t2] = new i()), this.demWorkerSources[e2][t2];
        }
        enforceCacheSizeLimit(t2, r2) {
          e.enforceCacheSizeLimit(r2);
        }
        getWorkerPerformanceMetrics(e2, t2, r2) {
          r2(void 0, void 0);
        }
      }
      return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new Pe(self)), Pe;
    });
    define(["./shared"], function(e) {
      var t = i;
      function i(e2) {
        return !function(e3) {
          return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function() {
            if (!("Worker" in window && "Blob" in window && "URL" in window))
              return false;
            var e4, t3, i2 = new Blob([""], { type: "text/javascript" }), o2 = URL.createObjectURL(i2);
            try {
              t3 = new Worker(o2), e4 = true;
            } catch (t4) {
              e4 = false;
            }
            return t3 && t3.terminate(), URL.revokeObjectURL(o2), e4;
          }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function() {
            var e4 = document.createElement("canvas");
            e4.width = e4.height = 1;
            var t3 = e4.getContext("2d");
            if (!t3)
              return false;
            var i2 = t3.getImageData(0, 0, 1, 1);
            return i2 && i2.width === e4.width;
          }() ? (void 0 === o[t2 = e3 && e3.failIfMajorPerformanceCaveat] && (o[t2] = function(e4) {
            var t3, o2 = function(e5) {
              var t4 = document.createElement("canvas"), o3 = Object.create(i.webGLContextAttributes);
              return o3.failIfMajorPerformanceCaveat = e5, t4.getContext("webgl", o3) || t4.getContext("experimental-webgl", o3);
            }(e4);
            if (!o2)
              return false;
            try {
              t3 = o2.createShader(o2.VERTEX_SHADER);
            } catch (e5) {
              return false;
            }
            return !(!t3 || o2.isContextLost()) && (o2.shaderSource(t3, "void main() {}"), o2.compileShader(t3), true === o2.getShaderParameter(t3, o2.COMPILE_STATUS));
          }(t2)), o[t2] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
          var t2;
        }(e2);
      }
      var o = {};
      function r(e2, t2) {
        if (Array.isArray(e2)) {
          if (!Array.isArray(t2) || e2.length !== t2.length)
            return false;
          for (let i2 = 0; i2 < e2.length; i2++)
            if (!r(e2[i2], t2[i2]))
              return false;
          return true;
        }
        if ("object" == typeof e2 && null !== e2 && null !== t2) {
          if ("object" != typeof t2)
            return false;
          if (Object.keys(e2).length !== Object.keys(t2).length)
            return false;
          for (const i2 in e2)
            if (!r(e2[i2], t2[i2]))
              return false;
          return true;
        }
        return e2 === t2;
      }
      i.webGLContextAttributes = { antialias: false, alpha: true, stencil: true, depth: true };
      const n = { create: function(t2, i2, o2) {
        const r2 = e.window.document.createElement(t2);
        return void 0 !== i2 && (r2.className = i2), o2 && o2.appendChild(r2), r2;
      }, createNS: function(t2, i2) {
        return e.window.document.createElementNS(t2, i2);
      } }, a = e.window.document && e.window.document.documentElement.style, s = a && void 0 !== a.userSelect ? "userSelect" : "WebkitUserSelect";
      let l;
      n.disableDrag = function() {
        a && s && (l = a[s], a[s] = "none");
      }, n.enableDrag = function() {
        a && s && (a[s] = l);
      }, n.setTransform = function(e2, t2) {
        e2.style.transform = t2;
      };
      let c = false;
      try {
        const t2 = Object.defineProperty({}, "passive", { get() {
          c = true;
        } });
        e.window.addEventListener("test", t2, t2), e.window.removeEventListener("test", t2, t2);
      } catch (e2) {
        c = false;
      }
      n.addEventListener = function(e2, t2, i2, o2 = {}) {
        e2.addEventListener(t2, i2, "passive" in o2 && c ? o2 : o2.capture);
      }, n.removeEventListener = function(e2, t2, i2, o2 = {}) {
        e2.removeEventListener(t2, i2, "passive" in o2 && c ? o2 : o2.capture);
      };
      const h = function(t2) {
        t2.preventDefault(), t2.stopPropagation(), e.window.removeEventListener("click", h, true);
      };
      function u(t2, i2, o2) {
        const r2 = t2.offsetWidth === i2.width ? 1 : t2.offsetWidth / i2.width;
        return new e.pointGeometry((o2.clientX - i2.left) * r2, (o2.clientY - i2.top) * r2);
      }
      n.suppressClick = function() {
        e.window.addEventListener("click", h, true), e.window.setTimeout(() => {
          e.window.removeEventListener("click", h, true);
        }, 0);
      }, n.mousePos = function(e2, t2) {
        const i2 = e2.getBoundingClientRect();
        return u(e2, i2, t2);
      }, n.touchPos = function(e2, t2) {
        const i2 = e2.getBoundingClientRect(), o2 = [];
        for (let r2 = 0; r2 < t2.length; r2++)
          o2.push(u(e2, i2, t2[r2]));
        return o2;
      }, n.mouseButton = function(t2) {
        return void 0 !== e.window.InstallTrigger && 2 === t2.button && t2.ctrlKey && e.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : t2.button;
      }, n.remove = function(e2) {
        e2.parentNode && e2.parentNode.removeChild(e2);
      };
      class d {
        constructor(e2, t2) {
          this.pos = e2, this.dir = t2;
        }
        intersectsPlane(t2, i2, o2) {
          const r2 = e.dot(i2, this.dir);
          if (Math.abs(r2) < 1e-6)
            return false;
          const n2 = e.dot(e.sub(e.create(), t2, this.pos), i2) / r2, a2 = e.scaleAndAdd(e.create(), this.pos, this.dir, n2);
          return e.copy(o2, a2), true;
        }
      }
      class _ {
        constructor(e2, t2) {
          this.points = e2, this.planes = t2;
        }
        static fromInvProjectionMatrix(t2, i2, o2) {
          const r2 = Math.pow(2, o2), n2 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((o3) => {
            const n3 = e.transformMat4([], o3, t2), a3 = 1 / n3[3] / i2 * r2;
            return e.mul(n3, n3, [a3, a3, 1 / n3[3], a3]);
          }), a2 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((t3) => {
            const i3 = e.sub([], n2[t3[0]], n2[t3[1]]), o3 = e.sub([], n2[t3[2]], n2[t3[1]]), r3 = e.normalize([], e.cross([], i3, o3)), a3 = -e.dot(r3, n2[t3[1]]);
            return r3.concat(a3);
          });
          return new _(n2, a2);
        }
      }
      class p {
        constructor(t2, i2) {
          this.min = t2, this.max = i2, this.center = e.scale([], e.add([], this.min, this.max), 0.5);
        }
        quadrant(t2) {
          const i2 = [t2 % 2 == 0, t2 < 2], o2 = e.clone(this.min), r2 = e.clone(this.max);
          for (let e2 = 0; e2 < i2.length; e2++)
            o2[e2] = i2[e2] ? this.min[e2] : this.center[e2], r2[e2] = i2[e2] ? this.center[e2] : this.max[e2];
          return r2[2] = this.max[2], new p(o2, r2);
        }
        distanceX(e2) {
          return Math.max(Math.min(this.max[0], e2[0]), this.min[0]) - e2[0];
        }
        distanceY(e2) {
          return Math.max(Math.min(this.max[1], e2[1]), this.min[1]) - e2[1];
        }
        distanceZ(e2) {
          return Math.max(Math.min(this.max[2], e2[2]), this.min[2]) - e2[2];
        }
        intersects(t2) {
          const i2 = [[this.min[0], this.min[1], this.min[2], 1], [this.max[0], this.min[1], this.min[2], 1], [this.max[0], this.max[1], this.min[2], 1], [this.min[0], this.max[1], this.min[2], 1], [this.min[0], this.min[1], this.max[2], 1], [this.max[0], this.min[1], this.max[2], 1], [this.max[0], this.max[1], this.max[2], 1], [this.min[0], this.max[1], this.max[2], 1]];
          let o2 = true;
          for (let r2 = 0; r2 < t2.planes.length; r2++) {
            const n2 = t2.planes[r2];
            let a2 = 0;
            for (let t3 = 0; t3 < i2.length; t3++)
              a2 += e.dot$1(n2, i2[t3]) >= 0;
            if (0 === a2)
              return 0;
            a2 !== i2.length && (o2 = false);
          }
          if (o2)
            return 2;
          for (let e2 = 0; e2 < 3; e2++) {
            let i3 = Number.MAX_VALUE, o3 = -Number.MAX_VALUE;
            for (let r2 = 0; r2 < t2.points.length; r2++) {
              const n2 = t2.points[r2][e2] - this.min[e2];
              i3 = Math.min(i3, n2), o3 = Math.max(o3, n2);
            }
            if (o3 < 0 || i3 > this.max[e2] - this.min[e2])
              return 0;
          }
          return 1;
        }
      }
      function m(e2) {
        const { userImage: t2 } = e2;
        return !!(t2 && t2.render && t2.render()) && (e2.data.replace(new Uint8Array(t2.data.buffer)), true);
      }
      class f extends e.Evented {
        constructor() {
          super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new e.RGBAImage({ width: 1, height: 1 }), this.dirty = true;
        }
        isLoaded() {
          return this.loaded;
        }
        setLoaded(e2) {
          if (this.loaded !== e2 && (this.loaded = e2, e2)) {
            for (const { ids: e3, callback: t2 } of this.requestors)
              this._notify(e3, t2);
            this.requestors = [];
          }
        }
        getImage(e2) {
          return this.images[e2];
        }
        addImage(e2, t2) {
          this._validate(e2, t2) && (this.images[e2] = t2);
        }
        _validate(t2, i2) {
          let o2 = true;
          return this._validateStretch(i2.stretchX, i2.data && i2.data.width) || (this.fire(new e.ErrorEvent(new Error(`Image "${t2}" has invalid "stretchX" value`))), o2 = false), this._validateStretch(i2.stretchY, i2.data && i2.data.height) || (this.fire(new e.ErrorEvent(new Error(`Image "${t2}" has invalid "stretchY" value`))), o2 = false), this._validateContent(i2.content, i2) || (this.fire(new e.ErrorEvent(new Error(`Image "${t2}" has invalid "content" value`))), o2 = false), o2;
        }
        _validateStretch(e2, t2) {
          if (!e2)
            return true;
          let i2 = 0;
          for (const o2 of e2) {
            if (o2[0] < i2 || o2[1] < o2[0] || t2 < o2[1])
              return false;
            i2 = o2[1];
          }
          return true;
        }
        _validateContent(e2, t2) {
          return !(e2 && (4 !== e2.length || e2[0] < 0 || t2.data.width < e2[0] || e2[1] < 0 || t2.data.height < e2[1] || e2[2] < 0 || t2.data.width < e2[2] || e2[3] < 0 || t2.data.height < e2[3] || e2[2] < e2[0] || e2[3] < e2[1]));
        }
        updateImage(e2, t2) {
          t2.version = this.images[e2].version + 1, this.images[e2] = t2, this.updatedImages[e2] = true;
        }
        removeImage(e2) {
          const t2 = this.images[e2];
          delete this.images[e2], delete this.patterns[e2], t2.userImage && t2.userImage.onRemove && t2.userImage.onRemove();
        }
        listImages() {
          return Object.keys(this.images);
        }
        getImages(e2, t2) {
          let i2 = true;
          if (!this.isLoaded())
            for (const t3 of e2)
              this.images[t3] || (i2 = false);
          this.isLoaded() || i2 ? this._notify(e2, t2) : this.requestors.push({ ids: e2, callback: t2 });
        }
        _notify(t2, i2) {
          const o2 = {};
          for (const i3 of t2) {
            this.images[i3] || this.fire(new e.Event("styleimagemissing", { id: i3 }));
            const t3 = this.images[i3];
            t3 ? o2[i3] = { data: t3.data.clone(), pixelRatio: t3.pixelRatio, sdf: t3.sdf, version: t3.version, stretchX: t3.stretchX, stretchY: t3.stretchY, content: t3.content, hasRenderCallback: Boolean(t3.userImage && t3.userImage.render) } : e.warnOnce(`Image "${i3}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
          }
          i2(null, o2);
        }
        getPixelSize() {
          const { width: e2, height: t2 } = this.atlasImage;
          return { width: e2, height: t2 };
        }
        getPattern(t2) {
          const i2 = this.patterns[t2], o2 = this.getImage(t2);
          if (!o2)
            return null;
          if (i2 && i2.position.version === o2.version)
            return i2.position;
          if (i2)
            i2.position.version = o2.version;
          else {
            const i3 = { w: o2.data.width + 2, h: o2.data.height + 2, x: 0, y: 0 }, r2 = new e.ImagePosition(i3, o2);
            this.patterns[t2] = { bin: i3, position: r2 };
          }
          return this._updatePatternAtlas(), this.patterns[t2].position;
        }
        bind(t2) {
          const i2 = t2.gl;
          this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new e.Texture(t2, this.atlasImage, i2.RGBA), this.atlasTexture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas() {
          const t2 = [];
          for (const e2 in this.patterns)
            t2.push(this.patterns[e2].bin);
          const { w: i2, h: o2 } = e.potpack(t2), r2 = this.atlasImage;
          r2.resize({ width: i2 || 1, height: o2 || 1 });
          for (const t3 in this.patterns) {
            const { bin: i3 } = this.patterns[t3], o3 = i3.x + 1, n2 = i3.y + 1, a2 = this.images[t3].data, s2 = a2.width, l2 = a2.height;
            e.RGBAImage.copy(a2, r2, { x: 0, y: 0 }, { x: o3, y: n2 }, { width: s2, height: l2 }), e.RGBAImage.copy(a2, r2, { x: 0, y: l2 - 1 }, { x: o3, y: n2 - 1 }, { width: s2, height: 1 }), e.RGBAImage.copy(a2, r2, { x: 0, y: 0 }, { x: o3, y: n2 + l2 }, { width: s2, height: 1 }), e.RGBAImage.copy(a2, r2, { x: s2 - 1, y: 0 }, { x: o3 - 1, y: n2 }, { width: 1, height: l2 }), e.RGBAImage.copy(a2, r2, { x: 0, y: 0 }, { x: o3 + s2, y: n2 }, { width: 1, height: l2 });
          }
          this.dirty = true;
        }
        beginFrame() {
          this.callbackDispatchedThisFrame = {};
        }
        dispatchRenderCallbacks(e2) {
          for (const t2 of e2) {
            if (this.callbackDispatchedThisFrame[t2])
              continue;
            this.callbackDispatchedThisFrame[t2] = true;
            const e3 = this.images[t2];
            m(e3) && this.updateImage(t2, e3);
          }
        }
      }
      const g = new e.Properties({ anchor: new e.DataConstantProperty(e.spec.light.anchor), position: new class {
        constructor() {
          this.specification = e.spec.light.position;
        }
        possiblyEvaluate(t2, i2) {
          return function([t3, i3, o2]) {
            const r2 = e.degToRad(i3 + 90), n2 = e.degToRad(o2);
            return { x: t3 * Math.cos(r2) * Math.sin(n2), y: t3 * Math.sin(r2) * Math.sin(n2), z: t3 * Math.cos(n2), azimuthal: i3, polar: o2 };
          }(t2.expression.evaluate(i2));
        }
        interpolate(t2, i2, o2) {
          return { x: e.number(t2.x, i2.x, o2), y: e.number(t2.y, i2.y, o2), z: e.number(t2.z, i2.z, o2), azimuthal: e.number(t2.azimuthal, i2.azimuthal, o2), polar: e.number(t2.polar, i2.polar, o2) };
        }
      }(), color: new e.DataConstantProperty(e.spec.light.color), intensity: new e.DataConstantProperty(e.spec.light.intensity) }), v = "-transition";
      class x extends e.Evented {
        constructor(t2) {
          super(), this._transitionable = new e.Transitionable(g), this.setLight(t2), this._transitioning = this._transitionable.untransitioned();
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(t2, i2 = {}) {
          if (!this._validate(e.validateLight, t2, i2))
            for (const i3 in t2) {
              const o2 = t2[i3];
              e.endsWith(i3, v) ? this._transitionable.setTransition(i3.slice(0, -v.length), o2) : this._transitionable.setValue(i3, o2);
            }
        }
        updateTransitions(e2) {
          this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e2) {
          this.properties = this._transitioning.possiblyEvaluate(e2);
        }
        _validate(t2, i2, o2) {
          return (!o2 || false !== o2.validate) && e.emitValidationErrors(this, t2.call(e.validateStyle, e.extend({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: e.spec })));
        }
      }
      const y = new e.Properties({ source: new e.DataConstantProperty(e.spec.terrain.source), exaggeration: new e.DataConstantProperty(e.spec.terrain.exaggeration) }), b = "-transition";
      class w extends e.Evented {
        constructor(t2) {
          super(), this._transitionable = new e.Transitionable(y), this.set(t2), this._transitioning = this._transitionable.untransitioned();
        }
        get() {
          return this._transitionable.serialize();
        }
        set(t2) {
          for (const i2 in t2) {
            const o2 = t2[i2];
            e.endsWith(i2, b) ? this._transitionable.setTransition(i2.slice(0, -b.length), o2) : this._transitionable.setValue(i2, o2);
          }
        }
        updateTransitions(e2) {
          this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e2) {
          this.properties = this._transitioning.possiblyEvaluate(e2);
        }
      }
      function T(t2, i2, o2, r2) {
        const n2 = e.smoothstep(45, 65, o2), [a2, s2] = E(t2, r2), l2 = e.length(i2);
        let c2 = 1 - Math.min(1, Math.exp((l2 - a2) / (s2 - a2) * -6));
        return c2 *= c2 * c2, c2 = Math.min(1, 1.00747 * c2), c2 * n2 * t2.alpha;
      }
      function E(e2, t2) {
        const i2 = 0.5 / Math.tan(0.5 * t2);
        return [e2.range[0] + i2, e2.range[1] + i2];
      }
      const C = new e.Properties({ range: new e.DataConstantProperty(e.spec.fog.range), color: new e.DataConstantProperty(e.spec.fog.color), "horizon-blend": new e.DataConstantProperty(e.spec.fog["horizon-blend"]) }), S = "-transition";
      class M extends e.Evented {
        constructor(t2) {
          super(), this._transitionable = new e.Transitionable(C), this.set(t2), this._transitioning = this._transitionable.untransitioned();
        }
        get state() {
          return { range: this.properties.get("range"), horizonBlend: this.properties.get("horizon-blend"), alpha: this.properties.get("color").a };
        }
        get() {
          return this._transitionable.serialize();
        }
        set(t2, i2 = {}) {
          if (!this._validate(e.validateFog, t2, i2))
            for (const i3 in t2) {
              const o2 = t2[i3];
              e.endsWith(i3, S) ? this._transitionable.setTransition(i3.slice(0, -S.length), o2) : this._transitionable.setValue(i3, o2);
            }
        }
        getOpacity(t2) {
          const i2 = this.properties && this.properties.get("color") || 1;
          return e.smoothstep(45, 65, t2) * i2.a;
        }
        getOpacityAtLatLng(t2, i2) {
          return function(t3, i3, o2) {
            const r2 = e.MercatorCoordinate.fromLngLat(i3), n2 = o2.elevation ? o2.elevation.getAtPointOrZero(r2) : 0, a2 = [r2.x, r2.y, n2];
            return e.transformMat4$1(a2, a2, o2.mercatorFogMatrix), T(t3, a2, o2.pitch, o2._fov);
          }(this.state, t2, i2);
        }
        getFovAdjustedRange(e2) {
          return E(this.state, e2);
        }
        updateTransitions(e2) {
          this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e2) {
          this.properties = this._transitioning.possiblyEvaluate(e2);
        }
        _validate(t2, i2, o2) {
          return (!o2 || false !== o2.validate) && e.emitValidationErrors(this, t2.call(e.validateStyle, e.extend({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: e.spec })));
        }
      }
      class I {
        constructor(t2, i2) {
          this.workerPool = t2, this.actors = [], this.currentActor = 0, this.id = e.uniqueId();
          const o2 = this.workerPool.acquire(this.id);
          for (let e2 = 0; e2 < o2.length; e2++) {
            const t3 = new I.Actor(o2[e2], i2, this.id);
            t3.name = `Worker ${e2}`, this.actors.push(t3);
          }
          this.ready = false, this.broadcast("checkIfReady", null, () => {
            this.ready = true;
          });
        }
        broadcast(t2, i2, o2) {
          e.asyncAll(this.actors, (e2, o3) => {
            e2.send(t2, i2, o3);
          }, o2 = o2 || function() {
          });
        }
        getActor() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }
        remove() {
          this.actors.forEach((e2) => {
            e2.remove();
          }), this.actors = [], this.workerPool.release(this.id);
        }
      }
      function D(t2, i2, o2) {
        return i2 * (e.EXTENT / (t2.tileSize * Math.pow(2, o2 - t2.tileID.overscaledZ)));
      }
      I.Actor = e.Actor;
      class A {
        constructor(e2, t2, i2, o2) {
          this.screenBounds = e2, this.cameraPoint = t2, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = i2, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this.screenGeometry.map((e3) => o2.pointCoordinate3D(e3)), this.cameraGeometry = this.bufferedCameraGeometry(0);
        }
        static createFromScreenPoints(t2, i2) {
          let o2, r2;
          if (t2 instanceof e.pointGeometry || "number" == typeof t2[0]) {
            const n2 = e.pointGeometry.convert(t2);
            o2 = [e.pointGeometry.convert(t2)], r2 = i2.isPointAboveHorizon(n2);
          } else {
            const n2 = e.pointGeometry.convert(t2[0]), a2 = e.pointGeometry.convert(t2[1]);
            o2 = [n2, a2], r2 = e.polygonizeBounds(n2, a2).every((e2) => i2.isPointAboveHorizon(e2));
          }
          return new A(o2, i2.getCameraPoint(), r2, i2);
        }
        isPointQuery() {
          return 1 === this.screenBounds.length;
        }
        bufferedScreenGeometry(t2) {
          return e.polygonizeBounds(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t2);
        }
        bufferedCameraGeometry(t2) {
          const i2 = this.screenBounds[0], o2 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.pointGeometry(1, 1)) : this.screenBounds[1], r2 = e.polygonizeBounds(i2, o2, 0, false);
          return this.cameraPoint.y > o2.y && (this.cameraPoint.x > i2.x && this.cameraPoint.x < o2.x ? r2.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o2.x ? r2[2] = this.cameraPoint : this.cameraPoint.x <= i2.x && (r2[3] = this.cameraPoint)), e.bufferConvexPolygon(r2, t2);
        }
        containsTile(t2, i2, o2) {
          const r2 = t2.queryPadding + 1, n2 = o2 ? this._bufferedCameraMercator(r2, i2).map((e2) => t2.tileID.getTilePoint(e2)) : this._bufferedScreenMercator(r2, i2).map((e2) => t2.tileID.getTilePoint(e2)), a2 = this.screenGeometryMercator.map((e2) => t2.tileID.getTileVec3(e2)), s2 = a2.map((t3) => new e.pointGeometry(t3[0], t3[1])), l2 = i2.getFreeCameraOptions().position || new e.MercatorCoordinate(0, 0, 0), c2 = t2.tileID.getTileVec3(l2), h2 = a2.map((t3) => {
            const i3 = e.sub(t3, t3, c2);
            return e.normalize(i3, i3), new d(c2, i3);
          }), u2 = D(t2, 1, i2.zoom);
          if (e.polygonIntersectsBox(n2, 0, 0, e.EXTENT, e.EXTENT))
            return { queryGeometry: this, tilespaceGeometry: s2, tilespaceRays: h2, bufferedTilespaceGeometry: n2, bufferedTilespaceBounds: (_2 = e.getBounds(n2), _2.min.x = e.clamp(_2.min.x, 0, e.EXTENT), _2.min.y = e.clamp(_2.min.y, 0, e.EXTENT), _2.max.x = e.clamp(_2.max.x, 0, e.EXTENT), _2.max.y = e.clamp(_2.max.y, 0, e.EXTENT), _2), tile: t2, tileID: t2.tileID, pixelToTileUnitsFactor: u2 };
          var _2;
        }
        _bufferedScreenMercator(e2, t2) {
          const i2 = z(e2);
          if (this._screenRaycastCache[i2])
            return this._screenRaycastCache[i2];
          {
            const o2 = this.bufferedScreenGeometry(e2).map((e3) => t2.pointCoordinate3D(e3));
            return this._screenRaycastCache[i2] = o2, o2;
          }
        }
        _bufferedCameraMercator(e2, t2) {
          const i2 = z(e2);
          if (this._cameraRaycastCache[i2])
            return this._cameraRaycastCache[i2];
          {
            const o2 = this.bufferedCameraGeometry(e2).map((e3) => t2.pointCoordinate3D(e3));
            return this._cameraRaycastCache[i2] = o2, o2;
          }
        }
      }
      function z(e2) {
        return 100 * e2 | 0;
      }
      function P(t2, i2, o2) {
        const r2 = function(r3, n2) {
          if (r3)
            return o2(r3);
          if (n2) {
            const r4 = e.pick(e.extend(n2, t2), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
            n2.vector_layers && (r4.vectorLayers = n2.vector_layers, r4.vectorLayerIds = r4.vectorLayers.map((e2) => e2.id)), r4.tiles = i2.canonicalizeTileset(r4, t2.url), o2(null, r4);
          }
        };
        return t2.url ? e.getJSON(i2.transformRequest(i2.normalizeSourceURL(t2.url), e.ResourceType.Source), r2) : e.exported.frame(() => r2(null, t2));
      }
      class L {
        constructor(t2, i2, o2) {
          this.bounds = e.LngLatBounds.convert(this.validateBounds(t2)), this.minzoom = i2 || 0, this.maxzoom = o2 || 24;
        }
        validateBounds(e2) {
          return Array.isArray(e2) && 4 === e2.length ? [Math.max(-180, e2[0]), Math.max(-90, e2[1]), Math.min(180, e2[2]), Math.min(90, e2[3])] : [-180, -90, 180, 90];
        }
        contains(t2) {
          const i2 = Math.pow(2, t2.z), o2 = Math.floor(e.mercatorXfromLng(this.bounds.getWest()) * i2), r2 = Math.floor(e.mercatorYfromLat(this.bounds.getNorth()) * i2), n2 = Math.ceil(e.mercatorXfromLng(this.bounds.getEast()) * i2), a2 = Math.ceil(e.mercatorYfromLat(this.bounds.getSouth()) * i2);
          return t2.x >= o2 && t2.x < n2 && t2.y >= r2 && t2.y < a2;
        }
      }
      class R {
        constructor(e2, t2, i2) {
          this.context = e2;
          const o2 = e2.gl;
          this.buffer = o2.createBuffer(), this.dynamicDraw = Boolean(i2), this.context.unbindVAO(), e2.bindElementBuffer.set(this.buffer), o2.bufferData(o2.ELEMENT_ARRAY_BUFFER, t2.arrayBuffer, this.dynamicDraw ? o2.DYNAMIC_DRAW : o2.STATIC_DRAW), this.dynamicDraw || delete t2.arrayBuffer;
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(e2) {
          const t2 = this.context.gl;
          this.context.unbindVAO(), this.bind(), t2.bufferSubData(t2.ELEMENT_ARRAY_BUFFER, 0, e2.arrayBuffer);
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const k = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
      class F {
        constructor(e2, t2, i2, o2) {
          this.length = t2.length, this.attributes = i2, this.itemSize = t2.bytesPerElement, this.dynamicDraw = o2, this.context = e2;
          const r2 = e2.gl;
          this.buffer = r2.createBuffer(), e2.bindVertexBuffer.set(this.buffer), r2.bufferData(r2.ARRAY_BUFFER, t2.arrayBuffer, this.dynamicDraw ? r2.DYNAMIC_DRAW : r2.STATIC_DRAW), this.dynamicDraw || delete t2.arrayBuffer;
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(e2) {
          const t2 = this.context.gl;
          this.bind(), t2.bufferSubData(t2.ARRAY_BUFFER, 0, e2.arrayBuffer);
        }
        enableAttributes(e2, t2) {
          for (let i2 = 0; i2 < this.attributes.length; i2++) {
            const o2 = t2.attributes[this.attributes[i2].name];
            void 0 !== o2 && e2.enableVertexAttribArray(o2);
          }
        }
        setVertexAttribPointers(e2, t2, i2) {
          for (let o2 = 0; o2 < this.attributes.length; o2++) {
            const r2 = this.attributes[o2], n2 = t2.attributes[r2.name];
            void 0 !== n2 && e2.vertexAttribPointer(n2, r2.components, e2[k[r2.type]], false, this.itemSize, r2.offset + this.itemSize * (i2 || 0));
          }
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      class O {
        constructor(e2) {
          this.gl = e2.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
        }
        get() {
          return this.current;
        }
        set(e2) {
        }
        getDefault() {
          return this.default;
        }
        setDefault() {
          this.set(this.default);
        }
      }
      class B extends O {
        getDefault() {
          return e.Color.transparent;
        }
        set(e2) {
          const t2 = this.current;
          (e2.r !== t2.r || e2.g !== t2.g || e2.b !== t2.b || e2.a !== t2.a || this.dirty) && (this.gl.clearColor(e2.r, e2.g, e2.b, e2.a), this.current = e2, this.dirty = false);
        }
      }
      class U extends O {
        getDefault() {
          return 1;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.clearDepth(e2), this.current = e2, this.dirty = false);
        }
      }
      class N extends O {
        getDefault() {
          return 0;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.clearStencil(e2), this.current = e2, this.dirty = false);
        }
      }
      class G extends O {
        getDefault() {
          return [true, true, true, true];
        }
        set(e2) {
          const t2 = this.current;
          (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || e2[3] !== t2[3] || this.dirty) && (this.gl.colorMask(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
        }
      }
      class Z extends O {
        getDefault() {
          return true;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.depthMask(e2), this.current = e2, this.dirty = false);
        }
      }
      class V extends O {
        getDefault() {
          return 255;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.stencilMask(e2), this.current = e2, this.dirty = false);
        }
      }
      class j extends O {
        getDefault() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }
        set(e2) {
          const t2 = this.current;
          (e2.func !== t2.func || e2.ref !== t2.ref || e2.mask !== t2.mask || this.dirty) && (this.gl.stencilFunc(e2.func, e2.ref, e2.mask), this.current = e2, this.dirty = false);
        }
      }
      class q extends O {
        getDefault() {
          const e2 = this.gl;
          return [e2.KEEP, e2.KEEP, e2.KEEP];
        }
        set(e2) {
          const t2 = this.current;
          (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || this.dirty) && (this.gl.stencilOp(e2[0], e2[1], e2[2]), this.current = e2, this.dirty = false);
        }
      }
      class W extends O {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          e2 ? t2.enable(t2.STENCIL_TEST) : t2.disable(t2.STENCIL_TEST), this.current = e2, this.dirty = false;
        }
      }
      class $ extends O {
        getDefault() {
          return [0, 1];
        }
        set(e2) {
          const t2 = this.current;
          (e2[0] !== t2[0] || e2[1] !== t2[1] || this.dirty) && (this.gl.depthRange(e2[0], e2[1]), this.current = e2, this.dirty = false);
        }
      }
      class X extends O {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          e2 ? t2.enable(t2.DEPTH_TEST) : t2.disable(t2.DEPTH_TEST), this.current = e2, this.dirty = false;
        }
      }
      class H extends O {
        getDefault() {
          return this.gl.LESS;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.depthFunc(e2), this.current = e2, this.dirty = false);
        }
      }
      class K extends O {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          e2 ? t2.enable(t2.BLEND) : t2.disable(t2.BLEND), this.current = e2, this.dirty = false;
        }
      }
      class Y extends O {
        getDefault() {
          const e2 = this.gl;
          return [e2.ONE, e2.ZERO];
        }
        set(e2) {
          const t2 = this.current;
          (e2[0] !== t2[0] || e2[1] !== t2[1] || this.dirty) && (this.gl.blendFunc(e2[0], e2[1]), this.current = e2, this.dirty = false);
        }
      }
      class J extends O {
        getDefault() {
          return e.Color.transparent;
        }
        set(e2) {
          const t2 = this.current;
          (e2.r !== t2.r || e2.g !== t2.g || e2.b !== t2.b || e2.a !== t2.a || this.dirty) && (this.gl.blendColor(e2.r, e2.g, e2.b, e2.a), this.current = e2, this.dirty = false);
        }
      }
      class Q extends O {
        getDefault() {
          return this.gl.FUNC_ADD;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.blendEquation(e2), this.current = e2, this.dirty = false);
        }
      }
      class ee extends O {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          e2 ? t2.enable(t2.CULL_FACE) : t2.disable(t2.CULL_FACE), this.current = e2, this.dirty = false;
        }
      }
      class te extends O {
        getDefault() {
          return this.gl.BACK;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.cullFace(e2), this.current = e2, this.dirty = false);
        }
      }
      class ie extends O {
        getDefault() {
          return this.gl.CCW;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.frontFace(e2), this.current = e2, this.dirty = false);
        }
      }
      class oe extends O {
        getDefault() {
          return null;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.useProgram(e2), this.current = e2, this.dirty = false);
        }
      }
      class re extends O {
        getDefault() {
          return this.gl.TEXTURE0;
        }
        set(e2) {
          (e2 !== this.current || this.dirty) && (this.gl.activeTexture(e2), this.current = e2, this.dirty = false);
        }
      }
      class ne extends O {
        getDefault() {
          const e2 = this.gl;
          return [0, 0, e2.drawingBufferWidth, e2.drawingBufferHeight];
        }
        set(e2) {
          const t2 = this.current;
          (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || e2[3] !== t2[3] || this.dirty) && (this.gl.viewport(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
        }
      }
      class ae extends O {
        getDefault() {
          return null;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.bindFramebuffer(t2.FRAMEBUFFER, e2), this.current = e2, this.dirty = false;
        }
      }
      class se extends O {
        getDefault() {
          return null;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.bindRenderbuffer(t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
        }
      }
      class le extends O {
        getDefault() {
          return null;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.bindTexture(t2.TEXTURE_2D, e2), this.current = e2, this.dirty = false;
        }
      }
      class ce extends O {
        getDefault() {
          return null;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.bindBuffer(t2.ARRAY_BUFFER, e2), this.current = e2, this.dirty = false;
        }
      }
      class he extends O {
        getDefault() {
          return null;
        }
        set(e2) {
          const t2 = this.gl;
          t2.bindBuffer(t2.ELEMENT_ARRAY_BUFFER, e2), this.current = e2, this.dirty = false;
        }
      }
      class ue extends O {
        constructor(e2) {
          super(e2), this.vao = e2.extVertexArrayObject;
        }
        getDefault() {
          return null;
        }
        set(e2) {
          this.vao && (e2 !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(e2), this.current = e2, this.dirty = false);
        }
      }
      class de extends O {
        getDefault() {
          return 4;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.pixelStorei(t2.UNPACK_ALIGNMENT, e2), this.current = e2, this.dirty = false;
        }
      }
      class _e extends O {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.pixelStorei(t2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e2), this.current = e2, this.dirty = false;
        }
      }
      class pe extends O {
        getDefault() {
          return false;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          const t2 = this.gl;
          t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, e2), this.current = e2, this.dirty = false;
        }
      }
      class me extends O {
        constructor(e2, t2) {
          super(e2), this.context = e2, this.parent = t2;
        }
        getDefault() {
          return null;
        }
      }
      class fe extends me {
        setDirty() {
          this.dirty = true;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const t2 = this.gl;
          t2.framebufferTexture2D(t2.FRAMEBUFFER, t2.COLOR_ATTACHMENT0, t2.TEXTURE_2D, e2, 0), this.current = e2, this.dirty = false;
        }
      }
      class ge extends me {
        attachment() {
          return this.gl.DEPTH_ATTACHMENT;
        }
        set(e2) {
          if (e2 === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const t2 = this.gl;
          t2.framebufferRenderbuffer(t2.FRAMEBUFFER, this.attachment(), t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
        }
      }
      class ve extends ge {
        attachment() {
          return this.gl.DEPTH_STENCIL_ATTACHMENT;
        }
      }
      class xe {
        constructor(e2, t2, i2, o2) {
          this.context = e2, this.width = t2, this.height = i2;
          const r2 = this.framebuffer = e2.gl.createFramebuffer();
          this.colorAttachment = new fe(e2, r2), o2 && (this.depthAttachment = new ge(e2, r2));
        }
        destroy() {
          const e2 = this.context.gl, t2 = this.colorAttachment.get();
          if (t2 && e2.deleteTexture(t2), this.depthAttachment) {
            const t3 = this.depthAttachment.get();
            t3 && e2.deleteRenderbuffer(t3);
          }
          e2.deleteFramebuffer(this.framebuffer);
        }
      }
      class ye {
        constructor(e2) {
          this.gl = e2, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), this.clearColor = new B(this), this.clearDepth = new U(this), this.clearStencil = new N(this), this.colorMask = new G(this), this.depthMask = new Z(this), this.stencilMask = new V(this), this.stencilFunc = new j(this), this.stencilOp = new q(this), this.stencilTest = new W(this), this.depthRange = new $(this), this.depthTest = new X(this), this.depthFunc = new H(this), this.blend = new K(this), this.blendFunc = new Y(this), this.blendColor = new J(this), this.blendEquation = new Q(this), this.cullFace = new ee(this), this.cullFaceSide = new te(this), this.frontFace = new ie(this), this.program = new oe(this), this.activeTexture = new re(this), this.viewport = new ne(this), this.bindFramebuffer = new ae(this), this.bindRenderbuffer = new se(this), this.bindTexture = new le(this), this.bindVertexBuffer = new ce(this), this.bindElementBuffer = new he(this), this.bindVertexArrayOES = this.extVertexArrayObject && new ue(this), this.pixelStoreUnpack = new de(this), this.pixelStoreUnpackPremultiplyAlpha = new _e(this), this.pixelStoreUnpackFlipY = new pe(this), this.extTextureFilterAnisotropic = e2.getExtension("EXT_texture_filter_anisotropic") || e2.getExtension("MOZ_EXT_texture_filter_anisotropic") || e2.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e2.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureFilterAnisotropicForceOff = false, this.extTextureHalfFloat = e2.getExtension("OES_texture_half_float"), this.extTextureHalfFloat && (e2.getExtension("OES_texture_half_float_linear"), this.extRenderToTextureHalfFloat = e2.getExtension("EXT_color_buffer_half_float")), this.extTimerQuery = e2.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = e2.getParameter(e2.MAX_TEXTURE_SIZE);
        }
        setDefault() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }
        setDirty() {
          this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = true), this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
        }
        createIndexBuffer(e2, t2) {
          return new R(this, e2, t2);
        }
        createVertexBuffer(e2, t2, i2) {
          return new F(this, e2, t2, i2);
        }
        createRenderbuffer(e2, t2, i2) {
          const o2 = this.gl, r2 = o2.createRenderbuffer();
          return this.bindRenderbuffer.set(r2), o2.renderbufferStorage(o2.RENDERBUFFER, e2, t2, i2), this.bindRenderbuffer.set(null), r2;
        }
        createFramebuffer(e2, t2, i2) {
          return new xe(this, e2, t2, i2);
        }
        clear({ color: e2, depth: t2, stencil: i2 }) {
          const o2 = this.gl;
          let r2 = 0;
          e2 && (r2 |= o2.COLOR_BUFFER_BIT, this.clearColor.set(e2), this.colorMask.set([true, true, true, true])), void 0 !== t2 && (r2 |= o2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t2), this.depthMask.set(true)), void 0 !== i2 && (r2 |= o2.STENCIL_BUFFER_BIT, this.clearStencil.set(i2), this.stencilMask.set(255)), o2.clear(r2);
        }
        setCullFace(e2) {
          false === e2.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e2.mode), this.frontFace.set(e2.frontFace));
        }
        setDepthMode(e2) {
          e2.func !== this.gl.ALWAYS || e2.mask ? (this.depthTest.set(true), this.depthFunc.set(e2.func), this.depthMask.set(e2.mask), this.depthRange.set(e2.range)) : this.depthTest.set(false);
        }
        setStencilMode(e2) {
          e2.test.func !== this.gl.ALWAYS || e2.mask ? (this.stencilTest.set(true), this.stencilMask.set(e2.mask), this.stencilOp.set([e2.fail, e2.depthFail, e2.pass]), this.stencilFunc.set({ func: e2.test.func, ref: e2.ref, mask: e2.test.mask })) : this.stencilTest.set(false);
        }
        setColorMode(t2) {
          r(t2.blendFunction, e.ColorMode.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(t2.blendFunction), this.blendColor.set(t2.blendColor)), this.colorMask.set(t2.mask);
        }
        unbindVAO() {
          this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
        }
      }
      class be extends e.Evented {
        constructor(t2, i2, o2, r2) {
          super(), this.id = t2, this.dispatcher = o2, this.setEventedParent(r2), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = e.extend({ type: "raster" }, i2), e.extend(this, e.pick(i2, ["url", "scheme", "tileSize"]));
        }
        load() {
          this._loaded = false, this.fire(new e.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = P(this._options, this.map._requestManager, (t2, i2) => {
            this._tileJSONRequest = null, this._loaded = true, t2 ? this.fire(new e.ErrorEvent(t2)) : i2 && (e.extend(this, i2), i2.bounds && (this.tileBounds = new L(i2.bounds, this.minzoom, this.maxzoom)), e.postTurnstileEvent(i2.tiles), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" })));
          });
        }
        loaded() {
          return this._loaded;
        }
        onAdd(e2) {
          this.map = e2, this.load();
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }
        serialize() {
          return e.extend({}, this._options);
        }
        hasTile(e2) {
          return !this.tileBounds || this.tileBounds.contains(e2.canonical);
        }
        loadTile(t2, i2) {
          const o2 = e.exported.devicePixelRatio >= 2, r2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme), o2, this.tileSize);
          t2.request = e.getImage(this.map._requestManager.transformRequest(r2, e.ResourceType.Tile), (o3, r3, n2, a2) => {
            if (delete t2.request, t2.aborted)
              t2.state = "unloaded", i2(null);
            else if (o3)
              t2.state = "errored", i2(o3);
            else if (r3) {
              this.map._refreshExpiredTiles && t2.setExpiryData({ cacheControl: n2, expires: a2 });
              const o4 = this.map.painter.context, s2 = o4.gl;
              t2.texture = this.map.painter.getTileTexture(r3.width), t2.texture ? t2.texture.update(r3, { useMipmap: true }) : (t2.texture = new e.Texture(o4, r3, s2.RGBA, { useMipmap: true }), t2.texture.bind(s2.LINEAR, s2.CLAMP_TO_EDGE, s2.LINEAR_MIPMAP_NEAREST), o4.extTextureFilterAnisotropic && s2.texParameterf(s2.TEXTURE_2D, o4.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, o4.extTextureFilterAnisotropicMax)), t2.state = "loaded", e.cacheEntryPossiblyAdded(this.dispatcher), i2(null);
            }
          });
        }
        abortTile(e2, t2) {
          e2.request && (e2.request.cancel(), delete e2.request), t2();
        }
        unloadTile(e2, t2) {
          e2.texture && this.map.painter.saveTileTexture(e2.texture), t2();
        }
        hasTransition() {
          return false;
        }
      }
      let we;
      var Te = e.createLayout([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
      class Ee extends e.Evented {
        constructor(e2, t2, i2, o2) {
          super(), this.id = e2, this.dispatcher = i2, this.coordinates = t2.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(o2), this.options = t2;
        }
        load(t2, i2) {
          this._loaded = false, this.fire(new e.Event("dataloading", { dataType: "source" })), this.url = this.options.url, e.getImage(this.map._requestManager.transformRequest(this.url, e.ResourceType.Image), (o2, r2) => {
            this._loaded = true, o2 ? this.fire(new e.ErrorEvent(o2)) : r2 && (this.image = e.exported.getImageData(r2), t2 && (this.coordinates = t2), i2 && i2(), this._finishLoading());
          });
        }
        loaded() {
          return this._loaded;
        }
        updateImage(e2) {
          return this.image && e2.url ? (this.options.url = e2.url, this.load(e2.coordinates, () => {
            this.texture = null;
          }), this) : this;
        }
        _finishLoading() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })));
        }
        onAdd(e2) {
          this.map = e2, this.load();
        }
        setCoordinates(t2) {
          this.coordinates = t2;
          const i2 = t2.map(e.MercatorCoordinate.fromLngLat);
          this.tileID = function(t3) {
            let i3 = 1 / 0, o3 = 1 / 0, r2 = -1 / 0, n2 = -1 / 0;
            for (const e2 of t3)
              i3 = Math.min(i3, e2.x), o3 = Math.min(o3, e2.y), r2 = Math.max(r2, e2.x), n2 = Math.max(n2, e2.y);
            const a2 = Math.max(r2 - i3, n2 - o3), s2 = Math.max(0, Math.floor(-Math.log(a2) / Math.LN2)), l2 = Math.pow(2, s2);
            return new e.CanonicalTileID(s2, Math.floor((i3 + r2) / 2 * l2), Math.floor((o3 + n2) / 2 * l2));
          }(i2), this.minzoom = this.maxzoom = this.tileID.z;
          const o2 = i2.map((e2) => this.tileID.getTilePoint(e2)._round());
          return this._boundsArray = new e.StructArrayLayout4i8(), this._boundsArray.emplaceBack(o2[0].x, o2[0].y, 0, 0), this._boundsArray.emplaceBack(o2[1].x, o2[1].y, e.EXTENT, 0), this._boundsArray.emplaceBack(o2[3].x, o2[3].y, 0, e.EXTENT), this._boundsArray.emplaceBack(o2[2].x, o2[2].y, e.EXTENT, e.EXTENT), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" })), this;
        }
        prepare() {
          if (0 === Object.keys(this.tiles).length || !this.image)
            return;
          const t2 = this.map.painter.context, i2 = t2.gl;
          this.boundsBuffer || (this.boundsBuffer = t2.createVertexBuffer(this._boundsArray, Te.members)), this.boundsSegments || (this.boundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new e.Texture(t2, this.image, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE));
          for (const e2 in this.tiles) {
            const t3 = this.tiles[e2];
            "loaded" !== t3.state && (t3.state = "loaded", t3.texture = this.texture);
          }
        }
        loadTile(e2, t2) {
          this.tileID && this.tileID.equals(e2.tileID.canonical) ? (this.tiles[String(e2.tileID.wrap)] = e2, e2.buckets = {}, t2(null)) : (e2.state = "errored", t2(null));
        }
        serialize() {
          return { type: "image", url: this.options.url, coordinates: this.coordinates };
        }
        hasTransition() {
          return false;
        }
      }
      const Ce = { vector: class extends e.Evented {
        constructor(t2, i2, o2, r2) {
          if (super(), this.id = t2, this.dispatcher = o2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, e.extend(this, e.pick(i2, ["url", "scheme", "tileSize", "promoteId"])), this._options = e.extend({ type: "vector" }, i2), this._collectResourceTiming = i2.collectResourceTiming, 512 !== this.tileSize)
            throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(r2), this._tileWorkers = {}, this._deduped = new e.DedupedRequest();
        }
        load() {
          this._loaded = false, this.fire(new e.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = P(this._options, this.map._requestManager, (t2, i2) => {
            this._tileJSONRequest = null, this._loaded = true, t2 ? this.fire(new e.ErrorEvent(t2)) : i2 && (e.extend(this, i2), i2.bounds && (this.tileBounds = new L(i2.bounds, this.minzoom, this.maxzoom)), e.postTurnstileEvent(i2.tiles, this.map._requestManager._customAccessToken), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.Event("data", { dataType: "source", sourceDataType: "content" })));
          });
        }
        loaded() {
          return this._loaded;
        }
        hasTile(e2) {
          return !this.tileBounds || this.tileBounds.contains(e2.canonical);
        }
        onAdd(e2) {
          this.map = e2, this.load();
        }
        setSourceProperty(e2) {
          this._tileJSONRequest && this._tileJSONRequest.cancel(), e2();
          const t2 = this.map.style._getSourceCaches(this.id);
          for (const e3 of t2)
            e3.clearTiles();
          this.load();
        }
        setTiles(e2) {
          return this.setSourceProperty(() => {
            this._options.tiles = e2;
          }), this;
        }
        setUrl(e2) {
          return this.setSourceProperty(() => {
            this.url = e2, this._options.url = e2;
          }), this;
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
        }
        serialize() {
          return e.extend({}, this._options);
        }
        loadTile(t2, i2) {
          const o2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme)), r2 = { request: this.map._requestManager.transformRequest(o2, e.ResourceType.Tile), data: void 0, uid: t2.uid, tileID: t2.tileID, tileZoom: t2.tileZoom, zoom: t2.tileID.overscaledZ, tileSize: this.tileSize * t2.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: e.exported.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, isSymbolTile: t2.isSymbolTile };
          if (r2.request.collectResourceTiming = this._collectResourceTiming, t2.actor && "expired" !== t2.state)
            "loading" === t2.state ? t2.reloadCallback = i2 : t2.request = t2.actor.send("reloadTile", r2, n2.bind(this));
          else if (t2.actor = this._tileWorkers[o2] = this._tileWorkers[o2] || this.dispatcher.getActor(), this.dispatcher.ready)
            t2.request = t2.actor.send("loadTile", r2, n2.bind(this), void 0, true);
          else {
            const i3 = e.loadVectorTile.call({ deduped: this._deduped }, r2, (e2, i4) => {
              e2 || !i4 ? n2.call(this, e2) : (r2.data = { cacheControl: i4.cacheControl, expires: i4.expires, rawData: i4.rawData.slice(0) }, t2.actor && t2.actor.send("loadTile", r2, n2.bind(this), void 0, true));
            }, true);
            t2.request = { cancel: i3 };
          }
          function n2(o3, r3) {
            return delete t2.request, t2.aborted ? i2(null) : o3 && 404 !== o3.status ? i2(o3) : (r3 && r3.resourceTiming && (t2.resourceTiming = r3.resourceTiming), this.map._refreshExpiredTiles && r3 && t2.setExpiryData(r3), t2.loadVectorData(r3, this.map.painter), e.cacheEntryPossiblyAdded(this.dispatcher), i2(null), void (t2.reloadCallback && (this.loadTile(t2, t2.reloadCallback), t2.reloadCallback = null)));
          }
        }
        abortTile(e2) {
          e2.request && (e2.request.cancel(), delete e2.request), e2.actor && e2.actor.send("abortTile", { uid: e2.uid, type: this.type, source: this.id });
        }
        unloadTile(e2) {
          e2.unloadVectorData(), e2.actor && e2.actor.send("removeTile", { uid: e2.uid, type: this.type, source: this.id });
        }
        hasTransition() {
          return false;
        }
        afterUpdate() {
          this._tileWorkers = {};
        }
      }, raster: be, "raster-dem": class extends be {
        constructor(t2, i2, o2, r2) {
          super(t2, i2, o2, r2), this.type = "raster-dem", this.maxzoom = 22, this._options = e.extend({ type: "raster-dem" }, i2), this.encoding = i2.encoding || "mapbox";
        }
        loadTile(t2, i2) {
          const o2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme), false, this.tileSize);
          function r2(e2, o3) {
            e2 && (t2.state = "errored", i2(e2)), o3 && (t2.dem = o3, t2.dem.onDeserialize(), t2.needsHillshadePrepare = true, t2.needsDEMTextureUpload = true, t2.state = "loaded", i2(null));
          }
          t2.request = e.getImage(this.map._requestManager.transformRequest(o2, e.ResourceType.Tile), function(o3, n2, a2, s2) {
            if (delete t2.request, t2.aborted)
              t2.state = "unloaded", i2(null);
            else if (o3)
              t2.state = "errored", i2(o3);
            else if (n2) {
              this.map._refreshExpiredTiles && t2.setExpiryData({ cacheControl: a2, expires: s2 });
              const i3 = e.window.ImageBitmap && n2 instanceof e.window.ImageBitmap && (null == we && (we = e.window.OffscreenCanvas && new e.window.OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof e.window.createImageBitmap), we), o4 = 1 - (n2.width - e.prevPowerOfTwo(n2.width)) / 2;
              o4 < 1 || t2.neighboringTiles || (t2.neighboringTiles = this._getNeighboringTiles(t2.tileID));
              const l2 = i3 ? n2 : e.exported.getImageData(n2, o4), c2 = { uid: t2.uid, coord: t2.tileID, source: this.id, rawImageData: l2, encoding: this.encoding, padding: o4 };
              t2.actor && "expired" !== t2.state || (t2.actor = this.dispatcher.getActor(), t2.actor.send("loadDEMTile", c2, r2.bind(this), void 0, true));
            }
          }.bind(this));
        }
        _getNeighboringTiles(t2) {
          const i2 = t2.canonical, o2 = Math.pow(2, i2.z), r2 = (i2.x - 1 + o2) % o2, n2 = 0 === i2.x ? t2.wrap - 1 : t2.wrap, a2 = (i2.x + 1 + o2) % o2, s2 = i2.x + 1 === o2 ? t2.wrap + 1 : t2.wrap, l2 = {};
          return l2[new e.OverscaledTileID(t2.overscaledZ, n2, i2.z, r2, i2.y).key] = { backfilled: false }, l2[new e.OverscaledTileID(t2.overscaledZ, s2, i2.z, a2, i2.y).key] = { backfilled: false }, i2.y > 0 && (l2[new e.OverscaledTileID(t2.overscaledZ, n2, i2.z, r2, i2.y - 1).key] = { backfilled: false }, l2[new e.OverscaledTileID(t2.overscaledZ, t2.wrap, i2.z, i2.x, i2.y - 1).key] = { backfilled: false }, l2[new e.OverscaledTileID(t2.overscaledZ, s2, i2.z, a2, i2.y - 1).key] = { backfilled: false }), i2.y + 1 < o2 && (l2[new e.OverscaledTileID(t2.overscaledZ, n2, i2.z, r2, i2.y + 1).key] = { backfilled: false }, l2[new e.OverscaledTileID(t2.overscaledZ, t2.wrap, i2.z, i2.x, i2.y + 1).key] = { backfilled: false }, l2[new e.OverscaledTileID(t2.overscaledZ, s2, i2.z, a2, i2.y + 1).key] = { backfilled: false }), l2;
        }
        unloadTile(e2) {
          e2.demTexture && this.map.painter.saveTileTexture(e2.demTexture), e2.fbo && (e2.fbo.destroy(), delete e2.fbo), e2.dem && delete e2.dem, delete e2.neighboringTiles, e2.state = "unloaded";
        }
      }, geojson: class extends e.Evented {
        constructor(t2, i2, o2, r2) {
          super(), this.id = t2, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._loaded = false, this.actor = o2.getActor(), this.setEventedParent(r2), this._data = i2.data, this._options = e.extend({}, i2), this._collectResourceTiming = i2.collectResourceTiming, void 0 !== i2.maxzoom && (this.maxzoom = i2.maxzoom), i2.type && (this.type = i2.type), i2.attribution && (this.attribution = i2.attribution), this.promoteId = i2.promoteId;
          const n2 = e.EXTENT / this.tileSize;
          this.workerOptions = e.extend({ source: this.id, cluster: i2.cluster || false, geojsonVtOptions: { buffer: (void 0 !== i2.buffer ? i2.buffer : 128) * n2, tolerance: (void 0 !== i2.tolerance ? i2.tolerance : 0.375) * n2, extent: e.EXTENT, maxZoom: this.maxzoom, lineMetrics: i2.lineMetrics || false, generateId: i2.generateId || false }, superclusterOptions: { maxZoom: void 0 !== i2.clusterMaxZoom ? i2.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i2.clusterMinPoints || 2), extent: e.EXTENT, radius: (void 0 !== i2.clusterRadius ? i2.clusterRadius : 50) * n2, log: false, generateId: i2.generateId || false }, clusterProperties: i2.clusterProperties, filter: i2.filter }, i2.workerOptions);
        }
        onAdd(e2) {
          this.map = e2, this.setData(this._data);
        }
        setData(e2) {
          return this._data = e2, this._updateWorkerData(), this;
        }
        getClusterExpansionZoom(e2, t2) {
          return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: e2, source: this.id }, t2), this;
        }
        getClusterChildren(e2, t2) {
          return this.actor.send("geojson.getClusterChildren", { clusterId: e2, source: this.id }, t2), this;
        }
        getClusterLeaves(e2, t2, i2, o2) {
          return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: e2, limit: t2, offset: i2 }, o2), this;
        }
        _updateWorkerData() {
          if (this._pendingLoad)
            return void (this._coalesce = true);
          this.fire(new e.Event("dataloading", { dataType: "source" })), this._loaded = false;
          const t2 = e.extend({}, this.workerOptions), i2 = this._data;
          "string" == typeof i2 ? (t2.request = this.map._requestManager.transformRequest(e.exported.resolveURL(i2), e.ResourceType.Source), t2.request.collectResourceTiming = this._collectResourceTiming) : t2.data = JSON.stringify(i2), this._pendingLoad = this.actor.send(`${this.type}.loadData`, t2, (t3, i3) => {
            if (this._loaded = true, this._pendingLoad = null, t3)
              this.fire(new e.ErrorEvent(t3));
            else {
              const t4 = { dataType: "source", sourceDataType: this._metadataFired ? "content" : "metadata" };
              this._collectResourceTiming && i3 && i3.resourceTiming && i3.resourceTiming[this.id] && (t4.resourceTiming = i3.resourceTiming[this.id]), this.fire(new e.Event("data", t4)), this._metadataFired = true;
            }
            this._coalesce && (this._updateWorkerData(), this._coalesce = false);
          });
        }
        loaded() {
          return this._loaded;
        }
        loadTile(t2, i2) {
          const o2 = t2.actor ? "reloadTile" : "loadTile";
          t2.actor = this.actor, t2.request = this.actor.send(o2, { type: this.type, uid: t2.uid, tileID: t2.tileID, tileZoom: t2.tileZoom, zoom: t2.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: e.exported.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId }, (e2, r2) => (delete t2.request, t2.unloadVectorData(), t2.aborted ? i2(null) : e2 ? i2(e2) : (t2.loadVectorData(r2, this.map.painter, "reloadTile" === o2), i2(null))), void 0, "loadTile" === o2);
        }
        abortTile(e2) {
          e2.request && (e2.request.cancel(), delete e2.request), e2.aborted = true;
        }
        unloadTile(e2) {
          e2.unloadVectorData(), this.actor.send("removeTile", { uid: e2.uid, type: this.type, source: this.id });
        }
        onRemove() {
          this._pendingLoad && this._pendingLoad.cancel();
        }
        serialize() {
          return e.extend({}, this._options, { type: this.type, data: this._data });
        }
        hasTransition() {
          return false;
        }
      }, video: class extends Ee {
        constructor(e2, t2, i2, o2) {
          super(e2, t2, i2, o2), this.roundZoom = true, this.type = "video", this.options = t2;
        }
        load() {
          this._loaded = false;
          const t2 = this.options;
          this.urls = [];
          for (const i2 of t2.urls)
            this.urls.push(this.map._requestManager.transformRequest(i2, e.ResourceType.Source).url);
          e.getVideo(this.urls, (t3, i2) => {
            this._loaded = true, t3 ? this.fire(new e.ErrorEvent(t3)) : i2 && (this.video = i2, this.video.loop = true, this.video.addEventListener("playing", () => {
              this.map.triggerRepaint();
            }), this.map && this.video.play(), this._finishLoading());
          });
        }
        pause() {
          this.video && this.video.pause();
        }
        play() {
          this.video && this.video.play();
        }
        seek(t2) {
          if (this.video) {
            const i2 = this.video.seekable;
            t2 < i2.start(0) || t2 > i2.end(0) ? this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i2.start(0)} and ${i2.end(0)}-second mark.`))) : this.video.currentTime = t2;
          }
        }
        getVideo() {
          return this.video;
        }
        onAdd(e2) {
          this.map || (this.map = e2, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }
        prepare() {
          if (0 === Object.keys(this.tiles).length || this.video.readyState < 2)
            return;
          const t2 = this.map.painter.context, i2 = t2.gl;
          this.boundsBuffer || (this.boundsBuffer = t2.createVertexBuffer(this._boundsArray, Te.members)), this.boundsSegments || (this.boundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), i2.texSubImage2D(i2.TEXTURE_2D, 0, 0, 0, i2.RGBA, i2.UNSIGNED_BYTE, this.video)) : (this.texture = new e.Texture(t2, this.video, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE));
          for (const e2 in this.tiles) {
            const t3 = this.tiles[e2];
            "loaded" !== t3.state && (t3.state = "loaded", t3.texture = this.texture);
          }
        }
        serialize() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }
        hasTransition() {
          return this.video && !this.video.paused;
        }
      }, image: Ee, canvas: class extends Ee {
        constructor(t2, i2, o2, r2) {
          super(t2, i2, o2, r2), i2.coordinates ? Array.isArray(i2.coordinates) && 4 === i2.coordinates.length && !i2.coordinates.some((e2) => !Array.isArray(e2) || 2 !== e2.length || e2.some((e3) => "number" != typeof e3)) || this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t2}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t2}`, null, 'missing required property "coordinates"'))), i2.animate && "boolean" != typeof i2.animate && this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t2}`, null, 'optional "animate" property must be a boolean value'))), i2.canvas ? "string" == typeof i2.canvas || i2.canvas instanceof e.window.HTMLCanvasElement || this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t2}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e.ErrorEvent(new e.ValidationError(`sources.${t2}`, null, 'missing required property "canvas"'))), this.options = i2, this.animate = void 0 === i2.animate || i2.animate;
        }
        load() {
          this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof e.window.HTMLCanvasElement ? this.options.canvas : e.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
            this._playing = true, this.map.triggerRepaint();
          }, this.pause = function() {
            this._playing && (this.prepare(), this._playing = false);
          }, this._finishLoading());
        }
        getCanvas() {
          return this.canvas;
        }
        onAdd(e2) {
          this.map = e2, this.load(), this.canvas && this.animate && this.play();
        }
        onRemove() {
          this.pause();
        }
        prepare() {
          let t2 = false;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, t2 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, t2 = true), this._hasInvalidDimensions())
            return;
          if (0 === Object.keys(this.tiles).length)
            return;
          const i2 = this.map.painter.context, o2 = i2.gl;
          this.boundsBuffer || (this.boundsBuffer = i2.createVertexBuffer(this._boundsArray, Te.members)), this.boundsSegments || (this.boundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? (t2 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new e.Texture(i2, this.canvas, o2.RGBA, { premultiply: true });
          for (const e2 in this.tiles) {
            const t3 = this.tiles[e2];
            "loaded" !== t3.state && (t3.state = "loaded", t3.texture = this.texture);
          }
        }
        serialize() {
          return { type: "canvas", coordinates: this.coordinates };
        }
        hasTransition() {
          return this._playing;
        }
        _hasInvalidDimensions() {
          for (const e2 of [this.canvas.width, this.canvas.height])
            if (isNaN(e2) || e2 <= 0)
              return true;
          return false;
        }
      } }, Se = function(t2, i2, o2, r2) {
        const n2 = new Ce[i2.type](t2, i2, o2, r2);
        if (n2.id !== t2)
          throw new Error(`Expected Source id to be ${t2} instead of ${n2.id}`);
        return e.bindAll(["load", "abort", "unload", "serialize", "prepare"], n2), n2;
      };
      function Me(t2, i2) {
        const o2 = e.identity([]);
        return e.scale$1(o2, o2, [0.5 * t2.width, 0.5 * -t2.height, 1]), e.translate(o2, o2, [1, -1, 0]), e.multiply(o2, o2, t2.calculateProjMatrix(i2.toUnwrapped()));
      }
      function Ie(e2, t2, i2, o2, r2, n2, a2, s2 = false) {
        const l2 = e2.tilesIn(o2, a2, s2);
        l2.sort(Ae);
        const c2 = [];
        for (const o3 of l2)
          c2.push({ wrappedTileID: o3.tile.tileID.wrapped().key, queryResults: o3.tile.queryRenderedFeatures(t2, i2, e2._state, o3, r2, n2, Me(e2.transform, o3.tile.tileID), s2) });
        const h2 = function(e3) {
          const t3 = {}, i3 = {};
          for (const o3 of e3) {
            const e4 = o3.queryResults, r3 = o3.wrappedTileID, n3 = i3[r3] = i3[r3] || {};
            for (const i4 in e4) {
              const o4 = e4[i4], r4 = n3[i4] = n3[i4] || {}, a3 = t3[i4] = t3[i4] || [];
              for (const e5 of o4)
                r4[e5.featureIndex] || (r4[e5.featureIndex] = true, a3.push(e5));
            }
          }
          return t3;
        }(c2);
        for (const t3 in h2)
          h2[t3].forEach((t4) => {
            const i3 = t4.feature, o3 = e2.getFeatureState(i3.layer["source-layer"], i3.id);
            i3.source = i3.layer.source, i3.layer["source-layer"] && (i3.sourceLayer = i3.layer["source-layer"]), i3.state = o3;
          });
        return h2;
      }
      function De(e2, t2) {
        const i2 = e2.getRenderableIds().map((t3) => e2.getTileByID(t3)), o2 = [], r2 = {};
        for (let e3 = 0; e3 < i2.length; e3++) {
          const n2 = i2[e3], a2 = n2.tileID.canonical.key;
          r2[a2] || (r2[a2] = true, n2.querySourceFeatures(o2, t2));
        }
        return o2;
      }
      function Ae(e2, t2) {
        const i2 = e2.tileID, o2 = t2.tileID;
        return i2.overscaledZ - o2.overscaledZ || i2.canonical.y - o2.canonical.y || i2.wrap - o2.wrap || i2.canonical.x - o2.canonical.x;
      }
      function ze() {
        return null != Wr.workerClass ? new Wr.workerClass() : new e.window.Worker(Wr.workerUrl);
      }
      const Pe = "mapboxgl_preloaded_worker_pool";
      class Le {
        constructor() {
          this.active = {};
        }
        acquire(e2) {
          if (!this.workers)
            for (this.workers = []; this.workers.length < Le.workerCount; )
              this.workers.push(new ze());
          return this.active[e2] = true, this.workers.slice();
        }
        release(e2) {
          delete this.active[e2], 0 === this.numActive() && (this.workers.forEach((e3) => {
            e3.terminate();
          }), this.workers = null);
        }
        isPreloaded() {
          return !!this.active[Pe];
        }
        numActive() {
          return Object.keys(this.active).length;
        }
      }
      let Re;
      function ke() {
        return Re || (Re = new Le()), Re;
      }
      function Fe(t2, i2) {
        const o2 = {};
        for (const e2 in t2)
          "ref" !== e2 && (o2[e2] = t2[e2]);
        return e.refProperties.forEach((e2) => {
          e2 in i2 && (o2[e2] = i2[e2]);
        }), o2;
      }
      function Oe(e2) {
        e2 = e2.slice();
        const t2 = /* @__PURE__ */ Object.create(null);
        for (let i2 = 0; i2 < e2.length; i2++)
          t2[e2[i2].id] = e2[i2];
        for (let i2 = 0; i2 < e2.length; i2++)
          "ref" in e2[i2] && (e2[i2] = Fe(e2[i2], t2[e2[i2].ref]));
        return e2;
      }
      Le.workerCount = 2;
      const Be = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight", setTerrain: "setTerrain", setFog: "setFog" };
      function Ue(e2, t2, i2) {
        i2.push({ command: Be.addSource, args: [e2, t2[e2]] });
      }
      function Ne(e2, t2, i2) {
        t2.push({ command: Be.removeSource, args: [e2] }), i2[e2] = true;
      }
      function Ge(e2, t2, i2, o2) {
        Ne(e2, i2, o2), Ue(e2, t2, i2);
      }
      function Ze(e2, t2, i2) {
        let o2;
        for (o2 in e2[i2])
          if (e2[i2].hasOwnProperty(o2) && "data" !== o2 && !r(e2[i2][o2], t2[i2][o2]))
            return false;
        for (o2 in t2[i2])
          if (t2[i2].hasOwnProperty(o2) && "data" !== o2 && !r(e2[i2][o2], t2[i2][o2]))
            return false;
        return true;
      }
      function Ve(e2, t2, i2, o2, n2, a2) {
        let s2;
        for (s2 in t2 = t2 || {}, e2 = e2 || {})
          e2.hasOwnProperty(s2) && (r(e2[s2], t2[s2]) || i2.push({ command: a2, args: [o2, s2, t2[s2], n2] }));
        for (s2 in t2)
          t2.hasOwnProperty(s2) && !e2.hasOwnProperty(s2) && (r(e2[s2], t2[s2]) || i2.push({ command: a2, args: [o2, s2, t2[s2], n2] }));
      }
      function je(e2) {
        return e2.id;
      }
      function qe(e2, t2) {
        return e2[t2.id] = t2, e2;
      }
      class We {
        constructor(e2, t2) {
          this.reset(e2, t2);
        }
        reset(e2, t2) {
          this.points = e2 || [], this._distances = [0];
          for (let e3 = 1; e3 < this.points.length; e3++)
            this._distances[e3] = this._distances[e3 - 1] + this.points[e3].dist(this.points[e3 - 1]);
          this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t2 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
        }
        lerp(t2) {
          if (1 === this.points.length)
            return this.points[0];
          t2 = e.clamp(t2, 0, 1);
          let i2 = 1, o2 = this._distances[i2];
          const r2 = t2 * this.paddedLength + this.padding;
          for (; o2 < r2 && i2 < this._distances.length; )
            o2 = this._distances[++i2];
          const n2 = i2 - 1, a2 = this._distances[n2], s2 = o2 - a2, l2 = s2 > 0 ? (r2 - a2) / s2 : 0;
          return this.points[n2].mult(1 - l2).add(this.points[i2].mult(l2));
        }
      }
      class $e {
        constructor(e2, t2, i2) {
          const o2 = this.boxCells = [], r2 = this.circleCells = [];
          this.xCellCount = Math.ceil(e2 / i2), this.yCellCount = Math.ceil(t2 / i2);
          for (let e3 = 0; e3 < this.xCellCount * this.yCellCount; e3++)
            o2.push([]), r2.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e2, this.height = t2, this.xScale = this.xCellCount / e2, this.yScale = this.yCellCount / t2, this.boxUid = 0, this.circleUid = 0;
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(e2, t2, i2, o2, r2) {
          this._forEachCell(t2, i2, o2, r2, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e2), this.bboxes.push(t2), this.bboxes.push(i2), this.bboxes.push(o2), this.bboxes.push(r2);
        }
        insertCircle(e2, t2, i2, o2) {
          this._forEachCell(t2 - o2, i2 - o2, t2 + o2, i2 + o2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e2), this.circles.push(t2), this.circles.push(i2), this.circles.push(o2);
        }
        _insertBoxCell(e2, t2, i2, o2, r2, n2) {
          this.boxCells[r2].push(n2);
        }
        _insertCircleCell(e2, t2, i2, o2, r2, n2) {
          this.circleCells[r2].push(n2);
        }
        _query(e2, t2, i2, o2, r2, n2) {
          if (i2 < 0 || e2 > this.width || o2 < 0 || t2 > this.height)
            return !r2 && [];
          const a2 = [];
          if (e2 <= 0 && t2 <= 0 && this.width <= i2 && this.height <= o2) {
            if (r2)
              return true;
            for (let e3 = 0; e3 < this.boxKeys.length; e3++)
              a2.push({ key: this.boxKeys[e3], x1: this.bboxes[4 * e3], y1: this.bboxes[4 * e3 + 1], x2: this.bboxes[4 * e3 + 2], y2: this.bboxes[4 * e3 + 3] });
            for (let e3 = 0; e3 < this.circleKeys.length; e3++) {
              const t3 = this.circles[3 * e3], i3 = this.circles[3 * e3 + 1], o3 = this.circles[3 * e3 + 2];
              a2.push({ key: this.circleKeys[e3], x1: t3 - o3, y1: i3 - o3, x2: t3 + o3, y2: i3 + o3 });
            }
            return n2 ? a2.filter(n2) : a2;
          }
          return this._forEachCell(e2, t2, i2, o2, this._queryCell, a2, { hitTest: r2, seenUids: { box: {}, circle: {} } }, n2), r2 ? a2.length > 0 : a2;
        }
        _queryCircle(e2, t2, i2, o2, r2) {
          const n2 = e2 - i2, a2 = e2 + i2, s2 = t2 - i2, l2 = t2 + i2;
          if (a2 < 0 || n2 > this.width || l2 < 0 || s2 > this.height)
            return !o2 && [];
          const c2 = [];
          return this._forEachCell(n2, s2, a2, l2, this._queryCellCircle, c2, { hitTest: o2, circle: { x: e2, y: t2, radius: i2 }, seenUids: { box: {}, circle: {} } }, r2), o2 ? c2.length > 0 : c2;
        }
        query(e2, t2, i2, o2, r2) {
          return this._query(e2, t2, i2, o2, false, r2);
        }
        hitTest(e2, t2, i2, o2, r2) {
          return this._query(e2, t2, i2, o2, true, r2);
        }
        hitTestCircle(e2, t2, i2, o2) {
          return this._queryCircle(e2, t2, i2, true, o2);
        }
        _queryCell(e2, t2, i2, o2, r2, n2, a2, s2) {
          const l2 = a2.seenUids, c2 = this.boxCells[r2];
          if (null !== c2) {
            const r3 = this.bboxes;
            for (const h3 of c2)
              if (!l2.box[h3]) {
                l2.box[h3] = true;
                const c3 = 4 * h3;
                if (e2 <= r3[c3 + 2] && t2 <= r3[c3 + 3] && i2 >= r3[c3 + 0] && o2 >= r3[c3 + 1] && (!s2 || s2(this.boxKeys[h3]))) {
                  if (a2.hitTest)
                    return n2.push(true), true;
                  n2.push({ key: this.boxKeys[h3], x1: r3[c3], y1: r3[c3 + 1], x2: r3[c3 + 2], y2: r3[c3 + 3] });
                }
              }
          }
          const h2 = this.circleCells[r2];
          if (null !== h2) {
            const r3 = this.circles;
            for (const c3 of h2)
              if (!l2.circle[c3]) {
                l2.circle[c3] = true;
                const h3 = 3 * c3;
                if (this._circleAndRectCollide(r3[h3], r3[h3 + 1], r3[h3 + 2], e2, t2, i2, o2) && (!s2 || s2(this.circleKeys[c3]))) {
                  if (a2.hitTest)
                    return n2.push(true), true;
                  {
                    const e3 = r3[h3], t3 = r3[h3 + 1], i3 = r3[h3 + 2];
                    n2.push({ key: this.circleKeys[c3], x1: e3 - i3, y1: t3 - i3, x2: e3 + i3, y2: t3 + i3 });
                  }
                }
              }
          }
        }
        _queryCellCircle(e2, t2, i2, o2, r2, n2, a2, s2) {
          const l2 = a2.circle, c2 = a2.seenUids, h2 = this.boxCells[r2];
          if (null !== h2) {
            const e3 = this.bboxes;
            for (const t3 of h2)
              if (!c2.box[t3]) {
                c2.box[t3] = true;
                const i3 = 4 * t3;
                if (this._circleAndRectCollide(l2.x, l2.y, l2.radius, e3[i3 + 0], e3[i3 + 1], e3[i3 + 2], e3[i3 + 3]) && (!s2 || s2(this.boxKeys[t3])))
                  return n2.push(true), true;
              }
          }
          const u2 = this.circleCells[r2];
          if (null !== u2) {
            const e3 = this.circles;
            for (const t3 of u2)
              if (!c2.circle[t3]) {
                c2.circle[t3] = true;
                const i3 = 3 * t3;
                if (this._circlesCollide(e3[i3], e3[i3 + 1], e3[i3 + 2], l2.x, l2.y, l2.radius) && (!s2 || s2(this.circleKeys[t3])))
                  return n2.push(true), true;
              }
          }
        }
        _forEachCell(e2, t2, i2, o2, r2, n2, a2, s2) {
          const l2 = this._convertToXCellCoord(e2), c2 = this._convertToYCellCoord(t2), h2 = this._convertToXCellCoord(i2), u2 = this._convertToYCellCoord(o2);
          for (let d2 = l2; d2 <= h2; d2++)
            for (let l3 = c2; l3 <= u2; l3++)
              if (r2.call(this, e2, t2, i2, o2, this.xCellCount * l3 + d2, n2, a2, s2))
                return;
        }
        _convertToXCellCoord(e2) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e2 * this.xScale)));
        }
        _convertToYCellCoord(e2) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e2 * this.yScale)));
        }
        _circlesCollide(e2, t2, i2, o2, r2, n2) {
          const a2 = o2 - e2, s2 = r2 - t2, l2 = i2 + n2;
          return l2 * l2 > a2 * a2 + s2 * s2;
        }
        _circleAndRectCollide(e2, t2, i2, o2, r2, n2, a2) {
          const s2 = (n2 - o2) / 2, l2 = Math.abs(e2 - (o2 + s2));
          if (l2 > s2 + i2)
            return false;
          const c2 = (a2 - r2) / 2, h2 = Math.abs(t2 - (r2 + c2));
          if (h2 > c2 + i2)
            return false;
          if (l2 <= s2 || h2 <= c2)
            return true;
          const u2 = l2 - s2, d2 = h2 - c2;
          return u2 * u2 + d2 * d2 <= i2 * i2;
        }
      }
      const Xe = Math.tan(85 * Math.PI / 180);
      function He(t2, i2, o2, r2, n2) {
        const a2 = e.create$1();
        return i2 ? (e.scale$1(a2, a2, [1 / n2, 1 / n2, 1]), o2 || e.rotateZ(a2, a2, r2.angle)) : e.multiply(a2, r2.labelPlaneMatrix, t2), a2;
      }
      function Ke(t2, i2, o2, r2, n2) {
        if (i2) {
          const i3 = e.clone$1(t2);
          return e.scale$1(i3, i3, [n2, n2, 1]), o2 || e.rotateZ(i3, i3, -r2.angle), i3;
        }
        return r2.glCoordMatrix;
      }
      function Ye(t2, i2, o2 = 0) {
        const r2 = [t2.x, t2.y, o2, 1];
        o2 ? e.transformMat4(r2, r2, i2) : ct(r2, r2, i2);
        const n2 = r2[3];
        return { point: new e.pointGeometry(r2[0] / n2, r2[1] / n2), signedDistanceFromCamera: n2 };
      }
      function Je(e2, t2) {
        return Math.min(0.5 + e2 / t2 * 0.5, 1.5);
      }
      function Qe(e2, t2) {
        const i2 = e2[0] / e2[3], o2 = e2[1] / e2[3];
        return i2 >= -t2[0] && i2 <= t2[0] && o2 >= -t2[1] && o2 <= t2[1];
      }
      function et(t2, i2, o2, r2, n2, a2, s2, l2, c2) {
        const h2 = r2 ? t2.textSizeData : t2.iconSizeData, u2 = e.evaluateSizeForZoom(h2, o2.transform.zoom), d2 = [256 / o2.width * 2 + 1, 256 / o2.height * 2 + 1], _2 = r2 ? t2.text.dynamicLayoutVertexArray : t2.icon.dynamicLayoutVertexArray;
        _2.clear();
        const p2 = t2.lineVertexArray, m2 = r2 ? t2.text.placedSymbolArray : t2.icon.placedSymbolArray, f2 = o2.transform.width / o2.transform.height;
        let g2 = false;
        for (let r3 = 0; r3 < m2.length; r3++) {
          const v2 = m2.get(r3);
          if (v2.writingMode !== e.WritingMode.vertical || g2 || 0 !== r3 && m2.get(r3 - 1).writingMode === e.WritingMode.horizontal || (g2 = true), v2.hidden || v2.writingMode === e.WritingMode.vertical && !g2) {
            lt(v2.numGlyphs, _2);
            continue;
          }
          g2 = false;
          const x2 = new e.pointGeometry(v2.tileAnchorX, v2.tileAnchorY), y2 = c2 ? c2(x2) : 0, b2 = [x2.x, x2.y, y2], w2 = [...b2, 1];
          if (e.transformMat4(w2, w2, i2), !Qe(w2, d2)) {
            lt(v2.numGlyphs, _2);
            continue;
          }
          const T2 = Je(o2.transform.cameraToCenterDistance, w2[3]), E2 = e.evaluateSizeForFeature(h2, u2, v2), C2 = s2 ? E2 / T2 : E2 * T2, S2 = Ye(new e.pointGeometry(b2[0], b2[1]), n2, b2[2]);
          if (S2.signedDistanceFromCamera <= 0) {
            lt(v2.numGlyphs, _2);
            continue;
          }
          let M2 = {};
          const I2 = s2 ? null : c2, D2 = ot(v2, C2, false, l2, i2, n2, a2, t2.glyphOffsetArray, p2, _2, S2.point, x2, M2, f2, I2);
          g2 = D2.useVertical, I2 && D2.needsFlipping && (M2 = {}), (D2.notEnoughRoom || g2 || D2.needsFlipping && ot(v2, C2, true, l2, i2, n2, a2, t2.glyphOffsetArray, p2, _2, S2.point, x2, M2, f2, I2).notEnoughRoom) && lt(v2.numGlyphs, _2);
        }
        r2 ? t2.text.dynamicLayoutVertexBuffer.updateData(_2) : t2.icon.dynamicLayoutVertexBuffer.updateData(_2);
      }
      function tt(e2, t2, i2, o2, r2, n2, a2, s2, l2, c2, h2, u2, d2) {
        const _2 = s2.glyphStartIndex + s2.numGlyphs, p2 = s2.lineStartIndex, m2 = s2.lineStartIndex + s2.lineLength, f2 = t2.getoffsetX(s2.glyphStartIndex), g2 = t2.getoffsetX(_2 - 1), v2 = at(e2 * f2, i2, o2, r2, n2, a2, s2.segment, p2, m2, l2, c2, h2, u2, d2, true);
        if (!v2)
          return null;
        const x2 = at(e2 * g2, i2, o2, r2, n2, a2, s2.segment, p2, m2, l2, c2, h2, u2, d2, true);
        return x2 ? { first: v2, last: x2 } : null;
      }
      function it(t2, i2, o2, r2) {
        return t2.writingMode === e.WritingMode.horizontal && Math.abs(o2.y - i2.y) > Math.abs(o2.x - i2.x) * r2 ? { useVertical: true } : t2.writingMode === e.WritingMode.vertical ? i2.y < o2.y ? { needsFlipping: true } : null : 0 !== t2.flipState && function(e2, t3, i3) {
          const o3 = (t3.x - e2.x) * i3;
          return 0 === o3 || Math.abs((t3.y - e2.y) / o3) > Xe;
        }(i2, o2, r2) ? 1 === t2.flipState ? { needsFlipping: true } : null : i2.x > o2.x ? { needsFlipping: true } : null;
      }
      function ot(t2, i2, o2, r2, n2, a2, s2, l2, c2, h2, u2, d2, _2, p2, m2) {
        const f2 = i2 / 24, g2 = t2.lineOffsetX * f2, v2 = t2.lineOffsetY * f2;
        let x2;
        if (t2.numGlyphs > 1) {
          const e2 = t2.glyphStartIndex + t2.numGlyphs, i3 = t2.lineStartIndex, n3 = t2.lineStartIndex + t2.lineLength, h3 = tt(f2, l2, g2, v2, o2, u2, d2, t2, c2, a2, _2, m2, false);
          if (!h3)
            return { notEnoughRoom: true };
          const y2 = Ye(h3.first.point, s2).point, b2 = Ye(h3.last.point, s2).point;
          if (r2 && !o2) {
            const e3 = it(t2, y2, b2, p2);
            if (t2.flipState = e3 && e3.needsFlipping ? 1 : 2, e3)
              return e3;
          }
          x2 = [h3.first];
          for (let r3 = t2.glyphStartIndex + 1; r3 < e2 - 1; r3++)
            x2.push(at(f2 * l2.getoffsetX(r3), g2, v2, o2, u2, d2, t2.segment, i3, n3, c2, a2, _2, m2, false, false));
          x2.push(h3.last);
        } else {
          if (r2 && !o2) {
            const i4 = Ye(d2, n2).point, o3 = t2.lineStartIndex + t2.segment + 1, r3 = new e.pointGeometry(c2.getx(o3), c2.gety(o3)), a3 = Ye(r3, n2), s3 = it(t2, i4, a3.signedDistanceFromCamera > 0 ? a3.point : nt(d2, r3, i4, 1, n2, void 0), p2);
            if (t2.flipState = s3 && s3.needsFlipping ? 1 : 2, s3)
              return s3;
          }
          const i3 = at(f2 * l2.getoffsetX(t2.glyphStartIndex), g2, v2, o2, u2, d2, t2.segment, t2.lineStartIndex, t2.lineStartIndex + t2.lineLength, c2, a2, _2, m2, false, false);
          if (!i3)
            return { notEnoughRoom: true };
          x2 = [i3];
        }
        for (const t3 of x2)
          e.addDynamicAttributes(h2, t3.point, t3.angle);
        return {};
      }
      function rt(t2, i2, o2) {
        const r2 = { x: t2.x, y: t2.y, z: 0 };
        if (!o2)
          return Ye(r2, i2, r2.z);
        const n2 = o2(t2);
        return Ye(new e.pointGeometry(r2.x, r2.y), i2, r2.z + n2);
      }
      function nt(e2, t2, i2, o2, r2, n2) {
        const a2 = rt(e2.add(e2.sub(t2)._unit()), r2, n2).point, s2 = i2.sub(a2);
        return i2.add(s2._mult(o2 / s2.mag()));
      }
      function at(t2, i2, o2, r2, n2, a2, s2, l2, c2, h2, u2, d2, _2, p2, m2) {
        const f2 = r2 ? t2 - i2 : t2 + i2;
        let g2 = f2 > 0 ? 1 : -1, v2 = 0;
        r2 && (g2 *= -1, v2 = Math.PI), g2 < 0 && (v2 += Math.PI);
        let x2 = g2 > 0 ? l2 + s2 : l2 + s2 + 1, y2 = n2, b2 = n2, w2 = 0, T2 = 0;
        const E2 = Math.abs(f2), C2 = [], S2 = [];
        let M2 = a2;
        const I2 = () => {
          const t3 = x2 - g2;
          return 0 === w2 ? a2 : new e.pointGeometry(h2.getx(t3), h2.gety(t3));
        }, D2 = () => nt(I2(), M2, b2, E2 - w2 + 1, u2, _2);
        for (; w2 + T2 <= E2; ) {
          if (x2 += g2, x2 < l2 || x2 >= c2)
            return null;
          if (b2 = y2, C2.push(y2), p2 && S2.push(M2 || I2()), y2 = d2[x2], void 0 === y2) {
            M2 = new e.pointGeometry(h2.getx(x2), h2.gety(x2));
            const t3 = rt(M2, u2, _2);
            y2 = t3.signedDistanceFromCamera > 0 ? d2[x2] = t3.point : D2();
          } else
            M2 = null;
          w2 += T2, T2 = b2.dist(y2);
        }
        m2 && _2 && (M2 = M2 || new e.pointGeometry(h2.getx(x2), h2.gety(x2)), d2[x2] = y2 = void 0 === d2[x2] ? y2 : D2(), T2 = b2.dist(y2));
        const A2 = (E2 - w2) / T2, z2 = y2.sub(b2), P2 = z2.mult(A2)._add(b2);
        o2 && P2._add(z2._unit()._perp()._mult(o2 * g2));
        const L2 = v2 + Math.atan2(y2.y - b2.y, y2.x - b2.x);
        return C2.push(P2), p2 && (M2 = M2 || new e.pointGeometry(h2.getx(x2), h2.gety(x2)), S2.push(function(t3, i3, o3) {
          const r3 = 1 - o3;
          return new e.pointGeometry(t3.x * r3 + i3.x * o3, t3.y * r3 + i3.y * o3);
        }(S2.length > 0 ? S2[S2.length - 1] : M2, M2, A2))), { point: P2, angle: L2, path: C2, tilePath: S2 };
      }
      const st = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
      function lt(e2, t2) {
        for (let i2 = 0; i2 < e2; i2++) {
          const e3 = t2.length;
          t2.resize(e3 + 4), t2.float32.set(st, 3 * e3);
        }
      }
      function ct(e2, t2, i2) {
        const o2 = t2[0], r2 = t2[1];
        return e2[0] = i2[0] * o2 + i2[4] * r2 + i2[12], e2[1] = i2[1] * o2 + i2[5] * r2 + i2[13], e2[3] = i2[3] * o2 + i2[7] * r2 + i2[15], e2;
      }
      const ht = 100;
      class ut {
        constructor(e2, t2, i2 = new $e(e2.width + 200, e2.height + 200, 25), o2 = new $e(e2.width + 200, e2.height + 200, 25)) {
          this.transform = e2, this.grid = i2, this.ignoredGrid = o2, this.pitchfactor = Math.cos(e2._pitch) * e2.cameraToCenterDistance, this.screenRightBoundary = e2.width + ht, this.screenBottomBoundary = e2.height + ht, this.gridRightBoundary = e2.width + 200, this.gridBottomBoundary = e2.height + 200, this.fogState = t2;
        }
        placeCollisionBox(e2, t2, i2, o2, r2, n2, a2) {
          let s2 = t2.projectedAnchorZ;
          t2.elevation && (s2 += t2.elevation);
          const l2 = this.projectAndGetPerspectiveRatio(n2, t2.projectedAnchorX, t2.projectedAnchorY, s2, t2.tileID), c2 = r2 * l2.perspectiveRatio, h2 = (t2.x1 * e2 + i2.x - t2.padding) * c2 + l2.point.x, u2 = (t2.y1 * e2 + i2.y - t2.padding) * c2 + l2.point.y, d2 = (t2.x2 * e2 + i2.x + t2.padding) * c2 + l2.point.x, _2 = (t2.y2 * e2 + i2.y + t2.padding) * c2 + l2.point.y, p2 = l2.perspectiveRatio <= 0.55 || l2.aboveHorizon;
          return !this.isInsideGrid(h2, u2, d2, _2) || !o2 && this.grid.hitTest(h2, u2, d2, _2, a2) || p2 ? { box: [], offscreen: false } : { box: [h2, u2, d2, _2], offscreen: this.isOffscreen(h2, u2, d2, _2) };
        }
        placeCollisionCircles(t2, i2, o2, r2, n2, a2, s2, l2, c2, h2, u2, d2, _2, p2) {
          const m2 = [], f2 = this.transform.elevation, g2 = f2 ? (e2) => f2.getAtTileOffset(p2, e2.x, e2.y) : (e2) => 0, v2 = new e.pointGeometry(i2.tileAnchorX, i2.tileAnchorY), x2 = g2(v2), y2 = this.projectAndGetPerspectiveRatio(a2, v2.x, v2.y, x2, p2), { perspectiveRatio: b2 } = y2, w2 = (h2 ? n2 / b2 : n2 * b2) / e.ONE_EM, T2 = Ye(v2, s2, x2).point, E2 = y2.signedDistanceFromCamera > 0 ? tt(w2, r2, i2.lineOffsetX * w2, i2.lineOffsetY * w2, false, T2, v2, i2, o2, s2, {}, f2 && !h2 ? g2 : null, h2 && !!f2) : null;
          let C2 = false, S2 = false, M2 = true;
          if (E2 && !y2.aboveHorizon) {
            const i3 = 0.5 * d2 * b2 + _2, o3 = new e.pointGeometry(-100, -100), r3 = new e.pointGeometry(this.screenRightBoundary, this.screenBottomBoundary), n3 = new We(), a3 = E2.first, s3 = E2.last;
            let h3 = [];
            for (let e2 = a3.path.length - 1; e2 >= 1; e2--)
              h3.push(a3.path[e2]);
            for (let e2 = 1; e2 < s3.path.length; e2++)
              h3.push(s3.path[e2]);
            const p3 = 2.5 * i3;
            if (l2) {
              const e2 = h3.map(f2 ? (e3, t3) => {
                const i4 = g2(t3 < a3.path.length - 1 ? a3.tilePath[a3.path.length - 1 - t3] : s3.tilePath[t3 - a3.path.length + 2]);
                return Ye(e3, l2, i4);
              } : (e3) => Ye(e3, l2));
              h3 = e2.some((e3) => e3.signedDistanceFromCamera <= 0) ? [] : e2.map((e3) => e3.point);
            }
            let v3 = [];
            if (h3.length > 0) {
              const t3 = h3[0].clone(), i4 = h3[0].clone();
              for (let e2 = 1; e2 < h3.length; e2++)
                t3.x = Math.min(t3.x, h3[e2].x), t3.y = Math.min(t3.y, h3[e2].y), i4.x = Math.max(i4.x, h3[e2].x), i4.y = Math.max(i4.y, h3[e2].y);
              v3 = t3.x >= o3.x && i4.x <= r3.x && t3.y >= o3.y && i4.y <= r3.y ? [h3] : i4.x < o3.x || t3.x > r3.x || i4.y < o3.y || t3.y > r3.y ? [] : e.clipLine([h3], o3.x, o3.y, r3.x, r3.y);
            }
            for (const e2 of v3) {
              n3.reset(e2, 0.25 * i3);
              let o4 = 0;
              o4 = n3.length <= 0.5 * i3 ? 1 : Math.ceil(n3.paddedLength / p3) + 1;
              for (let e3 = 0; e3 < o4; e3++) {
                const r4 = e3 / Math.max(o4 - 1, 1), a4 = n3.lerp(r4), s4 = a4.x + ht, l3 = a4.y + ht;
                m2.push(s4, l3, i3, 0);
                const h4 = s4 - i3, d3 = l3 - i3, _3 = s4 + i3, p4 = l3 + i3;
                if (M2 = M2 && this.isOffscreen(h4, d3, _3, p4), S2 = S2 || this.isInsideGrid(h4, d3, _3, p4), !t2 && this.grid.hitTestCircle(s4, l3, i3, u2) && (C2 = true, !c2))
                  return { circles: [], offscreen: false, collisionDetected: C2 };
              }
            }
          }
          return { circles: !c2 && C2 || !S2 ? [] : m2, offscreen: M2, collisionDetected: C2 };
        }
        queryRenderedSymbols(t2) {
          if (0 === t2.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength())
            return {};
          const i2 = [];
          let o2 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, a2 = -1 / 0;
          for (const s3 of t2) {
            const t3 = new e.pointGeometry(s3.x + ht, s3.y + ht);
            o2 = Math.min(o2, t3.x), r2 = Math.min(r2, t3.y), n2 = Math.max(n2, t3.x), a2 = Math.max(a2, t3.y), i2.push(t3);
          }
          const s2 = this.grid.query(o2, r2, n2, a2).concat(this.ignoredGrid.query(o2, r2, n2, a2)), l2 = {}, c2 = {};
          for (const t3 of s2) {
            const o3 = t3.key;
            if (void 0 === l2[o3.bucketInstanceId] && (l2[o3.bucketInstanceId] = {}), l2[o3.bucketInstanceId][o3.featureIndex])
              continue;
            const r3 = [new e.pointGeometry(t3.x1, t3.y1), new e.pointGeometry(t3.x2, t3.y1), new e.pointGeometry(t3.x2, t3.y2), new e.pointGeometry(t3.x1, t3.y2)];
            e.polygonIntersectsPolygon(i2, r3) && (l2[o3.bucketInstanceId][o3.featureIndex] = true, void 0 === c2[o3.bucketInstanceId] && (c2[o3.bucketInstanceId] = []), c2[o3.bucketInstanceId].push(o3.featureIndex));
          }
          return c2;
        }
        insertCollisionBox(e2, t2, i2, o2, r2) {
          (t2 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: i2, featureIndex: o2, collisionGroupID: r2 }, e2[0], e2[1], e2[2], e2[3]);
        }
        insertCollisionCircles(e2, t2, i2, o2, r2) {
          const n2 = t2 ? this.ignoredGrid : this.grid, a2 = { bucketInstanceId: i2, featureIndex: o2, collisionGroupID: r2 };
          for (let t3 = 0; t3 < e2.length; t3 += 4)
            n2.insertCircle(a2, e2[t3], e2[t3 + 1], e2[t3 + 2]);
        }
        projectAndGetPerspectiveRatio(t2, i2, o2, r2, n2) {
          const a2 = [i2, o2, r2 || 0, 1];
          let s2 = false;
          if (r2 || this.transform.pitch > 0) {
            e.transformMat4(a2, a2, t2);
            let l2 = false;
            this.fogState && n2 && (l2 = function(t3, i3, o3, r3, n3, a3) {
              const s3 = a3.calculateFogTileMatrix(n3), l3 = [i3, o3, r3];
              return e.transformMat4$1(l3, l3, s3), T(t3, l3, a3.pitch, a3._fov);
            }(this.fogState, i2, o2, r2 || 0, n2.toUnwrapped(), this.transform) > 0.9), s2 = a2[2] > a2[3] || l2;
          } else
            ct(a2, a2, t2);
          return { point: new e.pointGeometry((a2[0] / a2[3] + 1) / 2 * this.transform.width + ht, (-a2[1] / a2[3] + 1) / 2 * this.transform.height + ht), perspectiveRatio: Math.min(0.5 + this.transform.cameraToCenterDistance / a2[3] * 0.5, 1.5), signedDistanceFromCamera: a2[3], aboveHorizon: s2 };
        }
        isOffscreen(e2, t2, i2, o2) {
          return i2 < ht || e2 >= this.screenRightBoundary || o2 < ht || t2 > this.screenBottomBoundary;
        }
        isInsideGrid(e2, t2, i2, o2) {
          return i2 >= 0 && e2 < this.gridRightBoundary && o2 >= 0 && t2 < this.gridBottomBoundary;
        }
        getViewportMatrix() {
          const t2 = e.identity([]);
          return e.translate(t2, t2, [-100, -100, 0]), t2;
        }
      }
      class dt {
        constructor(e2, t2, i2, o2) {
          this.opacity = e2 ? Math.max(0, Math.min(1, e2.opacity + (e2.placed ? t2 : -t2))) : o2 && i2 ? 1 : 0, this.placed = i2;
        }
        isHidden() {
          return 0 === this.opacity && !this.placed;
        }
      }
      class _t {
        constructor(e2, t2, i2, o2, r2) {
          this.text = new dt(e2 ? e2.text : null, t2, i2, r2), this.icon = new dt(e2 ? e2.icon : null, t2, o2, r2);
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      }
      class pt {
        constructor(e2, t2, i2) {
          this.text = e2, this.icon = t2, this.skipFade = i2;
        }
      }
      class mt {
        constructor() {
          this.invProjMatrix = e.create$1(), this.viewportMatrix = e.create$1(), this.circles = [];
        }
      }
      class ft {
        constructor(e2, t2, i2, o2, r2) {
          this.bucketInstanceId = e2, this.featureIndex = t2, this.sourceLayerIndex = i2, this.bucketIndex = o2, this.tileID = r2;
        }
      }
      class gt {
        constructor(e2) {
          this.crossSourceCollisions = e2, this.maxGroupID = 0, this.collisionGroups = {};
        }
        get(e2) {
          if (this.crossSourceCollisions)
            return { ID: 0, predicate: null };
          if (!this.collisionGroups[e2]) {
            const t2 = ++this.maxGroupID;
            this.collisionGroups[e2] = { ID: t2, predicate: (e3) => e3.collisionGroupID === t2 };
          }
          return this.collisionGroups[e2];
        }
      }
      function vt(t2, i2, o2, r2, n2) {
        const { horizontalAlign: a2, verticalAlign: s2 } = e.getAnchorAlignment(t2), l2 = -(a2 - 0.5) * i2, c2 = -(s2 - 0.5) * o2, h2 = e.evaluateVariableOffset(t2, r2);
        return new e.pointGeometry(l2 + h2[0] * n2, c2 + h2[1] * n2);
      }
      function xt(t2, i2, o2, r2, n2) {
        const a2 = new e.pointGeometry(t2, i2);
        return o2 && a2._rotate(r2 ? n2 : -n2), a2;
      }
      class yt {
        constructor(e2, t2, i2, o2, r2) {
          this.transform = e2.clone(), this.collisionIndex = new ut(this.transform, r2), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = t2, this.retainedQueryData = {}, this.collisionGroups = new gt(i2), this.collisionCircleArrays = {}, this.prevPlacement = o2, o2 && (o2.prevPlacement = void 0), this.placedOrientations = {};
        }
        getBucketParts(t2, i2, o2, r2) {
          const n2 = o2.getBucket(i2), a2 = o2.latestFeatureIndex;
          if (!n2 || !a2 || i2.id !== n2.layerIds[0])
            return;
          const s2 = o2.collisionBoxArray, l2 = n2.layers[0].layout, c2 = Math.pow(2, this.transform.zoom - o2.tileID.overscaledZ), h2 = o2.tileSize / e.EXTENT, u2 = this.transform.calculateProjMatrix(o2.tileID.toUnwrapped()), d2 = "map" === l2.get("text-pitch-alignment"), _2 = "map" === l2.get("text-rotation-alignment"), p2 = D(o2, 1, this.transform.zoom), m2 = He(u2, d2, _2, this.transform, p2);
          let f2 = null;
          if (d2) {
            const t3 = Ke(u2, d2, _2, this.transform, p2);
            f2 = e.multiply([], this.transform.labelPlaneMatrix, t3);
          }
          this.retainedQueryData[n2.bucketInstanceId] = new ft(n2.bucketInstanceId, a2, n2.sourceLayerIndex, n2.index, o2.tileID);
          const g2 = { bucket: n2, layout: l2, posMatrix: u2, textLabelPlaneMatrix: m2, labelToScreenMatrix: f2, scale: c2, textPixelRatio: h2, holdingForFade: o2.holdingForFade(), collisionBoxArray: s2, partiallyEvaluatedTextSize: e.evaluateSizeForZoom(n2.textSizeData, this.transform.zoom), partiallyEvaluatedIconSize: e.evaluateSizeForZoom(n2.iconSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(n2.sourceID) };
          if (r2)
            for (const e2 of n2.sortKeyRanges) {
              const { sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: r3 } = e2;
              t2.push({ sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: r3, parameters: g2 });
            }
          else
            t2.push({ symbolInstanceStart: 0, symbolInstanceEnd: n2.symbolInstances.length, parameters: g2 });
        }
        attemptAnchorPlacement(e2, t2, i2, o2, r2, n2, a2, s2, l2, c2, h2, u2, d2, _2, p2, m2, f2, g2) {
          const v2 = [u2.textOffset0, u2.textOffset1], x2 = vt(e2, i2, o2, v2, r2), y2 = this.collisionIndex.placeCollisionBox(r2, t2, xt(x2.x, x2.y, n2, a2, this.transform.angle), h2, s2, l2, c2.predicate);
          if ((!m2 || 0 !== this.collisionIndex.placeCollisionBox(_2.getSymbolInstanceIconSize(g2, this.transform.zoom, d2), m2, xt(x2.x, x2.y, n2, a2, this.transform.angle), h2, s2, l2, c2.predicate).box.length) && y2.box.length > 0) {
            let t3;
            return this.prevPlacement && this.prevPlacement.variableOffsets[u2.crossTileID] && this.prevPlacement.placements[u2.crossTileID] && this.prevPlacement.placements[u2.crossTileID].text && (t3 = this.prevPlacement.variableOffsets[u2.crossTileID].anchor), this.variableOffsets[u2.crossTileID] = { textOffset: v2, width: i2, height: o2, anchor: e2, textScale: r2, prevAnchor: t3 }, this.markUsedJustification(_2, e2, u2, p2), _2.allowVerticalPlacement && (this.markUsedOrientation(_2, p2, u2), this.placedOrientations[u2.crossTileID] = p2), { shift: x2, placedGlyphBoxes: y2 };
          }
        }
        placeLayerBucketPart(t2, i2, o2, r2) {
          const { bucket: n2, layout: a2, posMatrix: s2, textLabelPlaneMatrix: l2, labelToScreenMatrix: c2, textPixelRatio: h2, holdingForFade: u2, collisionBoxArray: d2, partiallyEvaluatedTextSize: _2, partiallyEvaluatedIconSize: p2, collisionGroup: m2 } = t2.parameters, f2 = a2.get("text-optional"), g2 = a2.get("icon-optional"), v2 = a2.get("text-allow-overlap"), x2 = a2.get("icon-allow-overlap"), y2 = "map" === a2.get("text-rotation-alignment"), b2 = "map" === a2.get("text-pitch-alignment"), w2 = "none" !== a2.get("icon-text-fit"), T2 = "viewport-y" === a2.get("symbol-z-order"), E2 = v2 && (x2 || !n2.hasIconData() || g2), C2 = x2 && (v2 || !n2.hasTextData() || f2);
          !n2.collisionArrays && d2 && n2.deserializeCollisionBoxes(d2), o2 && r2 && n2.updateCollisionDebugBuffers(this.transform.zoom, d2);
          const S2 = (t3, r3, d3) => {
            if (i2[t3.crossTileID])
              return;
            if (u2)
              return void (this.placements[t3.crossTileID] = new pt(false, false, false));
            let T3 = false, S3 = false, M2 = true, I2 = null, D2 = { box: null, offscreen: null }, A2 = { box: null, offscreen: null }, z2 = null, P2 = null, L2 = null, R2 = 0, k2 = 0, F2 = 0;
            d3.textFeatureIndex ? R2 = d3.textFeatureIndex : t3.useRuntimeCollisionCircles && (R2 = t3.featureIndex), d3.verticalTextFeatureIndex && (k2 = d3.verticalTextFeatureIndex);
            const O2 = (e2) => {
              e2.tileID = this.retainedQueryData[n2.bucketInstanceId].tileID, (this.transform.elevation || e2.elevation) && (e2.elevation = this.transform.elevation ? this.transform.elevation.getAtTileOffset(this.retainedQueryData[n2.bucketInstanceId].tileID, e2.tileAnchorX, e2.tileAnchorY) : 0);
            }, B2 = d3.textBox;
            if (B2) {
              O2(B2);
              const i3 = (i4) => {
                let o4 = e.WritingMode.horizontal;
                if (n2.allowVerticalPlacement && !i4 && this.prevPlacement) {
                  const e2 = this.prevPlacement.placedOrientations[t3.crossTileID];
                  e2 && (this.placedOrientations[t3.crossTileID] = e2, o4 = e2, this.markUsedOrientation(n2, o4, t3));
                }
                return o4;
              }, o3 = (i4, o4) => {
                if (n2.allowVerticalPlacement && t3.numVerticalGlyphVertices > 0 && d3.verticalTextBox) {
                  for (const t4 of n2.writingModes)
                    if (t4 === e.WritingMode.vertical ? (D2 = o4(), A2 = D2) : D2 = i4(), D2 && D2.box && D2.box.length)
                      break;
                } else
                  D2 = i4();
              };
              if (a2.get("text-variable-anchor")) {
                let l3 = a2.get("text-variable-anchor");
                if (this.prevPlacement && this.prevPlacement.variableOffsets[t3.crossTileID]) {
                  const e2 = this.prevPlacement.variableOffsets[t3.crossTileID];
                  l3.indexOf(e2.anchor) > 0 && (l3 = l3.filter((t4) => t4 !== e2.anchor), l3.unshift(e2.anchor));
                }
                const c3 = (e2, i4, o4) => {
                  const a3 = n2.getSymbolInstanceTextSize(_2, t3, this.transform.zoom, r3), c4 = (e2.x2 - e2.x1) * a3 + 2 * e2.padding, u4 = (e2.y2 - e2.y1) * a3 + 2 * e2.padding, d4 = w2 && !x2 ? i4 : null;
                  d4 && O2(d4);
                  let f3 = { box: [], offscreen: false };
                  const g3 = v2 ? 2 * l3.length : l3.length;
                  for (let i5 = 0; i5 < g3; ++i5) {
                    const g4 = this.attemptAnchorPlacement(l3[i5 % l3.length], e2, c4, u4, a3, y2, b2, h2, s2, m2, i5 >= l3.length, t3, r3, n2, o4, d4, _2, p2);
                    if (g4 && (f3 = g4.placedGlyphBoxes, f3 && f3.box && f3.box.length)) {
                      T3 = true, I2 = g4.shift;
                      break;
                    }
                  }
                  return f3;
                };
                o3(() => c3(B2, d3.iconBox, e.WritingMode.horizontal), () => {
                  const i4 = d3.verticalTextBox;
                  return i4 && O2(i4), n2.allowVerticalPlacement && !(D2 && D2.box && D2.box.length) && t3.numVerticalGlyphVertices > 0 && i4 ? c3(i4, d3.verticalIconBox, e.WritingMode.vertical) : { box: null, offscreen: null };
                }), D2 && (T3 = D2.box, M2 = D2.offscreen);
                const u3 = i3(D2 && D2.box);
                if (!T3 && this.prevPlacement) {
                  const e2 = this.prevPlacement.variableOffsets[t3.crossTileID];
                  e2 && (this.variableOffsets[t3.crossTileID] = e2, this.markUsedJustification(n2, e2.anchor, t3, u3));
                }
              } else {
                const a3 = (i4, o4) => {
                  const a4 = n2.getSymbolInstanceTextSize(_2, t3, this.transform.zoom, r3), l3 = this.collisionIndex.placeCollisionBox(a4, i4, new e.pointGeometry(0, 0), v2, h2, s2, m2.predicate);
                  return l3 && l3.box && l3.box.length && (this.markUsedOrientation(n2, o4, t3), this.placedOrientations[t3.crossTileID] = o4), l3;
                };
                o3(() => a3(B2, e.WritingMode.horizontal), () => {
                  const i4 = d3.verticalTextBox;
                  return n2.allowVerticalPlacement && t3.numVerticalGlyphVertices > 0 && i4 ? (O2(i4), a3(i4, e.WritingMode.vertical)) : { box: null, offscreen: null };
                }), i3(D2 && D2.box && D2.box.length);
              }
            }
            if (z2 = D2, T3 = z2 && z2.box && z2.box.length > 0, M2 = z2 && z2.offscreen, t3.useRuntimeCollisionCircles) {
              const i3 = n2.text.placedSymbolArray.get(t3.centerJustifiedTextSymbolIndex >= 0 ? t3.centerJustifiedTextSymbolIndex : t3.verticalPlacedTextSymbolIndex), r4 = e.evaluateSizeForFeature(n2.textSizeData, _2, i3), h3 = a2.get("text-padding");
              P2 = this.collisionIndex.placeCollisionCircles(v2, i3, n2.lineVertexArray, n2.glyphOffsetArray, r4, s2, l2, c2, o2, b2, m2.predicate, t3.collisionCircleDiameter * r4 / e.ONE_EM, h3, this.retainedQueryData[n2.bucketInstanceId].tileID), T3 = v2 || P2.circles.length > 0 && !P2.collisionDetected, M2 = M2 && P2.offscreen;
            }
            if (d3.iconFeatureIndex && (F2 = d3.iconFeatureIndex), d3.iconBox) {
              const t4 = (t5) => {
                O2(t5);
                const i3 = w2 && I2 ? xt(I2.x, I2.y, y2, b2, this.transform.angle) : new e.pointGeometry(0, 0), o3 = n2.getSymbolInstanceIconSize(p2, this.transform.zoom, r3);
                return this.collisionIndex.placeCollisionBox(o3, t5, i3, x2, h2, s2, m2.predicate);
              };
              A2 && A2.box && A2.box.length && d3.verticalIconBox ? (L2 = t4(d3.verticalIconBox), S3 = L2.box.length > 0) : (L2 = t4(d3.iconBox), S3 = L2.box.length > 0), M2 = M2 && L2.offscreen;
            }
            const U2 = f2 || 0 === t3.numHorizontalGlyphVertices && 0 === t3.numVerticalGlyphVertices, N2 = g2 || 0 === t3.numIconVertices;
            if (U2 || N2 ? N2 ? U2 || (S3 = S3 && T3) : T3 = S3 && T3 : S3 = T3 = S3 && T3, T3 && z2 && z2.box && this.collisionIndex.insertCollisionBox(z2.box, a2.get("text-ignore-placement"), n2.bucketInstanceId, A2 && A2.box && k2 ? k2 : R2, m2.ID), S3 && L2 && this.collisionIndex.insertCollisionBox(L2.box, a2.get("icon-ignore-placement"), n2.bucketInstanceId, F2, m2.ID), P2 && (T3 && this.collisionIndex.insertCollisionCircles(P2.circles, a2.get("text-ignore-placement"), n2.bucketInstanceId, R2, m2.ID), o2)) {
              const e2 = n2.bucketInstanceId;
              let t4 = this.collisionCircleArrays[e2];
              void 0 === t4 && (t4 = this.collisionCircleArrays[e2] = new mt());
              for (let e3 = 0; e3 < P2.circles.length; e3 += 4)
                t4.circles.push(P2.circles[e3 + 0]), t4.circles.push(P2.circles[e3 + 1]), t4.circles.push(P2.circles[e3 + 2]), t4.circles.push(P2.collisionDetected ? 1 : 0);
            }
            this.placements[t3.crossTileID] = new pt(T3 || E2, S3 || C2, M2 || n2.justReloaded), i2[t3.crossTileID] = true;
          };
          if (T2) {
            const e2 = n2.getSortedSymbolIndexes(this.transform.angle);
            for (let t3 = e2.length - 1; t3 >= 0; --t3) {
              const i3 = e2[t3];
              S2(n2.symbolInstances.get(i3), i3, n2.collisionArrays[i3]);
            }
          } else
            for (let e2 = t2.symbolInstanceStart; e2 < t2.symbolInstanceEnd; e2++)
              S2(n2.symbolInstances.get(e2), e2, n2.collisionArrays[e2]);
          if (o2 && n2.bucketInstanceId in this.collisionCircleArrays) {
            const t3 = this.collisionCircleArrays[n2.bucketInstanceId];
            e.invert(t3.invProjMatrix, s2), t3.viewportMatrix = this.collisionIndex.getViewportMatrix();
          }
          n2.justReloaded = false;
        }
        markUsedJustification(t2, i2, o2, r2) {
          let n2;
          n2 = r2 === e.WritingMode.vertical ? o2.verticalPlacedTextSymbolIndex : { left: o2.leftJustifiedTextSymbolIndex, center: o2.centerJustifiedTextSymbolIndex, right: o2.rightJustifiedTextSymbolIndex }[e.getAnchorJustification(i2)];
          const a2 = [o2.leftJustifiedTextSymbolIndex, o2.centerJustifiedTextSymbolIndex, o2.rightJustifiedTextSymbolIndex, o2.verticalPlacedTextSymbolIndex];
          for (const e2 of a2)
            e2 >= 0 && (t2.text.placedSymbolArray.get(e2).crossTileID = n2 >= 0 && e2 !== n2 ? 0 : o2.crossTileID);
        }
        markUsedOrientation(t2, i2, o2) {
          const r2 = i2 === e.WritingMode.horizontal || i2 === e.WritingMode.horizontalOnly ? i2 : 0, n2 = i2 === e.WritingMode.vertical ? i2 : 0, a2 = [o2.leftJustifiedTextSymbolIndex, o2.centerJustifiedTextSymbolIndex, o2.rightJustifiedTextSymbolIndex];
          for (const e2 of a2)
            t2.text.placedSymbolArray.get(e2).placedOrientation = r2;
          o2.verticalPlacedTextSymbolIndex && (t2.text.placedSymbolArray.get(o2.verticalPlacedTextSymbolIndex).placedOrientation = n2);
        }
        commit(e2) {
          this.commitTime = e2, this.zoomAtLastRecencyCheck = this.transform.zoom;
          const t2 = this.prevPlacement;
          let i2 = false;
          this.prevZoomAdjustment = t2 ? t2.zoomAdjustment(this.transform.zoom) : 0;
          const o2 = t2 ? t2.symbolFadeChange(e2) : 1, r2 = t2 ? t2.opacities : {}, n2 = t2 ? t2.variableOffsets : {}, a2 = t2 ? t2.placedOrientations : {};
          for (const e3 in this.placements) {
            const t3 = this.placements[e3], n3 = r2[e3];
            n3 ? (this.opacities[e3] = new _t(n3, o2, t3.text, t3.icon), i2 = i2 || t3.text !== n3.text.placed || t3.icon !== n3.icon.placed) : (this.opacities[e3] = new _t(null, o2, t3.text, t3.icon, t3.skipFade), i2 = i2 || t3.text || t3.icon);
          }
          for (const e3 in r2) {
            const t3 = r2[e3];
            if (!this.opacities[e3]) {
              const r3 = new _t(t3, o2, false, false);
              r3.isHidden() || (this.opacities[e3] = r3, i2 = i2 || t3.text.placed || t3.icon.placed);
            }
          }
          for (const e3 in n2)
            this.variableOffsets[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.variableOffsets[e3] = n2[e3]);
          for (const e3 in a2)
            this.placedOrientations[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.placedOrientations[e3] = a2[e3]);
          i2 ? this.lastPlacementChangeTime = e2 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t2 ? t2.lastPlacementChangeTime : e2);
        }
        updateLayerOpacities(e2, t2) {
          const i2 = {};
          for (const o2 of t2) {
            const t3 = o2.getBucket(e2);
            t3 && o2.latestFeatureIndex && e2.id === t3.layerIds[0] && this.updateBucketOpacities(t3, i2, o2.collisionBoxArray);
          }
        }
        updateBucketOpacities(t2, i2, o2) {
          t2.hasTextData() && t2.text.opacityVertexArray.clear(), t2.hasIconData() && t2.icon.opacityVertexArray.clear(), t2.hasIconCollisionBoxData() && t2.iconCollisionBox.collisionVertexArray.clear(), t2.hasTextCollisionBoxData() && t2.textCollisionBox.collisionVertexArray.clear();
          const r2 = t2.layers[0].layout, n2 = new _t(null, 0, false, false, true), a2 = r2.get("text-allow-overlap"), s2 = r2.get("icon-allow-overlap"), l2 = r2.get("text-variable-anchor"), c2 = "map" === r2.get("text-rotation-alignment"), h2 = "map" === r2.get("text-pitch-alignment"), u2 = "none" !== r2.get("icon-text-fit"), d2 = new _t(null, 0, a2 && (s2 || !t2.hasIconData() || r2.get("icon-optional")), s2 && (a2 || !t2.hasTextData() || r2.get("text-optional")), true);
          !t2.collisionArrays && o2 && (t2.hasIconCollisionBoxData() || t2.hasTextCollisionBoxData()) && t2.deserializeCollisionBoxes(o2);
          const _2 = (e2, t3, i3) => {
            for (let o3 = 0; o3 < t3 / 4; o3++)
              e2.opacityVertexArray.emplaceBack(i3);
          };
          for (let o3 = 0; o3 < t2.symbolInstances.length; o3++) {
            const r3 = t2.symbolInstances.get(o3), { numHorizontalGlyphVertices: a3, numVerticalGlyphVertices: s3, crossTileID: p2 } = r3;
            let m2 = this.opacities[p2];
            i2[p2] ? m2 = n2 : m2 || (m2 = d2, this.opacities[p2] = m2), i2[p2] = true;
            const f2 = r3.numIconVertices > 0, g2 = this.placedOrientations[r3.crossTileID], v2 = g2 === e.WritingMode.vertical, x2 = g2 === e.WritingMode.horizontal || g2 === e.WritingMode.horizontalOnly;
            if (a3 > 0 || s3 > 0) {
              const e2 = Dt(m2.text);
              _2(t2.text, a3, v2 ? At : e2), _2(t2.text, s3, x2 ? At : e2);
              const i3 = m2.text.isHidden();
              [r3.rightJustifiedTextSymbolIndex, r3.centerJustifiedTextSymbolIndex, r3.leftJustifiedTextSymbolIndex].forEach((e3) => {
                e3 >= 0 && (t2.text.placedSymbolArray.get(e3).hidden = i3 || v2 ? 1 : 0);
              }), r3.verticalPlacedTextSymbolIndex >= 0 && (t2.text.placedSymbolArray.get(r3.verticalPlacedTextSymbolIndex).hidden = i3 || x2 ? 1 : 0);
              const o4 = this.variableOffsets[r3.crossTileID];
              o4 && this.markUsedJustification(t2, o4.anchor, r3, g2);
              const n3 = this.placedOrientations[r3.crossTileID];
              n3 && (this.markUsedJustification(t2, "left", r3, n3), this.markUsedOrientation(t2, n3, r3));
            }
            if (f2) {
              const e2 = Dt(m2.icon);
              r3.placedIconSymbolIndex >= 0 && (_2(t2.icon, r3.numIconVertices, v2 ? At : e2), t2.icon.placedSymbolArray.get(r3.placedIconSymbolIndex).hidden = m2.icon.isHidden()), r3.verticalPlacedIconSymbolIndex >= 0 && (_2(t2.icon, r3.numVerticalIconVertices, x2 ? At : e2), t2.icon.placedSymbolArray.get(r3.verticalPlacedIconSymbolIndex).hidden = m2.icon.isHidden());
            }
            if (t2.hasIconCollisionBoxData() || t2.hasTextCollisionBoxData()) {
              const i3 = t2.collisionArrays[o3];
              if (i3) {
                let o4 = new e.pointGeometry(0, 0);
                if (i3.textBox || i3.verticalTextBox) {
                  let e2 = true;
                  if (l2) {
                    const t3 = this.variableOffsets[p2];
                    t3 ? (o4 = vt(t3.anchor, t3.width, t3.height, t3.textOffset, t3.textScale), c2 && o4._rotate(h2 ? this.transform.angle : -this.transform.angle)) : e2 = false;
                  }
                  i3.textBox && bt(t2.textCollisionBox.collisionVertexArray, m2.text.placed, !e2 || v2, o4.x, o4.y), i3.verticalTextBox && bt(t2.textCollisionBox.collisionVertexArray, m2.text.placed, !e2 || x2, o4.x, o4.y);
                }
                const r4 = Boolean(!x2 && i3.verticalIconBox);
                i3.iconBox && bt(t2.iconCollisionBox.collisionVertexArray, m2.icon.placed, r4, u2 ? o4.x : 0, u2 ? o4.y : 0), i3.verticalIconBox && bt(t2.iconCollisionBox.collisionVertexArray, m2.icon.placed, !r4, u2 ? o4.x : 0, u2 ? o4.y : 0);
              }
            }
          }
          if (t2.sortFeatures(this.transform.angle), this.retainedQueryData[t2.bucketInstanceId] && (this.retainedQueryData[t2.bucketInstanceId].featureSortOrder = t2.featureSortOrder), t2.hasTextData() && t2.text.opacityVertexBuffer && t2.text.opacityVertexBuffer.updateData(t2.text.opacityVertexArray), t2.hasIconData() && t2.icon.opacityVertexBuffer && t2.icon.opacityVertexBuffer.updateData(t2.icon.opacityVertexArray), t2.hasIconCollisionBoxData() && t2.iconCollisionBox.collisionVertexBuffer && t2.iconCollisionBox.collisionVertexBuffer.updateData(t2.iconCollisionBox.collisionVertexArray), t2.hasTextCollisionBoxData() && t2.textCollisionBox.collisionVertexBuffer && t2.textCollisionBox.collisionVertexBuffer.updateData(t2.textCollisionBox.collisionVertexArray), t2.bucketInstanceId in this.collisionCircleArrays) {
            const e2 = this.collisionCircleArrays[t2.bucketInstanceId];
            t2.placementInvProjMatrix = e2.invProjMatrix, t2.placementViewportMatrix = e2.viewportMatrix, t2.collisionCircleArray = e2.circles, delete this.collisionCircleArrays[t2.bucketInstanceId];
          }
        }
        symbolFadeChange(e2) {
          return 0 === this.fadeDuration ? 1 : (e2 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }
        zoomAdjustment(e2) {
          return Math.max(0, (this.transform.zoom - e2) / 1.5);
        }
        hasTransitions(e2) {
          return this.stale || e2 - this.lastPlacementChangeTime < this.fadeDuration;
        }
        stillRecent(e2, t2) {
          const i2 = this.zoomAtLastRecencyCheck === t2 ? 1 - this.zoomAdjustment(t2) : 1;
          return this.zoomAtLastRecencyCheck = t2, this.commitTime + this.fadeDuration * i2 > e2;
        }
        setStale() {
          this.stale = true;
        }
      }
      function bt(e2, t2, i2, o2, r2) {
        e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r2 || 0), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r2 || 0), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r2 || 0), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r2 || 0);
      }
      const wt = Math.pow(2, 25), Tt = Math.pow(2, 24), Et = Math.pow(2, 17), Ct = Math.pow(2, 16), St = Math.pow(2, 9), Mt = Math.pow(2, 8), It = Math.pow(2, 1);
      function Dt(e2) {
        if (0 === e2.opacity && !e2.placed)
          return 0;
        if (1 === e2.opacity && e2.placed)
          return 4294967295;
        const t2 = e2.placed ? 1 : 0, i2 = Math.floor(127 * e2.opacity);
        return i2 * wt + t2 * Tt + i2 * Et + t2 * Ct + i2 * St + t2 * Mt + i2 * It + t2;
      }
      const At = 0;
      class zt {
        constructor(e2) {
          this._sortAcrossTiles = "viewport-y" !== e2.layout.get("symbol-z-order") && void 0 !== e2.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
        }
        continuePlacement(e2, t2, i2, o2, r2) {
          const n2 = this._bucketParts;
          for (; this._currentTileIndex < e2.length; )
            if (t2.getBucketParts(n2, o2, e2[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r2())
              return true;
          for (this._sortAcrossTiles && (this._sortAcrossTiles = false, n2.sort((e3, t3) => e3.sortKey - t3.sortKey)); this._currentPartIndex < n2.length; ) {
            const e3 = n2[this._currentPartIndex];
            if (t2.placeLayerBucketPart(e3, this._seenCrossTileIDs, i2, 0 === e3.symbolInstanceStart), this._currentPartIndex++, r2())
              return true;
          }
          return false;
        }
      }
      class Pt {
        constructor(e2, t2, i2, o2, r2, n2, a2, s2) {
          this.placement = new yt(e2, r2, n2, a2, s2), this._currentPlacementIndex = t2.length - 1, this._forceFullPlacement = i2, this._showCollisionBoxes = o2, this._done = false;
        }
        isDone() {
          return this._done;
        }
        continuePlacement(t2, i2, o2) {
          const r2 = e.exported.now(), n2 = () => {
            const t3 = e.exported.now() - r2;
            return !this._forceFullPlacement && t3 > 2;
          };
          for (; this._currentPlacementIndex >= 0; ) {
            const e2 = i2[t2[this._currentPlacementIndex]], r3 = this.placement.collisionIndex.transform.zoom;
            if ("symbol" === e2.type && (!e2.minzoom || e2.minzoom <= r3) && (!e2.maxzoom || e2.maxzoom > r3)) {
              if (this._inProgressLayer || (this._inProgressLayer = new zt(e2)), this._inProgressLayer.continuePlacement(o2[e2.source], this.placement, this._showCollisionBoxes, e2, n2))
                return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = true;
        }
        commit(e2) {
          return this.placement.commit(e2), this.placement;
        }
      }
      const Lt = 512 / e.EXTENT / 2;
      class Rt {
        constructor(e2, t2, i2) {
          this.tileID = e2, this.indexedSymbolInstances = {}, this.bucketInstanceId = i2;
          for (let i3 = 0; i3 < t2.length; i3++) {
            const o2 = t2.get(i3), r2 = o2.key;
            this.indexedSymbolInstances[r2] || (this.indexedSymbolInstances[r2] = []), this.indexedSymbolInstances[r2].push({ crossTileID: o2.crossTileID, coord: this.getScaledCoordinates(o2, e2) });
          }
        }
        getScaledCoordinates(t2, i2) {
          const o2 = Lt / Math.pow(2, i2.canonical.z - this.tileID.canonical.z);
          return { x: Math.floor((i2.canonical.x * e.EXTENT + t2.tileAnchorX) * o2), y: Math.floor((i2.canonical.y * e.EXTENT + t2.tileAnchorY) * o2) };
        }
        findMatches(e2, t2, i2) {
          const o2 = this.tileID.canonical.z < t2.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t2.canonical.z);
          for (let r2 = 0; r2 < e2.length; r2++) {
            const n2 = e2.get(r2);
            if (n2.crossTileID)
              continue;
            const a2 = this.indexedSymbolInstances[n2.key];
            if (!a2)
              continue;
            const s2 = this.getScaledCoordinates(n2, t2);
            for (const e3 of a2)
              if (Math.abs(e3.coord.x - s2.x) <= o2 && Math.abs(e3.coord.y - s2.y) <= o2 && !i2[e3.crossTileID]) {
                i2[e3.crossTileID] = true, n2.crossTileID = e3.crossTileID;
                break;
              }
          }
        }
      }
      class kt {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      }
      class Ft {
        constructor() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        }
        handleWrapJump(e2) {
          const t2 = Math.round((e2 - this.lng) / 360);
          if (0 !== t2)
            for (const e3 in this.indexes) {
              const i2 = this.indexes[e3], o2 = {};
              for (const e4 in i2) {
                const r2 = i2[e4];
                r2.tileID = r2.tileID.unwrapTo(r2.tileID.wrap + t2), o2[r2.tileID.key] = r2;
              }
              this.indexes[e3] = o2;
            }
          this.lng = e2;
        }
        addBucket(e2, t2, i2) {
          if (this.indexes[e2.overscaledZ] && this.indexes[e2.overscaledZ][e2.key]) {
            if (this.indexes[e2.overscaledZ][e2.key].bucketInstanceId === t2.bucketInstanceId)
              return false;
            this.removeBucketCrossTileIDs(e2.overscaledZ, this.indexes[e2.overscaledZ][e2.key]);
          }
          for (let e3 = 0; e3 < t2.symbolInstances.length; e3++)
            t2.symbolInstances.get(e3).crossTileID = 0;
          this.usedCrossTileIDs[e2.overscaledZ] || (this.usedCrossTileIDs[e2.overscaledZ] = {});
          const o2 = this.usedCrossTileIDs[e2.overscaledZ];
          for (const i3 in this.indexes) {
            const r2 = this.indexes[i3];
            if (Number(i3) > e2.overscaledZ)
              for (const i4 in r2) {
                const n2 = r2[i4];
                n2.tileID.isChildOf(e2) && n2.findMatches(t2.symbolInstances, e2, o2);
              }
            else {
              const n2 = r2[e2.scaledTo(Number(i3)).key];
              n2 && n2.findMatches(t2.symbolInstances, e2, o2);
            }
          }
          for (let e3 = 0; e3 < t2.symbolInstances.length; e3++) {
            const r2 = t2.symbolInstances.get(e3);
            r2.crossTileID || (r2.crossTileID = i2.generate(), o2[r2.crossTileID] = true);
          }
          return void 0 === this.indexes[e2.overscaledZ] && (this.indexes[e2.overscaledZ] = {}), this.indexes[e2.overscaledZ][e2.key] = new Rt(e2, t2.symbolInstances, t2.bucketInstanceId), true;
        }
        removeBucketCrossTileIDs(e2, t2) {
          for (const i2 in t2.indexedSymbolInstances)
            for (const o2 of t2.indexedSymbolInstances[i2])
              delete this.usedCrossTileIDs[e2][o2.crossTileID];
        }
        removeStaleBuckets(e2) {
          let t2 = false;
          for (const i2 in this.indexes) {
            const o2 = this.indexes[i2];
            for (const r2 in o2)
              e2[o2[r2].bucketInstanceId] || (this.removeBucketCrossTileIDs(i2, o2[r2]), delete o2[r2], t2 = true);
          }
          return t2;
        }
      }
      class Ot {
        constructor() {
          this.layerIndexes = {}, this.crossTileIDs = new kt(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        }
        addLayer(e2, t2, i2) {
          let o2 = this.layerIndexes[e2.id];
          void 0 === o2 && (o2 = this.layerIndexes[e2.id] = new Ft());
          let r2 = false;
          const n2 = {};
          o2.handleWrapJump(i2);
          for (const i3 of t2) {
            const t3 = i3.getBucket(e2);
            t3 && e2.id === t3.layerIds[0] && (t3.bucketInstanceId || (t3.bucketInstanceId = ++this.maxBucketInstanceId), o2.addBucket(i3.tileID, t3, this.crossTileIDs) && (r2 = true), n2[t3.bucketInstanceId] = true);
          }
          return o2.removeStaleBuckets(n2) && (r2 = true), r2;
        }
        pruneUnusedLayers(e2) {
          const t2 = {};
          e2.forEach((e3) => {
            t2[e3] = true;
          });
          for (const e3 in this.layerIndexes)
            t2[e3] || delete this.layerIndexes[e3];
        }
      }
      const Bt = (t2, i2) => e.emitValidationErrors(t2, i2 && i2.filter((e2) => "source.canvas" !== e2.identifier)), Ut = e.pick(Be, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog"]), Nt = e.pick(Be, ["setCenter", "setZoom", "setBearing", "setPitch"]), Gt = function() {
        const t2 = {}, i2 = e.spec.$version;
        for (const o2 in e.spec.$root) {
          const r2 = e.spec.$root[o2];
          if (r2.required) {
            let e2 = null;
            e2 = "version" === o2 ? i2 : "array" === r2.type ? [] : {}, null != e2 && (t2[o2] = e2);
          }
        }
        return t2;
      }(), Zt = { fill: true, line: true, background: true, hillshade: true, raster: true };
      class Vt extends e.Evented {
        constructor(t2, i2 = {}) {
          super(), this.map = t2, this.dispatcher = new I(ke(), this), this.imageManager = new f(), this.imageManager.setEventedParent(this), this.glyphManager = new e.GlyphManager(t2._requestManager, i2.localFontFamily ? e.LocalGlyphMode.all : i2.localIdeographFontFamily ? e.LocalGlyphMode.ideographs : e.LocalGlyphMode.none, i2.localFontFamily || i2.localIdeographFontFamily), this.lineAtlas = new e.LineAtlas(256, 512), this.crossTileSymbolIndex = new Ot(), this._layers = {}, this._num3DLayers = 0, this._numSymbolLayers = 0, this._numCircleLayers = 0, this._serializedLayers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this.zoomHistory = new e.ZoomHistory(), this._loaded = false, this._availableImages = [], this._order = [], this._drapedFirstOrder = [], this._markersNeedUpdate = false, this._resetUpdates(), this.dispatcher.broadcast("setReferrer", e.getReferrer());
          const o2 = this;
          this._rtlTextPluginCallback = Vt.registerForPluginStateChange((t3) => {
            o2.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: t3.pluginStatus, pluginURL: t3.pluginURL }, (t4, i3) => {
              if (e.triggerPluginCompletionEvent(t4), i3 && i3.every((e2) => e2))
                for (const e2 in o2._sourceCaches) {
                  const t5 = o2._sourceCaches[e2], i4 = t5.getSource().type;
                  "vector" !== i4 && "geojson" !== i4 || t5.reload();
                }
            });
          }), this.on("data", (e2) => {
            if ("source" !== e2.dataType || "metadata" !== e2.sourceDataType)
              return;
            const t3 = this.getSource(e2.sourceId);
            if (t3 && t3.vectorLayerIds)
              for (const e3 in this._layers) {
                const i3 = this._layers[e3];
                i3.source === t3.id && this._validateLayer(i3);
              }
          });
        }
        loadURL(t2, i2 = {}) {
          this.fire(new e.Event("dataloading", { dataType: "style" }));
          const o2 = "boolean" == typeof i2.validate ? i2.validate : !e.isMapboxURL(t2);
          t2 = this.map._requestManager.normalizeStyleURL(t2, i2.accessToken);
          const r2 = this.map._requestManager.transformRequest(t2, e.ResourceType.Style);
          this._request = e.getJSON(r2, (t3, i3) => {
            this._request = null, t3 ? this.fire(new e.ErrorEvent(t3)) : i3 && this._load(i3, o2);
          });
        }
        loadJSON(t2, i2 = {}) {
          this.fire(new e.Event("dataloading", { dataType: "style" })), this._request = e.exported.frame(() => {
            this._request = null, this._load(t2, false !== i2.validate);
          });
        }
        loadEmpty() {
          this.fire(new e.Event("dataloading", { dataType: "style" })), this._load(Gt, false);
        }
        _updateLayerCount(e2, t2) {
          const i2 = t2 ? 1 : -1;
          e2.is3D() && (this._num3DLayers += i2), "circle" === e2.type && (this._numCircleLayers += i2), "symbol" === e2.type && (this._numSymbolLayers += i2);
        }
        _load(t2, i2) {
          if (i2 && Bt(this, e.validateStyle(t2)))
            return;
          this._loaded = true, this.stylesheet = t2;
          for (const e2 in t2.sources)
            this.addSource(e2, t2.sources[e2], { validate: false });
          this._changed = false, t2.sprite ? this._loadSprite(t2.sprite) : (this.imageManager.setLoaded(true), this.dispatcher.broadcast("spriteLoaded", true)), this.glyphManager.setURL(t2.glyphs);
          const o2 = Oe(this.stylesheet.layers);
          this._order = o2.map((e2) => e2.id), this._layers = {}, this._serializedLayers = {};
          for (let t3 of o2)
            t3 = e.createStyleLayer(t3), t3.setEventedParent(this, { layer: { id: t3.id } }), this._layers[t3.id] = t3, this._serializedLayers[t3.id] = t3.serialize(), this._updateLayerCount(t3, true);
          this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new x(this.stylesheet.light), this.stylesheet.terrain && this._createTerrain(this.stylesheet.terrain), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this._updateDrapeFirstLayers(), this.fire(new e.Event("data", { dataType: "style" })), this.fire(new e.Event("style.load"));
        }
        _loadSprite(t2) {
          this._spriteRequest = function(t3, i2, o2) {
            let r2, n2, a2;
            const s2 = e.exported.devicePixelRatio > 1 ? "@2x" : "";
            let l2 = e.getJSON(i2.transformRequest(i2.normalizeSpriteURL(t3, s2, ".json"), e.ResourceType.SpriteJSON), (e2, t4) => {
              l2 = null, a2 || (a2 = e2, r2 = t4, h2());
            }), c2 = e.getImage(i2.transformRequest(i2.normalizeSpriteURL(t3, s2, ".png"), e.ResourceType.SpriteImage), (e2, t4) => {
              c2 = null, a2 || (a2 = e2, n2 = t4, h2());
            });
            function h2() {
              if (a2)
                o2(a2);
              else if (r2 && n2) {
                const t4 = e.exported.getImageData(n2), i3 = {};
                for (const o3 in r2) {
                  const { width: n3, height: a3, x: s3, y: l3, sdf: c3, pixelRatio: h3, stretchX: u2, stretchY: d2, content: _2 } = r2[o3], p2 = new e.RGBAImage({ width: n3, height: a3 });
                  e.RGBAImage.copy(t4, p2, { x: s3, y: l3 }, { x: 0, y: 0 }, { width: n3, height: a3 }), i3[o3] = { data: p2, pixelRatio: h3, sdf: c3, stretchX: u2, stretchY: d2, content: _2 };
                }
                o2(null, i3);
              }
            }
            return { cancel() {
              l2 && (l2.cancel(), l2 = null), c2 && (c2.cancel(), c2 = null);
            } };
          }(t2, this.map._requestManager, (t3, i2) => {
            if (this._spriteRequest = null, t3)
              this.fire(new e.ErrorEvent(t3));
            else if (i2)
              for (const e2 in i2)
                this.imageManager.addImage(e2, i2[e2]);
            this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), this.dispatcher.broadcast("setImages", this._availableImages), this.dispatcher.broadcast("spriteLoaded", true), this.fire(new e.Event("data", { dataType: "style" }));
          });
        }
        _validateLayer(t2) {
          const i2 = this.getSource(t2.source);
          if (!i2)
            return;
          const o2 = t2.sourceLayer;
          o2 && ("geojson" === i2.type || i2.vectorLayerIds && -1 === i2.vectorLayerIds.indexOf(o2)) && this.fire(new e.ErrorEvent(new Error(`Source layer "${o2}" does not exist on source "${i2.id}" as specified by style layer "${t2.id}"`)));
        }
        loaded() {
          if (!this._loaded)
            return false;
          if (Object.keys(this._updatedSources).length)
            return false;
          for (const e2 in this._sourceCaches)
            if (!this._sourceCaches[e2].loaded())
              return false;
          return !!this.imageManager.isLoaded();
        }
        _serializeLayers(e2) {
          const t2 = [];
          for (const i2 of e2) {
            const e3 = this._layers[i2];
            "custom" !== e3.type && t2.push(e3.serialize());
          }
          return t2;
        }
        hasTransitions() {
          if (this.light && this.light.hasTransition())
            return true;
          if (this.fog && this.fog.hasTransition())
            return true;
          for (const e2 in this._sourceCaches)
            if (this._sourceCaches[e2].hasTransition())
              return true;
          for (const e2 in this._layers)
            if (this._layers[e2].hasTransition())
              return true;
          return false;
        }
        get order() {
          return this.map._optimizeForTerrain && this.terrain ? this._drapedFirstOrder : this._order;
        }
        isLayerDraped(e2) {
          return !!this.terrain && Zt[e2.type];
        }
        _checkLoaded() {
          if (!this._loaded)
            throw new Error("Style is not done loading");
        }
        update(t2) {
          if (!this._loaded)
            return;
          const i2 = this._changed;
          if (this._changed) {
            const e2 = Object.keys(this._updatedLayers), i3 = Object.keys(this._removedLayers);
            (e2.length || i3.length) && this._updateWorkerLayers(e2, i3);
            for (const e3 in this._updatedSources) {
              const t3 = this._updatedSources[e3];
              "reload" === t3 ? this._reloadSource(e3) : "clear" === t3 && this._clearSource(e3);
            }
            this._updateTilesForChangedImages();
            for (const e3 in this._updatedPaintProps)
              this._layers[e3].updateTransitions(t2);
            this.light.updateTransitions(t2), this.fog && this.fog.updateTransitions(t2), this._resetUpdates();
          }
          const o2 = {};
          for (const e2 in this._sourceCaches) {
            const t3 = this._sourceCaches[e2];
            o2[e2] = t3.used, t3.used = false;
          }
          for (const e2 of this._order) {
            const i3 = this._layers[e2];
            if (i3.recalculate(t2, this._availableImages), !i3.isHidden(t2.zoom)) {
              const e3 = this._getLayerSourceCache(i3);
              e3 && (e3.used = true);
            }
            const o3 = this.map.painter;
            if (o3) {
              const e3 = i3.getProgramIds();
              if (!e3)
                continue;
              const r2 = i3.getProgramConfiguration(t2.zoom);
              for (const t3 of e3)
                o3.useProgram(t3, r2);
            }
          }
          for (const t3 in o2) {
            const i3 = this._sourceCaches[t3];
            o2[t3] !== i3.used && i3.getSource().fire(new e.Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: i3.getSource().id }));
          }
          this.light.recalculate(t2), this.terrain && this.terrain.recalculate(t2), this.fog && this.fog.recalculate(t2), this.z = t2.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = false), i2 && this.fire(new e.Event("data", { dataType: "style" }));
        }
        _updateTilesForChangedImages() {
          const e2 = Object.keys(this._changedImages);
          if (e2.length) {
            for (const t2 in this._sourceCaches)
              this._sourceCaches[t2].reloadTilesForDependencies(["icons", "patterns"], e2);
            this._changedImages = {};
          }
        }
        _updateWorkerLayers(e2, t2) {
          this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(e2), removedIds: t2 });
        }
        _resetUpdates() {
          this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
        }
        setState(t2) {
          if (this._checkLoaded(), Bt(this, e.validateStyle(t2)))
            return false;
          (t2 = e.clone$2(t2)).layers = Oe(t2.layers);
          const i2 = function(e2, t3) {
            if (!e2)
              return [{ command: Be.setStyle, args: [t3] }];
            let i3 = [];
            try {
              if (!r(e2.version, t3.version))
                return [{ command: Be.setStyle, args: [t3] }];
              r(e2.center, t3.center) || i3.push({ command: Be.setCenter, args: [t3.center] }), r(e2.zoom, t3.zoom) || i3.push({ command: Be.setZoom, args: [t3.zoom] }), r(e2.bearing, t3.bearing) || i3.push({ command: Be.setBearing, args: [t3.bearing] }), r(e2.pitch, t3.pitch) || i3.push({ command: Be.setPitch, args: [t3.pitch] }), r(e2.sprite, t3.sprite) || i3.push({ command: Be.setSprite, args: [t3.sprite] }), r(e2.glyphs, t3.glyphs) || i3.push({ command: Be.setGlyphs, args: [t3.glyphs] }), r(e2.transition, t3.transition) || i3.push({ command: Be.setTransition, args: [t3.transition] }), r(e2.light, t3.light) || i3.push({ command: Be.setLight, args: [t3.light] }), r(e2.fog, t3.fog) || i3.push({ command: Be.setFog, args: [t3.fog] });
              const o3 = {}, n2 = [];
              !function(e3, t4, i4, o4) {
                let n3;
                for (n3 in t4 = t4 || {}, e3 = e3 || {})
                  e3.hasOwnProperty(n3) && (t4.hasOwnProperty(n3) || Ne(n3, i4, o4));
                for (n3 in t4)
                  t4.hasOwnProperty(n3) && (e3.hasOwnProperty(n3) ? r(e3[n3], t4[n3]) || ("geojson" === e3[n3].type && "geojson" === t4[n3].type && Ze(e3, t4, n3) ? i4.push({ command: Be.setGeoJSONSourceData, args: [n3, t4[n3].data] }) : Ge(n3, t4, i4, o4)) : Ue(n3, t4, i4));
              }(e2.sources, t3.sources, n2, o3);
              const a2 = [];
              e2.layers && e2.layers.forEach((e3) => {
                o3[e3.source] ? i3.push({ command: Be.removeLayer, args: [e3.id] }) : a2.push(e3);
              });
              let s2 = e2.terrain;
              s2 && o3[s2.source] && (i3.push({ command: Be.setTerrain, args: [void 0] }), s2 = void 0), i3 = i3.concat(n2), r(s2, t3.terrain) || i3.push({ command: Be.setTerrain, args: [t3.terrain] }), function(e3, t4, i4) {
                t4 = t4 || [];
                const o4 = (e3 = e3 || []).map(je), n3 = t4.map(je), a3 = e3.reduce(qe, {}), s3 = t4.reduce(qe, {}), l2 = o4.slice(), c2 = /* @__PURE__ */ Object.create(null);
                let h2, u2, d2, _2, p2, m2, f2;
                for (h2 = 0, u2 = 0; h2 < o4.length; h2++)
                  d2 = o4[h2], s3.hasOwnProperty(d2) ? u2++ : (i4.push({ command: Be.removeLayer, args: [d2] }), l2.splice(l2.indexOf(d2, u2), 1));
                for (h2 = 0, u2 = 0; h2 < n3.length; h2++)
                  d2 = n3[n3.length - 1 - h2], l2[l2.length - 1 - h2] !== d2 && (a3.hasOwnProperty(d2) ? (i4.push({ command: Be.removeLayer, args: [d2] }), l2.splice(l2.lastIndexOf(d2, l2.length - u2), 1)) : u2++, m2 = l2[l2.length - h2], i4.push({ command: Be.addLayer, args: [s3[d2], m2] }), l2.splice(l2.length - h2, 0, d2), c2[d2] = true);
                for (h2 = 0; h2 < n3.length; h2++)
                  if (d2 = n3[h2], _2 = a3[d2], p2 = s3[d2], !c2[d2] && !r(_2, p2))
                    if (r(_2.source, p2.source) && r(_2["source-layer"], p2["source-layer"]) && r(_2.type, p2.type)) {
                      for (f2 in Ve(_2.layout, p2.layout, i4, d2, null, Be.setLayoutProperty), Ve(_2.paint, p2.paint, i4, d2, null, Be.setPaintProperty), r(_2.filter, p2.filter) || i4.push({ command: Be.setFilter, args: [d2, p2.filter] }), r(_2.minzoom, p2.minzoom) && r(_2.maxzoom, p2.maxzoom) || i4.push({ command: Be.setLayerZoomRange, args: [d2, p2.minzoom, p2.maxzoom] }), _2)
                        _2.hasOwnProperty(f2) && "layout" !== f2 && "paint" !== f2 && "filter" !== f2 && "metadata" !== f2 && "minzoom" !== f2 && "maxzoom" !== f2 && (0 === f2.indexOf("paint.") ? Ve(_2[f2], p2[f2], i4, d2, f2.slice(6), Be.setPaintProperty) : r(_2[f2], p2[f2]) || i4.push({ command: Be.setLayerProperty, args: [d2, f2, p2[f2]] }));
                      for (f2 in p2)
                        p2.hasOwnProperty(f2) && !_2.hasOwnProperty(f2) && "layout" !== f2 && "paint" !== f2 && "filter" !== f2 && "metadata" !== f2 && "minzoom" !== f2 && "maxzoom" !== f2 && (0 === f2.indexOf("paint.") ? Ve(_2[f2], p2[f2], i4, d2, f2.slice(6), Be.setPaintProperty) : r(_2[f2], p2[f2]) || i4.push({ command: Be.setLayerProperty, args: [d2, f2, p2[f2]] }));
                    } else
                      i4.push({ command: Be.removeLayer, args: [d2] }), m2 = l2[l2.lastIndexOf(d2) + 1], i4.push({ command: Be.addLayer, args: [p2, m2] });
              }(a2, t3.layers, i3);
            } catch (e3) {
              console.warn("Unable to compute style diff:", e3), i3 = [{ command: Be.setStyle, args: [t3] }];
            }
            return i3;
          }(this.serialize(), t2).filter((e2) => !(e2.command in Nt));
          if (0 === i2.length)
            return false;
          const o2 = i2.filter((e2) => !(e2.command in Ut));
          if (o2.length > 0)
            throw new Error(`Unimplemented: ${o2.map((e2) => e2.command).join(", ")}.`);
          return i2.forEach((e2) => {
            "setTransition" !== e2.command && this[e2.command].apply(this, e2.args);
          }), this.stylesheet = t2, true;
        }
        addImage(t2, i2) {
          if (this.getImage(t2))
            return this.fire(new e.ErrorEvent(new Error("An image with this name already exists.")));
          this.imageManager.addImage(t2, i2), this._afterImageUpdated(t2);
        }
        updateImage(e2, t2) {
          this.imageManager.updateImage(e2, t2);
        }
        getImage(e2) {
          return this.imageManager.getImage(e2);
        }
        removeImage(t2) {
          if (!this.getImage(t2))
            return this.fire(new e.ErrorEvent(new Error("No image with this name exists.")));
          this.imageManager.removeImage(t2), this._afterImageUpdated(t2);
        }
        _afterImageUpdated(t2) {
          this._availableImages = this.imageManager.listImages(), this._changedImages[t2] = true, this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new e.Event("data", { dataType: "style" }));
        }
        listImages() {
          return this._checkLoaded(), this.imageManager.listImages();
        }
        addSource(t2, i2, o2 = {}) {
          if (this._checkLoaded(), void 0 !== this.getSource(t2))
            throw new Error("There is already a source with this ID");
          if (!i2.type)
            throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i2).join(", ")}.`);
          if (["vector", "raster", "geojson", "video", "image"].indexOf(i2.type) >= 0 && this._validate(e.validateStyle.source, `sources.${t2}`, i2, null, o2))
            return;
          this.map && this.map._collectResourceTiming && (i2.collectResourceTiming = true);
          const r2 = Se(t2, i2, this.dispatcher, this);
          r2.setEventedParent(this, () => ({ isSourceLoaded: this.loaded(), source: r2.serialize(), sourceId: t2 }));
          const n2 = (i3) => {
            const o3 = (i3 ? "symbol:" : "other:") + t2, n3 = this._sourceCaches[o3] = new e.SourceCache(o3, r2, i3);
            (i3 ? this._symbolSourceCaches : this._otherSourceCaches)[t2] = n3, n3.style = this, n3.onAdd(this.map);
          };
          n2(false), "vector" !== i2.type && "geojson" !== i2.type || n2(true), r2.onAdd && r2.onAdd(this.map), this._changed = true;
        }
        removeSource(t2) {
          this._checkLoaded();
          const i2 = this.getSource(t2);
          if (void 0 === i2)
            throw new Error("There is no source with this ID");
          for (const i3 in this._layers)
            if (this._layers[i3].source === t2)
              return this.fire(new e.ErrorEvent(new Error(`Source "${t2}" cannot be removed while layer "${i3}" is using it.`)));
          if (this.terrain && this.terrain.get().source === t2)
            return this.fire(new e.ErrorEvent(new Error(`Source "${t2}" cannot be removed while terrain is using it.`)));
          const o2 = this._getSourceCaches(t2);
          for (const t3 of o2)
            delete this._sourceCaches[t3.id], delete this._updatedSources[t3.id], t3.fire(new e.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: t3.getSource().id })), t3.setEventedParent(null), t3.clearTiles();
          delete this._otherSourceCaches[t2], delete this._symbolSourceCaches[t2], i2.setEventedParent(null), i2.onRemove && i2.onRemove(this.map), this._changed = true;
        }
        setGeoJSONSourceData(e2, t2) {
          this._checkLoaded(), this.getSource(e2).setData(t2), this._changed = true;
        }
        getSource(e2) {
          const t2 = this._getSourceCache(e2);
          return t2 && t2.getSource();
        }
        addLayer(t2, i2, o2 = {}) {
          this._checkLoaded();
          const r2 = t2.id;
          if (this.getLayer(r2))
            return void this.fire(new e.ErrorEvent(new Error(`Layer with id "${r2}" already exists on this map`)));
          let n2;
          if ("custom" === t2.type) {
            if (Bt(this, e.validateCustomStyleLayer(t2)))
              return;
            n2 = e.createStyleLayer(t2);
          } else {
            if ("object" == typeof t2.source && (this.addSource(r2, t2.source), t2 = e.clone$2(t2), t2 = e.extend(t2, { source: r2 })), this._validate(e.validateStyle.layer, `layers.${r2}`, t2, { arrayIndex: -1 }, o2))
              return;
            n2 = e.createStyleLayer(t2), this._validateLayer(n2), n2.setEventedParent(this, { layer: { id: r2 } }), this._serializedLayers[n2.id] = n2.serialize(), this._updateLayerCount(n2, true);
          }
          const a2 = i2 ? this._order.indexOf(i2) : this._order.length;
          if (i2 && -1 === a2)
            return void this.fire(new e.ErrorEvent(new Error(`Layer with id "${i2}" does not exist on this map.`)));
          this._order.splice(a2, 0, r2), this._layerOrderChanged = true, this._layers[r2] = n2;
          const s2 = this._getLayerSourceCache(n2);
          if (this._removedLayers[r2] && n2.source && s2 && "custom" !== n2.type) {
            const e2 = this._removedLayers[r2];
            delete this._removedLayers[r2], e2.type !== n2.type ? this._updatedSources[n2.source] = "clear" : (this._updatedSources[n2.source] = "reload", s2.pause());
          }
          this._updateLayer(n2), n2.onAdd && n2.onAdd(this.map), this._updateDrapeFirstLayers();
        }
        moveLayer(t2, i2) {
          if (this._checkLoaded(), this._changed = true, !this._layers[t2])
            return void this.fire(new e.ErrorEvent(new Error(`The layer '${t2}' does not exist in the map's style and cannot be moved.`)));
          if (t2 === i2)
            return;
          const o2 = this._order.indexOf(t2);
          this._order.splice(o2, 1);
          const r2 = i2 ? this._order.indexOf(i2) : this._order.length;
          i2 && -1 === r2 ? this.fire(new e.ErrorEvent(new Error(`Layer with id "${i2}" does not exist on this map.`))) : (this._order.splice(r2, 0, t2), this._layerOrderChanged = true, this._updateDrapeFirstLayers());
        }
        removeLayer(t2) {
          this._checkLoaded();
          const i2 = this._layers[t2];
          if (!i2)
            return void this.fire(new e.ErrorEvent(new Error(`The layer '${t2}' does not exist in the map's style and cannot be removed.`)));
          i2.setEventedParent(null), this._updateLayerCount(i2, false);
          const o2 = this._order.indexOf(t2);
          this._order.splice(o2, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[t2] = i2, delete this._layers[t2], delete this._serializedLayers[t2], delete this._updatedLayers[t2], delete this._updatedPaintProps[t2], i2.onRemove && i2.onRemove(this.map), this._updateDrapeFirstLayers();
        }
        getLayer(e2) {
          return this._layers[e2];
        }
        hasLayer(e2) {
          return e2 in this._layers;
        }
        hasLayerType(e2) {
          for (const t2 in this._layers)
            if (this._layers[t2].type === e2)
              return true;
          return false;
        }
        setLayerZoomRange(t2, i2, o2) {
          this._checkLoaded();
          const r2 = this.getLayer(t2);
          r2 ? r2.minzoom === i2 && r2.maxzoom === o2 || (null != i2 && (r2.minzoom = i2), null != o2 && (r2.maxzoom = o2), this._updateLayer(r2)) : this.fire(new e.ErrorEvent(new Error(`The layer '${t2}' does not exist in the map's style and cannot have zoom extent.`)));
        }
        setFilter(t2, i2, o2 = {}) {
          this._checkLoaded();
          const n2 = this.getLayer(t2);
          if (n2) {
            if (!r(n2.filter, i2))
              return null == i2 ? (n2.filter = void 0, void this._updateLayer(n2)) : void (this._validate(e.validateStyle.filter, `layers.${n2.id}.filter`, i2, null, o2) || (n2.filter = e.clone$2(i2), this._updateLayer(n2)));
          } else
            this.fire(new e.ErrorEvent(new Error(`The layer '${t2}' does not exist in the map's style and cannot be filtered.`)));
        }
        getFilter(t2) {
          return e.clone$2(this.getLayer(t2).filter);
        }
        setLayoutProperty(t2, i2, o2, n2 = {}) {
          this._checkLoaded();
          const a2 = this.getLayer(t2);
          a2 ? r(a2.getLayoutProperty(i2), o2) || (a2.setLayoutProperty(i2, o2, n2), this._updateLayer(a2)) : this.fire(new e.ErrorEvent(new Error(`The layer '${t2}' does not exist in the map's style and cannot be styled.`)));
        }
        getLayoutProperty(t2, i2) {
          const o2 = this.getLayer(t2);
          if (o2)
            return o2.getLayoutProperty(i2);
          this.fire(new e.ErrorEvent(new Error(`The layer '${t2}' does not exist in the map's style.`)));
        }
        setPaintProperty(t2, i2, o2, n2 = {}) {
          this._checkLoaded();
          const a2 = this.getLayer(t2);
          a2 ? r(a2.getPaintProperty(i2), o2) || (a2.setPaintProperty(i2, o2, n2) && this._updateLayer(a2), this._changed = true, this._updatedPaintProps[t2] = true) : this.fire(new e.ErrorEvent(new Error(`The layer '${t2}' does not exist in the map's style and cannot be styled.`)));
        }
        getPaintProperty(e2, t2) {
          return this.getLayer(e2).getPaintProperty(t2);
        }
        setFeatureState(t2, i2) {
          this._checkLoaded();
          const o2 = t2.source, r2 = t2.sourceLayer, n2 = this.getSource(o2);
          if (void 0 === n2)
            return void this.fire(new e.ErrorEvent(new Error(`The source '${o2}' does not exist in the map's style.`)));
          const a2 = n2.type;
          if ("geojson" === a2 && r2)
            return void this.fire(new e.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
          if ("vector" === a2 && !r2)
            return void this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          void 0 === t2.id && this.fire(new e.ErrorEvent(new Error("The feature id parameter must be provided.")));
          const s2 = this._getSourceCaches(o2);
          for (const e2 of s2)
            e2.setFeatureState(r2, t2.id, i2);
        }
        removeFeatureState(t2, i2) {
          this._checkLoaded();
          const o2 = t2.source, r2 = this.getSource(o2);
          if (void 0 === r2)
            return void this.fire(new e.ErrorEvent(new Error(`The source '${o2}' does not exist in the map's style.`)));
          const n2 = r2.type, a2 = "vector" === n2 ? t2.sourceLayer : void 0;
          if ("vector" === n2 && !a2)
            return void this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          if (i2 && "string" != typeof t2.id && "number" != typeof t2.id)
            return void this.fire(new e.ErrorEvent(new Error("A feature id is required to remove its specific state property.")));
          const s2 = this._getSourceCaches(o2);
          for (const e2 of s2)
            e2.removeFeatureState(a2, t2.id, i2);
        }
        getFeatureState(t2) {
          this._checkLoaded();
          const i2 = t2.source, o2 = t2.sourceLayer, r2 = this.getSource(i2);
          if (void 0 !== r2) {
            if ("vector" !== r2.type || o2)
              return void 0 === t2.id && this.fire(new e.ErrorEvent(new Error("The feature id parameter must be provided."))), this._getSourceCaches(i2)[0].getFeatureState(o2, t2.id);
            this.fire(new e.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
          } else
            this.fire(new e.ErrorEvent(new Error(`The source '${i2}' does not exist in the map's style.`)));
        }
        getTransition() {
          return e.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
        }
        serialize() {
          const t2 = {};
          for (const e2 in this._sourceCaches) {
            const i2 = this._sourceCaches[e2].getSource();
            t2[i2.id] || (t2[i2.id] = i2.serialize());
          }
          return e.filterObject({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, terrain: this.stylesheet.terrain, fog: this.stylesheet.fog, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, sources: t2, layers: this._serializeLayers(this._order) }, (e2) => void 0 !== e2);
        }
        _updateLayer(e2) {
          this._updatedLayers[e2.id] = true;
          const t2 = this._getLayerSourceCache(e2);
          e2.source && !this._updatedSources[e2.source] && t2 && "raster" !== t2.getSource().type && (this._updatedSources[e2.source] = "reload", t2.pause()), this._changed = true;
        }
        _flattenAndSortRenderedFeatures(e2) {
          const t2 = (e3) => "fill-extrusion" === this._layers[e3].type, i2 = {}, o2 = [];
          for (let r3 = this._order.length - 1; r3 >= 0; r3--) {
            const n2 = this._order[r3];
            if (t2(n2)) {
              i2[n2] = r3;
              for (const t3 of e2) {
                const e3 = t3[n2];
                if (e3)
                  for (const t4 of e3)
                    o2.push(t4);
              }
            }
          }
          o2.sort((e3, t3) => t3.intersectionZ - e3.intersectionZ);
          const r2 = [];
          for (let n2 = this._order.length - 1; n2 >= 0; n2--) {
            const a2 = this._order[n2];
            if (t2(a2))
              for (let e3 = o2.length - 1; e3 >= 0; e3--) {
                const t3 = o2[e3].feature;
                if (i2[t3.layer.id] < n2)
                  break;
                r2.push(t3), o2.pop();
              }
            else
              for (const t3 of e2) {
                const e3 = t3[a2];
                if (e3)
                  for (const t4 of e3)
                    r2.push(t4.feature);
              }
          }
          return r2;
        }
        queryRenderedFeatures(t2, i2, o2) {
          i2 && i2.filter && this._validate(e.validateStyle.filter, "queryRenderedFeatures.filter", i2.filter, null, i2);
          const r2 = {};
          if (i2 && i2.layers) {
            if (!Array.isArray(i2.layers))
              return this.fire(new e.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
            for (const t3 of i2.layers) {
              const i3 = this._layers[t3];
              if (!i3)
                return this.fire(new e.ErrorEvent(new Error(`The layer '${t3}' does not exist in the map's style and cannot be queried for features.`))), [];
              r2[i3.source] = true;
            }
          }
          const n2 = [];
          i2.availableImages = this._availableImages;
          const a2 = i2 && i2.layers ? i2.layers.some((e2) => {
            const t3 = this.getLayer(e2);
            return t3 && t3.is3D();
          }) : this.has3DLayers(), s2 = A.createFromScreenPoints(t2, o2);
          for (const e2 in this._sourceCaches) {
            const t3 = this._sourceCaches[e2].getSource().id;
            i2.layers && !r2[t3] || n2.push(Ie(this._sourceCaches[e2], this._layers, this._serializedLayers, s2, i2, o2, a2, !!this.map._showQueryGeometry));
          }
          return this.placement && n2.push(function(e2, t3, i3, o3, r3, n3, a3) {
            const s3 = {}, l2 = n3.queryRenderedSymbols(o3), c2 = [];
            for (const e3 of Object.keys(l2).map(Number))
              c2.push(a3[e3]);
            c2.sort(Ae);
            for (const i4 of c2) {
              const o4 = i4.featureIndex.lookupSymbolFeatures(l2[i4.bucketInstanceId], t3, i4.bucketIndex, i4.sourceLayerIndex, r3.filter, r3.layers, r3.availableImages, e2);
              for (const e3 in o4) {
                const t4 = s3[e3] = s3[e3] || [], r4 = o4[e3];
                r4.sort((e4, t5) => {
                  const o5 = i4.featureSortOrder;
                  if (o5) {
                    const i5 = o5.indexOf(e4.featureIndex);
                    return o5.indexOf(t5.featureIndex) - i5;
                  }
                  return t5.featureIndex - e4.featureIndex;
                });
                for (const e4 of r4)
                  t4.push(e4);
              }
            }
            for (const t4 in s3)
              s3[t4].forEach((o4) => {
                const r4 = o4.feature, n4 = i3(e2[t4]).getFeatureState(r4.layer["source-layer"], r4.id);
                r4.source = r4.layer.source, r4.layer["source-layer"] && (r4.sourceLayer = r4.layer["source-layer"]), r4.state = n4;
              });
            return s3;
          }(this._layers, this._serializedLayers, this._getLayerSourceCache.bind(this), s2.screenGeometry, i2, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(n2);
        }
        querySourceFeatures(t2, i2) {
          i2 && i2.filter && this._validate(e.validateStyle.filter, "querySourceFeatures.filter", i2.filter, null, i2);
          const o2 = this._getSourceCaches(t2);
          let r2 = [];
          for (const e2 of o2)
            r2 = r2.concat(De(e2, i2));
          return r2;
        }
        addSourceType(e2, t2, i2) {
          return Vt.getSourceType(e2) ? i2(new Error(`A source type called "${e2}" already exists.`)) : (Vt.setSourceType(e2, t2), t2.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: e2, url: t2.workerSourceURL }, i2) : i2(null, null));
        }
        getLight() {
          return this.light.getLight();
        }
        setLight(t2, i2 = {}) {
          this._checkLoaded();
          const o2 = this.light.getLight();
          let n2 = false;
          for (const e2 in t2)
            if (!r(t2[e2], o2[e2])) {
              n2 = true;
              break;
            }
          if (!n2)
            return;
          const a2 = { now: e.exported.now(), transition: e.extend({ duration: 300, delay: 0 }, this.stylesheet.transition) };
          this.light.setLight(t2, i2), this.light.updateTransitions(a2);
        }
        getTerrain() {
          return this.terrain ? this.terrain.get() : null;
        }
        setTerrain(t2) {
          if (this._checkLoaded(), !t2)
            return delete this.terrain, delete this.stylesheet.terrain, this.dispatcher.broadcast("enableTerrain", false), this._force3DLayerUpdate(), void (this._markersNeedUpdate = true);
          if ("object" == typeof t2.source) {
            const i2 = "terrain-dem-src";
            this.addSource(i2, t2.source), t2 = e.clone$2(t2), t2 = e.extend(t2, { source: i2 });
          }
          if (!this._validate(e.validateStyle.terrain, "terrain", t2)) {
            if (this.terrain) {
              const i2 = this.terrain, o2 = i2.get();
              for (const n2 in t2)
                if (!r(t2[n2], o2[n2])) {
                  i2.set(t2), this.stylesheet.terrain = t2;
                  const o3 = { now: e.exported.now(), transition: e.extend({ duration: 0 }, this.stylesheet.transition) };
                  i2.updateTransitions(o3);
                  break;
                }
            } else
              this._createTerrain(t2);
            this._updateDrapeFirstLayers(), this._markersNeedUpdate = true;
          }
        }
        _createFog(t2) {
          const i2 = this.fog = new M(t2);
          this.stylesheet.fog = t2;
          const o2 = { now: e.exported.now(), transition: e.extend({ duration: 0 }, this.stylesheet.transition) };
          i2.updateTransitions(o2);
        }
        _updateMarkersOpacity() {
          0 !== this.map._markers.length && this.map._requestDomTask(() => {
            for (const e2 of this.map._markers)
              e2._evaluateOpacity();
          });
        }
        getFog() {
          return this.fog ? this.fog.get() : null;
        }
        setFog(t2) {
          if (this._checkLoaded(), !t2)
            return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = true);
          if (this.fog) {
            const i2 = this.fog, o2 = i2.get();
            for (const n2 in t2)
              if (!r(t2[n2], o2[n2])) {
                i2.set(t2), this.stylesheet.fog = t2;
                const o3 = { now: e.exported.now(), transition: e.extend({ duration: 0 }, this.stylesheet.transition) };
                i2.updateTransitions(o3);
                break;
              }
          } else
            this._createFog(t2);
          this._markersNeedUpdate = true;
        }
        _updateDrapeFirstLayers() {
          if (!this.map._optimizeForTerrain || !this.terrain)
            return;
          const e2 = this._order.filter((e3) => this.isLayerDraped(this._layers[e3])), t2 = this._order.filter((e3) => !this.isLayerDraped(this._layers[e3]));
          this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e2), this._drapedFirstOrder.push(...t2);
        }
        _createTerrain(t2) {
          const i2 = this.terrain = new w(t2);
          this.stylesheet.terrain = t2, this.dispatcher.broadcast("enableTerrain", true), this._force3DLayerUpdate();
          const o2 = { now: e.exported.now(), transition: e.extend({ duration: 0 }, this.stylesheet.transition) };
          i2.updateTransitions(o2);
        }
        _force3DLayerUpdate() {
          for (const e2 in this._layers) {
            const t2 = this._layers[e2];
            "fill-extrusion" === t2.type && this._updateLayer(t2);
          }
        }
        _validate(t2, i2, o2, r2, n2 = {}) {
          return (!n2 || false !== n2.validate) && Bt(this, t2.call(e.validateStyle, e.extend({ key: i2, style: this.serialize(), value: o2, styleSpec: e.spec }, r2)));
        }
        _remove() {
          this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e.evented.off("pluginStateChange", this._rtlTextPluginCallback);
          for (const e2 in this._layers)
            this._layers[e2].setEventedParent(null);
          for (const e2 in this._sourceCaches)
            this._sourceCaches[e2].clearTiles(), this._sourceCaches[e2].setEventedParent(null);
          this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
        }
        _clearSource(e2) {
          const t2 = this._getSourceCaches(e2);
          for (const e3 of t2)
            e3.clearTiles();
        }
        _reloadSource(e2) {
          const t2 = this._getSourceCaches(e2);
          for (const e3 of t2)
            e3.resume(), e3.reload();
        }
        _updateSources(e2) {
          for (const t2 in this._sourceCaches)
            this._sourceCaches[t2].update(e2);
        }
        _generateCollisionBoxes() {
          for (const e2 in this._sourceCaches) {
            const t2 = this._sourceCaches[e2];
            t2.resume(), t2.reload();
          }
        }
        _updatePlacement(t2, i2, o2, r2, n2 = false) {
          let a2 = false, s2 = false;
          const l2 = {};
          for (const e2 of this._order) {
            const i3 = this._layers[e2];
            if ("symbol" !== i3.type)
              continue;
            if (!l2[i3.source]) {
              const e3 = this._getLayerSourceCache(i3);
              if (!e3)
                continue;
              l2[i3.source] = e3.getRenderableIds(true).map((t3) => e3.getTileByID(t3)).sort((e4, t3) => t3.tileID.overscaledZ - e4.tileID.overscaledZ || (e4.tileID.isLessThan(t3.tileID) ? -1 : 1));
            }
            const o3 = this.crossTileSymbolIndex.addLayer(i3, l2[i3.source], t2.center.lng);
            a2 = a2 || o3;
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), n2 = n2 || this._layerOrderChanged || 0 === o2, this._layerOrderChanged && this.fire(new e.Event("neworder")), (n2 || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e.exported.now(), t2.zoom)) && (this.pauseablePlacement = new Pt(t2, this._order, n2, i2, o2, r2, this.placement, this.fog ? this.fog.state : null), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l2), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e.exported.now()), s2 = true), a2 && this.pauseablePlacement.placement.setStale()), s2 || a2)
            for (const e2 of this._order) {
              const t3 = this._layers[e2];
              "symbol" === t3.type && this.placement.updateLayerOpacities(t3, l2[t3.source]);
            }
          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e.exported.now());
        }
        _releaseSymbolFadeTiles() {
          for (const e2 in this._sourceCaches)
            this._sourceCaches[e2].releaseSymbolFadeTiles();
        }
        getImages(e2, t2, i2) {
          this.imageManager.getImages(t2.icons, i2), this._updateTilesForChangedImages();
          const o2 = (e3) => {
            e3 && e3.setDependencies(t2.tileID.key, t2.type, t2.icons);
          };
          o2(this._otherSourceCaches[t2.source]), o2(this._symbolSourceCaches[t2.source]);
        }
        getGlyphs(e2, t2, i2) {
          this.glyphManager.getGlyphs(t2.stacks, i2);
        }
        getResource(t2, i2, o2) {
          return e.makeRequest(i2, o2);
        }
        _getSourceCache(e2) {
          return this._otherSourceCaches[e2];
        }
        _getLayerSourceCache(e2) {
          return "symbol" === e2.type ? this._symbolSourceCaches[e2.source] : this._otherSourceCaches[e2.source];
        }
        _getSourceCaches(e2) {
          const t2 = [];
          return this._otherSourceCaches[e2] && t2.push(this._otherSourceCaches[e2]), this._symbolSourceCaches[e2] && t2.push(this._symbolSourceCaches[e2]), t2;
        }
        has3DLayers() {
          return this._num3DLayers > 0;
        }
        hasSymbolLayers() {
          return this._numSymbolLayers > 0;
        }
        hasCircleLayers() {
          return this._numCircleLayers > 0;
        }
      }
      Vt.getSourceType = function(e2) {
        return Ce[e2];
      }, Vt.setSourceType = function(e2, t2) {
        Ce[e2] = t2;
      }, Vt.registerForPluginStateChange = e.registerForPluginStateChange;
      var jt = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;varying vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}\n#endif", qt = "attribute highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;varying highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}";
      let Wt = {}, $t = {};
      Wt = Yt("", "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef TERRAIN\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;\n#else\nuniform sampler2D u_dem;uniform sampler2D u_dem_prev;\n#endif\nuniform vec4 u_dem_unpack;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec3 elevationVector(vec2 pos) {vec2 uv=pos/8192.0;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float decodeElevation(vec4 v) {return dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem,pos));\n#ifdef TERRAIN_DEM_NEAREST_FILTER\nreturn u_exaggeration*tl;\n#endif\nfloat tr=decodeElevation(texture2D(u_dem,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem_prev,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem_prev,pos));float tr=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem_prev,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {float nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {return currentElevation(apos);}\n#endif\nfloat unpack_depth(vec4 rgba_depth)\n{const vec4 bit_shift=vec4(1.0/(256.0*256.0*256.0),1.0/(256.0*256.0),1.0/256.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\nunpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nfloat tl=texture2D(u_dem,pos).a;float tr=texture2D(u_dem,pos+vec2(off.x,0.0)).a;float bl=texture2D(u_dem,pos+vec2(0.0,off.y)).a;float br=texture2D(u_dem,pos+off).a;\n#else\nvec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);float tl=dot(demtl,u_dem_unpack);vec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);float tr=dot(demtr,u_dem_unpack);vec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);float bl=dot(dembl,u_dem_unpack);vec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);float br=dot(dembr,u_dem_unpack);\n#endif\nreturn vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;vec4 bounds=vec4(d,vec2(1.0)-d);h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }vec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif", true), $t = Yt("#ifdef FOG\nuniform float u_fog_temporal_offset;float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);return mix(color,u_fog_color.rgb,opacity);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec3 fog_dither(vec3 color) {vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif", "#ifdef FOG\nuniform mat4 u_fog_matrix;vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif", true);
      const Xt = Yt("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nhighp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}\n#ifdef TERRAIN\nhighp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(256.0*256.0*256.0,256.0*256.0,256.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/256.0,1.0/256.0,1.0/256.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\n#endif", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered."), Ht = jt;
      var Kt = { background: Yt("uniform vec4 u_color;uniform float u_opacity;void main() {vec4 out_color=u_color;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), backgroundPattern: Yt("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 out_color=mix(color1,color2,u_mix);\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), circle: Yt("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\ngl_FragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float height=circle_elevation(circle_center);vec4 world_center=vec4(circle_center,height,1);vec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);vec4 occlusion_world_center=vec4(circle_center,cantilevered_height,1);vec4 occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nvec4 occlusion_world_center=world_center;vec4 occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}"), clippingMask: Yt("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: Yt("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\ngl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec3 pos=vec3(floor(a_pos*0.5)+extrude,elevation(floor(a_pos*0.5)));gl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), heatmapTexture: Yt("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"), collisionBox: Yt("varying float v_placed;varying float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;gl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", "attribute vec3 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;attribute float a_size_scale;attribute vec2 a_padding;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*elevation(a_anchor_pos),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: Yt("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos_2f;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: Yt("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);}"), fill: Yt("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillOutline: Yt("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillOutlinePattern: Yt("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=mix(color1,color2,u_fade);\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillPattern: Yt("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 out_color=mix(color1,color2,u_fade);\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), fillExtrusion: Yt("varying vec4 v_color;void main() {vec4 color=v_color;\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;varying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;float ele=elevation(pos_nx.xy);float c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;float h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);vec3 pos=vec3(pos_nx.xy,h);\n#else\nvec3 pos=vec3(pos_nx.xy,t > 0.0 ? height : base);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.rgb+=clamp(color.rgb*directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), fillExtrusionPattern: Yt("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 out_color=mix(color1,color2,u_fade);out_color=out_color*v_lighting;\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;float ele=elevation(pos_nx.xy);float c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;float h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);vec3 p=vec3(pos_nx.xy,h);\n#else\nvec3 p=vec3(pos_nx.xy,z);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}"), hillshadePrepare: Yt("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nreturn texture2D(u_image,coord).a/4.0;\n#else\nvec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;\n#endif\n}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos);float f=getElevation(v_pos+vec2(epsilon.x,0));float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float h=getElevation(v_pos+vec2(0,epsilon.y));float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Yt("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef FOG\ngl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), line: Yt("uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;uniform float u_mix;uniform vec3 u_scale;varying vec2 v_tex_a;varying vec2 v_tex_b;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;varying highp vec2 v_uv;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash_from\n#pragma mapbox: define lowp vec4 dash_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash_from\n#pragma mapbox: initialize lowp vec4 dash_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist_a=texture2D(u_dash_image,v_tex_a).a;float sdfdist_b=texture2D(u_dash_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);float sdfwidth=min(dash_from.z*u_scale.y,dash_to.z*u_scale.z);float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/sdfwidth;alpha*=smoothstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\n#ifdef RENDER_LINE_GRADIENT\nvec4 out_color=texture2D(u_gradient_image,v_uv);\n#else\nvec4 out_color=color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define EXTRUDE_SCALE 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;\n#ifdef RENDER_LINE_GRADIENT\nattribute vec3 a_packed;\n#else\nattribute float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform mediump vec3 u_scale;varying vec2 v_tex_a;varying vec2 v_tex_b;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;varying highp vec2 v_uv;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash_from\n#pragma mapbox: define lowp vec4 dash_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash_from\n#pragma mapbox: initialize lowp vec4 dash_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];float a_linesofar=a_packed[2];highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);\n#endif\n#ifdef RENDER_LINE_DASH\nfloat tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;float scaleA=dash_from.z==0.0 ? 0.0 : tileZoomRatio/(dash_from.z*fromScale);float scaleB=dash_to.z==0.0 ? 0.0 : tileZoomRatio/(dash_to.z*toScale);float heightA=dash_from.y;float heightB=dash_to.y;v_tex_a=vec2(a_linesofar*scaleA/floorwidth,(-normal.y*heightA+dash_from.x+0.5)/u_texsize.y);v_tex_b=vec2(a_linesofar*scaleB/floorwidth,(-normal.y*heightB+dash_to.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), linePattern: Yt("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"), raster: Yt("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef FOG\nout_color=fog_dither(fog_apply(out_color,v_fog_pos));\n#endif\ngl_FragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"), symbolIcon: Yt("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_z_tile_anchor;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}float anchorZ=a_z_tile_anchor.x;vec2 tileAnchor=a_z_tile_anchor.yz;vec3 h=elevationVector(tileAnchor)*elevation(tileAnchor);vec4 projectedPoint=u_matrix*vec4(vec3(a_pos,anchorZ)+h,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),anchorZ,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}\n#ifdef PROJECTED_POS_ON_VIEWPORT\nvec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);\n#else\nvec4 projected_pos=u_label_plane_matrix*vec4(vec3(a_projected_pos.xy,anchorZ)+h,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0);\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\nfloat occlusion_fade=occlusionFade(projectedPoint);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projectedPoint.w <=0.0 || occlusion_fade==0.0));v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));}"), symbolSDF: Yt("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_z_tile_anchor;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}float anchorZ=a_z_tile_anchor.x;vec2 tileAnchor=a_z_tile_anchor.yz;vec3 h=elevationVector(tileAnchor)*elevation(tileAnchor);vec4 projectedPoint=u_matrix*vec4(vec3(a_pos,anchorZ)+h,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),anchorZ,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}\n#ifdef PROJECTED_POS_ON_VIEWPORT\nvec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);\n#else\nvec4 projected_pos=u_label_plane_matrix*vec4(vec3(a_projected_pos.xy,anchorZ)+h,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\nfloat occlusion_fade=occlusionFade(projectedPoint);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projectedPoint.w <=0.0 || occlusion_fade==0.0));float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"), symbolTextAndIcon: Yt("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_z_tile_anchor;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}float anchorZ=a_z_tile_anchor.x;vec2 tileAnchor=a_z_tile_anchor.yz;vec3 h=elevationVector(tileAnchor)*elevation(tileAnchor);vec4 projectedPoint=u_matrix*vec4(vec3(a_pos,anchorZ)+h,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),anchorZ,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}\n#ifdef PROJECTED_POS_ON_VIEWPORT\nvec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);\n#else\nvec4 projected_pos=u_label_plane_matrix*vec4(vec3(a_projected_pos.xy,anchorZ)+h,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale);\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\nfloat occlusion_fade=occlusionFade(projectedPoint);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projectedPoint.w <=0.0 || occlusion_fade==0.0));float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}"), terrainRaster: Yt("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\nvoid main() {vec4 color=texture2D(u_image0,v_pos0);\n#ifdef FOG\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_skirt_height;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\nconst float skirtOffset=24575.0;const float wireframeOffset=0.00015;void main() {v_pos0=a_texture_pos/8192.0;float skirt=float(a_pos.x >=skirtOffset);float elevation=elevation(a_texture_pos)-skirt*u_skirt_height;\n#ifdef TERRAIN_WIREFRAME\nelevation+=u_skirt_height*u_skirt_height*wireframeOffset;\n#endif\nvec2 decodedPos=a_pos-vec2(skirt*skirtOffset,0.0);gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n}"), terrainDepth: Yt("#ifdef GL_ES\nprecision highp float;\n#endif\nvarying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying float v_depth;void main() {float elevation=elevation(a_texture_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}"), skybox: Yt("\nvarying lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=textureCube(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);gl_FragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", qt), skyboxGradient: Yt("varying highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture2D(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", qt), skyboxCapture: Yt("\nvarying highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;\n#ifdef GL_ES\nprecision highp float;\n#endif\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}", "attribute highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"), globeRaster: Yt("uniform sampler2D u_image0;varying vec2 v_pos0;void main() {vec4 color=texture2D(u_image0,v_pos0);gl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_globe_matrix;attribute vec3 a_globe_pos;attribute vec2 a_uv;varying vec2 v_pos0;void main() {v_pos0=a_uv;gl_Position=u_globe_matrix*vec4(a_globe_pos+elevationVector(a_uv*8192.0)*elevation(a_uv*8192.0),1.0);}"), globeAtmosphere: Yt("uniform vec2 u_center;uniform float u_radius;uniform vec2 u_screen_size;uniform float u_opacity;uniform float u_fadeout_range;uniform vec3 u_start_color;uniform vec3 u_end_color;uniform float u_pixel_ratio;void main() {vec2 fragCoord=gl_FragCoord.xy/u_pixel_ratio;fragCoord.y=u_screen_size.y-fragCoord.y;float distFromCenter=length(fragCoord-u_center);float normDistFromCenter=length(fragCoord-u_center)/u_radius;if (normDistFromCenter < 1.0)\ndiscard;float t=clamp(1.0-sqrt(normDistFromCenter-1.0)/u_fadeout_range,0.0,1.0);vec3 color=mix(u_start_color,u_end_color,1.0-t);gl_FragColor=vec4(color*t*u_opacity,u_opacity);}", "attribute vec3 a_pos;void main() {gl_Position=vec4(a_pos,1.0);}"), globeDepth: Yt("#ifdef GL_ES\nprecision highp float;\n#endif\nvarying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}", "uniform mat4 u_globe_matrix;attribute vec3 a_globe_pos;attribute vec2 a_uv;varying float v_depth;void main() {gl_Position=u_globe_matrix*vec4(a_globe_pos+elevationVector(a_uv*8192.0)*elevation(a_uv*8192.0),1.0);v_depth=gl_Position.z/gl_Position.w;}") };
      function Yt(e2, t2, i2) {
        const o2 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, r2 = /uniform (highp |mediump |lowp )?([\w]+) ([\w]+)([\s]*)([\w]*)/g, n2 = t2.match(/attribute (highp |mediump |lowp )?([\w]+) ([\w]+)/g), a2 = e2.match(r2), s2 = t2.match(r2), l2 = jt.match(r2);
        let c2 = s2 ? s2.concat(a2) : a2;
        i2 || (Wt.staticUniforms && (c2 = Wt.staticUniforms.concat(c2)), $t.staticUniforms && (c2 = $t.staticUniforms.concat(c2))), c2 && (c2 = c2.concat(l2));
        const h2 = {};
        return { fragmentSource: e2 = e2.replace(o2, (e3, t3, i3, o3, r3) => (h2[r3] = true, "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${r3}
varying ${i3} ${o3} ${r3};
#else
uniform ${i3} ${o3} u_${r3};
#endif
` : `
#ifdef HAS_UNIFORM_u_${r3}
    ${i3} ${o3} ${r3} = u_${r3};
#endif
`)), vertexSource: t2 = t2.replace(o2, (e3, t3, i3, o3, r3) => {
          const n3 = "float" === o3 ? "vec2" : "vec4", a3 = r3.match(/color/) ? "color" : n3;
          return h2[r3] ? "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${r3}
uniform lowp float u_${r3}_t;
attribute ${i3} ${n3} a_${r3};
varying ${i3} ${o3} ${r3};
#else
uniform ${i3} ${o3} u_${r3};
#endif
` : "vec4" === a3 ? `
#ifndef HAS_UNIFORM_u_${r3}
    ${r3} = a_${r3};
#else
    ${i3} ${o3} ${r3} = u_${r3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${r3}
    ${r3} = unpack_mix_${a3}(a_${r3}, u_${r3}_t);
#else
    ${i3} ${o3} ${r3} = u_${r3};
#endif
` : "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${r3}
uniform lowp float u_${r3}_t;
attribute ${i3} ${n3} a_${r3};
#else
uniform ${i3} ${o3} u_${r3};
#endif
` : "vec4" === a3 ? `
#ifndef HAS_UNIFORM_u_${r3}
    ${i3} ${o3} ${r3} = a_${r3};
#else
    ${i3} ${o3} ${r3} = u_${r3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${r3}
    ${i3} ${o3} ${r3} = unpack_mix_${a3}(a_${r3}, u_${r3}_t);
#else
    ${i3} ${o3} ${r3} = u_${r3};
#endif
`;
        }), staticAttributes: n2, staticUniforms: c2 };
      }
      class Jt {
        constructor() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
        }
        bind(e2, t2, i2, o2, r2, n2, a2, s2) {
          this.context = e2;
          let l2 = this.boundPaintVertexBuffers.length !== o2.length;
          for (let e3 = 0; !l2 && e3 < o2.length; e3++)
            this.boundPaintVertexBuffers[e3] !== o2[e3] && (l2 = true);
          e2.extVertexArrayObject && this.vao && this.boundProgram === t2 && this.boundLayoutVertexBuffer === i2 && !l2 && this.boundIndexBuffer === r2 && this.boundVertexOffset === n2 && this.boundDynamicVertexBuffer === a2 && this.boundDynamicVertexBuffer2 === s2 ? (e2.bindVertexArrayOES.set(this.vao), a2 && a2.bind(), r2 && r2.dynamicDraw && r2.bind(), s2 && s2.bind()) : this.freshBind(t2, i2, o2, r2, n2, a2, s2);
        }
        freshBind(e2, t2, i2, o2, r2, n2, a2) {
          let s2;
          const l2 = e2.numAttributes, c2 = this.context, h2 = c2.gl;
          if (c2.extVertexArrayObject)
            this.vao && this.destroy(), this.vao = c2.extVertexArrayObject.createVertexArrayOES(), c2.bindVertexArrayOES.set(this.vao), s2 = 0, this.boundProgram = e2, this.boundLayoutVertexBuffer = t2, this.boundPaintVertexBuffers = i2, this.boundIndexBuffer = o2, this.boundVertexOffset = r2, this.boundDynamicVertexBuffer = n2, this.boundDynamicVertexBuffer2 = a2;
          else {
            s2 = c2.currentNumAttributes || 0;
            for (let e3 = l2; e3 < s2; e3++)
              h2.disableVertexAttribArray(e3);
          }
          t2.enableAttributes(h2, e2);
          for (const t3 of i2)
            t3.enableAttributes(h2, e2);
          n2 && n2.enableAttributes(h2, e2), a2 && a2.enableAttributes(h2, e2), t2.bind(), t2.setVertexAttribPointers(h2, e2, r2);
          for (const t3 of i2)
            t3.bind(), t3.setVertexAttribPointers(h2, e2, r2);
          n2 && (n2.bind(), n2.setVertexAttribPointers(h2, e2, r2)), o2 && o2.bind(), a2 && (a2.bind(), a2.setVertexAttribPointers(h2, e2, r2)), c2.currentNumAttributes = l2;
        }
        destroy() {
          this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
        }
      }
      function Qt(t2, i2) {
        const o2 = Math.pow(2, i2.canonical.z), r2 = i2.canonical.y;
        return [new e.MercatorCoordinate(0, r2 / o2).toLngLat().lat, new e.MercatorCoordinate(0, (r2 + 1) / o2).toLngLat().lat];
      }
      function ei(t2, i2, o2, r2, n2, a2, s2) {
        const l2 = t2.context, c2 = l2.gl, h2 = o2.fbo;
        if (!h2)
          return;
        t2.prepareDrawTile(i2);
        const u2 = t2.useProgram("hillshade");
        l2.activeTexture.set(c2.TEXTURE0), c2.bindTexture(c2.TEXTURE_2D, h2.colorAttachment.get());
        const d2 = ((e2, t3, i3, o3) => {
          const r3 = i3.paint.get("hillshade-shadow-color"), n3 = i3.paint.get("hillshade-highlight-color"), a3 = i3.paint.get("hillshade-accent-color");
          let s3 = i3.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
          "viewport" === i3.paint.get("hillshade-illumination-anchor") && (s3 -= e2.transform.angle);
          const l3 = !e2.options.moving;
          return { u_matrix: o3 || e2.transform.calculateProjMatrix(t3.tileID.toUnwrapped(), l3), u_image: 0, u_latrange: Qt(0, t3.tileID), u_light: [i3.paint.get("hillshade-exaggeration"), s3], u_shadow: r3, u_highlight: n3, u_accent: a3 };
        })(t2, o2, r2, t2.terrain ? i2.projMatrix : null);
        t2.prepareDrawProgram(l2, u2, i2.toUnwrapped()), u2.draw(l2, c2.TRIANGLES, n2, a2, s2, e.CullFaceMode.disabled, d2, r2.id, t2.rasterBoundsBuffer, t2.quadTriangleIndexBuffer, t2.rasterBoundsSegments);
      }
      function ti(t2, i2, o2) {
        if (!i2.needsDEMTextureUpload)
          return;
        const r2 = t2.context, n2 = r2.gl;
        r2.pixelStoreUnpackPremultiplyAlpha.set(false), i2.demTexture = i2.demTexture || t2.getTileTexture(o2.stride);
        const a2 = o2.getPixels();
        i2.demTexture ? i2.demTexture.update(a2, { premultiply: false }) : i2.demTexture = new e.Texture(r2, a2, n2.RGBA, { premultiply: false }), i2.needsDEMTextureUpload = false;
      }
      function ii(t2, i2, o2, r2, n2, a2) {
        const s2 = t2.context, l2 = s2.gl;
        if (!i2.dem)
          return;
        const c2 = i2.dem;
        if (s2.activeTexture.set(l2.TEXTURE1), ti(t2, i2, c2), !i2.demTexture)
          return;
        i2.demTexture.bind(l2.NEAREST, l2.CLAMP_TO_EDGE);
        const h2 = c2.dim;
        s2.activeTexture.set(l2.TEXTURE0);
        let u2 = i2.fbo;
        if (!u2) {
          const t3 = new e.Texture(s2, { width: h2, height: h2, data: null }, l2.RGBA);
          t3.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), u2 = i2.fbo = s2.createFramebuffer(h2, h2, true), u2.colorAttachment.set(t3.texture);
        }
        s2.bindFramebuffer.set(u2.framebuffer), s2.viewport.set([0, 0, h2, h2]), t2.useProgram("hillshadePrepare").draw(s2, l2.TRIANGLES, r2, n2, a2, e.CullFaceMode.disabled, ((t3, i3) => {
          const o3 = i3.stride, r3 = e.create$1();
          return e.ortho(r3, 0, e.EXTENT, -e.EXTENT, 0, 0, 1), e.translate(r3, r3, [0, -e.EXTENT, 0]), { u_matrix: r3, u_image: 1, u_dimension: [o3, o3], u_zoom: t3.overscaledZ, u_unpack: i3.unpackVector };
        })(i2.tileID, c2), o2.id, t2.rasterBoundsBuffer, t2.quadTriangleIndexBuffer, t2.rasterBoundsSegments), i2.needsHillshadePrepare = false;
      }
      const oi = (t2, i2) => ({ u_matrix: new e.UniformMatrix4f(t2, i2.u_matrix), u_image0: new e.Uniform1i(t2, i2.u_image0), u_skirt_height: new e.Uniform1f(t2, i2.u_skirt_height) }), ri = (e2, t2) => ({ u_matrix: e2, u_image0: 0, u_skirt_height: t2 }), ni = new class {
        constructor() {
          this.operations = {};
        }
        newMorphing(e2, t2, i2, o2, r2) {
          if (e2 in this.operations) {
            const t3 = this.operations[e2];
            t3.to.tileID.key !== i2.tileID.key && (t3.queued = i2);
          } else
            this.operations[e2] = { startTime: o2, phase: 0, duration: r2, from: t2, to: i2, queued: null };
        }
        getMorphValuesForProxy(e2) {
          if (!(e2 in this.operations))
            return null;
          const t2 = this.operations[e2];
          return { from: t2.from, to: t2.to, phase: t2.phase };
        }
        update(e2) {
          for (const t2 in this.operations) {
            const i2 = this.operations[t2];
            for (i2.phase = (e2 - i2.startTime) / i2.duration; i2.phase >= 1 || !this._validOp(i2); )
              if (!this._nextOp(i2, e2)) {
                delete this.operations[t2];
                break;
              }
          }
        }
        _nextOp(e2, t2) {
          return !!e2.queued && (e2.from = e2.to, e2.to = e2.queued, e2.queued = null, e2.phase = 0, e2.startTime = t2, true);
        }
        _validOp(e2) {
          return e2.from.hasData() && e2.to.hasData();
        }
      }(), ai = { 0: null, 1: "TERRAIN_VERTEX_MORPHING", 2: "TERRAIN_WIREFRAME" };
      function si(e2, t2) {
        const i2 = 1 << e2.z;
        return !t2 && (0 === e2.x || e2.x === i2 - 1) || 0 === e2.y || e2.y === i2 - 1;
      }
      const li = (e2) => ({ u_matrix: e2 });
      function ci(t2, i2, o2, r2, n2) {
        if (n2 > 0) {
          const a2 = e.exported.now(), s2 = (a2 - t2.timeAdded) / n2, l2 = i2 ? (a2 - i2.timeAdded) / n2 : -1, c2 = o2.getSource(), h2 = r2.coveringZoomLevel({ tileSize: c2.tileSize, roundZoom: c2.roundZoom }), u2 = !i2 || Math.abs(i2.tileID.overscaledZ - h2) > Math.abs(t2.tileID.overscaledZ - h2), d2 = u2 && t2.refreshedUponExpiration ? 1 : e.clamp(u2 ? s2 : 1 - l2, 0, 1);
          return t2.refreshedUponExpiration && s2 >= 1 && (t2.refreshedUponExpiration = false), i2 ? { opacity: 1, mix: 1 - d2 } : { opacity: d2, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      class hi extends e.SourceCache {
        constructor(e2) {
          const t2 = Se("proxy", { type: "geojson", maxzoom: e2.transform.maxZoom }, new I(ke(), null), e2.style);
          super("proxy", t2, false), t2.setEventedParent(this), this.map = this.getSource().map = e2, this.used = this._sourceLoaded = true, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
        }
        update(t2, i2, o2) {
          if (t2.freezeTileCoverage)
            return;
          this.transform = t2;
          const r2 = t2.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }).reduce((i3, o3) => {
            if (i3[o3.key] = "", !this._tiles[o3.key]) {
              const i4 = new e.Tile(o3, this._source.tileSize * o3.overscaleFactor(), t2.tileZoom);
              i4.state = "loaded", this._tiles[o3.key] = i4;
            }
            return i3;
          }, {});
          for (const e2 in this._tiles)
            e2 in r2 || (this.freeFBO(e2), this._tiles[e2].unloadVectorData(), delete this._tiles[e2]);
        }
        freeFBO(e2) {
          const t2 = this.proxyCachedFBO[e2];
          if (void 0 !== t2) {
            const i2 = Object.values(t2);
            this.renderCachePool.push(...i2), delete this.proxyCachedFBO[e2];
          }
        }
        deallocRenderCache() {
          this.renderCache.forEach((e2) => e2.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
        }
      }
      class ui extends e.OverscaledTileID {
        constructor(e2, t2, i2) {
          super(e2.overscaledZ, e2.wrap, e2.canonical.z, e2.canonical.x, e2.canonical.y), this.proxyTileKey = t2, this.projMatrix = i2;
        }
      }
      class di extends e.Elevation {
        constructor(t2, i2) {
          super(), this.painter = t2, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
          const [o2, r2, n2] = function(t3) {
            const i3 = new e.StructArrayLayout4i8(), o3 = new e.StructArrayLayout3ui6(), r3 = 131;
            i3.reserve(17161), o3.reserve(33800);
            const n3 = e.EXTENT / 128, a3 = e.EXTENT + n3 / 2, s3 = a3 + n3;
            for (let t4 = -n3; t4 < s3; t4 += n3)
              for (let o4 = -n3; o4 < s3; o4 += n3) {
                const r4 = o4 < 0 || o4 > a3 || t4 < 0 || t4 > a3 ? 24575 : 0, n4 = e.clamp(Math.round(o4), 0, e.EXTENT), s4 = e.clamp(Math.round(t4), 0, e.EXTENT);
                i3.emplaceBack(n4 + r4, s4, n4, s4);
              }
            const l2 = (e2, t4) => {
              const i4 = t4 * r3 + e2;
              o3.emplaceBack(i4 + 1, i4, i4 + r3), o3.emplaceBack(i4 + r3, i4 + r3 + 1, i4 + 1);
            };
            for (let e2 = 1; e2 < 129; e2++)
              for (let t4 = 1; t4 < 129; t4++)
                l2(t4, e2);
            return [0, 129].forEach((e2) => {
              for (let t4 = 0; t4 < 130; t4++)
                l2(t4, e2), l2(e2, t4);
            }), [i3, o3, 32768];
          }(), a2 = t2.context;
          this.gridBuffer = a2.createVertexBuffer(o2, Te.members), this.gridIndexBuffer = a2.createIndexBuffer(r2), this.gridSegments = e.SegmentVector.simpleSegment(0, 0, o2.length, r2.length), this.gridNoSkirtSegments = e.SegmentVector.simpleSegment(0, 0, o2.length, n2), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new hi(i2.map), this.orthoMatrix = e.create$1(), e.ortho(this.orthoMatrix, 0, e.EXTENT, 0, e.EXTENT, 0, 1);
          const s2 = a2.gl;
          this._overlapStencilMode = new e.StencilMode({ func: s2.GEQUAL, mask: 255 }, 0, 255, s2.KEEP, s2.KEEP, s2.REPLACE), this._previousZoom = t2.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i2, this._useVertexMorphing = true, this._exaggeration = 1;
        }
        set style(e2) {
          e2.on("data", this._onStyleDataEvent.bind(this)), e2.on("neworder", this._checkRenderCacheEfficiency.bind(this)), this._style = e2, this._checkRenderCacheEfficiency();
        }
        update(t2, i2, o2) {
          if (t2 && t2.terrain) {
            this._style !== t2 && (this.style = t2), this.enabled = true;
            const r2 = t2.terrain.properties;
            this.sourceCache = t2._getSourceCache(r2.get("source")), this._exaggeration = r2.get("exaggeration");
            const n2 = () => {
              this.sourceCache.used && e.warnOnce(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.
This leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
              const t3 = this.sourceCache.getSource().tileSize / 128, o3 = this.proxySourceCache.getSource().tileSize;
              this.sourceCache.update(i2, t3 * o3, true), this._findCoveringTileCache[this.sourceCache.id] = {};
            };
            this.sourceCache.usedForTerrain || (this._findCoveringTileCache[this.sourceCache.id] = {}, this.sourceCache.usedForTerrain = true, n2(), this._initializing = true), n2(), i2.updateElevation(!o2), this._findCoveringTileCache[this.proxySourceCache.id] = {}, this.proxySourceCache.update(i2), this._emptyDEMTextureDirty = true;
          } else
            this._disable();
        }
        _checkRenderCacheEfficiency() {
          const t2 = this.renderCacheEfficiency(this._style);
          this._style.map._optimizeForTerrain || 100 !== t2.efficiency && e.warnOnce(`Terrain render cache efficiency is not optimal (${t2.efficiency}%) and performance
                may be affected negatively, consider placing all background, fill and line layers before layer
                with id '${t2.firstUndrapedLayer}' or create a map using optimizeForTerrain: true option.`);
        }
        _onStyleDataEvent(e2) {
          e2.coord && "source" === e2.dataType ? this._clearRenderCacheForTile(e2.sourceCacheId, e2.coord) : "style" === e2.dataType && (this._invalidateRenderCache = true);
        }
        _disable() {
          if (this.enabled && (this.enabled = false, this._sharedDepthStencil = void 0, this.proxySourceCache.deallocRenderCache(), this._style))
            for (const e2 in this._style._sourceCaches)
              this._style._sourceCaches[e2].usedForTerrain = false;
        }
        destroy() {
          this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this.pool.forEach((e2) => e2.fb.destroy()), this.pool = [], this._depthFBO && (this._depthFBO.destroy(), delete this._depthFBO, delete this._depthTexture);
        }
        _source() {
          return this.enabled ? this.sourceCache : null;
        }
        exaggeration() {
          return this._exaggeration;
        }
        get visibleDemTiles() {
          return this._visibleDemTiles;
        }
        get drapeBufferSize() {
          const e2 = 2 * this.proxySourceCache.getSource().tileSize;
          return [e2, e2];
        }
        set useVertexMorphing(e2) {
          this._useVertexMorphing = e2;
        }
        updateTileBinding(t2) {
          if (!this.enabled)
            return;
          this.prevTerrainTileForTile = this.terrainTileForTile;
          const i2 = this.proxySourceCache, o2 = this.painter.transform;
          this._initializing && (this._initializing = 0 === o2._centerAltitude && -1 === this.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(o2.center), -1), this._emptyDEMTextureDirty = !this._initializing);
          const r2 = this.proxyCoords = i2.getIds().map((e2) => {
            const t3 = i2.getTileByID(e2).tileID;
            return t3.projMatrix = o2.calculateProjMatrix(t3.toUnwrapped()), t3;
          });
          !function(t3, i3) {
            const o3 = i3.transform.pointCoordinate(i3.transform.getCameraPoint()), r3 = new e.pointGeometry(o3.x, o3.y);
            t3.sort((t4, i4) => {
              if (i4.overscaledZ - t4.overscaledZ)
                return i4.overscaledZ - t4.overscaledZ;
              const o4 = new e.pointGeometry(t4.canonical.x + (1 << t4.canonical.z) * t4.wrap, t4.canonical.y), n3 = new e.pointGeometry(i4.canonical.x + (1 << i4.canonical.z) * i4.wrap, i4.canonical.y), a3 = r3.mult(1 << t4.canonical.z);
              return a3.x -= 0.5, a3.y -= 0.5, a3.distSqr(o4) - a3.distSqr(n3);
            });
          }(r2, this.painter), this._previousZoom = o2.zoom;
          const n2 = this.proxyToSource || {};
          this.proxyToSource = {}, r2.forEach((e2) => {
            this.proxyToSource[e2.key] = {};
          }), this.terrainTileForTile = {};
          const a2 = this._style._sourceCaches;
          for (const e2 in a2) {
            const i3 = a2[e2];
            if (!i3.used)
              continue;
            if (i3 !== this.sourceCache && (this._findCoveringTileCache[i3.id] = {}), this._setupProxiedCoordsForOrtho(i3, t2[e2], n2), i3.usedForTerrain)
              continue;
            const o3 = t2[e2];
            i3.getSource().reparseOverscaled && this._assignTerrainTiles(o3);
          }
          this.proxiedCoords[i2.id] = r2.map((e2) => new ui(e2, e2.key, this.orthoMatrix)), this._assignTerrainTiles(r2), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(n2), this.renderingToTexture = false, this._updateTimestamp = e.exported.now();
          const s2 = {};
          this._visibleDemTiles = [];
          for (const e2 of this.proxyCoords) {
            const t3 = this.terrainTileForTile[e2.key];
            if (!t3)
              continue;
            const i3 = t3.tileID.key;
            i3 in s2 || (this._visibleDemTiles.push(t3), s2[i3] = i3);
          }
        }
        _assignTerrainTiles(e2) {
          this._initializing || e2.forEach((e3) => {
            if (this.terrainTileForTile[e3.key])
              return;
            const t2 = this._findTileCoveringTileID(e3, this.sourceCache);
            t2 && (this.terrainTileForTile[e3.key] = t2);
          });
        }
        _prepareDEMTextures() {
          const e2 = this.painter.context, t2 = e2.gl;
          for (const i2 in this.terrainTileForTile) {
            const o2 = this.terrainTileForTile[i2], r2 = o2.dem;
            !r2 || o2.demTexture && !o2.needsDEMTextureUpload || (e2.activeTexture.set(t2.TEXTURE1), ti(this.painter, o2, r2));
          }
        }
        _prepareDemTileUniforms(e2, t2, i2, o2) {
          if (!t2 || null == t2.demTexture)
            return false;
          const r2 = e2.tileID.canonical, n2 = Math.pow(2, t2.tileID.canonical.z - r2.z), a2 = o2 || "";
          return i2[`u_dem_tl${a2}`] = [r2.x * n2 % 1, r2.y * n2 % 1], i2[`u_dem_scale${a2}`] = n2, true;
        }
        get emptyDEMTexture() {
          return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
        }
        _getLoadedAreaMinimum() {
          let e2 = 0;
          const t2 = this._visibleDemTiles.reduce((t3, i2) => {
            if (!i2.dem)
              return t3;
            const o2 = i2.dem.tree.minimums[0];
            return o2 > 0 && e2++, t3 + o2;
          }, 0);
          return e2 ? t2 / e2 : 0;
        }
        _updateEmptyDEMTexture() {
          const t2 = this.painter.context, i2 = t2.gl;
          t2.activeTexture.set(i2.TEXTURE2);
          const o2 = this._getLoadedAreaMinimum(), r2 = { width: 1, height: 1, data: new Uint8Array(e.DEMData.pack(o2, this.sourceCache.getSource().encoding)) };
          this._emptyDEMTextureDirty = false;
          let n2 = this._emptyDEMTexture;
          return n2 ? n2.update(r2, { premultiply: false }) : n2 = this._emptyDEMTexture = new e.Texture(t2, r2, i2.RGBA, { premultiply: false }), n2;
        }
        setupElevationDraw(t2, i2, o2) {
          const r2 = this.painter.context, n2 = r2.gl, a2 = (s2 = this.sourceCache.getSource().encoding, { u_dem: 2, u_dem_prev: 4, u_dem_unpack: e.DEMData.getUnpackVector(s2), u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_exaggeration: 0, u_tile_tl_up: [0, 0, 1], u_tile_tr_up: [0, 0, 1], u_tile_br_up: [0, 0, 1], u_tile_bl_up: [0, 0, 1], u_tile_up_scale: 1 });
          var s2;
          a2.u_dem_size = this.sourceCache.getSource().tileSize, a2.u_exaggeration = this.exaggeration();
          let l2 = null, c2 = null, h2 = 1;
          if (o2 && o2.morphing && this._useVertexMorphing) {
            const e2 = o2.morphing.srcDemTile, i3 = o2.morphing.dstDemTile;
            h2 = o2.morphing.phase, e2 && i3 && (this._prepareDemTileUniforms(t2, e2, a2, "_prev") && (c2 = e2), this._prepareDemTileUniforms(t2, i3, a2) && (l2 = i3));
          }
          if (c2 && l2 ? (r2.activeTexture.set(n2.TEXTURE2), l2.demTexture.bind(n2.NEAREST, n2.CLAMP_TO_EDGE, n2.NEAREST), r2.activeTexture.set(n2.TEXTURE4), c2.demTexture.bind(n2.NEAREST, n2.CLAMP_TO_EDGE, n2.NEAREST), a2.u_dem_lerp = h2) : (l2 = this.terrainTileForTile[t2.tileID.key], r2.activeTexture.set(n2.TEXTURE2), (this._prepareDemTileUniforms(t2, l2, a2) ? l2.demTexture : this.emptyDEMTexture).bind(n2.NEAREST, n2.CLAMP_TO_EDGE, n2.NEAREST)), o2 && o2.useDepthForOcclusion && (r2.activeTexture.set(n2.TEXTURE3), this._depthTexture.bind(n2.NEAREST, n2.CLAMP_TO_EDGE, n2.NEAREST), a2.u_depth_size_inv = [1 / this._depthFBO.width, 1 / this._depthFBO.height]), o2 && o2.useMeterToDem && l2) {
            const t3 = (1 << l2.tileID.canonical.z) * e.mercatorZfromAltitude(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
            a2.u_meter_to_dem = t3;
          }
          o2 && o2.labelPlaneMatrixInv && (a2.u_label_plane_matrix_inv = o2.labelPlaneMatrixInv), i2.setTerrainUniformValues(r2, a2);
        }
        renderToBackBuffer(t2) {
          const i2 = this.painter, o2 = this.painter.context;
          0 !== t2.length && (o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, i2.width, i2.height]), this.renderingToTexture = false, function(t3, i3, o3, r2, n2) {
            const a2 = t3.context, s2 = a2.gl;
            let l2, c2;
            const h2 = t3.options.showTerrainWireframe ? 2 : 0, u2 = (e2, i4) => {
              if (c2 === e2)
                return;
              const o4 = [ai[e2]];
              i4 && o4.push(ai[h2]), l2 = t3.useProgram("terrainRaster", null, o4), c2 = e2;
            }, d2 = t3.colorModeForRenderPass(), _2 = new e.DepthMode(s2.LEQUAL, e.DepthMode.ReadWrite, t3.depthRangeFor3D);
            ni.update(n2);
            const p2 = t3.transform, m2 = 6 * Math.pow(1.5, 22 - p2.zoom) * i3.exaggeration();
            (h2 ? [false, true] : [false]).forEach((h3) => {
              c2 = -1;
              const f2 = h3 ? s2.LINES : s2.TRIANGLES, [g2, v2] = h3 ? i3.getWirefameBuffer() : [i3.gridIndexBuffer, i3.gridSegments];
              for (const c3 of r2) {
                const r3 = o3.getTile(c3), b2 = e.StencilMode.disabled, w2 = i3.prevTerrainTileForTile[c3.key], T2 = i3.terrainTileForTile[c3.key];
                y2 = T2, null != (x2 = w2) && null != y2 && x2.hasData() && y2.hasData() && null != x2.demTexture && null != y2.demTexture && x2.tileID.key !== y2.tileID.key && ni.newMorphing(c3.key, w2, T2, n2, 250), a2.activeTexture.set(s2.TEXTURE0), r3.texture.bind(s2.LINEAR, s2.CLAMP_TO_EDGE, s2.LINEAR_MIPMAP_NEAREST);
                const E2 = ni.getMorphValuesForProxy(c3.key), C2 = E2 ? 1 : 0;
                let S2;
                E2 && (S2 = { morphing: { srcDemTile: E2.from, dstDemTile: E2.to, phase: e.easeCubicInOut(E2.phase) } });
                const M2 = ri(c3.projMatrix, si(c3.canonical, p2.renderWorldCopies) ? m2 / 10 : m2);
                u2(C2, h3), i3.setupElevationDraw(r3, l2, S2), t3.prepareDrawProgram(a2, l2, c3.toUnwrapped()), l2.draw(a2, f2, _2, b2, d2, e.CullFaceMode.backCCW, M2, "terrain_raster", i3.gridBuffer, g2, v2);
              }
              var x2, y2;
            });
          }(i2, this, this.proxySourceCache, t2, this._updateTimestamp), this.renderingToTexture = true, t2.splice(0, t2.length));
        }
        renderBatch(t2) {
          if (0 === this._drapedRenderBatches.length)
            return t2 + 1;
          this.renderingToTexture = true;
          const i2 = this.painter, o2 = this.painter.context, r2 = this.proxySourceCache, n2 = this.proxiedCoords[r2.id], a2 = this._drapedRenderBatches.shift(), s2 = [], l2 = i2.style.order;
          let c2 = 0;
          for (const h2 of n2) {
            const n3 = r2.getTileByID(h2.proxyTileKey), u2 = r2.proxyCachedFBO[h2.key] ? r2.proxyCachedFBO[h2.key][t2] : void 0, d2 = void 0 !== u2 ? r2.renderCache[u2] : this.pool[c2++], _2 = void 0 !== u2;
            if (n3.texture = d2.tex, _2 && !d2.dirty) {
              s2.push(n3.tileID);
              continue;
            }
            let p2;
            o2.bindFramebuffer.set(d2.fb.framebuffer), this.renderedToTile = false, d2.dirty && (o2.clear({ color: e.Color.transparent }), d2.dirty = false);
            for (let e2 = a2.start; e2 <= a2.end; ++e2) {
              const t3 = i2.style._layers[l2[e2]];
              if (t3.isHidden(i2.transform.zoom))
                continue;
              const r3 = i2.style._getLayerSourceCache(t3), n4 = r3 ? this.proxyToSource[h2.key][r3.id] : [h2];
              if (!n4)
                continue;
              const a3 = n4;
              o2.viewport.set([0, 0, d2.fb.width, d2.fb.height]), p2 !== (r3 ? r3.id : null) && (this._setupStencil(d2, n4, t3, r3), p2 = r3 ? r3.id : null), i2.renderLayer(i2, r3, t3, a3);
            }
            this.renderedToTile ? (d2.dirty = true, s2.push(n3.tileID)) : _2 || --c2, 5 === c2 && (c2 = 0, this.renderToBackBuffer(s2));
          }
          return this.renderToBackBuffer(s2), this.renderingToTexture = false, o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, i2.width, i2.height]), a2.end + 1;
        }
        postRender() {
        }
        renderCacheEfficiency(e2) {
          const t2 = e2.order.length;
          if (0 === t2)
            return { efficiency: 100 };
          let i2, o2 = 0, r2 = 0, n2 = false;
          for (let a2 = 0; a2 < t2; ++a2) {
            const t3 = e2._layers[e2.order[a2]];
            this._style.isLayerDraped(t3) ? (n2 && ++o2, ++r2) : n2 || (n2 = true, i2 = t3.id);
          }
          return 0 === r2 ? { efficiency: 100 } : { efficiency: 100 * (1 - o2 / r2), firstUndrapedLayer: i2 };
        }
        getMinElevationBelowMSL() {
          let e2 = 0;
          return this._visibleDemTiles.filter((e3) => e3.dem).forEach((t2) => {
            e2 = Math.min(e2, t2.dem.tree.minimums[0]);
          }), 0 === e2 ? e2 : (e2 - 30) * this._exaggeration;
        }
        raycast(e2, t2, i2) {
          if (!this._visibleDemTiles)
            return null;
          const o2 = this._visibleDemTiles.filter((e3) => e3.dem).map((o3) => {
            const r2 = o3.tileID, n2 = Math.pow(2, r2.overscaledZ), { x: a2, y: s2 } = r2.canonical, l2 = a2 / n2, c2 = (a2 + 1) / n2, h2 = s2 / n2, u2 = (s2 + 1) / n2;
            return { minx: l2, miny: h2, maxx: c2, maxy: u2, t: o3.dem.tree.raycastRoot(l2, h2, c2, u2, e2, t2, i2), tile: o3 };
          });
          o2.sort((e3, t3) => (null !== e3.t ? e3.t : Number.MAX_VALUE) - (null !== t3.t ? t3.t : Number.MAX_VALUE));
          for (const r2 of o2) {
            if (null == r2.t)
              return null;
            const o3 = r2.tile.dem.tree.raycast(r2.minx, r2.miny, r2.maxx, r2.maxy, e2, t2, i2);
            if (null != o3)
              return o3;
          }
          return null;
        }
        _createFBO() {
          const t2 = this.painter.context, i2 = t2.gl, o2 = this.drapeBufferSize;
          t2.activeTexture.set(i2.TEXTURE0);
          const r2 = new e.Texture(t2, { width: o2[0], height: o2[1], data: null }, i2.RGBA);
          r2.bind(i2.LINEAR, i2.CLAMP_TO_EDGE);
          const n2 = t2.createFramebuffer(o2[0], o2[1], false);
          return n2.colorAttachment.set(r2.texture), n2.depthAttachment = new ve(t2, n2.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t2.createRenderbuffer(t2.gl.DEPTH_STENCIL, o2[0], o2[1]), this._stencilRef = 0, n2.depthAttachment.set(this._sharedDepthStencil), t2.clear({ stencil: 0 })) : n2.depthAttachment.set(this._sharedDepthStencil), t2.extTextureFilterAnisotropic && !t2.extTextureFilterAnisotropicForceOff && i2.texParameterf(i2.TEXTURE_2D, t2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t2.extTextureFilterAnisotropicMax), { fb: n2, tex: r2, dirty: false };
        }
        _initFBOPool() {
          for (; this.pool.length < Math.min(5, this.proxyCoords.length); )
            this.pool.push(this._createFBO());
        }
        _shouldDisableRenderCache() {
          if (this._style.light && this._style.light.hasTransition())
            return true;
          for (const e2 in this._style._sourceCaches)
            if (this._style._sourceCaches[e2].hasTransition())
              return true;
          return this._style.order.some((e2) => {
            const t2 = this._style._layers[e2], i2 = t2.isHidden(this.painter.transform.zoom), o2 = t2.getCrossfadeParameters(), r2 = !!o2 && 1 !== o2.t, n2 = t2.hasTransition();
            return "custom" !== t2.type && !i2 && (r2 || n2);
          });
        }
        _clearRasterFadeFromRenderCache() {
          let e2 = false;
          for (const t2 in this._style._sourceCaches)
            if (this._style._sourceCaches[t2]._source instanceof be) {
              e2 = true;
              break;
            }
          if (e2)
            for (let e3 = 0; e3 < this._style.order.length; ++e3) {
              const t2 = this._style._layers[this._style.order[e3]], i2 = t2.isHidden(this.painter.transform.zoom), o2 = this._style._getLayerSourceCache(t2);
              if ("raster" !== t2.type || i2 || !o2)
                continue;
              const r2 = t2.paint.get("raster-fade-duration");
              for (const e4 of this.proxyCoords) {
                const t3 = this.proxyToSource[e4.key][o2.id];
                if (t3)
                  for (const e5 of t3) {
                    const t4 = ci(o2.getTile(e5), o2.findLoadedParent(e5, 0), o2, this.painter.transform, r2);
                    (1 !== t4.opacity || 0 !== t4.mix) && this._clearRenderCacheForTile(o2.id, e5);
                  }
              }
            }
        }
        _setupDrapedRenderBatches() {
          const e2 = this._style.order, t2 = e2.length;
          if (0 === t2)
            return;
          const i2 = [];
          let o2, r2 = 0, n2 = this._style._layers[e2[r2]];
          for (; !this._style.isLayerDraped(n2) && n2.isHidden(this.painter.transform.zoom) && ++r2 < t2; )
            n2 = this._style._layers[e2[r2]];
          for (; r2 < t2; ++r2) {
            const t3 = this._style._layers[e2[r2]];
            t3.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(t3) ? void 0 === o2 && (o2 = r2) : void 0 !== o2 && (i2.push({ start: o2, end: r2 - 1 }), o2 = void 0));
          }
          void 0 !== o2 && i2.push({ start: o2, end: r2 - 1 }), this._drapedRenderBatches = i2;
        }
        _setupRenderCache(e2) {
          const t2 = this.proxySourceCache;
          if (this._shouldDisableRenderCache() || this._invalidateRenderCache) {
            if (this._invalidateRenderCache = false, t2.renderCache.length > t2.renderCachePool.length) {
              const e3 = Object.values(t2.proxyCachedFBO);
              t2.proxyCachedFBO = {};
              for (let i3 = 0; i3 < e3.length; ++i3) {
                const o3 = Object.values(e3[i3]);
                t2.renderCachePool.push(...o3);
              }
            }
            return;
          }
          this._clearRasterFadeFromRenderCache();
          const i2 = this.proxyCoords, o2 = this._tilesDirty;
          for (let r3 = i2.length - 1; r3 >= 0; r3--) {
            const n2 = i2[r3];
            if (t2.getTileByID(n2.key), void 0 !== t2.proxyCachedFBO[n2.key]) {
              const i3 = e2[n2.key], r4 = this.proxyToSource[n2.key];
              let a2 = 0;
              for (const e3 in r4) {
                const t3 = r4[e3], n3 = i3[e3];
                if (!n3 || n3.length !== t3.length || t3.some((t4, i4) => t4 !== n3[i4] || o2[e3] && o2[e3].hasOwnProperty(t4.key))) {
                  a2 = -1;
                  break;
                }
                ++a2;
              }
              for (const e3 in t2.proxyCachedFBO[n2.key])
                t2.renderCache[t2.proxyCachedFBO[n2.key][e3]].dirty = a2 < 0 || a2 !== Object.values(i3).length;
            }
          }
          const r2 = [...this._drapedRenderBatches];
          r2.sort((e3, t3) => t3.end - t3.start - (e3.end - e3.start));
          for (const e3 of r2)
            for (const o3 of i2) {
              if (t2.proxyCachedFBO[o3.key])
                continue;
              let i3 = t2.renderCachePool.pop();
              void 0 === i3 && t2.renderCache.length < 50 && (i3 = t2.renderCache.length, t2.renderCache.push(this._createFBO())), void 0 !== i3 && (t2.proxyCachedFBO[o3.key] = {}, t2.proxyCachedFBO[o3.key][e3.start] = i3, t2.renderCache[i3].dirty = true);
            }
          this._tilesDirty = {};
        }
        _setupStencil(e2, t2, i2, o2) {
          if (!o2 || !this._sourceTilesOverlap[o2.id])
            return void (this._overlapStencilType && (this._overlapStencilType = false));
          const r2 = this.painter.context, n2 = r2.gl;
          if (t2.length <= 1)
            return void (this._overlapStencilType = false);
          let a2;
          if (i2.isTileClipped())
            a2 = t2.length, this._overlapStencilMode.test = { func: n2.EQUAL, mask: 255 }, this._overlapStencilType = "Clip";
          else {
            if (!(t2[0].overscaledZ > t2[t2.length - 1].overscaledZ))
              return void (this._overlapStencilType = false);
            a2 = 1, this._overlapStencilMode.test = { func: n2.GREATER, mask: 255 }, this._overlapStencilType = "Mask";
          }
          this._stencilRef + a2 > 255 && (r2.clear({ stencil: 0 }), this._stencilRef = 0), this._stencilRef += a2, this._overlapStencilMode.ref = this._stencilRef, i2.isTileClipped() && this._renderTileClippingMasks(t2, this._overlapStencilMode.ref);
        }
        stencilModeForRTTOverlap(t2) {
          return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[t2.key]), this._overlapStencilMode) : e.StencilMode.disabled;
        }
        _renderTileClippingMasks(t2, i2) {
          const o2 = this.painter, r2 = this.painter.context, n2 = r2.gl;
          o2._tileClippingMaskIDs = {}, r2.setColorMode(e.ColorMode.disabled), r2.setDepthMode(e.DepthMode.disabled);
          const a2 = o2.useProgram("clippingMask");
          for (const s2 of t2) {
            const t3 = o2._tileClippingMaskIDs[s2.key] = --i2;
            a2.draw(r2, n2.TRIANGLES, e.DepthMode.disabled, new e.StencilMode({ func: n2.ALWAYS, mask: 0 }, t3, 255, n2.KEEP, n2.KEEP, n2.REPLACE), e.ColorMode.disabled, e.CullFaceMode.disabled, li(s2.projMatrix), "$clipping", o2.tileExtentBuffer, o2.quadTriangleIndexBuffer, o2.tileExtentSegments);
          }
        }
        pointCoordinate(t2) {
          const i2 = this.painter.transform;
          if (t2.x < 0 || t2.x > i2.width || t2.y < 0 || t2.y > i2.height)
            return null;
          const o2 = [t2.x, t2.y, 1, 1];
          e.transformMat4(o2, o2, i2.pixelMatrixInverse), e.scale$2(o2, o2, 1 / o2[3]), o2[0] /= i2.worldSize, o2[1] /= i2.worldSize;
          const r2 = i2._camera.position, n2 = e.mercatorZfromAltitude(1, i2.center.lat), a2 = [r2[0], r2[1], r2[2] / n2, 0], s2 = e.subtract([], o2.slice(0, 3), a2);
          e.normalize(s2, s2);
          const l2 = this.raycast(a2, s2, this._exaggeration);
          return null !== l2 && l2 ? (e.scaleAndAdd(a2, a2, s2, l2), a2[3] = a2[2], a2[2] *= n2, a2) : null;
        }
        drawDepth() {
          const t2 = this.painter, i2 = t2.context, o2 = this.proxySourceCache, r2 = Math.ceil(t2.width), n2 = Math.ceil(t2.height);
          if (!this._depthFBO || this._depthFBO.width === r2 && this._depthFBO.height === n2 || (this._depthFBO.destroy(), delete this._depthFBO, delete this._depthTexture), !this._depthFBO) {
            const t3 = i2.gl, o3 = i2.createFramebuffer(r2, n2, true);
            i2.activeTexture.set(t3.TEXTURE0);
            const a2 = new e.Texture(i2, { width: r2, height: n2, data: null }, t3.RGBA);
            a2.bind(t3.NEAREST, t3.CLAMP_TO_EDGE), o3.colorAttachment.set(a2.texture);
            const s2 = i2.createRenderbuffer(i2.gl.DEPTH_COMPONENT16, r2, n2);
            o3.depthAttachment.set(s2), this._depthFBO = o3, this._depthTexture = a2;
          }
          i2.bindFramebuffer.set(this._depthFBO.framebuffer), i2.viewport.set([0, 0, r2, n2]), function(t3, i3, o3, r3) {
            const n3 = t3.context, a2 = n3.gl;
            n3.clear({ depth: 1 });
            const s2 = t3.useProgram("terrainDepth"), l2 = new e.DepthMode(a2.LESS, e.DepthMode.ReadWrite, t3.depthRangeFor3D);
            for (const t4 of r3) {
              const r4 = o3.getTile(t4), c2 = ri(t4.projMatrix, 0);
              i3.setupElevationDraw(r4, s2), s2.draw(n3, a2.TRIANGLES, l2, e.StencilMode.disabled, e.ColorMode.unblended, e.CullFaceMode.backCCW, c2, "terrain_depth", i3.gridBuffer, i3.gridIndexBuffer, i3.gridNoSkirtSegments);
            }
          }(t2, this, o2, this.proxyCoords);
        }
        _setupProxiedCoordsForOrtho(e2, t2, i2) {
          if (e2.getSource() instanceof Ee)
            return this._setupProxiedCoordsForImageSource(e2, t2, i2);
          this._findCoveringTileCache[e2.id] = this._findCoveringTileCache[e2.id] || {};
          const o2 = this.proxiedCoords[e2.id] = [], r2 = this.proxyCoords;
          for (let t3 = 0; t3 < r2.length; t3++) {
            const n3 = r2[t3], a2 = this._findTileCoveringTileID(n3, e2);
            if (a2) {
              const t4 = this._createProxiedId(n3, a2, i2[n3.key] && i2[n3.key][e2.id]);
              o2.push(t4), this.proxyToSource[n3.key][e2.id] = [t4];
            }
          }
          let n2 = false;
          for (let r3 = 0; r3 < t2.length; r3++) {
            const a2 = e2.getTile(t2[r3]);
            if (!a2 || !a2.hasData())
              continue;
            const s2 = this._findTileCoveringTileID(a2.tileID, this.proxySourceCache);
            if (s2 && s2.tileID.canonical.z !== a2.tileID.canonical.z) {
              const t3 = this.proxyToSource[s2.tileID.key][e2.id], r4 = this._createProxiedId(s2.tileID, a2, i2[s2.tileID.key] && i2[s2.tileID.key][e2.id]);
              t3 ? t3.splice(t3.length - 1, 0, r4) : this.proxyToSource[s2.tileID.key][e2.id] = [r4], o2.push(r4), n2 = true;
            }
          }
          this._sourceTilesOverlap[e2.id] = n2;
        }
        _setupProxiedCoordsForImageSource(t2, i2, o2) {
          if (!t2.getSource().loaded())
            return;
          const r2 = this.proxiedCoords[t2.id] = [], n2 = this.proxyCoords, a2 = t2.getSource(), s2 = new e.pointGeometry(a2.tileID.x, a2.tileID.y)._div(1 << a2.tileID.z), l2 = a2.coordinates.map(e.MercatorCoordinate.fromLngLat).reduce((e2, t3) => (e2.min.x = Math.min(e2.min.x, t3.x - s2.x), e2.min.y = Math.min(e2.min.y, t3.y - s2.y), e2.max.x = Math.max(e2.max.x, t3.x - s2.x), e2.max.y = Math.max(e2.max.y, t3.y - s2.y), e2), { min: new e.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE), max: new e.pointGeometry(-Number.MAX_VALUE, -Number.MAX_VALUE) }), c2 = (t3, i3) => {
            const o3 = t3.wrap + t3.canonical.x / (1 << t3.canonical.z), r3 = t3.canonical.y / (1 << t3.canonical.z), n3 = e.EXTENT / (1 << t3.canonical.z), a3 = i3.wrap + i3.canonical.x / (1 << i3.canonical.z), s3 = i3.canonical.y / (1 << i3.canonical.z);
            return o3 + n3 < a3 + l2.min.x || o3 > a3 + l2.max.x || r3 + n3 < s3 + l2.min.y || r3 > s3 + l2.max.y;
          };
          for (let e2 = 0; e2 < n2.length; e2++) {
            const a3 = n2[e2];
            for (let e3 = 0; e3 < i2.length; e3++) {
              const n3 = t2.getTile(i2[e3]);
              if (!n3 || !n3.hasData())
                continue;
              if (c2(a3, n3.tileID))
                continue;
              const s3 = this._createProxiedId(a3, n3, o2[a3.key] && o2[a3.key][t2.id]), l3 = this.proxyToSource[a3.key][t2.id];
              l3 ? l3.push(s3) : this.proxyToSource[a3.key][t2.id] = [s3], r2.push(s3);
            }
          }
        }
        _createProxiedId(t2, i2, o2) {
          let r2 = this.orthoMatrix;
          if (o2) {
            const e2 = o2.find((e3) => e3.key === i2.tileID.key);
            if (e2)
              return e2;
          }
          if (i2.tileID.key !== t2.key) {
            const o3 = t2.canonical.z - i2.tileID.canonical.z;
            let n2, a2, s2;
            r2 = e.create$1();
            const l2 = i2.tileID.wrap - t2.wrap << t2.overscaledZ;
            o3 > 0 ? (n2 = e.EXTENT >> o3, a2 = n2 * ((i2.tileID.canonical.x << o3) - t2.canonical.x + l2), s2 = n2 * ((i2.tileID.canonical.y << o3) - t2.canonical.y)) : (n2 = e.EXTENT << -o3, a2 = e.EXTENT * (i2.tileID.canonical.x - (t2.canonical.x + l2 << -o3)), s2 = e.EXTENT * (i2.tileID.canonical.y - (t2.canonical.y << -o3))), e.ortho(r2, 0, n2, 0, n2, 0, 1), e.translate(r2, r2, [a2, s2, 0]);
          }
          return new ui(i2.tileID, t2.key, r2);
        }
        _findTileCoveringTileID(t2, i2) {
          let o2 = i2.getTile(t2);
          if (o2 && o2.hasData())
            return o2;
          const r2 = this._findCoveringTileCache[i2.id], n2 = r2[t2.key];
          if (o2 = n2 ? i2.getTileByID(n2) : null, o2 && o2.hasData() || null === n2)
            return o2;
          let a2 = o2 ? o2.tileID : t2, s2 = a2.overscaledZ;
          const l2 = i2.getSource().minzoom, c2 = [];
          if (!n2) {
            const r3 = i2.getSource().maxzoom;
            if (t2.canonical.z >= r3) {
              const o3 = t2.canonical.z - r3;
              i2.getSource().reparseOverscaled ? (s2 = Math.max(t2.canonical.z + 2, i2.transform.tileZoom), a2 = new e.OverscaledTileID(s2, t2.wrap, r3, t2.canonical.x >> o3, t2.canonical.y >> o3)) : 0 !== o3 && (s2 = r3, a2 = new e.OverscaledTileID(s2, t2.wrap, r3, t2.canonical.x >> o3, t2.canonical.y >> o3));
            }
            a2.key !== t2.key && (c2.push(a2.key), o2 = i2.getTile(a2));
          }
          const h2 = (e2) => {
            c2.forEach((t3) => {
              r2[t3] = e2;
            }), c2.length = 0;
          };
          for (s2 -= 1; s2 >= l2 && (!o2 || !o2.hasData()); s2--) {
            o2 && h2(o2.tileID.key);
            const e2 = a2.calculateScaledKey(s2);
            if (o2 = i2.getTileByID(e2), o2 && o2.hasData())
              break;
            const t3 = r2[e2];
            if (null === t3)
              break;
            void 0 === t3 ? c2.push(e2) : o2 = i2.getTileByID(t3);
          }
          return h2(o2 ? o2.tileID.key : null), o2 && o2.hasData() ? o2 : null;
        }
        findDEMTileFor(e2) {
          return this.enabled ? this._findTileCoveringTileID(e2, this.sourceCache) : null;
        }
        prepareDrawTile(e2) {
          this.renderedToTile = true;
        }
        _clearRenderCacheForTile(e2, t2) {
          let i2 = this._tilesDirty[e2];
          i2 || (i2 = this._tilesDirty[e2] = {}), i2[t2.key] = true;
        }
        getWirefameBuffer() {
          if (!this.wireframeSegments) {
            const t2 = function(t3) {
              let i2, o2, r2;
              const n2 = new e.StructArrayLayout2ui4(), a2 = 131;
              for (o2 = 1; o2 < 129; o2++) {
                for (i2 = 1; i2 < 129; i2++)
                  r2 = o2 * a2 + i2, n2.emplaceBack(r2, r2 + 1), n2.emplaceBack(r2, r2 + a2), n2.emplaceBack(r2 + 1, r2 + a2), 128 === o2 && n2.emplaceBack(r2 + a2, r2 + a2 + 1);
                n2.emplaceBack(r2 + 1, r2 + 1 + a2);
              }
              return n2;
            }();
            this.wireframeIndexBuffer = this.painter.context.createIndexBuffer(t2), this.wireframeSegments = e.SegmentVector.simpleSegment(0, 0, this.gridBuffer.length, t2.length);
          }
          return [this.wireframeIndexBuffer, this.wireframeSegments];
        }
      }
      function _i(e2) {
        const t2 = [];
        for (let i2 = 0; i2 < e2.length; i2++) {
          if (null === e2[i2])
            continue;
          const o2 = e2[i2].split(" ");
          t2.push(o2.pop());
        }
        return t2;
      }
      class pi {
        static cacheKey(e2, t2, i2) {
          let o2 = `${e2}${i2 ? i2.cacheKey : ""}`;
          for (const e3 of t2)
            o2 += `/${e3}`;
          return o2;
        }
        constructor(t2, i2, o2, r2, n2, a2) {
          const s2 = t2.gl;
          this.program = s2.createProgram();
          const l2 = _i(o2.staticAttributes), c2 = r2 ? r2.getBinderAttributes() : [], h2 = l2.concat(c2), u2 = o2.staticUniforms ? _i(o2.staticUniforms) : [], d2 = r2 ? r2.getBinderUniforms() : [], _2 = u2.concat(d2), p2 = [];
          for (const e2 of _2)
            p2.indexOf(e2) < 0 && p2.push(e2);
          let m2 = r2 ? r2.defines() : [];
          m2 = m2.concat(a2.map((e2) => `#define ${e2}`));
          const f2 = m2.concat(Xt.fragmentSource, Ht, $t.fragmentSource, o2.fragmentSource).join("\n"), g2 = m2.concat(Xt.vertexSource, Ht, $t.vertexSource, Wt.vertexSource, o2.vertexSource).join("\n"), v2 = s2.createShader(s2.FRAGMENT_SHADER);
          if (s2.isContextLost())
            return void (this.failedToCreate = true);
          s2.shaderSource(v2, f2), s2.compileShader(v2), s2.attachShader(this.program, v2);
          const x2 = s2.createShader(s2.VERTEX_SHADER);
          if (s2.isContextLost())
            return void (this.failedToCreate = true);
          s2.shaderSource(x2, g2), s2.compileShader(x2), s2.attachShader(this.program, x2), this.attributes = {};
          const y2 = {};
          this.numAttributes = h2.length;
          for (let e2 = 0; e2 < this.numAttributes; e2++)
            h2[e2] && (s2.bindAttribLocation(this.program, e2, h2[e2]), this.attributes[h2[e2]] = e2);
          s2.linkProgram(this.program), s2.deleteShader(x2), s2.deleteShader(v2);
          for (let e2 = 0; e2 < p2.length; e2++) {
            const t3 = p2[e2];
            if (t3 && !y2[t3]) {
              const e3 = s2.getUniformLocation(this.program, t3);
              e3 && (y2[t3] = e3);
            }
          }
          this.fixedUniforms = n2(t2, y2), this.binderUniforms = r2 ? r2.getUniforms(t2, y2) : [], -1 !== a2.indexOf("TERRAIN") && (this.terrainUniforms = ((t3, i3) => ({ u_dem: new e.Uniform1i(t3, i3.u_dem), u_dem_prev: new e.Uniform1i(t3, i3.u_dem_prev), u_dem_unpack: new e.Uniform4f(t3, i3.u_dem_unpack), u_dem_tl: new e.Uniform2f(t3, i3.u_dem_tl), u_dem_scale: new e.Uniform1f(t3, i3.u_dem_scale), u_dem_tl_prev: new e.Uniform2f(t3, i3.u_dem_tl_prev), u_dem_scale_prev: new e.Uniform1f(t3, i3.u_dem_scale_prev), u_dem_size: new e.Uniform1f(t3, i3.u_dem_size), u_dem_lerp: new e.Uniform1f(t3, i3.u_dem_lerp), u_exaggeration: new e.Uniform1f(t3, i3.u_exaggeration), u_depth: new e.Uniform1i(t3, i3.u_depth), u_depth_size_inv: new e.Uniform2f(t3, i3.u_depth_size_inv), u_meter_to_dem: new e.Uniform1f(t3, i3.u_meter_to_dem), u_label_plane_matrix_inv: new e.UniformMatrix4f(t3, i3.u_label_plane_matrix_inv), u_tile_tl_up: new e.Uniform3f(t3, i3.u_tile_tl_up), u_tile_tr_up: new e.Uniform3f(t3, i3.u_tile_tr_up), u_tile_br_up: new e.Uniform3f(t3, i3.u_tile_br_up), u_tile_bl_up: new e.Uniform3f(t3, i3.u_tile_bl_up), u_tile_up_scale: new e.Uniform1f(t3, i3.u_tile_up_scale) }))(t2, y2)), -1 !== a2.indexOf("FOG") && (this.fogUniforms = ((t3, i3) => ({ u_fog_matrix: new e.UniformMatrix4f(t3, i3.u_fog_matrix), u_fog_range: new e.Uniform2f(t3, i3.u_fog_range), u_fog_color: new e.Uniform4f(t3, i3.u_fog_color), u_fog_horizon_blend: new e.Uniform1f(t3, i3.u_fog_horizon_blend), u_fog_temporal_offset: new e.Uniform1f(t3, i3.u_fog_temporal_offset) }))(t2, y2));
        }
        setTerrainUniformValues(e2, t2) {
          if (!this.terrainUniforms)
            return;
          const i2 = this.terrainUniforms;
          if (!this.failedToCreate) {
            e2.program.set(this.program);
            for (const e3 in t2)
              i2[e3].set(t2[e3]);
          }
        }
        setFogUniformValues(e2, t2) {
          if (!this.fogUniforms)
            return;
          const i2 = this.fogUniforms;
          if (!this.failedToCreate) {
            e2.program.set(this.program);
            for (const e3 in t2)
              i2[e3].location && i2[e3].set(t2[e3]);
          }
        }
        draw(e2, t2, i2, o2, r2, n2, a2, s2, l2, c2, h2, u2, d2, _2, p2, m2) {
          const f2 = e2.gl;
          if (this.failedToCreate)
            return;
          e2.program.set(this.program), e2.setDepthMode(i2), e2.setStencilMode(o2), e2.setColorMode(r2), e2.setCullFace(n2);
          for (const e3 in this.fixedUniforms)
            this.fixedUniforms[e3].set(a2[e3]);
          _2 && _2.setUniforms(e2, this.binderUniforms, u2, { zoom: d2 });
          const g2 = { [f2.LINES]: 2, [f2.TRIANGLES]: 3, [f2.LINE_STRIP]: 1 }[t2];
          for (const i3 of h2.get()) {
            const o3 = i3.vaos || (i3.vaos = {});
            (o3[s2] || (o3[s2] = new Jt())).bind(e2, this, l2, _2 ? _2.getPaintVertexBuffers() : [], c2, i3.vertexOffset, p2, m2), f2.drawElements(t2, i3.primitiveLength * g2, f2.UNSIGNED_SHORT, i3.primitiveOffset * g2 * 2);
          }
        }
      }
      function mi(e2, t2, i2) {
        const o2 = 1 / D(i2, 1, t2.transform.tileZoom), r2 = Math.pow(2, i2.tileID.overscaledZ), n2 = i2.tileSize * Math.pow(2, t2.transform.tileZoom) / r2, a2 = n2 * (i2.tileID.canonical.x + i2.tileID.wrap * r2), s2 = n2 * i2.tileID.canonical.y;
        return { u_image: 0, u_texsize: i2.imageAtlasTexture.size, u_scale: [o2, e2.fromScale, e2.toScale], u_fade: e2.t, u_pixel_coord_upper: [a2 >> 16, s2 >> 16], u_pixel_coord_lower: [65535 & a2, 65535 & s2] };
      }
      const fi = (t2, i2, o2, r2) => {
        const n2 = i2.style.light, a2 = n2.properties.get("position"), s2 = [a2.x, a2.y, a2.z], l2 = e.create$2();
        "viewport" === n2.properties.get("anchor") && (e.fromRotation(l2, -i2.transform.angle), e.transformMat3(s2, s2, l2));
        const c2 = n2.properties.get("color");
        return { u_matrix: t2, u_lightpos: s2, u_lightintensity: n2.properties.get("intensity"), u_lightcolor: [c2.r, c2.g, c2.b], u_vertical_gradient: +o2, u_opacity: r2 };
      }, gi = (t2, i2, o2, r2, n2, a2, s2) => e.extend(fi(t2, i2, o2, r2), mi(a2, i2, s2), { u_height_factor: -Math.pow(2, n2.overscaledZ) / s2.tileSize / 8 }), vi = (e2) => ({ u_matrix: e2 }), xi = (t2, i2, o2, r2) => e.extend(vi(t2), mi(o2, i2, r2)), yi = (e2, t2) => ({ u_matrix: e2, u_world: t2 }), bi = (t2, i2, o2, r2, n2) => e.extend(xi(t2, i2, o2, r2), { u_world: n2 }), wi = (t2, i2, o2, r2) => {
        const n2 = t2.transform;
        let a2;
        if ("map" === r2.paint.get("circle-pitch-alignment")) {
          const e2 = D(o2, 1, n2.zoom);
          a2 = [e2, e2];
        } else
          a2 = n2.pixelsToGLUnits;
        return { u_camera_to_center_distance: n2.cameraToCenterDistance, u_matrix: t2.translatePosMatrix(i2.projMatrix, o2, r2.paint.get("circle-translate"), r2.paint.get("circle-translate-anchor")), u_device_pixel_ratio: e.exported.devicePixelRatio, u_extrude_scale: a2 };
      }, Ti = (e2) => {
        const t2 = [];
        return "map" === e2.paint.get("circle-pitch-alignment") && t2.push("PITCH_WITH_MAP"), "map" === e2.paint.get("circle-pitch-scale") && t2.push("SCALE_WITH_MAP"), t2;
      }, Ei = (t2, i2, o2) => {
        const r2 = e.EXTENT / o2.tileSize;
        return { u_matrix: t2, u_camera_to_center_distance: i2.cameraToCenterDistance, u_extrude_scale: [i2.pixelsToGLUnits[0] / r2, i2.pixelsToGLUnits[1] / r2] };
      }, Ci = (e2, t2, i2 = 1) => ({ u_matrix: e2, u_color: t2, u_overlay: 0, u_overlay_scale: i2 }), Si = (e2, t2, i2, o2) => ({ u_matrix: e2, u_extrude_scale: D(t2, 1, i2), u_intensity: o2 }), Mi = (t2, i2, o2, r2, n2, a2) => {
        const s2 = t2.transform, l2 = { u_matrix: Ai(t2, i2, o2, n2), u_ratio: 1 / D(i2, 1, s2.zoom), u_device_pixel_ratio: e.exported.devicePixelRatio, u_units_to_pixels: [1 / s2.pixelsToGLUnits[0], 1 / s2.pixelsToGLUnits[1]], u_dash_image: 0, u_gradient_image: 1, u_image_height: a2, u_texsize: [0, 0], u_scale: [0, 0, 0], u_mix: 0 };
        if (Pi(o2)) {
          const e2 = Di(i2, t2.transform);
          l2.u_texsize = i2.lineAtlasTexture.size, l2.u_scale = [e2, r2.fromScale, r2.toScale], l2.u_mix = r2.t;
        }
        return l2;
      }, Ii = (t2, i2, o2, r2, n2) => {
        const a2 = t2.transform, s2 = Di(i2, a2);
        return { u_matrix: Ai(t2, i2, o2, n2), u_texsize: i2.imageAtlasTexture.size, u_ratio: 1 / D(i2, 1, a2.zoom), u_device_pixel_ratio: e.exported.devicePixelRatio, u_image: 0, u_scale: [s2, r2.fromScale, r2.toScale], u_fade: r2.t, u_units_to_pixels: [1 / a2.pixelsToGLUnits[0], 1 / a2.pixelsToGLUnits[1]] };
      };
      function Di(e2, t2) {
        return 1 / D(e2, 1, t2.tileZoom);
      }
      function Ai(e2, t2, i2, o2) {
        return e2.translatePosMatrix(o2 || t2.tileID.projMatrix, t2, i2.paint.get("line-translate"), i2.paint.get("line-translate-anchor"));
      }
      const zi = (e2) => {
        const t2 = [];
        return Pi(e2) && t2.push("RENDER_LINE_DASH"), e2.paint.get("line-gradient") && t2.push("RENDER_LINE_GRADIENT"), t2;
      };
      function Pi(e2) {
        const t2 = e2.paint.get("line-dasharray").value;
        return t2.value || "constant" !== t2.kind;
      }
      const Li = (e2, t2, i2, o2, r2) => {
        return { u_matrix: e2, u_tl_parent: t2, u_scale_parent: i2, u_buffer_scale: 1, u_fade_t: o2.mix, u_opacity: o2.opacity * r2.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: r2.paint.get("raster-brightness-min"), u_brightness_high: r2.paint.get("raster-brightness-max"), u_saturation_factor: (a2 = r2.paint.get("raster-saturation"), a2 > 0 ? 1 - 1 / (1.001 - a2) : -a2), u_contrast_factor: (n2 = r2.paint.get("raster-contrast"), n2 > 0 ? 1 / (1 - n2) : 1 + n2), u_spin_weights: Ri(r2.paint.get("raster-hue-rotate")) };
        var n2, a2;
      };
      function Ri(e2) {
        e2 *= Math.PI / 180;
        const t2 = Math.sin(e2), i2 = Math.cos(e2);
        return [(2 * i2 + 1) / 3, (-Math.sqrt(3) * t2 - i2 + 1) / 3, (Math.sqrt(3) * t2 - i2 + 1) / 3];
      }
      const ki = (e2, t2, i2, o2, r2, n2, a2, s2, l2, c2) => {
        const h2 = r2.transform;
        return { u_is_size_zoom_constant: +("constant" === e2 || "source" === e2), u_is_size_feature_constant: +("constant" === e2 || "camera" === e2), u_size_t: t2 ? t2.uSizeT : 0, u_size: t2 ? t2.uSize : 0, u_camera_to_center_distance: h2.cameraToCenterDistance, u_pitch: h2.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i2, u_aspect_ratio: h2.width / h2.height, u_fade_change: r2.options.fadeDuration ? r2.symbolFadeChange : 1, u_matrix: n2, u_label_plane_matrix: a2, u_coord_matrix: s2, u_is_text: +l2, u_pitch_with_map: +o2, u_texsize: c2, u_texture: 0 };
      }, Fi = (t2, i2, o2, r2, n2, a2, s2, l2, c2, h2, u2) => {
        const { cameraToCenterDistance: d2, _pitch: _2 } = n2.transform;
        return e.extend(ki(t2, i2, o2, r2, n2, a2, s2, l2, c2, h2), { u_gamma_scale: r2 ? d2 * Math.cos(n2.terrain ? 0 : _2) : 1, u_device_pixel_ratio: e.exported.devicePixelRatio, u_is_halo: +u2 });
      }, Oi = (t2, i2, o2, r2, n2, a2, s2, l2, c2, h2) => e.extend(Fi(t2, i2, o2, r2, n2, a2, s2, l2, true, c2, true), { u_texsize_icon: h2, u_texture_icon: 1 }), Bi = (e2, t2, i2) => ({ u_matrix: e2, u_opacity: t2, u_color: i2 }), Ui = (t2, i2, o2, r2, n2, a2) => e.extend(function(e2, t3, i3, o3) {
        const r3 = i3.imageManager.getPattern(e2.from.toString()), n3 = i3.imageManager.getPattern(e2.to.toString()), { width: a3, height: s2 } = i3.imageManager.getPixelSize(), l2 = Math.pow(2, o3.tileID.overscaledZ), c2 = o3.tileSize * Math.pow(2, i3.transform.tileZoom) / l2, h2 = c2 * (o3.tileID.canonical.x + o3.tileID.wrap * l2), u2 = c2 * o3.tileID.canonical.y;
        return { u_image: 0, u_pattern_tl_a: r3.tl, u_pattern_br_a: r3.br, u_pattern_tl_b: n3.tl, u_pattern_br_b: n3.br, u_texsize: [a3, s2], u_mix: t3.t, u_pattern_size_a: r3.displaySize, u_pattern_size_b: n3.displaySize, u_scale_a: t3.fromScale, u_scale_b: t3.toScale, u_tile_units_to_pixels: 1 / D(o3, 1, i3.transform.tileZoom), u_pixel_coord_upper: [h2 >> 16, u2 >> 16], u_pixel_coord_lower: [65535 & h2, 65535 & u2] };
      }(r2, a2, o2, n2), { u_matrix: t2, u_opacity: i2 }), Ni = { fillExtrusion: (t2, i2) => ({ u_matrix: new e.UniformMatrix4f(t2, i2.u_matrix), u_lightpos: new e.Uniform3f(t2, i2.u_lightpos), u_lightintensity: new e.Uniform1f(t2, i2.u_lightintensity), u_lightcolor: new e.Uniform3f(t2, i2.u_lightcolor), u_vertical_gradient: new e.Uniform1f(t2, i2.u_vertical_gradient), u_opacity: new e.Uniform1f(t2, i2.u_opacity) }), fillExtrusionPattern: (t2, i2) => ({ u_matrix: new e.UniformMatrix4f(t2, i2.u_matrix), u_lightpos: new e.Uniform3f(t2, i2.u_lightpos), u_lightintensity: new e.Uniform1f(t2, i2.u_lightintensity), u_lightcolor: new e.Uniform3f(t2, i2.u_lightcolor), u_vertical_gradient: new e.Uniform1f(t2, i2.u_vertical_gradient), u_height_factor: new e.Uniform1f(t2, i2.u_height_factor), u_image: new e.Uniform1i(t2, i2.u_image), u_texsize: new e.Uniform2f(t2, i2.u_texsize), u_pixel_coord_upper: new e.Uniform2f(t2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new e.Uniform2f(t2, i2.u_pixel_coord_lower), u_scale: new e.Uniform3f(t2, i2.u_scale), u_fade: new e.Uniform1f(t2, i2.u_fade), u_opacity: new e.Uniform1f(t2, i2.u_opacity) }), fill: (t2, i2) => ({ u_matrix: new e.UniformMatrix4f(t2, i2.u_matrix) }), fillPattern: (t2, i2) => ({ u_matrix: new e.UniformMatrix4f(t2, i2.u_matrix), u_image: new e.Uniform1i(t2, i2.u_image), u_texsize: new e.Uniform2f(t2, i2.u_texsize), u_pixel_coord_upper: new e.Uniform2f(t2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new e.Uniform2f(t2, i2.u_pixel_coord_lower), u_scale: new e.Uniform3f(t2, i2.u_scale), u_fade: new e.Uniform1f(t2, i2.u_fade) }), fillOutline: (t2, i2) => ({ u_matrix: new e.UniformMatrix4f(t2, i2.u_matrix), u_world: new e.Uniform2f(t2, i2.u_world) }), fillOutlinePattern: (t2, i2) => ({ u_matrix: new e.UniformMatrix4f(t2, i2.u_matrix), u_world: new e.Uniform2f(t2, i2.u_world), u_image: new e.Uniform1i(t2, i2.u_image), u_texsize: new e.Uniform2f(t2, i2.u_texsize), u_pixel_coord_upper: new e.Uniform2f(t2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new e.Uniform2f(t2, i2.u_pixel_coord_lower), u_scale: new e.Uniform3f(t2, i2.u_scale), u_fade: new e.Uniform1f(t2, i2.u_fade) }), circle: (t2, i2) => ({ u_camera_to_center_distance: new e.Uniform1f(t2, i2.u_camera_to_center_distance), u_extrude_scale: new e.Uniform2f(t2, i2.u_extrude_scale), u_device_pixel_ratio: new e.Uniform1f(t2, i2.u_device_pixel_ratio), u_matrix: new e.UniformMatrix4f(t2, i2.u_matrix) }), collisionBox: (t2, i2) => ({ u_matrix: new e.UniformMatrix4f(t2, i2.u_matrix), u_camera_to_center_distance: new e.Uniform1f(t2, i2.u_camera_to_center_distance), u_extrude_scale: new e.Uniform2f(t2, i2.u_extrude_scale) }), collisionCircle: (t2, i2) => ({ u_matrix: new e.UniformMatrix4f(t2, i2.u_matrix), u_inv_matrix: new e.UniformMatrix4f(t2, i2.u_inv_matrix), u_camera_to_center_distance: new e.Uniform1f(t2, i2.u_camera_to_center_distance), u_viewport_size: new e.Uniform2f(t2, i2.u_viewport_size) }), debug: (t2, i2) => ({ u_color: new e.UniformColor(t2, i2.u_color), u_matrix: new e.UniformMatrix4f(t2, i2.u_matrix), u_overlay: new e.Uniform1i(t2, i2.u_overlay), u_overlay_scale: new e.Uniform1f(t2, i2.u_overlay_scale) }), clippingMask: (t2, i2) => ({ u_matrix: new e.UniformMatrix4f(t2, i2.u_matrix) }), heatmap: (t2, i2) => ({ u_extrude_scale: new e.Uniform1f(t2, i2.u_extrude_scale), u_intensity: new e.Uniform1f(t2, i2.u_intensity), u_matrix: new e.UniformMatrix4f(t2, i2.u_matrix) }), heatmapTexture: (t2, i2) => ({ u_image: new e.Uniform1i(t2, i2.u_image), u_color_ramp: new e.Uniform1i(t2, i2.u_color_ramp), u_opacity: new e.Uniform1f(t2, i2.u_opacity) }), hillshade: (t2, i2) => ({ u_matrix: new e.UniformMatrix4f(t2, i2.u_matrix), u_image: new e.Uniform1i(t2, i2.u_image), u_latrange: new e.Uniform2f(t2, i2.u_latrange), u_light: new e.Uniform2f(t2, i2.u_light), u_shadow: new e.UniformColor(t2, i2.u_shadow), u_highlight: new e.UniformColor(t2, i2.u_highlight), u_accent: new e.UniformColor(t2, i2.u_accent) }), hillshadePrepare: (t2, i2) => ({ u_matrix: new e.UniformMatrix4f(t2, i2.u_matrix), u_image: new e.Uniform1i(t2, i2.u_image), u_dimension: new e.Uniform2f(t2, i2.u_dimension), u_zoom: new e.Uniform1f(t2, i2.u_zoom), u_unpack: new e.Uniform4f(t2, i2.u_unpack) }), line: (t2, i2) => ({ u_matrix: new e.UniformMatrix4f(t2, i2.u_matrix), u_ratio: new e.Uniform1f(t2, i2.u_ratio), u_device_pixel_ratio: new e.Uniform1f(t2, i2.u_device_pixel_ratio), u_units_to_pixels: new e.Uniform2f(t2, i2.u_units_to_pixels), u_dash_image: new e.Uniform1i(t2, i2.u_dash_image), u_gradient_image: new e.Uniform1i(t2, i2.u_gradient_image), u_image_height: new e.Uniform1f(t2, i2.u_image_height), u_texsize: new e.Uniform2f(t2, i2.u_texsize), u_scale: new e.Uniform3f(t2, i2.u_scale), u_mix: new e.Uniform1f(t2, i2.u_mix) }), linePattern: (t2, i2) => ({ u_matrix: new e.UniformMatrix4f(t2, i2.u_matrix), u_texsize: new e.Uniform2f(t2, i2.u_texsize), u_ratio: new e.Uniform1f(t2, i2.u_ratio), u_device_pixel_ratio: new e.Uniform1f(t2, i2.u_device_pixel_ratio), u_image: new e.Uniform1i(t2, i2.u_image), u_units_to_pixels: new e.Uniform2f(t2, i2.u_units_to_pixels), u_scale: new e.Uniform3f(t2, i2.u_scale), u_fade: new e.Uniform1f(t2, i2.u_fade) }), raster: (t2, i2) => ({ u_matrix: new e.UniformMatrix4f(t2, i2.u_matrix), u_tl_parent: new e.Uniform2f(t2, i2.u_tl_parent), u_scale_parent: new e.Uniform1f(t2, i2.u_scale_parent), u_buffer_scale: new e.Uniform1f(t2, i2.u_buffer_scale), u_fade_t: new e.Uniform1f(t2, i2.u_fade_t), u_opacity: new e.Uniform1f(t2, i2.u_opacity), u_image0: new e.Uniform1i(t2, i2.u_image0), u_image1: new e.Uniform1i(t2, i2.u_image1), u_brightness_low: new e.Uniform1f(t2, i2.u_brightness_low), u_brightness_high: new e.Uniform1f(t2, i2.u_brightness_high), u_saturation_factor: new e.Uniform1f(t2, i2.u_saturation_factor), u_contrast_factor: new e.Uniform1f(t2, i2.u_contrast_factor), u_spin_weights: new e.Uniform3f(t2, i2.u_spin_weights) }), symbolIcon: (t2, i2) => ({ u_is_size_zoom_constant: new e.Uniform1i(t2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new e.Uniform1i(t2, i2.u_is_size_feature_constant), u_size_t: new e.Uniform1f(t2, i2.u_size_t), u_size: new e.Uniform1f(t2, i2.u_size), u_camera_to_center_distance: new e.Uniform1f(t2, i2.u_camera_to_center_distance), u_pitch: new e.Uniform1f(t2, i2.u_pitch), u_rotate_symbol: new e.Uniform1i(t2, i2.u_rotate_symbol), u_aspect_ratio: new e.Uniform1f(t2, i2.u_aspect_ratio), u_fade_change: new e.Uniform1f(t2, i2.u_fade_change), u_matrix: new e.UniformMatrix4f(t2, i2.u_matrix), u_label_plane_matrix: new e.UniformMatrix4f(t2, i2.u_label_plane_matrix), u_coord_matrix: new e.UniformMatrix4f(t2, i2.u_coord_matrix), u_is_text: new e.Uniform1i(t2, i2.u_is_text), u_pitch_with_map: new e.Uniform1i(t2, i2.u_pitch_with_map), u_texsize: new e.Uniform2f(t2, i2.u_texsize), u_texture: new e.Uniform1i(t2, i2.u_texture) }), symbolSDF: (t2, i2) => ({ u_is_size_zoom_constant: new e.Uniform1i(t2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new e.Uniform1i(t2, i2.u_is_size_feature_constant), u_size_t: new e.Uniform1f(t2, i2.u_size_t), u_size: new e.Uniform1f(t2, i2.u_size), u_camera_to_center_distance: new e.Uniform1f(t2, i2.u_camera_to_center_distance), u_pitch: new e.Uniform1f(t2, i2.u_pitch), u_rotate_symbol: new e.Uniform1i(t2, i2.u_rotate_symbol), u_aspect_ratio: new e.Uniform1f(t2, i2.u_aspect_ratio), u_fade_change: new e.Uniform1f(t2, i2.u_fade_change), u_matrix: new e.UniformMatrix4f(t2, i2.u_matrix), u_label_plane_matrix: new e.UniformMatrix4f(t2, i2.u_label_plane_matrix), u_coord_matrix: new e.UniformMatrix4f(t2, i2.u_coord_matrix), u_is_text: new e.Uniform1i(t2, i2.u_is_text), u_pitch_with_map: new e.Uniform1i(t2, i2.u_pitch_with_map), u_texsize: new e.Uniform2f(t2, i2.u_texsize), u_texture: new e.Uniform1i(t2, i2.u_texture), u_gamma_scale: new e.Uniform1f(t2, i2.u_gamma_scale), u_device_pixel_ratio: new e.Uniform1f(t2, i2.u_device_pixel_ratio), u_is_halo: new e.Uniform1i(t2, i2.u_is_halo) }), symbolTextAndIcon: (t2, i2) => ({ u_is_size_zoom_constant: new e.Uniform1i(t2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new e.Uniform1i(t2, i2.u_is_size_feature_constant), u_size_t: new e.Uniform1f(t2, i2.u_size_t), u_size: new e.Uniform1f(t2, i2.u_size), u_camera_to_center_distance: new e.Uniform1f(t2, i2.u_camera_to_center_distance), u_pitch: new e.Uniform1f(t2, i2.u_pitch), u_rotate_symbol: new e.Uniform1i(t2, i2.u_rotate_symbol), u_aspect_ratio: new e.Uniform1f(t2, i2.u_aspect_ratio), u_fade_change: new e.Uniform1f(t2, i2.u_fade_change), u_matrix: new e.UniformMatrix4f(t2, i2.u_matrix), u_label_plane_matrix: new e.UniformMatrix4f(t2, i2.u_label_plane_matrix), u_coord_matrix: new e.UniformMatrix4f(t2, i2.u_coord_matrix), u_is_text: new e.Uniform1i(t2, i2.u_is_text), u_pitch_with_map: new e.Uniform1i(t2, i2.u_pitch_with_map), u_texsize: new e.Uniform2f(t2, i2.u_texsize), u_texsize_icon: new e.Uniform2f(t2, i2.u_texsize_icon), u_texture: new e.Uniform1i(t2, i2.u_texture), u_texture_icon: new e.Uniform1i(t2, i2.u_texture_icon), u_gamma_scale: new e.Uniform1f(t2, i2.u_gamma_scale), u_device_pixel_ratio: new e.Uniform1f(t2, i2.u_device_pixel_ratio), u_is_halo: new e.Uniform1i(t2, i2.u_is_halo) }), background: (t2, i2) => ({ u_matrix: new e.UniformMatrix4f(t2, i2.u_matrix), u_opacity: new e.Uniform1f(t2, i2.u_opacity), u_color: new e.UniformColor(t2, i2.u_color) }), backgroundPattern: (t2, i2) => ({ u_matrix: new e.UniformMatrix4f(t2, i2.u_matrix), u_opacity: new e.Uniform1f(t2, i2.u_opacity), u_image: new e.Uniform1i(t2, i2.u_image), u_pattern_tl_a: new e.Uniform2f(t2, i2.u_pattern_tl_a), u_pattern_br_a: new e.Uniform2f(t2, i2.u_pattern_br_a), u_pattern_tl_b: new e.Uniform2f(t2, i2.u_pattern_tl_b), u_pattern_br_b: new e.Uniform2f(t2, i2.u_pattern_br_b), u_texsize: new e.Uniform2f(t2, i2.u_texsize), u_mix: new e.Uniform1f(t2, i2.u_mix), u_pattern_size_a: new e.Uniform2f(t2, i2.u_pattern_size_a), u_pattern_size_b: new e.Uniform2f(t2, i2.u_pattern_size_b), u_scale_a: new e.Uniform1f(t2, i2.u_scale_a), u_scale_b: new e.Uniform1f(t2, i2.u_scale_b), u_pixel_coord_upper: new e.Uniform2f(t2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new e.Uniform2f(t2, i2.u_pixel_coord_lower), u_tile_units_to_pixels: new e.Uniform1f(t2, i2.u_tile_units_to_pixels) }), terrainRaster: oi, terrainDepth: oi, skybox: (t2, i2) => ({ u_matrix: new e.UniformMatrix4f(t2, i2.u_matrix), u_sun_direction: new e.Uniform3f(t2, i2.u_sun_direction), u_cubemap: new e.Uniform1i(t2, i2.u_cubemap), u_opacity: new e.Uniform1f(t2, i2.u_opacity), u_temporal_offset: new e.Uniform1f(t2, i2.u_temporal_offset) }), skyboxGradient: (t2, i2) => ({ u_matrix: new e.UniformMatrix4f(t2, i2.u_matrix), u_color_ramp: new e.Uniform1i(t2, i2.u_color_ramp), u_center_direction: new e.Uniform3f(t2, i2.u_center_direction), u_radius: new e.Uniform1f(t2, i2.u_radius), u_opacity: new e.Uniform1f(t2, i2.u_opacity), u_temporal_offset: new e.Uniform1f(t2, i2.u_temporal_offset) }), skyboxCapture: (t2, i2) => ({ u_matrix_3f: new e.UniformMatrix3f(t2, i2.u_matrix_3f), u_sun_direction: new e.Uniform3f(t2, i2.u_sun_direction), u_sun_intensity: new e.Uniform1f(t2, i2.u_sun_intensity), u_color_tint_r: new e.Uniform4f(t2, i2.u_color_tint_r), u_color_tint_m: new e.Uniform4f(t2, i2.u_color_tint_m), u_luminance: new e.Uniform1f(t2, i2.u_luminance) }) };
      let Gi;
      function Zi(t2, i2, o2, r2, n2, a2, s2) {
        const l2 = t2.context, c2 = l2.gl, h2 = t2.useProgram("collisionBox"), u2 = [];
        let d2 = 0, _2 = 0;
        for (let p3 = 0; p3 < r2.length; p3++) {
          const m3 = r2[p3], f3 = i2.getTile(m3), g3 = f3.getBucket(o2);
          if (!g3)
            continue;
          let v3 = m3.projMatrix;
          0 === n2[0] && 0 === n2[1] || (v3 = t2.translatePosMatrix(m3.projMatrix, f3, n2, a2));
          const x3 = s2 ? g3.textCollisionBox : g3.iconCollisionBox, y2 = g3.collisionCircleArray;
          if (y2.length > 0) {
            const i3 = e.create$1(), o3 = v3;
            e.mul$1(i3, g3.placementInvProjMatrix, t2.transform.glCoordMatrix), e.mul$1(i3, i3, g3.placementViewportMatrix), u2.push({ circleArray: y2, circleOffset: _2, transform: o3, invTransform: i3 }), d2 += y2.length / 4, _2 = d2;
          }
          x3 && (t2.terrain && t2.terrain.setupElevationDraw(f3, h2), h2.draw(l2, c2.LINES, e.DepthMode.disabled, e.StencilMode.disabled, t2.colorModeForRenderPass(), e.CullFaceMode.disabled, Ei(v3, t2.transform, f3), o2.id, x3.layoutVertexBuffer, x3.indexBuffer, x3.segments, null, t2.transform.zoom, null, x3.collisionVertexBuffer, x3.collisionVertexBufferExt));
        }
        if (!s2 || !u2.length)
          return;
        const p2 = t2.useProgram("collisionCircle"), m2 = new e.StructArrayLayout2f1f2i16();
        m2.resize(4 * d2), m2._trim();
        let f2 = 0;
        for (const e2 of u2)
          for (let t3 = 0; t3 < e2.circleArray.length / 4; t3++) {
            const i3 = 4 * t3, o3 = e2.circleArray[i3 + 0], r3 = e2.circleArray[i3 + 1], n3 = e2.circleArray[i3 + 2], a3 = e2.circleArray[i3 + 3];
            m2.emplace(f2++, o3, r3, n3, a3, 0), m2.emplace(f2++, o3, r3, n3, a3, 1), m2.emplace(f2++, o3, r3, n3, a3, 2), m2.emplace(f2++, o3, r3, n3, a3, 3);
          }
        (!Gi || Gi.length < 2 * d2) && (Gi = function(t3) {
          const i3 = 2 * t3, o3 = new e.StructArrayLayout3ui6();
          o3.resize(i3), o3._trim();
          for (let e2 = 0; e2 < i3; e2++) {
            const t4 = 6 * e2;
            o3.uint16[t4 + 0] = 4 * e2 + 0, o3.uint16[t4 + 1] = 4 * e2 + 1, o3.uint16[t4 + 2] = 4 * e2 + 2, o3.uint16[t4 + 3] = 4 * e2 + 2, o3.uint16[t4 + 4] = 4 * e2 + 3, o3.uint16[t4 + 5] = 4 * e2 + 0;
          }
          return o3;
        }(d2));
        const g2 = l2.createIndexBuffer(Gi, true), v2 = l2.createVertexBuffer(m2, e.collisionCircleLayout.members, true);
        for (const i3 of u2) {
          const r3 = { u_matrix: i3.transform, u_inv_matrix: i3.invTransform, u_camera_to_center_distance: (x2 = t2.transform).cameraToCenterDistance, u_viewport_size: [x2.width, x2.height] };
          p2.draw(l2, c2.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, t2.colorModeForRenderPass(), e.CullFaceMode.disabled, r3, o2.id, v2, g2, e.SegmentVector.simpleSegment(0, 2 * i3.circleOffset, i3.circleArray.length, i3.circleArray.length / 2), null, t2.transform.zoom, null, null, null);
        }
        var x2;
        v2.destroy(), g2.destroy();
      }
      const Vi = e.identity(new Float32Array(16));
      function ji(t2, i2, o2, r2, n2, a2) {
        const { horizontalAlign: s2, verticalAlign: l2 } = e.getAnchorAlignment(t2), c2 = -(s2 - 0.5) * i2, h2 = -(l2 - 0.5) * o2, u2 = e.evaluateVariableOffset(t2, r2);
        return new e.pointGeometry((c2 / n2 + u2[0]) * a2, (h2 / n2 + u2[1]) * a2);
      }
      function qi(t2, i2, o2, r2, n2, a2, s2, l2, c2, h2, u2, d2) {
        const _2 = t2.text.placedSymbolArray, p2 = t2.text.dynamicLayoutVertexArray, m2 = t2.icon.dynamicLayoutVertexArray, f2 = {};
        p2.clear();
        for (let m3 = 0; m3 < _2.length; m3++) {
          const g2 = _2.get(m3), v2 = t2.allowVerticalPlacement && !g2.placedOrientation, x2 = g2.hidden || !g2.crossTileID || v2 ? null : r2[g2.crossTileID];
          if (x2) {
            const r3 = new e.pointGeometry(g2.tileAnchorX, g2.tileAnchorY), _3 = d2(r3), m4 = Ye(r3, o2 ? l2 : s2, _3), v3 = Je(a2.cameraToCenterDistance, m4.signedDistanceFromCamera);
            let y2 = n2.evaluateSizeForFeature(t2.textSizeData, h2, g2) * v3 / e.ONE_EM;
            o2 && (y2 *= t2.tilePixelRatio / c2);
            const { width: b2, height: w2, anchor: T2, textOffset: E2, textScale: C2 } = x2, S2 = ji(T2, b2, w2, E2, C2, y2), M2 = o2 ? Ye(r3.add(S2), s2, _3).point : m4.point.add(i2 ? S2.rotate(-a2.angle) : S2), I2 = t2.allowVerticalPlacement && g2.placedOrientation === e.WritingMode.vertical ? Math.PI / 2 : 0;
            for (let t3 = 0; t3 < g2.numGlyphs; t3++)
              e.addDynamicAttributes(p2, M2, I2);
            u2 && g2.associatedIconIndex >= 0 && (f2[g2.associatedIconIndex] = { shiftedAnchor: M2, angle: I2 });
          } else
            lt(g2.numGlyphs, p2);
        }
        if (u2) {
          m2.clear();
          const i3 = t2.icon.placedSymbolArray;
          for (let t3 = 0; t3 < i3.length; t3++) {
            const o3 = i3.get(t3);
            if (o3.hidden)
              lt(o3.numGlyphs, m2);
            else {
              const i4 = f2[t3];
              if (i4)
                for (let t4 = 0; t4 < o3.numGlyphs; t4++)
                  e.addDynamicAttributes(m2, i4.shiftedAnchor, i4.angle);
              else
                lt(o3.numGlyphs, m2);
            }
          }
          t2.icon.dynamicLayoutVertexBuffer.updateData(m2);
        }
        t2.text.dynamicLayoutVertexBuffer.updateData(p2);
      }
      function Wi(e2, t2, i2) {
        return i2.iconsInText && t2 ? "symbolTextAndIcon" : e2 ? "symbolSDF" : "symbolIcon";
      }
      function $i(t2, i2, o2, r2, n2, a2, s2, l2, c2, h2, u2, d2) {
        const _2 = t2.context, p2 = _2.gl, m2 = t2.transform, f2 = "map" === l2, g2 = "map" === c2, v2 = f2 && "point" !== o2.layout.get("symbol-placement"), x2 = f2 && !g2 && !v2, y2 = void 0 !== o2.layout.get("symbol-sort-key").constantOr(1);
        let b2 = false;
        const w2 = t2.depthModeForSublayer(0, e.DepthMode.ReadOnly), T2 = o2.layout.get("text-variable-anchor"), E2 = [], C2 = t2.terrain && g2 ? ["PITCH_WITH_MAP_TERRAIN"] : null;
        for (const l3 of r2) {
          const r3 = i2.getTile(l3), c3 = r3.getBucket(o2);
          if (!c3)
            continue;
          const u3 = n2 ? c3.text : c3.icon;
          if (!u3 || !u3.segments.get().length)
            continue;
          const d3 = u3.programConfigurations.get(o2.id), _3 = n2 || c3.sdfIcons, w3 = n2 ? c3.textSizeData : c3.iconSizeData, S2 = g2 || 0 !== m2.pitch, M2 = t2.useProgram(Wi(_3, n2, c3), d3, C2), I2 = e.evaluateSizeForZoom(w3, m2.zoom);
          let A2, z2, P2, L2, R2 = [0, 0], k2 = null;
          if (n2) {
            if (z2 = r3.glyphAtlasTexture, P2 = p2.LINEAR, A2 = r3.glyphAtlasTexture.size, c3.iconsInText) {
              R2 = r3.imageAtlasTexture.size, k2 = r3.imageAtlasTexture;
              const e2 = "composite" === w3.kind || "camera" === w3.kind;
              L2 = S2 || t2.options.rotating || t2.options.zooming || e2 ? p2.LINEAR : p2.NEAREST;
            }
          } else {
            const e2 = 1 !== o2.layout.get("icon-size").constantOr(0) || c3.iconsNeedLinear;
            z2 = r3.imageAtlasTexture, P2 = _3 || t2.options.rotating || t2.options.zooming || e2 || S2 ? p2.LINEAR : p2.NEAREST, A2 = r3.imageAtlasTexture.size;
          }
          const F2 = D(r3, 1, t2.transform.zoom), O2 = He(l3.projMatrix, g2, f2, t2.transform, F2), B2 = t2.terrain && g2 && v2 ? e.invert(new Float32Array(16), O2) : Vi, U2 = Ke(l3.projMatrix, g2, f2, t2.transform, F2), N2 = T2 && c3.hasTextData(), G2 = "none" !== o2.layout.get("icon-text-fit") && N2 && c3.hasIconData();
          if (v2) {
            const e2 = m2.elevation;
            et(c3, l3.projMatrix, t2, n2, O2, U2, g2, h2, e2 ? (t3) => e2.getAtTileOffset(l3, t3.x, t3.y) : null);
          }
          const Z2 = t2.translatePosMatrix(l3.projMatrix, r3, a2, s2), V2 = v2 || n2 && T2 || G2 ? Vi : O2, j2 = t2.translatePosMatrix(U2, r3, a2, s2, true), q2 = _3 && 0 !== o2.paint.get(n2 ? "text-halo-width" : "icon-halo-width").constantOr(1);
          let W2;
          W2 = _3 ? c3.iconsInText ? Oi(w3.kind, I2, x2, g2, t2, Z2, V2, j2, A2, R2) : Fi(w3.kind, I2, x2, g2, t2, Z2, V2, j2, n2, A2, true) : ki(w3.kind, I2, x2, g2, t2, Z2, V2, j2, n2, A2);
          const $2 = { program: M2, buffers: u3, uniformValues: W2, atlasTexture: z2, atlasTextureIcon: k2, atlasInterpolation: P2, atlasInterpolationIcon: L2, isSDF: _3, hasHalo: q2, tile: r3, labelPlaneMatrixInv: B2 };
          if (y2 && c3.canOverlap) {
            b2 = true;
            const t3 = u3.segments.get();
            for (const i3 of t3)
              E2.push({ segments: new e.SegmentVector([i3]), sortKey: i3.sortKey, state: $2 });
          } else
            E2.push({ segments: u3.segments, sortKey: 0, state: $2 });
        }
        b2 && E2.sort((e2, t3) => e2.sortKey - t3.sortKey);
        for (const e2 of E2) {
          const i3 = e2.state;
          if (t2.terrain && t2.terrain.setupElevationDraw(i3.tile, i3.program, { useDepthForOcclusion: true, labelPlaneMatrixInv: i3.labelPlaneMatrixInv }), _2.activeTexture.set(p2.TEXTURE0), i3.atlasTexture.bind(i3.atlasInterpolation, p2.CLAMP_TO_EDGE), i3.atlasTextureIcon && (_2.activeTexture.set(p2.TEXTURE1), i3.atlasTextureIcon && i3.atlasTextureIcon.bind(i3.atlasInterpolationIcon, p2.CLAMP_TO_EDGE)), i3.isSDF) {
            const r3 = i3.uniformValues;
            i3.hasHalo && (r3.u_is_halo = 1, Xi(i3.buffers, e2.segments, o2, t2, i3.program, w2, u2, d2, r3)), r3.u_is_halo = 0;
          }
          Xi(i3.buffers, e2.segments, o2, t2, i3.program, w2, u2, d2, i3.uniformValues);
        }
      }
      function Xi(t2, i2, o2, r2, n2, a2, s2, l2, c2) {
        const h2 = r2.context;
        n2.draw(h2, h2.gl.TRIANGLES, a2, s2, l2, e.CullFaceMode.disabled, c2, o2.id, t2.layoutVertexBuffer, t2.indexBuffer, i2, o2.paint, r2.transform.zoom, t2.programConfigurations.get(o2.id), t2.dynamicLayoutVertexBuffer, t2.opacityVertexBuffer);
      }
      function Hi(t2, i2, o2, r2, n2, a2, s2) {
        const l2 = t2.context.gl, c2 = o2.paint.get("fill-pattern"), h2 = c2 && c2.constantOr(1), u2 = o2.getCrossfadeParameters();
        let d2, _2, p2, m2, f2;
        s2 ? (_2 = h2 && !o2.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", d2 = l2.LINES) : (_2 = h2 ? "fillPattern" : "fill", d2 = l2.TRIANGLES);
        for (const g2 of r2) {
          const r3 = i2.getTile(g2);
          if (h2 && !r3.patternsLoaded())
            continue;
          const v2 = r3.getBucket(o2);
          if (!v2)
            continue;
          t2.prepareDrawTile(g2);
          const x2 = v2.programConfigurations.get(o2.id), y2 = t2.useProgram(_2, x2);
          h2 && (t2.context.activeTexture.set(l2.TEXTURE0), r3.imageAtlasTexture.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), x2.updatePaintBuffers(u2));
          const b2 = c2.constantOr(null);
          if (b2 && r3.imageAtlas) {
            const e2 = r3.imageAtlas, t3 = e2.patternPositions[b2.to.toString()], i3 = e2.patternPositions[b2.from.toString()];
            t3 && i3 && x2.setConstantPatternPositions(t3, i3);
          }
          const w2 = t2.translatePosMatrix(g2.projMatrix, r3, o2.paint.get("fill-translate"), o2.paint.get("fill-translate-anchor"));
          if (s2) {
            m2 = v2.indexBuffer2, f2 = v2.segments2;
            const e2 = t2.terrain && t2.terrain.renderingToTexture ? t2.terrain.drapeBufferSize : [l2.drawingBufferWidth, l2.drawingBufferHeight];
            p2 = "fillOutlinePattern" === _2 && h2 ? bi(w2, t2, u2, r3, e2) : yi(w2, e2);
          } else
            m2 = v2.indexBuffer, f2 = v2.segments, p2 = h2 ? xi(w2, t2, u2, r3) : vi(w2);
          t2.prepareDrawProgram(t2.context, y2, g2.toUnwrapped()), y2.draw(t2.context, d2, n2, t2.stencilModeForClipping(g2), a2, e.CullFaceMode.disabled, p2, o2.id, v2.layoutVertexBuffer, m2, f2, o2.paint, t2.transform.zoom, x2);
        }
      }
      function Ki(t2, i2, o2, r2, n2, a2, s2) {
        const l2 = t2.context, c2 = l2.gl, h2 = o2.paint.get("fill-extrusion-pattern"), u2 = h2.constantOr(1), d2 = o2.getCrossfadeParameters(), _2 = o2.paint.get("fill-extrusion-opacity");
        for (const p2 of r2) {
          const r3 = i2.getTile(p2), m2 = r3.getBucket(o2);
          if (!m2)
            continue;
          const f2 = m2.programConfigurations.get(o2.id), g2 = t2.useProgram(u2 ? "fillExtrusionPattern" : "fillExtrusion", f2);
          if (t2.terrain) {
            const e2 = t2.terrain;
            if (!m2.enableTerrain)
              continue;
            if (e2.setupElevationDraw(r3, g2, { useMeterToDem: true }), Yi(l2, i2, p2, m2, o2, e2), !m2.centroidVertexBuffer) {
              const e3 = g2.attributes.a_centroid_pos;
              void 0 !== e3 && c2.vertexAttrib2f(e3, 0, 0);
            }
          }
          u2 && (t2.context.activeTexture.set(c2.TEXTURE0), r3.imageAtlasTexture.bind(c2.LINEAR, c2.CLAMP_TO_EDGE), f2.updatePaintBuffers(d2));
          const v2 = h2.constantOr(null);
          if (v2 && r3.imageAtlas) {
            const e2 = r3.imageAtlas, t3 = e2.patternPositions[v2.to.toString()], i3 = e2.patternPositions[v2.from.toString()];
            t3 && i3 && f2.setConstantPatternPositions(t3, i3);
          }
          const x2 = t2.translatePosMatrix(p2.projMatrix, r3, o2.paint.get("fill-extrusion-translate"), o2.paint.get("fill-extrusion-translate-anchor")), y2 = o2.paint.get("fill-extrusion-vertical-gradient"), b2 = u2 ? gi(x2, t2, y2, _2, p2, d2, r3) : fi(x2, t2, y2, _2);
          t2.prepareDrawProgram(l2, g2, p2.toUnwrapped()), g2.draw(l2, l2.gl.TRIANGLES, n2, a2, s2, e.CullFaceMode.backCCW, b2, o2.id, m2.layoutVertexBuffer, m2.indexBuffer, m2.segments, o2.paint, t2.transform.zoom, f2, t2.terrain ? m2.centroidVertexBuffer : null);
        }
      }
      function Yi(t2, i2, o2, r2, n2, a2) {
        const s2 = [(t3) => {
          let i3 = t3.canonical.x - 1, o3 = t3.wrap;
          return i3 < 0 && (i3 = (1 << t3.canonical.z) - 1, o3--), new e.OverscaledTileID(t3.overscaledZ, o3, t3.canonical.z, i3, t3.canonical.y);
        }, (t3) => {
          let i3 = t3.canonical.x + 1, o3 = t3.wrap;
          return i3 === 1 << t3.canonical.z && (i3 = 0, o3++), new e.OverscaledTileID(t3.overscaledZ, o3, t3.canonical.z, i3, t3.canonical.y);
        }, (t3) => new e.OverscaledTileID(t3.overscaledZ, t3.wrap, t3.canonical.z, t3.canonical.x, (0 === t3.canonical.y ? 1 << t3.canonical.z : t3.canonical.y) - 1), (t3) => new e.OverscaledTileID(t3.overscaledZ, t3.wrap, t3.canonical.z, t3.canonical.x, t3.canonical.y === (1 << t3.canonical.z) - 1 ? 0 : t3.canonical.y + 1)], l2 = (e2) => {
          const t3 = i2.getSource().maxzoom, o3 = (e3) => {
            const t4 = i2.getTileByID(e3);
            if (t4 && t4.hasData())
              return t4.getBucket(n2);
          };
          let r3, a3, s3;
          return (e2.overscaledZ === e2.canonical.z || e2.overscaledZ >= t3) && (r3 = o3(e2.key)), e2.overscaledZ >= t3 && (a3 = o3(e2.calculateScaledKey(e2.overscaledZ + 1))), e2.overscaledZ > t3 && (s3 = o3(e2.calculateScaledKey(e2.overscaledZ - 1))), r3 || a3 || s3;
        }, c2 = [0, 0, 0], h2 = (t3, i3) => (c2[0] = Math.min(t3.min.y, i3.min.y), c2[1] = Math.max(t3.max.y, i3.max.y), c2[2] = e.EXTENT - i3.min.x > t3.max.x ? i3.min.x - e.EXTENT : t3.max.x, c2), u2 = (t3, i3) => (c2[0] = Math.min(t3.min.x, i3.min.x), c2[1] = Math.max(t3.max.x, i3.max.x), c2[2] = e.EXTENT - i3.min.y > t3.max.y ? i3.min.y - e.EXTENT : t3.max.y, c2), d2 = [(e2, t3) => h2(e2, t3), (e2, t3) => h2(t3, e2), (e2, t3) => u2(e2, t3), (e2, t3) => u2(t3, e2)], _2 = new e.pointGeometry(0, 0);
        let p2, m2, f2;
        const g2 = (t3, i3, r3, n3, s3) => {
          const l3 = [[n3 ? r3 : t3, n3 ? t3 : r3, 0], [n3 ? r3 : i3, n3 ? i3 : r3, 0]], c3 = s3 < 0 ? e.EXTENT + s3 : s3, h3 = [n3 ? c3 : (t3 + i3) / 2, n3 ? (t3 + i3) / 2 : c3, 0];
          return 0 === r3 && s3 < 0 || 0 !== r3 && s3 > 0 ? a2.getForTilePoints(f2, [h3], true, m2) : l3.push(h3), a2.getForTilePoints(o2, l3, true, p2), Math.max(l3[0][2], l3[1][2], h3[2]) / a2.exaggeration();
        };
        for (let t3 = 0; t3 < 4; t3++) {
          const i3 = r2.borders[t3];
          if (0 === i3.length && (r2.borderDone[t3] = true), r2.borderDone[t3])
            continue;
          const n3 = f2 = s2[t3](o2), c3 = l2(n3);
          if (!c3 || !c3.enableTerrain)
            continue;
          if (m2 = a2.findDEMTileFor(n3), !m2 || !m2.dem)
            continue;
          if (!p2) {
            const e2 = a2.findDEMTileFor(o2);
            if (!e2 || !e2.dem)
              return;
            p2 = e2;
          }
          const h3 = (t3 < 2 ? 1 : 5) - t3, u3 = c3.borders[h3];
          let v2 = 0;
          for (let o3 = 0; o3 < i3.length; o3++) {
            const n4 = r2.featuresOnBorder[i3[o3]], a3 = n4.borders[t3];
            let s3;
            for (; v2 < u3.length && (s3 = c3.featuresOnBorder[u3[v2]], !(s3.borders[h3][1] > a3[0] + 3)); )
              c3.borderDone[h3] || c3.encodeCentroid(void 0, s3, false), v2++;
            if (s3 && v2 < u3.length) {
              const i4 = v2;
              let o4 = 0;
              for (; !(s3.borders[h3][0] > a3[1] - 3) && (o4++, ++v2 !== u3.length); )
                s3 = c3.featuresOnBorder[u3[v2]];
              if (s3 = c3.featuresOnBorder[u3[i4]], n4.intersectsCount() > 1 || s3.intersectsCount() > 1 || 1 !== o4) {
                1 !== o4 && (v2 = i4), r2.encodeCentroid(void 0, n4, false), c3.borderDone[h3] || c3.encodeCentroid(void 0, s3, false);
                continue;
              }
              const l3 = d2[t3](n4, s3), p3 = t3 % 2 ? e.EXTENT - 1 : 0;
              _2.x = g2(l3[0], Math.min(e.EXTENT - 1, l3[1]), p3, t3 < 2, l3[2]), _2.y = 0, r2.encodeCentroid(_2, n4, false), c3.borderDone[h3] || c3.encodeCentroid(_2, s3, false);
            } else
              r2.encodeCentroid(void 0, n4, false);
          }
          r2.borderDone[t3] = r2.needsCentroidUpdate = true, c3.borderDone[h3] || (c3.borderDone[h3] = c3.needsCentroidUpdate = true);
        }
        (r2.needsCentroidUpdate || !r2.centroidVertexBuffer && 0 !== r2.centroidVertexArray.length) && r2.uploadCentroid(t2);
      }
      const Ji = new e.Color(1, 0, 0, 1), Qi = new e.Color(0, 1, 0, 1), eo = new e.Color(0, 0, 1, 1), to = new e.Color(1, 0, 1, 1), io = new e.Color(0, 1, 1, 1);
      function oo(e2, t2, i2, o2) {
        no(e2, 0, t2 + i2 / 2, e2.transform.width, i2, o2);
      }
      function ro(e2, t2, i2, o2) {
        no(e2, t2 - i2 / 2, 0, i2, e2.transform.height, o2);
      }
      function no(t2, i2, o2, r2, n2, a2) {
        const s2 = t2.context, l2 = s2.gl;
        l2.enable(l2.SCISSOR_TEST), l2.scissor(i2 * e.exported.devicePixelRatio, o2 * e.exported.devicePixelRatio, r2 * e.exported.devicePixelRatio, n2 * e.exported.devicePixelRatio), s2.clear({ color: a2 }), l2.disable(l2.SCISSOR_TEST);
      }
      function ao(t2, i2, o2) {
        const r2 = t2.context, n2 = r2.gl, a2 = o2.projMatrix, s2 = t2.useProgram("debug"), l2 = i2.getTileByID(o2.key);
        t2.terrain && t2.terrain.setupElevationDraw(l2, s2);
        const c2 = e.DepthMode.disabled, h2 = e.StencilMode.disabled, u2 = t2.colorModeForRenderPass(), d2 = "$debug";
        r2.activeTexture.set(n2.TEXTURE0), t2.emptyTexture.bind(n2.LINEAR, n2.CLAMP_TO_EDGE), s2.draw(r2, n2.LINE_STRIP, c2, h2, u2, e.CullFaceMode.disabled, Ci(a2, e.Color.red), d2, t2.debugBuffer, t2.tileBorderIndexBuffer, t2.debugSegments);
        const _2 = l2.latestRawTileData, p2 = Math.floor((_2 && _2.byteLength || 0) / 1024), m2 = i2.getTile(o2).tileSize, f2 = 512 / Math.min(m2, 512) * (o2.overscaledZ / t2.transform.zoom) * 0.5;
        let g2 = o2.canonical.toString();
        o2.overscaledZ !== o2.canonical.z && (g2 += ` => ${o2.overscaledZ}`), function(e2, t3) {
          e2.initDebugOverlayCanvas();
          const i3 = e2.debugOverlayCanvas, o3 = e2.context.gl, r3 = e2.debugOverlayCanvas.getContext("2d");
          r3.clearRect(0, 0, i3.width, i3.height), r3.shadowColor = "white", r3.shadowBlur = 2, r3.lineWidth = 1.5, r3.strokeStyle = "white", r3.textBaseline = "top", r3.font = "bold 36px Open Sans, sans-serif", r3.fillText(t3, 5, 5), r3.strokeText(t3, 5, 5), e2.debugOverlayTexture.update(i3), e2.debugOverlayTexture.bind(o3.LINEAR, o3.CLAMP_TO_EDGE);
        }(t2, `${g2} ${p2}kb`), s2.draw(r2, n2.TRIANGLES, c2, h2, e.ColorMode.alphaBlended, e.CullFaceMode.disabled, Ci(a2, e.Color.transparent, f2), d2, t2.debugBuffer, t2.quadTriangleIndexBuffer, t2.debugSegments);
      }
      const so = e.createLayout([{ name: "a_pos_3f", components: 3, type: "Float32" }]), { members: lo } = so;
      function co(e2, t2, i2, o2) {
        e2.emplaceBack(t2, i2, o2);
      }
      class ho {
        constructor(t2) {
          this.vertexArray = new e.StructArrayLayout3f12(), this.indices = new e.StructArrayLayout3ui6(), co(this.vertexArray, -1, -1, 1), co(this.vertexArray, 1, -1, 1), co(this.vertexArray, -1, 1, 1), co(this.vertexArray, 1, 1, 1), co(this.vertexArray, -1, -1, -1), co(this.vertexArray, 1, -1, -1), co(this.vertexArray, -1, 1, -1), co(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t2.createVertexBuffer(this.vertexArray, lo), this.indexBuffer = t2.createIndexBuffer(this.indices), this.segment = e.SegmentVector.simpleSegment(0, 0, 36, 12);
        }
      }
      function uo(t2, i2, o2, r2, n2, a2) {
        const s2 = t2.gl, l2 = i2.paint.get("sky-atmosphere-color"), c2 = i2.paint.get("sky-atmosphere-halo-color"), h2 = i2.paint.get("sky-atmosphere-sun-intensity"), u2 = ((e2, t3, i3, o3, r3) => ({ u_matrix_3f: e2, u_sun_direction: t3, u_sun_intensity: i3, u_color_tint_r: [o3.r, o3.g, o3.b, o3.a], u_color_tint_m: [r3.r, r3.g, r3.b, r3.a], u_luminance: 5e-5 }))(e.fromMat4([], r2), n2, h2, l2, c2);
        s2.framebufferTexture2D(s2.FRAMEBUFFER, s2.COLOR_ATTACHMENT0, s2.TEXTURE_CUBE_MAP_POSITIVE_X + a2, i2.skyboxTexture, 0), o2.draw(t2, s2.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, e.ColorMode.unblended, e.CullFaceMode.frontCW, u2, "skyboxCapture", i2.skyboxGeometry.vertexBuffer, i2.skyboxGeometry.indexBuffer, i2.skyboxGeometry.segment);
      }
      const _o = { symbol: function(t2, i2, o2, r2, n2) {
        if ("translucent" !== t2.renderPass)
          return;
        const a2 = e.StencilMode.disabled, s2 = t2.colorModeForRenderPass();
        o2.layout.get("text-variable-anchor") && function(t3, i3, o3, r3, n3, a3, s3) {
          const l2 = i3.transform, c2 = "map" === n3, h2 = "map" === a3;
          for (const n4 of t3) {
            const t4 = r3.getTile(n4), a4 = t4.getBucket(o3);
            if (!a4 || !a4.text || !a4.text.segments.get().length)
              continue;
            const u2 = e.evaluateSizeForZoom(a4.textSizeData, l2.zoom), d2 = D(t4, 1, i3.transform.zoom), _2 = He(n4.projMatrix, h2, c2, i3.transform, d2), p2 = "none" !== o3.layout.get("icon-text-fit") && a4.hasIconData();
            if (u2) {
              const i4 = Math.pow(2, l2.zoom - t4.tileID.overscaledZ), o4 = l2.elevation;
              qi(a4, c2, h2, s3, e.symbolSize, l2, _2, n4.projMatrix, i4, u2, p2, o4 ? (e2) => o4.getAtTileOffset(n4, e2.x, e2.y) : (e2) => 0);
            }
          }
        }(r2, t2, o2, i2, o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), n2), 0 !== o2.paint.get("icon-opacity").constantOr(1) && $i(t2, i2, o2, r2, false, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), o2.layout.get("icon-rotation-alignment"), o2.layout.get("icon-pitch-alignment"), o2.layout.get("icon-keep-upright"), a2, s2), 0 !== o2.paint.get("text-opacity").constantOr(1) && $i(t2, i2, o2, r2, true, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), o2.layout.get("text-keep-upright"), a2, s2), i2.map.showCollisionBoxes && (Zi(t2, i2, o2, r2, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), true), Zi(t2, i2, o2, r2, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), false));
      }, circle: function(t2, i2, o2, r2) {
        if ("translucent" !== t2.renderPass)
          return;
        const n2 = o2.paint.get("circle-opacity"), a2 = o2.paint.get("circle-stroke-width"), s2 = o2.paint.get("circle-stroke-opacity"), l2 = void 0 !== o2.layout.get("circle-sort-key").constantOr(1);
        if (0 === n2.constantOr(1) && (0 === a2.constantOr(1) || 0 === s2.constantOr(1)))
          return;
        const c2 = t2.context, h2 = c2.gl, u2 = t2.depthModeForSublayer(0, e.DepthMode.ReadOnly), d2 = e.StencilMode.disabled, _2 = t2.colorModeForRenderPass(), p2 = [];
        for (let n3 = 0; n3 < r2.length; n3++) {
          const a3 = r2[n3], s3 = i2.getTile(a3), c3 = s3.getBucket(o2);
          if (!c3)
            continue;
          const h3 = c3.programConfigurations.get(o2.id), u3 = Ti(o2), d3 = { programConfiguration: h3, program: t2.useProgram("circle", h3, u3), layoutVertexBuffer: c3.layoutVertexBuffer, indexBuffer: c3.indexBuffer, uniformValues: wi(t2, a3, s3, o2), tile: s3 };
          if (l2) {
            const t3 = c3.segments.get();
            for (const i3 of t3)
              p2.push({ segments: new e.SegmentVector([i3]), sortKey: i3.sortKey, state: d3 });
          } else
            p2.push({ segments: c3.segments, sortKey: 0, state: d3 });
        }
        l2 && p2.sort((e2, t3) => e2.sortKey - t3.sortKey);
        for (const i3 of p2) {
          const { programConfiguration: r3, program: n3, layoutVertexBuffer: a3, indexBuffer: s3, uniformValues: l3, tile: p3 } = i3.state, m2 = i3.segments;
          t2.terrain && t2.terrain.setupElevationDraw(p3, n3, { useDepthForOcclusion: true }), t2.prepareDrawProgram(c2, n3, p3.tileID.toUnwrapped()), n3.draw(c2, h2.TRIANGLES, u2, d2, _2, e.CullFaceMode.disabled, l3, o2.id, a3, s3, m2, o2.paint, t2.transform.zoom, r3);
        }
      }, heatmap: function(t2, i2, o2, r2) {
        if (0 !== o2.paint.get("heatmap-opacity"))
          if ("offscreen" === t2.renderPass) {
            const n2 = t2.context, a2 = n2.gl, s2 = e.StencilMode.disabled, l2 = new e.ColorMode([a2.ONE, a2.ONE], e.Color.transparent, [true, true, true, true]);
            !function(e2, t3, i3) {
              const o3 = e2.gl;
              e2.activeTexture.set(o3.TEXTURE1), e2.viewport.set([0, 0, t3.width / 4, t3.height / 4]);
              let r3 = i3.heatmapFbo;
              if (r3)
                o3.bindTexture(o3.TEXTURE_2D, r3.colorAttachment.get()), e2.bindFramebuffer.set(r3.framebuffer);
              else {
                const n3 = o3.createTexture();
                o3.bindTexture(o3.TEXTURE_2D, n3), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_WRAP_S, o3.CLAMP_TO_EDGE), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_WRAP_T, o3.CLAMP_TO_EDGE), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_MIN_FILTER, o3.LINEAR), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_MAG_FILTER, o3.LINEAR), r3 = i3.heatmapFbo = e2.createFramebuffer(t3.width / 4, t3.height / 4, false), function(e3, t4, i4, o4) {
                  const r4 = e3.gl;
                  r4.texImage2D(r4.TEXTURE_2D, 0, r4.RGBA, t4.width / 4, t4.height / 4, 0, r4.RGBA, e3.extRenderToTextureHalfFloat ? e3.extTextureHalfFloat.HALF_FLOAT_OES : r4.UNSIGNED_BYTE, null), o4.colorAttachment.set(i4);
                }(e2, t3, n3, r3);
              }
            }(n2, t2, o2), n2.clear({ color: e.Color.transparent });
            for (let c2 = 0; c2 < r2.length; c2++) {
              const h2 = r2[c2];
              if (i2.hasRenderableParent(h2))
                continue;
              const u2 = i2.getTile(h2), d2 = u2.getBucket(o2);
              if (!d2)
                continue;
              const _2 = d2.programConfigurations.get(o2.id), p2 = t2.useProgram("heatmap", _2), { zoom: m2 } = t2.transform;
              t2.terrain && t2.terrain.setupElevationDraw(u2, p2), t2.prepareDrawProgram(n2, p2, h2.toUnwrapped()), p2.draw(n2, a2.TRIANGLES, e.DepthMode.disabled, s2, l2, e.CullFaceMode.disabled, Si(h2.projMatrix, u2, m2, o2.paint.get("heatmap-intensity")), o2.id, d2.layoutVertexBuffer, d2.indexBuffer, d2.segments, o2.paint, t2.transform.zoom, _2);
            }
            n2.viewport.set([0, 0, t2.width, t2.height]);
          } else
            "translucent" === t2.renderPass && (t2.context.setColorMode(t2.colorModeForRenderPass()), function(t3, i3) {
              const o3 = t3.context, r3 = o3.gl, n2 = i3.heatmapFbo;
              if (!n2)
                return;
              o3.activeTexture.set(r3.TEXTURE0), r3.bindTexture(r3.TEXTURE_2D, n2.colorAttachment.get()), o3.activeTexture.set(r3.TEXTURE1);
              let a2 = i3.colorRampTexture;
              a2 || (a2 = i3.colorRampTexture = new e.Texture(o3, i3.colorRamp, r3.RGBA)), a2.bind(r3.LINEAR, r3.CLAMP_TO_EDGE), t3.useProgram("heatmapTexture").draw(o3, r3.TRIANGLES, e.DepthMode.disabled, e.StencilMode.disabled, t3.colorModeForRenderPass(), e.CullFaceMode.disabled, ((e2, t4, i4, o4) => ({ u_image: 0, u_color_ramp: 1, u_opacity: t4.paint.get("heatmap-opacity") }))(0, i3), i3.id, t3.viewportBuffer, t3.quadTriangleIndexBuffer, t3.viewportSegments, i3.paint, t3.transform.zoom);
            }(t2, o2));
      }, line: function(t2, i2, o2, r2) {
        if ("translucent" !== t2.renderPass)
          return;
        const n2 = o2.paint.get("line-opacity"), a2 = o2.paint.get("line-width");
        if (0 === n2.constantOr(1) || 0 === a2.constantOr(1))
          return;
        const s2 = t2.depthModeForSublayer(0, e.DepthMode.ReadOnly), l2 = t2.colorModeForRenderPass(), c2 = o2.paint.get("line-dasharray"), h2 = c2.constantOr(1), u2 = o2.layout.get("line-cap"), d2 = o2.paint.get("line-pattern"), _2 = d2.constantOr(1), p2 = o2.paint.get("line-gradient"), m2 = o2.getCrossfadeParameters(), f2 = _2 ? "linePattern" : "line", g2 = t2.context, v2 = g2.gl;
        for (const n3 of r2) {
          const r3 = i2.getTile(n3);
          if (_2 && !r3.patternsLoaded())
            continue;
          const a3 = r3.getBucket(o2);
          if (!a3)
            continue;
          t2.prepareDrawTile(n3);
          const x2 = a3.programConfigurations.get(o2.id), y2 = zi(o2), b2 = t2.useProgram(f2, x2, y2), w2 = d2.constantOr(null);
          if (w2 && r3.imageAtlas) {
            const e2 = r3.imageAtlas, t3 = e2.patternPositions[w2.to.toString()], i3 = e2.patternPositions[w2.from.toString()];
            t3 && i3 && x2.setConstantPatternPositions(t3, i3);
          }
          const T2 = c2.constantOr(null), E2 = u2.constantOr(null);
          if (!_2 && T2 && E2 && r3.lineAtlas) {
            const e2 = r3.lineAtlas, t3 = e2.getDash(T2.to, E2), i3 = e2.getDash(T2.from, E2);
            t3 && i3 && x2.setConstantPatternPositions(t3, i3);
          }
          const C2 = t2.terrain ? n3.projMatrix : null, S2 = _2 ? Ii(t2, r3, o2, m2, C2) : Mi(t2, r3, o2, m2, C2, a3.lineClipsArray.length);
          if (p2) {
            const r4 = a3.gradients[o2.id];
            let s3 = r4.texture;
            if (o2.gradientVersion !== r4.version) {
              let l3 = 256;
              if (o2.stepInterpolant) {
                const o3 = i2.getSource().maxzoom, r5 = n3.canonical.z === o3 ? Math.ceil(1 << t2.transform.maxZoom - n3.canonical.z) : 1;
                l3 = e.clamp(e.nextPowerOfTwo(a3.maxLineLength / e.EXTENT * 1024 * r5), 256, g2.maxTextureSize);
              }
              r4.gradient = e.renderColorRamp({ expression: o2.gradientExpression(), evaluationKey: "lineProgress", resolution: l3, image: r4.gradient || void 0, clips: a3.lineClipsArray }), r4.texture ? r4.texture.update(r4.gradient) : r4.texture = new e.Texture(g2, r4.gradient, v2.RGBA), r4.version = o2.gradientVersion, s3 = r4.texture;
            }
            g2.activeTexture.set(v2.TEXTURE1), s3.bind(o2.stepInterpolant ? v2.NEAREST : v2.LINEAR, v2.CLAMP_TO_EDGE);
          }
          h2 && (g2.activeTexture.set(v2.TEXTURE0), r3.lineAtlasTexture.bind(v2.LINEAR, v2.REPEAT), x2.updatePaintBuffers(m2)), _2 && (g2.activeTexture.set(v2.TEXTURE0), r3.imageAtlasTexture.bind(v2.LINEAR, v2.CLAMP_TO_EDGE), x2.updatePaintBuffers(m2)), t2.prepareDrawProgram(g2, b2, n3.toUnwrapped()), b2.draw(g2, v2.TRIANGLES, s2, t2.stencilModeForClipping(n3), l2, e.CullFaceMode.disabled, S2, o2.id, a3.layoutVertexBuffer, a3.indexBuffer, a3.segments, o2.paint, t2.transform.zoom, x2, a3.layoutVertexBuffer2);
        }
      }, fill: function(t2, i2, o2, r2) {
        const n2 = o2.paint.get("fill-color"), a2 = o2.paint.get("fill-opacity");
        if (0 === a2.constantOr(1))
          return;
        const s2 = t2.colorModeForRenderPass(), l2 = o2.paint.get("fill-pattern"), c2 = t2.opaquePassEnabledForLayer() && !l2.constantOr(1) && 1 === n2.constantOr(e.Color.transparent).a && 1 === a2.constantOr(0) ? "opaque" : "translucent";
        if (t2.renderPass === c2) {
          const n3 = t2.depthModeForSublayer(1, "opaque" === t2.renderPass ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly);
          Hi(t2, i2, o2, r2, n3, s2, false);
        }
        if ("translucent" === t2.renderPass && o2.paint.get("fill-antialias")) {
          const n3 = t2.depthModeForSublayer(o2.getPaintProperty("fill-outline-color") ? 2 : 0, e.DepthMode.ReadOnly);
          Hi(t2, i2, o2, r2, n3, s2, true);
        }
      }, "fill-extrusion": function(t2, i2, o2, r2) {
        const n2 = o2.paint.get("fill-extrusion-opacity");
        if (0 !== n2 && "translucent" === t2.renderPass) {
          const a2 = new e.DepthMode(t2.context.gl.LEQUAL, e.DepthMode.ReadWrite, t2.depthRangeFor3D);
          if (1 !== n2 || o2.paint.get("fill-extrusion-pattern").constantOr(1))
            Ki(t2, i2, o2, r2, a2, e.StencilMode.disabled, e.ColorMode.disabled), Ki(t2, i2, o2, r2, a2, t2.stencilModeFor3D(), t2.colorModeForRenderPass());
          else {
            const n3 = t2.colorModeForRenderPass();
            Ki(t2, i2, o2, r2, a2, e.StencilMode.disabled, n3);
          }
        }
      }, hillshade: function(t2, i2, o2, r2) {
        if ("offscreen" !== t2.renderPass && "translucent" !== t2.renderPass)
          return;
        const n2 = t2.context, a2 = t2.depthModeForSublayer(0, e.DepthMode.ReadOnly), s2 = t2.colorModeForRenderPass(), l2 = t2.terrain && t2.terrain.renderingToTexture, [c2, h2] = "translucent" !== t2.renderPass || l2 ? [{}, r2] : t2.stencilConfigForOverlap(r2);
        for (const r3 of h2) {
          const n3 = i2.getTile(r3);
          if (n3.needsHillshadePrepare && "offscreen" === t2.renderPass)
            ii(t2, n3, o2, a2, e.StencilMode.disabled, s2);
          else if ("translucent" === t2.renderPass) {
            const e2 = l2 && t2.terrain ? t2.terrain.stencilModeForRTTOverlap(r3) : c2[r3.overscaledZ];
            ei(t2, r3, n3, o2, a2, e2, s2);
          }
        }
        n2.viewport.set([0, 0, t2.width, t2.height]);
      }, raster: function(t2, i2, o2, r2, n2, a2) {
        if ("translucent" !== t2.renderPass)
          return;
        if (0 === o2.paint.get("raster-opacity"))
          return;
        if (!r2.length)
          return;
        const s2 = t2.context, l2 = s2.gl, c2 = i2.getSource(), h2 = t2.useProgram("raster"), u2 = t2.colorModeForRenderPass(), d2 = t2.terrain && t2.terrain.renderingToTexture, [_2, p2] = c2 instanceof Ee || d2 ? [{}, r2] : t2.stencilConfigForOverlap(r2), m2 = p2[p2.length - 1].overscaledZ, f2 = !t2.options.moving;
        for (const r3 of p2) {
          const n3 = d2 ? e.DepthMode.disabled : t2.depthModeForSublayer(r3.overscaledZ - m2, 1 === o2.paint.get("raster-opacity") ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly, l2.LESS), p3 = r3.toUnwrapped(), g2 = i2.getTile(r3);
          if (d2 && (!g2 || !g2.hasData()))
            continue;
          const v2 = d2 ? r3.projMatrix : t2.transform.calculateProjMatrix(p3, f2), x2 = t2.terrain && d2 ? t2.terrain.stencilModeForRTTOverlap(r3) : _2[r3.overscaledZ], y2 = a2 ? 0 : o2.paint.get("raster-fade-duration");
          g2.registerFadeDuration(y2);
          const b2 = i2.findLoadedParent(r3, 0), w2 = ci(g2, b2, i2, t2.transform, y2);
          let T2, E2;
          t2.terrain && t2.terrain.prepareDrawTile(r3);
          const C2 = "nearest" === o2.paint.get("raster-resampling") ? l2.NEAREST : l2.LINEAR;
          s2.activeTexture.set(l2.TEXTURE0), g2.texture.bind(C2, l2.CLAMP_TO_EDGE, l2.LINEAR_MIPMAP_NEAREST), s2.activeTexture.set(l2.TEXTURE1), b2 ? (b2.texture.bind(C2, l2.CLAMP_TO_EDGE, l2.LINEAR_MIPMAP_NEAREST), T2 = Math.pow(2, b2.tileID.overscaledZ - g2.tileID.overscaledZ), E2 = [g2.tileID.canonical.x * T2 % 1, g2.tileID.canonical.y * T2 % 1]) : g2.texture.bind(C2, l2.CLAMP_TO_EDGE, l2.LINEAR_MIPMAP_NEAREST);
          const S2 = Li(v2, E2 || [0, 0], T2 || 1, w2, o2);
          t2.prepareDrawProgram(s2, h2, p3), c2 instanceof Ee ? h2.draw(s2, l2.TRIANGLES, n3, e.StencilMode.disabled, u2, e.CullFaceMode.disabled, S2, o2.id, c2.boundsBuffer, t2.quadTriangleIndexBuffer, c2.boundsSegments) : h2.draw(s2, l2.TRIANGLES, n3, x2, u2, e.CullFaceMode.disabled, S2, o2.id, t2.rasterBoundsBuffer, t2.quadTriangleIndexBuffer, t2.rasterBoundsSegments);
        }
      }, background: function(t2, i2, o2, r2) {
        const n2 = o2.paint.get("background-color"), a2 = o2.paint.get("background-opacity");
        if (0 === a2)
          return;
        const s2 = t2.context, l2 = s2.gl, c2 = t2.transform, h2 = c2.tileSize, u2 = o2.paint.get("background-pattern");
        if (t2.isPatternMissing(u2))
          return;
        const d2 = !u2 && 1 === n2.a && 1 === a2 && t2.opaquePassEnabledForLayer() ? "opaque" : "translucent";
        if (t2.renderPass !== d2)
          return;
        const _2 = e.StencilMode.disabled, p2 = t2.depthModeForSublayer(0, "opaque" === d2 ? e.DepthMode.ReadWrite : e.DepthMode.ReadOnly), m2 = t2.colorModeForRenderPass(), f2 = t2.useProgram(u2 ? "backgroundPattern" : "background"), g2 = r2 || c2.coveringTiles({ tileSize: h2 });
        u2 && (s2.activeTexture.set(l2.TEXTURE0), t2.imageManager.bind(t2.context));
        const v2 = o2.getCrossfadeParameters();
        for (const i3 of g2) {
          const c3 = i3.toUnwrapped(), d3 = r2 ? i3.projMatrix : t2.transform.calculateProjMatrix(c3);
          t2.prepareDrawTile(i3);
          const g3 = u2 ? Ui(d3, a2, t2, u2, { tileID: i3, tileSize: h2 }, v2) : Bi(d3, a2, n2);
          t2.prepareDrawProgram(s2, f2, c3), f2.draw(s2, l2.TRIANGLES, p2, _2, m2, e.CullFaceMode.disabled, g3, o2.id, t2.tileExtentBuffer, t2.quadTriangleIndexBuffer, t2.tileExtentSegments);
        }
      }, sky: function(t2, i2, o2) {
        const r2 = o2.paint.get("sky-opacity");
        if (0 === r2)
          return;
        const n2 = t2.context, a2 = o2.paint.get("sky-type"), s2 = new e.DepthMode(n2.gl.LEQUAL, e.DepthMode.ReadOnly, [0, 1]), l2 = t2.frameCounter / 1e3 % 1;
        "atmosphere" === a2 ? "offscreen" === t2.renderPass ? o2.needsSkyboxCapture(t2) && (function(t3, i3, o3, r3) {
          const n3 = t3.context, a3 = n3.gl;
          let s3 = i3.skyboxFbo;
          if (!s3) {
            s3 = i3.skyboxFbo = n3.createFramebuffer(32, 32, false), i3.skyboxGeometry = new ho(n3), i3.skyboxTexture = n3.gl.createTexture(), a3.bindTexture(a3.TEXTURE_CUBE_MAP, i3.skyboxTexture), a3.texParameteri(a3.TEXTURE_CUBE_MAP, a3.TEXTURE_WRAP_S, a3.CLAMP_TO_EDGE), a3.texParameteri(a3.TEXTURE_CUBE_MAP, a3.TEXTURE_WRAP_T, a3.CLAMP_TO_EDGE), a3.texParameteri(a3.TEXTURE_CUBE_MAP, a3.TEXTURE_MIN_FILTER, a3.LINEAR), a3.texParameteri(a3.TEXTURE_CUBE_MAP, a3.TEXTURE_MAG_FILTER, a3.LINEAR);
            for (let e2 = 0; e2 < 6; ++e2)
              a3.texImage2D(a3.TEXTURE_CUBE_MAP_POSITIVE_X + e2, 0, a3.RGBA, 32, 32, 0, a3.RGBA, a3.UNSIGNED_BYTE, null);
          }
          n3.bindFramebuffer.set(s3.framebuffer), n3.viewport.set([0, 0, 32, 32]);
          const l3 = i3.getCenter(t3, true), c2 = t3.useProgram("skyboxCapture"), h2 = new Float64Array(16);
          e.identity(h2), e.rotateY(h2, h2, 0.5 * -Math.PI), uo(n3, i3, c2, h2, l3, 0), e.identity(h2), e.rotateY(h2, h2, 0.5 * Math.PI), uo(n3, i3, c2, h2, l3, 1), e.identity(h2), e.rotateX(h2, h2, 0.5 * -Math.PI), uo(n3, i3, c2, h2, l3, 2), e.identity(h2), e.rotateX(h2, h2, 0.5 * Math.PI), uo(n3, i3, c2, h2, l3, 3), e.identity(h2), uo(n3, i3, c2, h2, l3, 4), e.identity(h2), e.rotateY(h2, h2, Math.PI), uo(n3, i3, c2, h2, l3, 5), n3.viewport.set([0, 0, t3.width, t3.height]);
        }(t2, o2), o2.markSkyboxValid(t2)) : "sky" === t2.renderPass && function(t3, i3, o3, r3, n3) {
          const a3 = t3.context, s3 = a3.gl, l3 = t3.transform, c2 = t3.useProgram("skybox");
          a3.activeTexture.set(s3.TEXTURE0), s3.bindTexture(s3.TEXTURE_CUBE_MAP, i3.skyboxTexture);
          const h2 = ((e2, t4, i4, o4, r4) => ({ u_matrix: e2, u_sun_direction: t4, u_cubemap: 0, u_opacity: o4, u_temporal_offset: r4 }))(l3.skyboxMatrix, i3.getCenter(t3, false), 0, r3, n3);
          t3.prepareDrawProgram(a3, c2), c2.draw(a3, s3.TRIANGLES, o3, e.StencilMode.disabled, t3.colorModeForRenderPass(), e.CullFaceMode.backCW, h2, "skybox", i3.skyboxGeometry.vertexBuffer, i3.skyboxGeometry.indexBuffer, i3.skyboxGeometry.segment);
        }(t2, o2, s2, r2, l2) : "gradient" === a2 && "sky" === t2.renderPass && function(t3, i3, o3, r3, n3) {
          const a3 = t3.context, s3 = a3.gl, l3 = t3.transform, c2 = t3.useProgram("skyboxGradient");
          i3.skyboxGeometry || (i3.skyboxGeometry = new ho(a3)), a3.activeTexture.set(s3.TEXTURE0);
          let h2 = i3.colorRampTexture;
          h2 || (h2 = i3.colorRampTexture = new e.Texture(a3, i3.colorRamp, s3.RGBA)), h2.bind(s3.LINEAR, s3.CLAMP_TO_EDGE);
          const u2 = ((t4, i4, o4, r4, n4) => ({ u_matrix: t4, u_color_ramp: 0, u_center_direction: i4, u_radius: e.degToRad(o4), u_opacity: r4, u_temporal_offset: n4 }))(l3.skyboxMatrix, i3.getCenter(t3, false), i3.paint.get("sky-gradient-radius"), r3, n3);
          t3.prepareDrawProgram(a3, c2), c2.draw(a3, s3.TRIANGLES, o3, e.StencilMode.disabled, t3.colorModeForRenderPass(), e.CullFaceMode.backCW, u2, "skyboxGradient", i3.skyboxGeometry.vertexBuffer, i3.skyboxGeometry.indexBuffer, i3.skyboxGeometry.segment);
        }(t2, o2, s2, r2, l2);
      }, debug: function(e2, t2, i2) {
        for (let o2 = 0; o2 < i2.length; o2++)
          ao(e2, t2, i2[o2]);
      }, custom: function(t2, i2, o2) {
        const r2 = t2.context, n2 = o2.implementation;
        if ("offscreen" === t2.renderPass) {
          const e2 = n2.prerender;
          e2 && (t2.setCustomLayerDefaults(), r2.setColorMode(t2.colorModeForRenderPass()), e2.call(n2, r2.gl, t2.transform.customLayerMatrix()), r2.setDirty(), t2.setBaseState());
        } else if ("translucent" === t2.renderPass) {
          t2.setCustomLayerDefaults(), r2.setColorMode(t2.colorModeForRenderPass()), r2.setStencilMode(e.StencilMode.disabled);
          const i3 = "3d" === n2.renderingMode ? new e.DepthMode(t2.context.gl.LEQUAL, e.DepthMode.ReadWrite, t2.depthRangeFor3D) : t2.depthModeForSublayer(0, e.DepthMode.ReadOnly);
          r2.setDepthMode(i3), n2.render(r2.gl, t2.transform.customLayerMatrix()), r2.setDirty(), t2.setBaseState(), r2.bindFramebuffer.set(null);
        }
      } };
      class po {
        constructor(t2, i2) {
          this.context = new ye(t2), this.transform = i2, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.setup(), this.numSublayers = e.SourceCache.maxUnderzooming + e.SourceCache.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Ot(), this.gpuTimers = {}, this.frameCounter = 0;
        }
        updateTerrain(e2, t2) {
          const i2 = !!e2 && !!e2.terrain;
          if (!(i2 || this._terrain && this._terrain.enabled))
            return;
          this._terrain || (this._terrain = new di(this, e2));
          const o2 = this._terrain;
          this.transform.elevation = i2 ? o2 : null, o2.update(e2, this.transform, t2);
        }
        _updateFog(e2) {
          const t2 = e2.fog;
          if (!t2 || t2.getOpacity(this.transform.pitch) < 1 || t2.properties.get("horizon-blend") < 0.03)
            return void (this.transform.fogCullDistSq = null);
          const [i2, o2] = t2.getFovAdjustedRange(this.transform._fov);
          if (i2 > o2)
            return void (this.transform.fogCullDistSq = null);
          const r2 = i2 + 0.78 * (o2 - i2);
          this.transform.fogCullDistSq = r2 * r2;
        }
        get terrain() {
          return this._terrain && this._terrain.enabled ? this._terrain : null;
        }
        resize(t2, i2) {
          if (this.width = t2 * e.exported.devicePixelRatio, this.height = i2 * e.exported.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
            for (const e2 of this.style.order)
              this.style._layers[e2].resize();
        }
        setup() {
          const t2 = this.context, i2 = new e.StructArrayLayout2i4();
          i2.emplaceBack(0, 0), i2.emplaceBack(e.EXTENT, 0), i2.emplaceBack(0, e.EXTENT), i2.emplaceBack(e.EXTENT, e.EXTENT), this.tileExtentBuffer = t2.createVertexBuffer(i2, e.posAttributes.members), this.tileExtentSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
          const o2 = new e.StructArrayLayout2i4();
          o2.emplaceBack(0, 0), o2.emplaceBack(e.EXTENT, 0), o2.emplaceBack(0, e.EXTENT), o2.emplaceBack(e.EXTENT, e.EXTENT), this.debugBuffer = t2.createVertexBuffer(o2, e.posAttributes.members), this.debugSegments = e.SegmentVector.simpleSegment(0, 0, 4, 5);
          const r2 = new e.StructArrayLayout4i8();
          r2.emplaceBack(0, 0, 0, 0), r2.emplaceBack(e.EXTENT, 0, e.EXTENT, 0), r2.emplaceBack(0, e.EXTENT, 0, e.EXTENT), r2.emplaceBack(e.EXTENT, e.EXTENT, e.EXTENT, e.EXTENT), this.rasterBoundsBuffer = t2.createVertexBuffer(r2, Te.members), this.rasterBoundsSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
          const n2 = new e.StructArrayLayout2i4();
          n2.emplaceBack(-1, -1), n2.emplaceBack(1, -1), n2.emplaceBack(-1, 1), n2.emplaceBack(1, 1), this.viewportBuffer = t2.createVertexBuffer(n2, e.posAttributes.members), this.viewportSegments = e.SegmentVector.simpleSegment(0, 0, 4, 2);
          const a2 = new e.StructArrayLayout1ui2();
          a2.emplaceBack(0), a2.emplaceBack(1), a2.emplaceBack(3), a2.emplaceBack(2), a2.emplaceBack(0), this.tileBorderIndexBuffer = t2.createIndexBuffer(a2);
          const s2 = new e.StructArrayLayout3ui6();
          s2.emplaceBack(0, 1, 2), s2.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t2.createIndexBuffer(s2), this.emptyTexture = new e.Texture(t2, { width: 1, height: 1, data: new Uint8Array([0, 0, 0, 0]) }, t2.gl.RGBA), this.identityMat = e.create$1();
          const l2 = this.context.gl;
          this.stencilClearMode = new e.StencilMode({ func: l2.ALWAYS, mask: 0 }, 0, 255, l2.ZERO, l2.ZERO, l2.ZERO), this.loadTimeStamps.push(e.window.performance.now());
        }
        clearStencil() {
          const t2 = this.context, i2 = t2.gl;
          this.nextStencilID = 1, this.currentStencilSource = void 0, this.useProgram("clippingMask").draw(t2, i2.TRIANGLES, e.DepthMode.disabled, this.stencilClearMode, e.ColorMode.disabled, e.CullFaceMode.disabled, li(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }
        _renderTileClippingMasks(t2, i2, o2) {
          if (!(i2 && this.currentStencilSource !== i2.id && t2.isTileClipped() && o2 && o2.length))
            return;
          this.currentStencilSource = i2.id;
          const r2 = this.context, n2 = r2.gl;
          this.nextStencilID + o2.length > 256 && this.clearStencil(), r2.setColorMode(e.ColorMode.disabled), r2.setDepthMode(e.DepthMode.disabled);
          const a2 = this.useProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (const t3 of o2) {
            const i3 = this._tileClippingMaskIDs[t3.key] = this.nextStencilID++;
            a2.draw(r2, n2.TRIANGLES, e.DepthMode.disabled, new e.StencilMode({ func: n2.ALWAYS, mask: 0 }, i3, 255, n2.KEEP, n2.KEEP, n2.REPLACE), e.ColorMode.disabled, e.CullFaceMode.disabled, li(t3.projMatrix), "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
        }
        stencilModeFor3D() {
          this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
          const t2 = this.nextStencilID++, i2 = this.context.gl;
          return new e.StencilMode({ func: i2.NOTEQUAL, mask: 255 }, t2, 255, i2.KEEP, i2.KEEP, i2.REPLACE);
        }
        stencilModeForClipping(t2) {
          if (this.terrain)
            return this.terrain.stencilModeForRTTOverlap(t2);
          const i2 = this.context.gl;
          return new e.StencilMode({ func: i2.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t2.key], 0, i2.KEEP, i2.KEEP, i2.REPLACE);
        }
        stencilConfigForOverlap(t2) {
          const i2 = this.context.gl, o2 = t2.sort((e2, t3) => t3.overscaledZ - e2.overscaledZ), r2 = o2[o2.length - 1].overscaledZ, n2 = o2[0].overscaledZ - r2 + 1;
          if (n2 > 1) {
            this.currentStencilSource = void 0, this.nextStencilID + n2 > 256 && this.clearStencil();
            const t3 = {};
            for (let o3 = 0; o3 < n2; o3++)
              t3[o3 + r2] = new e.StencilMode({ func: i2.GEQUAL, mask: 255 }, o3 + this.nextStencilID, 255, i2.KEEP, i2.KEEP, i2.REPLACE);
            return this.nextStencilID += n2, [t3, o2];
          }
          return [{ [r2]: e.StencilMode.disabled }, o2];
        }
        colorModeForRenderPass() {
          const t2 = this.context.gl;
          if (this._showOverdrawInspector) {
            const i2 = 1 / 8;
            return new e.ColorMode([t2.CONSTANT_COLOR, t2.ONE], new e.Color(i2, i2, i2, 0), [true, true, true, true]);
          }
          return "opaque" === this.renderPass ? e.ColorMode.unblended : e.ColorMode.alphaBlended;
        }
        depthModeForSublayer(t2, i2, o2) {
          if (!this.opaquePassEnabledForLayer())
            return e.DepthMode.disabled;
          const r2 = 1 - ((1 + this.currentLayer) * this.numSublayers + t2) * this.depthEpsilon;
          return new e.DepthMode(o2 || this.context.gl.LEQUAL, i2, [r2, r2]);
        }
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        render(t2, i2) {
          this.style = t2, this.options = i2, this.lineAtlas = t2.lineAtlas, this.imageManager = t2.imageManager, this.glyphManager = t2.glyphManager, this.symbolFadeChange = t2.placement.symbolFadeChange(e.exported.now()), this.imageManager.beginFrame();
          const o2 = this.style.order, r2 = this.style._sourceCaches;
          for (const e2 in r2) {
            const t3 = r2[e2];
            t3.used && t3.prepare(this.context);
          }
          const n2 = {}, a2 = {}, s2 = {};
          for (const e2 in r2) {
            const t3 = r2[e2];
            n2[e2] = t3.getVisibleCoordinates(), a2[e2] = n2[e2].slice().reverse(), s2[e2] = t3.getVisibleCoordinates(true).reverse();
          }
          this.opaquePassCutoff = 1 / 0;
          for (let e2 = 0; e2 < o2.length; e2++)
            if (this.style._layers[o2[e2]].is3D()) {
              this.opaquePassCutoff = e2;
              break;
            }
          if (this.terrain && (this.terrain.updateTileBinding(s2), this.opaquePassCutoff = 0), !e.isMapAuthenticated(this.context.gl))
            return;
          this.renderPass = "offscreen";
          for (const e2 of o2) {
            const i3 = this.style._layers[e2], o3 = t2._getLayerSourceCache(i3);
            if (!i3.hasOffscreenPass() || i3.isHidden(this.transform.zoom))
              continue;
            const r3 = o3 ? a2[o3.id] : void 0;
            ("custom" === i3.type || i3.isSky() || r3 && r3.length) && this.renderLayer(this, o3, i3, r3);
          }
          this.depthRangeFor3D = [0, 1 - (t2.order.length + 2) * this.numSublayers * this.depthEpsilon], this.terrain && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && this.terrain.drawDepth(), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]);
          let l2 = e.Color.transparent;
          if (this.style.fog && (l2 = this.style.fog.properties.get("color")), this.context.clear({ color: i2.showOverdrawInspector ? e.Color.black : l2, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i2.showOverdrawInspector, this.renderPass = "opaque", !this.terrain)
            for (this.currentLayer = o2.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const e2 = this.style._layers[o2[this.currentLayer]], i3 = t2._getLayerSourceCache(e2);
              if (e2.isSky())
                continue;
              const r3 = i3 ? a2[i3.id] : void 0;
              this._renderTileClippingMasks(e2, i3, r3), this.renderLayer(this, i3, e2, r3);
            }
          if (this.renderPass = "sky", this.transform.isHorizonVisible())
            for (this.currentLayer = 0; this.currentLayer < o2.length; this.currentLayer++) {
              const e2 = this.style._layers[o2[this.currentLayer]], i3 = t2._getLayerSourceCache(e2);
              e2.isSky() && this.renderLayer(this, i3, e2, i3 ? a2[i3.id] : void 0);
            }
          for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < o2.length; ) {
            const e2 = this.style._layers[o2[this.currentLayer]], i3 = t2._getLayerSourceCache(e2);
            if (e2.isSky()) {
              ++this.currentLayer;
              continue;
            }
            if (this.terrain && this.style.isLayerDraped(e2)) {
              if (e2.isHidden(this.transform.zoom)) {
                ++this.currentLayer;
                continue;
              }
              this.currentLayer = this.terrain.renderBatch(this.currentLayer);
              continue;
            }
            const r3 = i3 ? ("symbol" === e2.type ? s2 : a2)[i3.id] : void 0;
            this._renderTileClippingMasks(e2, i3, i3 ? n2[i3.id] : void 0), this.renderLayer(this, i3, e2, r3), ++this.currentLayer;
          }
          if (this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry) {
            let i3 = null;
            e.values(this.style._layers).forEach((e2) => {
              const o3 = t2._getLayerSourceCache(e2);
              o3 && !e2.isHidden(this.transform.zoom) && (!i3 || i3.getSource().maxzoom < o3.getSource().maxzoom) && (i3 = o3);
            }), i3 && this.options.showTileBoundaries && _o.debug(this, i3, i3.getVisibleCoordinates());
          }
          this.options.showPadding && function(e2) {
            const t3 = e2.transform.padding;
            oo(e2, e2.transform.height - (t3.top || 0), 3, Ji), oo(e2, t3.bottom || 0, 3, Qi), ro(e2, t3.left || 0, 3, eo), ro(e2, e2.transform.width - (t3.right || 0), 3, to);
            const i3 = e2.transform.centerPoint;
            !function(e3, t4, i4, o3) {
              no(e3, t4 - 1, i4 - 10, 2, 20, o3), no(e3, t4 - 10, i4 - 1, 20, 2, o3);
            }(e2, i3.x, e2.transform.height - i3.y, io);
          }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % e.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(e.window.performance.now()), this.saveCanvasCopy());
        }
        renderLayer(e2, t2, i2, o2) {
          i2.isHidden(this.transform.zoom) || ("background" === i2.type || "sky" === i2.type || "custom" === i2.type || o2 && o2.length) && (this.id = i2.id, this.gpuTimingStart(i2), _o[i2.type](e2, t2, i2, o2, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
        }
        gpuTimingStart(e2) {
          if (!this.options.gpuTiming)
            return;
          const t2 = this.context.extTimerQuery;
          let i2 = this.gpuTimers[e2.id];
          i2 || (i2 = this.gpuTimers[e2.id] = { calls: 0, cpuTime: 0, query: t2.createQueryEXT() }), i2.calls++, t2.beginQueryEXT(t2.TIME_ELAPSED_EXT, i2.query);
        }
        gpuTimingEnd() {
          if (!this.options.gpuTiming)
            return;
          const e2 = this.context.extTimerQuery;
          e2.endQueryEXT(e2.TIME_ELAPSED_EXT);
        }
        collectGpuTimers() {
          const e2 = this.gpuTimers;
          return this.gpuTimers = {}, e2;
        }
        queryGpuTimers(e2) {
          const t2 = {};
          for (const i2 in e2) {
            const o2 = e2[i2], r2 = this.context.extTimerQuery, n2 = r2.getQueryObjectEXT(o2.query, r2.QUERY_RESULT_EXT) / 1e6;
            r2.deleteQueryEXT(o2.query), t2[i2] = n2;
          }
          return t2;
        }
        translatePosMatrix(t2, i2, o2, r2, n2) {
          if (!o2[0] && !o2[1])
            return t2;
          const a2 = n2 ? "map" === r2 ? this.transform.angle : 0 : "viewport" === r2 ? -this.transform.angle : 0;
          if (a2) {
            const e2 = Math.sin(a2), t3 = Math.cos(a2);
            o2 = [o2[0] * t3 - o2[1] * e2, o2[0] * e2 + o2[1] * t3];
          }
          const s2 = [n2 ? o2[0] : D(i2, o2[0], this.transform.zoom), n2 ? o2[1] : D(i2, o2[1], this.transform.zoom), 0], l2 = new Float32Array(16);
          return e.translate(l2, t2, s2), l2;
        }
        saveTileTexture(e2) {
          const t2 = this._tileTextures[e2.size[0]];
          t2 ? t2.push(e2) : this._tileTextures[e2.size[0]] = [e2];
        }
        getTileTexture(e2) {
          const t2 = this._tileTextures[e2];
          return t2 && t2.length > 0 ? t2.pop() : null;
        }
        isPatternMissing(e2) {
          if (!e2)
            return false;
          if (!e2.from || !e2.to)
            return true;
          const t2 = this.imageManager.getPattern(e2.from.toString()), i2 = this.imageManager.getPattern(e2.to.toString());
          return !t2 || !i2;
        }
        currentGlobalDefines() {
          const e2 = this.terrain && this.terrain.renderingToTexture, t2 = this.style && this.style.fog, i2 = [];
          return this.terrain && !this.terrain.renderingToTexture && i2.push("TERRAIN"), t2 && !e2 && 0 !== t2.getOpacity(this.transform.pitch) && i2.push("FOG"), e2 && i2.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && i2.push("OVERDRAW_INSPECTOR"), i2;
        }
        useProgram(e2, t2, i2) {
          this.cache = this.cache || {};
          const o2 = i2 || [], r2 = this.currentGlobalDefines().concat(o2), n2 = pi.cacheKey(e2, r2, t2);
          return this.cache[n2] || (this.cache[n2] = new pi(this.context, e2, Kt[e2], t2, Ni[e2], r2)), this.cache[n2];
        }
        setCustomLayerDefaults() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }
        setBaseState() {
          const e2 = this.context.gl;
          this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e2.FUNC_ADD);
        }
        initDebugOverlayCanvas() {
          null == this.debugOverlayCanvas && (this.debugOverlayCanvas = e.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
        }
        destroy() {
          this._terrain && this._terrain.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy();
        }
        prepareDrawTile(e2) {
          this.terrain && this.terrain.prepareDrawTile(e2);
        }
        prepareDrawProgram(e2, t2, i2) {
          if (this.terrain && this.terrain.renderingToTexture)
            return;
          const o2 = this.style.fog;
          if (o2) {
            const r2 = o2.getOpacity(this.transform.pitch);
            0 !== r2 && t2.setFogUniformValues(e2, ((e3, t3, i3, o3) => {
              const r3 = t3.properties.get("color"), n2 = e3.frameCounter / 1e3 % 1, a2 = [r3.r / r3.a, r3.g / r3.a, r3.b / r3.a, o3];
              return { u_fog_matrix: i3 ? e3.transform.calculateFogTileMatrix(i3) : e3.identityMat, u_fog_range: t3.getFovAdjustedRange(e3.transform._fov), u_fog_color: a2, u_fog_horizon_blend: t3.properties.get("horizon-blend"), u_fog_temporal_offset: n2 };
            })(this, o2, i2, r2));
          }
        }
        setTileLoadedFlag(e2) {
          this.tileLoaded = e2;
        }
        saveCanvasCopy() {
          this.frameCopies.push(this.canvasCopy()), this.tileLoaded = false;
        }
        canvasCopy() {
          const e2 = this.context.gl, t2 = e2.createTexture();
          return e2.bindTexture(e2.TEXTURE_2D, t2), e2.copyTexImage2D(e2.TEXTURE_2D, 0, e2.RGBA, 0, 0, e2.drawingBufferWidth, e2.drawingBufferHeight, 0), t2;
        }
        getCanvasCopiesAndTimestamps() {
          return { canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps };
        }
        averageElevationNeedsEasing() {
          if (!this.transform._elevation)
            return false;
          const e2 = this.style && this.style.fog;
          return !!e2 && 0 !== e2.getOpacity(this.transform.pitch);
        }
      }
      class mo {
        constructor(e2 = 0, t2 = 0, i2 = 0, o2 = 0) {
          if (isNaN(e2) || e2 < 0 || isNaN(t2) || t2 < 0 || isNaN(i2) || i2 < 0 || isNaN(o2) || o2 < 0)
            throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
          this.top = e2, this.bottom = t2, this.left = i2, this.right = o2;
        }
        interpolate(t2, i2, o2) {
          return null != i2.top && null != t2.top && (this.top = e.number(t2.top, i2.top, o2)), null != i2.bottom && null != t2.bottom && (this.bottom = e.number(t2.bottom, i2.bottom, o2)), null != i2.left && null != t2.left && (this.left = e.number(t2.left, i2.left, o2)), null != i2.right && null != t2.right && (this.right = e.number(t2.right, i2.right, o2)), this;
        }
        getCenter(t2, i2) {
          const o2 = e.clamp((this.left + t2 - this.right) / 2, 0, t2), r2 = e.clamp((this.top + i2 - this.bottom) / 2, 0, i2);
          return new e.pointGeometry(o2, r2);
        }
        equals(e2) {
          return this.top === e2.top && this.bottom === e2.bottom && this.left === e2.left && this.right === e2.right;
        }
        clone() {
          return new mo(this.top, this.bottom, this.left, this.right);
        }
        toJSON() {
          return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
        }
      }
      function fo(e2, t2) {
        return [e2[4 * t2], e2[4 * t2 + 1], e2[4 * t2 + 2], e2[4 * t2 + 3]];
      }
      function go(e2, t2, i2) {
        e2[4 * t2 + 0] = i2[0], e2[4 * t2 + 1] = i2[1], e2[4 * t2 + 2] = i2[2], e2[4 * t2 + 3] = i2[3];
      }
      function vo(t2, i2) {
        const o2 = fo(t2, 3);
        e.fromQuat(t2, i2), go(t2, 3, o2);
      }
      function xo(e2, t2) {
        go(e2, 3, [t2[0], t2[1], t2[2], 1]);
      }
      function yo(t2, i2) {
        const o2 = e.identity$1([]);
        return e.rotateZ$1(o2, o2, -i2), e.rotateX$1(o2, o2, -t2), o2;
      }
      function bo(t2, i2) {
        const o2 = [t2[0], t2[1], 0], r2 = [i2[0], i2[1], 0];
        if (e.length(o2) >= 1e-15) {
          const t3 = e.normalize([], o2);
          e.scale(r2, t3, e.dot(r2, t3)), i2[0] = r2[0], i2[1] = r2[1];
        }
        const n2 = e.cross([], i2, t2);
        if (e.len(n2) < 1e-15)
          return null;
        const a2 = Math.atan2(-n2[1], n2[0]);
        return yo(Math.atan2(Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]), -t2[2]), a2);
      }
      class wo {
        constructor(e2, t2) {
          this.position = e2, this.orientation = t2;
        }
        get position() {
          return this._position;
        }
        set position(t2) {
          this._position = this._renderWorldCopies ? function(t3) {
            if (!t3)
              return;
            const i2 = Array.isArray(t3) ? new e.MercatorCoordinate(t3[0], t3[1], t3[2]) : t3;
            return i2.x = e.wrap(i2.x, 0, 1), i2;
          }(t2) : t2;
        }
        lookAtPoint(t2, i2) {
          if (this.orientation = null, !this.position)
            return;
          const o2 = this._elevation ? this._elevation.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(t2)) : 0, r2 = this.position, n2 = e.MercatorCoordinate.fromLngLat(t2, o2), a2 = [n2.x - r2.x, n2.y - r2.y, n2.z - r2.z];
          i2 || (i2 = [0, 0, 1]), i2[2] = Math.abs(i2[2]), this.orientation = bo(a2, i2);
        }
        setPitchBearing(t2, i2) {
          this.orientation = yo(e.degToRad(t2), e.degToRad(-i2));
        }
      }
      class To {
        constructor(t2, i2) {
          this._transform = e.identity([]), this._orientation = e.identity$1([]), i2 && (this._orientation = i2, vo(this._transform, this._orientation)), t2 && xo(this._transform, t2);
        }
        get mercatorPosition() {
          const t2 = this.position;
          return new e.MercatorCoordinate(t2[0], t2[1], t2[2]);
        }
        get position() {
          const e2 = fo(this._transform, 3);
          return [e2[0], e2[1], e2[2]];
        }
        set position(e2) {
          xo(this._transform, e2);
        }
        get orientation() {
          return this._orientation;
        }
        set orientation(e2) {
          this._orientation = e2, vo(this._transform, this._orientation);
        }
        getPitchBearing() {
          const e2 = this.forward(), t2 = this.right();
          return { bearing: Math.atan2(-t2[1], t2[0]), pitch: Math.atan2(Math.sqrt(e2[0] * e2[0] + e2[1] * e2[1]), -e2[2]) };
        }
        setPitchBearing(e2, t2) {
          this._orientation = yo(e2, t2), vo(this._transform, this._orientation);
        }
        forward() {
          const e2 = fo(this._transform, 2);
          return [-e2[0], -e2[1], -e2[2]];
        }
        up() {
          const e2 = fo(this._transform, 1);
          return [-e2[0], -e2[1], -e2[2]];
        }
        right() {
          const e2 = fo(this._transform, 0);
          return [e2[0], e2[1], e2[2]];
        }
        getCameraToWorld(t2, i2) {
          const o2 = new Float64Array(16);
          return e.invert(o2, this.getWorldToCamera(t2, i2)), o2;
        }
        getWorldToCameraPosition(t2, i2, o2) {
          const r2 = this.position;
          e.scale(r2, r2, -t2);
          const n2 = new Float64Array(16);
          return e.fromScaling(n2, [o2, o2, o2]), e.translate(n2, n2, r2), n2[10] *= i2, n2;
        }
        getWorldToCamera(t2, i2) {
          const o2 = new Float64Array(16), r2 = new Float64Array(4), n2 = this.position;
          return e.conjugate(r2, this._orientation), e.scale(n2, n2, -t2), e.fromQuat(o2, r2), e.translate(o2, o2, n2), o2[1] *= -1, o2[5] *= -1, o2[9] *= -1, o2[13] *= -1, o2[8] *= i2, o2[9] *= i2, o2[10] *= i2, o2[11] *= i2, o2;
        }
        getCameraToClipPerspective(t2, i2, o2, r2) {
          const n2 = new Float64Array(16);
          return e.perspective(n2, t2, i2, o2, r2), n2;
        }
        getDistanceToElevation(t2) {
          const i2 = 0 === t2 ? 0 : e.mercatorZfromAltitude(t2, this.position[1]), o2 = this.forward();
          return (i2 - this.position[2]) / o2[2];
        }
        clone() {
          return new To([...this.position], [...this.orientation]);
        }
      }
      class Eo {
        constructor(t2, i2, o2, r2, n2) {
          this.tileSize = 512, this.maxValidLatitude = 85.051129, this._renderWorldCopies = void 0 === n2 || n2, this._minZoom = t2 || 0, this._maxZoom = i2 || 22, this._minPitch = null == o2 ? 0 : o2, this._maxPitch = null == r2 ? 60 : r2, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new e.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = true, this._edgeInsets = new mo(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._camera = new To(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._horizonShift = 0.1;
        }
        clone() {
          const e2 = new Eo(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
          return e2._elevation = this._elevation, e2._centerAltitude = this._centerAltitude, e2.tileSize = this.tileSize, e2.latRange = this.latRange, e2.width = this.width, e2.height = this.height, e2.cameraElevationReference = this.cameraElevationReference, e2._center = this._center, e2._setZoom(this.zoom), e2._cameraZoom = this._cameraZoom, e2.angle = this.angle, e2._fov = this._fov, e2._pitch = this._pitch, e2._averageElevation = this._averageElevation, e2._unmodified = this._unmodified, e2._edgeInsets = this._edgeInsets.clone(), e2._camera = this._camera.clone(), e2._calcMatrices(), e2.freezeTileCoverage = this.freezeTileCoverage, e2;
        }
        get elevation() {
          return this._elevation;
        }
        set elevation(e2) {
          this._elevation !== e2 && (this._elevation = e2, e2 ? this._updateCenterElevation() && this._updateCameraOnTerrain() : (this._cameraZoom = null, this._centerAltitude = 0), this._calcMatrices());
        }
        updateElevation(e2) {
          this._terrainEnabled() && null == this._cameraZoom && this._updateCenterElevation() && this._updateCameraOnTerrain(), e2 && this._constrainCameraAltitude(), this._calcMatrices();
        }
        get minZoom() {
          return this._minZoom;
        }
        set minZoom(e2) {
          this._minZoom !== e2 && (this._minZoom = e2, this.zoom = Math.max(this.zoom, e2));
        }
        get maxZoom() {
          return this._maxZoom;
        }
        set maxZoom(e2) {
          this._maxZoom !== e2 && (this._maxZoom = e2, this.zoom = Math.min(this.zoom, e2));
        }
        get minPitch() {
          return this._minPitch;
        }
        set minPitch(e2) {
          this._minPitch !== e2 && (this._minPitch = e2, this.pitch = Math.max(this.pitch, e2));
        }
        get maxPitch() {
          return this._maxPitch;
        }
        set maxPitch(e2) {
          this._maxPitch !== e2 && (this._maxPitch = e2, this.pitch = Math.min(this.pitch, e2));
        }
        get renderWorldCopies() {
          return this._renderWorldCopies;
        }
        set renderWorldCopies(e2) {
          void 0 === e2 ? e2 = true : null === e2 && (e2 = false), this._renderWorldCopies = e2;
        }
        get worldSize() {
          return this.tileSize * this.scale;
        }
        get cameraWorldSize() {
          const e2 = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
          return this._worldSizeFromZoom(this._zoomFromMercatorZ(e2));
        }
        get pixelsPerMeter() {
          return e.mercatorZfromAltitude(1, this.center.lat) * this.worldSize;
        }
        get cameraPixelsPerMeter() {
          return e.mercatorZfromAltitude(1, this.center.lat) * this.cameraWorldSize;
        }
        get centerOffset() {
          return this.centerPoint._sub(this.size._div(2));
        }
        get size() {
          return new e.pointGeometry(this.width, this.height);
        }
        get bearing() {
          return -this.angle / Math.PI * 180;
        }
        set bearing(t2) {
          const i2 = -e.wrap(t2, -180, 180) * Math.PI / 180;
          var o2;
          this.angle !== i2 && (this._unmodified = false, this.angle = i2, this._calcMatrices(), this.rotationMatrix = (o2 = new e.ARRAY_TYPE(4), e.ARRAY_TYPE != Float32Array && (o2[1] = 0, o2[2] = 0), o2[0] = 1, o2[3] = 1, o2), function(e2, t3, i3) {
            var o3 = t3[0], r2 = t3[1], n2 = t3[2], a2 = t3[3], s2 = Math.sin(i3), l2 = Math.cos(i3);
            e2[0] = o3 * l2 + n2 * s2, e2[1] = r2 * l2 + a2 * s2, e2[2] = o3 * -s2 + n2 * l2, e2[3] = r2 * -s2 + a2 * l2;
          }(this.rotationMatrix, this.rotationMatrix, this.angle));
        }
        get pitch() {
          return this._pitch / Math.PI * 180;
        }
        set pitch(t2) {
          const i2 = e.clamp(t2, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitch !== i2 && (this._unmodified = false, this._pitch = i2, this._calcMatrices());
        }
        get fov() {
          return this._fov / Math.PI * 180;
        }
        set fov(e2) {
          e2 = Math.max(0.01, Math.min(60, e2)), this._fov !== e2 && (this._unmodified = false, this._fov = e2 / 180 * Math.PI, this._calcMatrices());
        }
        get averageElevation() {
          return this._averageElevation;
        }
        set averageElevation(e2) {
          this._averageElevation = e2, this._calcFogMatrices();
        }
        get zoom() {
          return this._zoom;
        }
        set zoom(e2) {
          const t2 = Math.min(Math.max(e2, this.minZoom), this.maxZoom);
          this._zoom !== t2 && (this._unmodified = false, this._setZoom(t2), this._terrainEnabled() && this._updateCameraOnTerrain(), this._constrain(), this._calcMatrices());
        }
        _setZoom(e2) {
          this._zoom = e2, this.scale = this.zoomScale(e2), this.tileZoom = Math.floor(e2), this.zoomFraction = e2 - this.tileZoom;
        }
        _updateCenterElevation() {
          if (!this._elevation)
            return false;
          const t2 = this._elevation.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(this.center), -1);
          return -1 === t2 ? (this._cameraZoom = null, false) : (this._centerAltitude = t2, true);
        }
        _updateCameraOnTerrain() {
          const t2 = this.cameraToCenterDistance / this.worldSize, i2 = e.mercatorZfromAltitude(this._centerAltitude, this.center.lat);
          this._cameraZoom = this._zoomFromMercatorZ(i2 + t2);
        }
        sampleAverageElevation() {
          if (!this._elevation)
            return 0;
          const t2 = this._elevation, i2 = [[0.5, 0.2], [0.3, 0.5], [0.5, 0.5], [0.7, 0.5], [0.5, 0.8]], o2 = this.horizonLineFromTop();
          let r2 = 0, n2 = 0;
          for (let a2 = 0; a2 < i2.length; a2++) {
            const s2 = new e.pointGeometry(i2[a2][0] * this.width, o2 + i2[a2][1] * (this.height - o2)), l2 = t2.pointCoordinate(s2);
            if (!l2)
              continue;
            const c2 = 1 / Math.hypot(l2[0] - this._camera.position[0], l2[1] - this._camera.position[1]);
            r2 += l2[3] * c2, n2 += c2;
          }
          return 0 === n2 ? NaN : r2 / n2;
        }
        get center() {
          return this._center;
        }
        set center(e2) {
          e2.lat === this._center.lat && e2.lng === this._center.lng || (this._unmodified = false, this._center = e2, this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCenterElevation() ? this._updateCameraOnTerrain() : this._cameraZoom = null : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
        }
        _updateZoomFromElevation() {
          if (null == this._cameraZoom || !this._elevation)
            return;
          const t2 = this._cameraZoom, i2 = this._elevation.getAtPointOrZero(e.MercatorCoordinate.fromLngLat(this.center)), o2 = e.mercatorZfromAltitude(i2, this.center.lat), r2 = this._mercatorZfromZoom(t2), n2 = this._mercatorZfromZoom(this._maxZoom), a2 = Math.max(r2 - o2, n2);
          this._setZoom(this._zoomFromMercatorZ(a2));
        }
        get padding() {
          return this._edgeInsets.toJSON();
        }
        set padding(e2) {
          this._edgeInsets.equals(e2) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e2, 1), this._calcMatrices());
        }
        computeZoomRelativeTo(t2) {
          const i2 = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t2.toAltitude()));
          let o2;
          o2 = t2.z < this._camera.position[2] ? [i2.x, i2.y, i2.z] : [t2.x, t2.y, t2.z];
          const r2 = e.length(e.sub([], this._camera.position, o2));
          return e.clamp(this._zoomFromMercatorZ(r2), this._minZoom, this._maxZoom);
        }
        setFreeCameraOptions(t2) {
          if (!this.height)
            return;
          if (!t2.position && !t2.orientation)
            return;
          this._updateCameraState();
          let i2 = false;
          if (t2.orientation && !e.exactEquals(t2.orientation, this._camera.orientation) && (i2 = this._setCameraOrientation(t2.orientation)), t2.position) {
            const o2 = [t2.position.x, t2.position.y, t2.position.z];
            e.exactEquals$1(o2, this._camera.position) || (this._setCameraPosition(o2), i2 = true);
          }
          i2 && (this._updateStateFromCamera(), this.recenterOnTerrain());
        }
        getFreeCameraOptions() {
          this._updateCameraState();
          const t2 = this._camera.position, i2 = new wo();
          return i2.position = new e.MercatorCoordinate(t2[0], t2[1], t2[2]), i2.orientation = this._camera.orientation, i2._elevation = this.elevation, i2._renderWorldCopies = this._renderWorldCopies, i2;
        }
        _setCameraOrientation(t2) {
          if (!e.length$1(t2))
            return false;
          e.normalize$1(t2, t2);
          const i2 = e.transformQuat([], [0, 0, -1], t2), o2 = e.transformQuat([], [0, -1, 0], t2);
          if (o2[2] < 0)
            return false;
          const r2 = bo(i2, o2);
          return !!r2 && (this._camera.orientation = r2, true);
        }
        _setCameraPosition(t2) {
          const i2 = this.zoomScale(this.minZoom) * this.tileSize, o2 = this.zoomScale(this.maxZoom) * this.tileSize, r2 = this.cameraToCenterDistance;
          t2[2] = e.clamp(t2[2], r2 / o2, r2 / i2), this._camera.position = t2;
        }
        get centerPoint() {
          return this._edgeInsets.getCenter(this.width, this.height);
        }
        get fovAboveCenter() {
          return this._fov * (0.5 + this.centerOffset.y / this.height);
        }
        isPaddingEqual(e2) {
          return this._edgeInsets.equals(e2);
        }
        interpolatePadding(e2, t2, i2) {
          this._unmodified = false, this._edgeInsets.interpolate(e2, t2, i2), this._constrain(), this._calcMatrices();
        }
        coveringZoomLevel(e2) {
          const t2 = (e2.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e2.tileSize));
          return Math.max(0, t2);
        }
        getVisibleUnwrappedCoordinates(t2) {
          const i2 = [new e.UnwrappedTileID(0, t2)];
          if (this._renderWorldCopies) {
            const o2 = this.pointCoordinate(new e.pointGeometry(0, 0)), r2 = this.pointCoordinate(new e.pointGeometry(this.width, 0)), n2 = this.pointCoordinate(new e.pointGeometry(this.width, this.height)), a2 = this.pointCoordinate(new e.pointGeometry(0, this.height)), s2 = Math.floor(Math.min(o2.x, r2.x, n2.x, a2.x)), l2 = Math.floor(Math.max(o2.x, r2.x, n2.x, a2.x)), c2 = 1;
            for (let o3 = s2 - c2; o3 <= l2 + c2; o3++)
              0 !== o3 && i2.push(new e.UnwrappedTileID(o3, t2));
          }
          return i2;
        }
        coveringTiles(t2) {
          let i2 = this.coveringZoomLevel(t2);
          const o2 = i2, r2 = this.elevation && !t2.isTerrainDEM;
          if (void 0 !== t2.minzoom && i2 < t2.minzoom)
            return [];
          void 0 !== t2.maxzoom && i2 > t2.maxzoom && (i2 = t2.maxzoom);
          const n2 = e.MercatorCoordinate.fromLngLat(this.center), a2 = 1 << i2, s2 = [a2 * n2.x, a2 * n2.y, 0], l2 = _.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i2), c2 = this.pointCoordinate(this.getCameraPoint()), h2 = a2 * e.mercatorZfromAltitude(1, this.center.lat), u2 = this._camera.position[2] / e.mercatorZfromAltitude(1, this.center.lat), d2 = [a2 * c2.x, a2 * c2.y, u2], m2 = this.cameraToCenterDistance / t2.tileSize * (t2.roundZoom ? 1 : 0.502), f2 = this.pitch <= 60 && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation ? i2 : 0, g2 = t2.isTerrainDEM && this._elevation ? 1e4 * this._elevation.exaggeration() : this._centerAltitude, v2 = t2.isTerrainDEM ? -g2 : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, x2 = (e2) => ({ aabb: new p([e2 * a2, 0, v2], [(e2 + 1) * a2, a2, g2]), zoom: 0, x: 0, y: 0, wrap: e2, fullyVisible: false }), y2 = [];
          let b2 = [];
          const w2 = i2, T2 = t2.reparseOverscaled ? o2 : i2, E2 = (e2) => {
            if (!this._elevation || !e2.tileID)
              return;
            const t3 = this._elevation.getMinMaxForTile(e2.tileID), i3 = e2.aabb;
            t3 ? (i3.min[2] = t3.min, i3.max[2] = t3.max, i3.center[2] = (i3.min[2] + i3.max[2]) / 2) : (e2.shouldSplit = M2(e2), e2.shouldSplit || (i3.min[2] = i3.max[2] = i3.center[2] = this._centerAltitude));
          }, C2 = (e2) => e2 * e2, S2 = C2((u2 - this._centerAltitude) * h2), M2 = (e2) => {
            if (e2.zoom < f2)
              return true;
            if (e2.zoom === w2)
              return false;
            if (null != e2.shouldSplit)
              return e2.shouldSplit;
            const t3 = e2.aabb.distanceX(d2), i3 = e2.aabb.distanceY(d2);
            let o3 = S2;
            r2 && (o3 = C2(e2.aabb.distanceZ(d2) * h2));
            const n3 = t3 * t3 + i3 * i3 + o3;
            return n3 < C2((1 << w2 - e2.zoom) * m2 * ((e3, t4) => {
              if (t4 * C2(0.707) < e3)
                return 1;
              const i4 = Math.sqrt(t4 / e3);
              return i4 / (1.4144271570014144 + (Math.pow(1.1, i4 - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
            })(Math.max(o3, S2), n3));
          };
          if (this._renderWorldCopies)
            for (let e2 = 1; e2 <= 3; e2++)
              y2.push(x2(-e2)), y2.push(x2(e2));
          for (y2.push(x2(0)); y2.length > 0; ) {
            const o3 = y2.pop(), n3 = o3.x, a3 = o3.y;
            let c3 = o3.fullyVisible;
            if (!c3) {
              const e2 = o3.aabb.intersects(l2);
              if (0 === e2)
                continue;
              c3 = 2 === e2;
            }
            if (o3.zoom !== w2 && M2(o3))
              for (let t3 = 0; t3 < 4; t3++) {
                const i3 = (n3 << 1) + t3 % 2, s3 = (a3 << 1) + (t3 >> 1), l3 = { aabb: o3.aabb.quadrant(t3), zoom: o3.zoom + 1, x: i3, y: s3, wrap: o3.wrap, fullyVisible: c3, tileID: void 0, shouldSplit: void 0 };
                r2 && (l3.tileID = new e.OverscaledTileID(o3.zoom + 1 === w2 ? T2 : o3.zoom + 1, o3.wrap, o3.zoom + 1, i3, s3), E2(l3)), y2.push(l3);
              }
            else {
              const r3 = o3.zoom === w2 ? T2 : o3.zoom;
              if (t2.minzoom && t2.minzoom > r3)
                continue;
              const l3 = s2[0] - (0.5 + n3 + (o3.wrap << o3.zoom)) * (1 << i2 - o3.zoom), c4 = s2[1] - 0.5 - a3, h3 = o3.tileID ? o3.tileID : new e.OverscaledTileID(r3, o3.wrap, o3.zoom, n3, a3);
              b2.push({ tileID: h3, distanceSq: l3 * l3 + c4 * c4 });
            }
          }
          if (this.fogCullDistSq) {
            const i3 = this.fogCullDistSq, o3 = this.horizonLineFromTop();
            b2 = b2.filter((r3) => {
              const n3 = [0, 0, 0, 1], a3 = [e.EXTENT, e.EXTENT, 0, 1], s3 = this.calculateFogTileMatrix(r3.tileID.toUnwrapped());
              e.transformMat4(n3, n3, s3), e.transformMat4(a3, a3, s3);
              const l3 = e.getAABBPointSquareDist(n3, a3);
              if (0 === l3)
                return true;
              let c3 = false;
              const h3 = this._elevation;
              if (h3 && l3 > i3 && 0 !== o3) {
                const i4 = this.calculateProjMatrix(r3.tileID.toUnwrapped());
                let n4;
                t2.isTerrainDEM || (n4 = h3.getMinMaxForTile(r3.tileID)), n4 || (n4 = { min: v2, max: g2 });
                const a4 = e.furthestTileCorner(this.bearing), s4 = [a4[0] * e.EXTENT, a4[1] * e.EXTENT, n4.max];
                e.transformMat4$1(s4, s4, i4), c3 = (1 - s4[1]) * this.height * 0.5 < o3;
              }
              return l3 < i3 || c3;
            });
          }
          return b2.sort((e2, t3) => e2.distanceSq - t3.distanceSq).map((e2) => e2.tileID);
        }
        resize(e2, t2) {
          this.width = e2, this.height = t2, this.pixelsToGLUnits = [2 / e2, -2 / t2], this._constrain(), this._calcMatrices();
        }
        get unmodified() {
          return this._unmodified;
        }
        zoomScale(e2) {
          return Math.pow(2, e2);
        }
        scaleZoom(e2) {
          return Math.log(e2) / Math.LN2;
        }
        project(t2) {
          const i2 = e.clamp(t2.lat, -this.maxValidLatitude, this.maxValidLatitude);
          return new e.pointGeometry(e.mercatorXfromLng(t2.lng) * this.worldSize, e.mercatorYfromLat(i2) * this.worldSize);
        }
        unproject(t2) {
          return new e.MercatorCoordinate(t2.x / this.worldSize, t2.y / this.worldSize).toLngLat();
        }
        get point() {
          return this.project(this.center);
        }
        setLocationAtPoint(t2, i2) {
          const o2 = this.pointCoordinate(i2), r2 = this.pointCoordinate(this.centerPoint), n2 = this.locationCoordinate(t2), a2 = new e.MercatorCoordinate(n2.x - (o2.x - r2.x), n2.y - (o2.y - r2.y));
          this.center = this.coordinateLocation(a2), this._renderWorldCopies && (this.center = this.center.wrap());
        }
        setLocation(e2) {
          this.center = this.coordinateLocation(e2), this._renderWorldCopies && (this.center = this.center.wrap());
        }
        locationPoint(e2) {
          return this._coordinatePoint(this.locationCoordinate(e2), false);
        }
        locationPoint3D(e2) {
          return this._coordinatePoint(this.locationCoordinate(e2), true);
        }
        pointLocation(e2) {
          return this.coordinateLocation(this.pointCoordinate(e2));
        }
        pointLocation3D(e2) {
          return this.coordinateLocation(this.pointCoordinate3D(e2));
        }
        locationCoordinate(t2) {
          return e.MercatorCoordinate.fromLngLat(t2);
        }
        coordinateLocation(e2) {
          return e2.toLngLat();
        }
        pointRayIntersection(t2, i2) {
          const o2 = null != i2 ? i2 : this._centerAltitude, r2 = [t2.x, t2.y, 0, 1], n2 = [t2.x, t2.y, 1, 1];
          e.transformMat4(r2, r2, this.pixelMatrixInverse), e.transformMat4(n2, n2, this.pixelMatrixInverse);
          const a2 = n2[3];
          e.scale$2(r2, r2, 1 / r2[3]), e.scale$2(n2, n2, 1 / a2);
          const s2 = r2[2], l2 = n2[2];
          return { p0: r2, p1: n2, t: s2 === l2 ? 0 : (o2 - s2) / (l2 - s2) };
        }
        screenPointToMercatorRay(t2) {
          const i2 = [t2.x, t2.y, 0, 1], o2 = [t2.x, t2.y, 1, 1];
          return e.transformMat4(i2, i2, this.pixelMatrixInverse), e.transformMat4(o2, o2, this.pixelMatrixInverse), e.scale$2(i2, i2, 1 / i2[3]), e.scale$2(o2, o2, 1 / o2[3]), i2[2] = e.mercatorZfromAltitude(i2[2], this._center.lat) * this.worldSize, o2[2] = e.mercatorZfromAltitude(o2[2], this._center.lat) * this.worldSize, e.scale$2(i2, i2, 1 / this.worldSize), e.scale$2(o2, o2, 1 / this.worldSize), new d([i2[0], i2[1], i2[2]], e.normalize([], e.sub([], o2, i2)));
        }
        rayIntersectionCoordinate(t2) {
          const { p0: i2, p1: o2, t: r2 } = t2, n2 = e.mercatorZfromAltitude(i2[2], this._center.lat), a2 = e.mercatorZfromAltitude(o2[2], this._center.lat);
          return new e.MercatorCoordinate(e.number(i2[0], o2[0], r2) / this.worldSize, e.number(i2[1], o2[1], r2) / this.worldSize, e.number(n2, a2, r2));
        }
        pointCoordinate(t2, i2 = this._centerAltitude) {
          const o2 = this.horizonLineFromTop(false), r2 = new e.pointGeometry(t2.x, Math.max(o2, t2.y));
          return this.rayIntersectionCoordinate(this.pointRayIntersection(r2, i2));
        }
        pointCoordinate3D(t2) {
          if (!this.elevation)
            return this.pointCoordinate(t2);
          const i2 = this.elevation;
          let o2 = this.elevation.pointCoordinate(t2);
          if (o2)
            return new e.MercatorCoordinate(o2[0], o2[1], o2[2]);
          let r2 = 0, n2 = this.horizonLineFromTop();
          if (t2.y > n2)
            return this.pointCoordinate(t2);
          const a2 = 0.02 * n2, s2 = t2.clone();
          for (let t3 = 0; t3 < 10 && n2 - r2 > a2; t3++) {
            s2.y = e.number(r2, n2, 0.66);
            const t4 = i2.pointCoordinate(s2);
            t4 ? (n2 = s2.y, o2 = t4) : r2 = s2.y;
          }
          return o2 ? new e.MercatorCoordinate(o2[0], o2[1], o2[2]) : this.pointCoordinate(t2);
        }
        isPointAboveHorizon(e2) {
          if (this.elevation)
            return !this.elevation.pointCoordinate(e2);
          {
            const t2 = this.horizonLineFromTop();
            return e2.y < t2;
          }
        }
        _coordinatePoint(t2, i2) {
          const o2 = i2 && this.elevation ? this.elevation.getAtPointOrZero(t2, this._centerAltitude) : this._centerAltitude, r2 = [t2.x * this.worldSize, t2.y * this.worldSize, o2 + t2.toAltitude(), 1];
          return e.transformMat4(r2, r2, this.pixelMatrix), r2[3] > 0 ? new e.pointGeometry(r2[0] / r2[3], r2[1] / r2[3]) : new e.pointGeometry(Number.MAX_VALUE, Number.MAX_VALUE);
        }
        _getBounds(t2, i2) {
          const o2 = new e.pointGeometry(this._edgeInsets.left, this._edgeInsets.top), r2 = new e.pointGeometry(this.width - this._edgeInsets.right, this._edgeInsets.top), n2 = new e.pointGeometry(this.width - this._edgeInsets.right, this.height - this._edgeInsets.bottom), a2 = new e.pointGeometry(this._edgeInsets.left, this.height - this._edgeInsets.bottom);
          let s2 = this.pointCoordinate(o2, t2), l2 = this.pointCoordinate(r2, t2);
          const c2 = this.pointCoordinate(n2, i2), h2 = this.pointCoordinate(a2, i2), u2 = (e2, t3) => (t3.y - e2.y) / (t3.x - e2.x);
          return s2.y > 1 && l2.y >= 0 ? s2 = new e.MercatorCoordinate((1 - h2.y) / u2(h2, s2) + h2.x, 1) : s2.y < 0 && l2.y <= 1 && (s2 = new e.MercatorCoordinate(-h2.y / u2(h2, s2) + h2.x, 0)), l2.y > 1 && s2.y >= 0 ? l2 = new e.MercatorCoordinate((1 - c2.y) / u2(c2, l2) + c2.x, 1) : l2.y < 0 && s2.y <= 1 && (l2 = new e.MercatorCoordinate(-c2.y / u2(c2, l2) + c2.x, 0)), new e.LngLatBounds().extend(this.coordinateLocation(s2)).extend(this.coordinateLocation(l2)).extend(this.coordinateLocation(h2)).extend(this.coordinateLocation(c2));
        }
        _getBounds3D() {
          const e2 = this.elevation, t2 = e2.visibleDemTiles.reduce((e3, t3) => {
            if (t3.dem) {
              const i2 = t3.dem.tree;
              e3.min = Math.min(e3.min, i2.minimums[0]), e3.max = Math.max(e3.max, i2.maximums[0]);
            }
            return e3;
          }, { min: Number.MAX_VALUE, max: 0 });
          return this._getBounds(t2.min * e2.exaggeration(), t2.max * e2.exaggeration());
        }
        getBounds() {
          return this._terrainEnabled() ? this._getBounds3D() : this._getBounds(0, 0);
        }
        horizonLineFromTop(e2 = true) {
          const t2 = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, 0.1)) + this.centerOffset.y, i2 = this.height / 2 - t2 * (1 - this._horizonShift);
          return e2 ? Math.max(0, i2) : i2;
        }
        getMaxBounds() {
          return this.latRange && 2 === this.latRange.length && this.lngRange && 2 === this.lngRange.length ? new e.LngLatBounds([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
        }
        setMaxBounds(e2) {
          if (e2) {
            const t2 = e2.getEast(), i2 = e2.getWest();
            this.lngRange = [i2, t2 > i2 ? t2 : t2 + 360], this.latRange = [e2.getSouth(), e2.getNorth()], this._constrain();
          } else
            this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude];
        }
        calculatePosMatrix(t2, i2) {
          const o2 = t2.canonical, r2 = i2 / this.zoomScale(o2.z), n2 = o2.x + Math.pow(2, o2.z) * t2.wrap, a2 = e.identity(new Float64Array(16));
          return e.translate(a2, a2, [n2 * r2, o2.y * r2, 0]), e.scale$1(a2, a2, [r2 / e.EXTENT, r2 / e.EXTENT, 1]), a2;
        }
        calculateFogTileMatrix(t2) {
          const i2 = t2.key, o2 = this._fogTileMatrixCache;
          if (o2[i2])
            return o2[i2];
          const r2 = this.calculatePosMatrix(t2, this.cameraWorldSize);
          return e.multiply(r2, this.worldToFogMatrix, r2), o2[i2] = new Float32Array(r2), o2[i2];
        }
        calculateProjMatrix(t2, i2 = false) {
          const o2 = t2.key, r2 = i2 ? this._alignedProjMatrixCache : this._projMatrixCache;
          if (r2[o2])
            return r2[o2];
          const n2 = this.calculatePosMatrix(t2, this.worldSize);
          return e.multiply(n2, i2 ? this.alignedProjMatrix : this.projMatrix, n2), r2[o2] = new Float32Array(n2), r2[o2];
        }
        customLayerMatrix() {
          return this.mercatorMatrix.slice();
        }
        recenterOnTerrain() {
          if (!this._elevation)
            return;
          const t2 = this._elevation;
          this._updateCameraState();
          const i2 = this._camera.position, o2 = this._camera.forward();
          if (i2[2] <= 0 || o2[2] >= 0)
            return;
          const r2 = e.mercatorZfromAltitude(1, this._center.lat);
          i2[2] /= r2, o2[2] /= r2, e.normalize(o2, o2);
          const n2 = t2.raycast(i2, o2, t2.exaggeration());
          if (n2) {
            const t3 = e.scaleAndAdd([], i2, o2, n2), r3 = new e.MercatorCoordinate(t3[0], t3[1], e.mercatorZfromAltitude(t3[2], e.latFromMercatorY(t3[1]))), a2 = this._camera.position, s2 = r3.z + e.length([r3.x - a2[0], r3.y - a2[1], r3.z - a2[2]]);
            this._cameraZoom = this._zoomFromMercatorZ(s2), this._centerAltitude = r3.toAltitude(), this._center = r3.toLngLat(), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
          }
        }
        _constrainCameraAltitude() {
          if (!this._elevation)
            return;
          const t2 = this._elevation;
          this._updateCameraState();
          const i2 = t2.getAtPointOrZero(this._camera.mercatorPosition), o2 = this._minimumHeightOverTerrain() * Math.cos(e.degToRad(this._maxPitch)), r2 = e.mercatorZfromAltitude(i2, this._center.lat), n2 = this._camera.position[2] - r2;
          if (n2 < o2) {
            const t3 = e.MercatorCoordinate.fromLngLat(this._center, this._centerAltitude), i3 = this._camera.mercatorPosition, r3 = [t3.x - i3.x, t3.y - i3.y, t3.z - i3.z], a2 = e.length(r3);
            r3[2] -= o2 - n2;
            const s2 = e.length(r3);
            if (0 === s2)
              return;
            e.scale(r3, r3, a2 / s2), this._camera.position = [t3.x - r3[0], t3.y - r3[1], t3.z - r3[2]], this._camera.orientation = bo(r3, this._camera.up()), this._updateStateFromCamera();
          }
        }
        _constrain() {
          if (!this.center || !this.width || !this.height || this._constraining)
            return;
          this._constraining = true;
          let t2, i2, o2, r2, n2, a2 = 1 / 0, s2 = -1 / 0;
          const l2 = this.size, c2 = this._unmodified;
          if (this.latRange) {
            const t3 = this.latRange;
            a2 = e.mercatorYfromLat(t3[1]) * this.worldSize, s2 = e.mercatorYfromLat(t3[0]) * this.worldSize, o2 = s2 - a2 < l2.y ? l2.y / (s2 - a2) : 0;
          }
          if (this.lngRange) {
            const o3 = this.lngRange;
            t2 = e.mercatorXfromLng(o3[0]) * this.worldSize, i2 = e.mercatorXfromLng(o3[1]) * this.worldSize, r2 = i2 - t2 < l2.x ? l2.x / (i2 - t2) : 0;
          }
          const h2 = this.point, u2 = Math.max(r2 || 0, o2 || 0);
          if (u2)
            return this.center = this.unproject(new e.pointGeometry(r2 ? (i2 + t2) / 2 : h2.x, o2 ? (s2 + a2) / 2 : h2.y)), this.zoom += this.scaleZoom(u2), this._unmodified = c2, void (this._constraining = false);
          if (this.latRange) {
            const e2 = h2.y, t3 = l2.y / 2;
            e2 - t3 < a2 && (n2 = a2 + t3), e2 + t3 > s2 && (n2 = s2 - t3);
          }
          let d2 = h2.x;
          if (this.lngRange) {
            const e2 = this.worldSize / 2 - (t2 + i2) / 2;
            d2 = (d2 + e2 + this.worldSize) % this.worldSize, t2 += e2, i2 += e2;
            const o3 = l2.x / 2;
            d2 - o3 < t2 && (d2 = t2 + o3), d2 + o3 > i2 && (d2 = i2 - o3), d2 -= e2;
          }
          d2 === h2.x && void 0 === n2 || (this.center = this.unproject(new e.pointGeometry(d2, void 0 !== n2 ? n2 : h2.y))), this._constrainCameraAltitude(), this._unmodified = c2, this._constraining = false;
        }
        _minZoomForBounds() {
          const t2 = (e2, t3) => Math.log2(e2 / (this.tileSize * Math.abs(t3[1] - t3[0])));
          let i2 = 0;
          if (this.latRange) {
            const o3 = this.latRange;
            i2 = t2(this.height, [e.mercatorYfromLat(o3[0]), e.mercatorYfromLat(o3[1])]);
          }
          let o2 = 0;
          if (this.lngRange) {
            const i3 = this.lngRange;
            o2 = t2(this.width, [e.mercatorXfromLng(i3[0]), e.mercatorXfromLng(i3[1])]);
          }
          return Math.max(i2, o2);
        }
        _maxCameraBoundsDistance() {
          return this._mercatorZfromZoom(this._minZoomForBounds());
        }
        _calcMatrices() {
          if (!this.height)
            return;
          const t2 = this.centerOffset;
          this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height;
          const i2 = this.pixelsPerMeter;
          this._updateCameraState();
          const o2 = Math.PI / 2 + this._pitch, r2 = this.fovAboveCenter, n2 = this.elevation ? this.elevation.getMinElevationBelowMSL() * i2 : 0, a2 = (this._camera.position[2] * this.worldSize - n2) / Math.cos(this._pitch), s2 = Math.sin(r2) * a2 / Math.sin(e.clamp(Math.PI - o2 - r2, 0.01, Math.PI - 0.01)), l2 = this.point, c2 = l2.x, h2 = l2.y, u2 = Math.cos(Math.PI / 2 - this._pitch) * s2 + a2, d2 = Math.min(1.01 * u2, a2 * (1 / this._horizonShift)), _2 = this.height / 50, p2 = this._camera.getWorldToCamera(this.worldSize, i2), m2 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, _2, d2);
          m2[8] = 2 * -t2.x / this.width, m2[9] = 2 * t2.y / this.height;
          let f2 = e.mul$1([], m2, p2);
          this.mercatorMatrix = e.scale$1([], f2, [this.worldSize, this.worldSize, this.worldSize / i2]), this.projMatrix = f2, this.invProjMatrix = e.invert(new Float64Array(16), this.projMatrix);
          const g2 = new Float32Array(16);
          e.identity(g2), e.scale$1(g2, g2, [1, -1, 1]), e.rotateX(g2, g2, this._pitch), e.rotateZ(g2, g2, this.angle);
          const v2 = e.perspective(new Float32Array(16), this._fov, this.width / this.height, _2, d2), x2 = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
          v2[8] = 2 * -t2.x / this.width, v2[9] = 2 * (t2.y + x2) / this.height, this.skyboxMatrix = e.multiply(g2, v2, g2);
          const y2 = this.width % 2 / 2, b2 = this.height % 2 / 2, w2 = Math.cos(this.angle), T2 = Math.sin(this.angle), E2 = c2 - Math.round(c2) + w2 * y2 + T2 * b2, C2 = h2 - Math.round(h2) + w2 * b2 + T2 * y2, S2 = new Float64Array(f2);
          if (e.translate(S2, S2, [E2 > 0.5 ? E2 - 1 : E2, C2 > 0.5 ? C2 - 1 : C2, 0]), this.alignedProjMatrix = S2, f2 = e.create$1(), e.scale$1(f2, f2, [this.width / 2, -this.height / 2, 1]), e.translate(f2, f2, [1, -1, 0]), this.labelPlaneMatrix = f2, f2 = e.create$1(), e.scale$1(f2, f2, [1, -1, 1]), e.translate(f2, f2, [-1, -1, 0]), e.scale$1(f2, f2, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = f2, this.pixelMatrix = e.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), this._calcFogMatrices(), f2 = e.invert(new Float64Array(16), this.pixelMatrix), !f2)
            throw new Error("failed to invert matrix");
          this.pixelMatrixInverse = f2, this._projMatrixCache = {}, this._alignedProjMatrixCache = {};
        }
        _calcFogMatrices() {
          this._fogTileMatrixCache = {};
          const t2 = this.cameraWorldSize, i2 = this.cameraPixelsPerMeter, o2 = this._camera.position, r2 = 1 / this.height, n2 = [t2, t2, i2];
          e.scale(n2, n2, r2), e.scale(o2, o2, -1), e.multiply$1(o2, o2, n2);
          const a2 = e.create$1();
          e.translate(a2, a2, o2), e.scale$1(a2, a2, n2), this.mercatorFogMatrix = a2, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t2, i2, r2);
        }
        _updateCameraState() {
          if (!this.height)
            return;
          this._camera.setPitchBearing(this._pitch, this.angle);
          const t2 = this._camera.forward(), i2 = this.cameraToCenterDistance, o2 = this.point, r2 = this._mercatorZfromZoom(this._cameraZoom ? this._cameraZoom : this._zoom) - e.mercatorZfromAltitude(this._centerAltitude, this.center.lat), n2 = this.cameraToCenterDistance / r2;
          this._camera.position = [o2.x / this.worldSize - t2[0] * i2 / n2, o2.y / this.worldSize - t2[1] * i2 / n2, e.mercatorZfromAltitude(this._centerAltitude, this._center.lat) + -t2[2] * i2 / n2];
        }
        _translateCameraConstrained(t2) {
          const i2 = this._maxCameraBoundsDistance() * Math.cos(this._pitch), o2 = t2[2];
          let r2 = 1;
          o2 > 0 && (r2 = Math.min((i2 - this._camera.position[2]) / o2, 1)), this._camera.position = e.scaleAndAdd([], this._camera.position, t2, r2), this._updateStateFromCamera();
        }
        _updateStateFromCamera() {
          const t2 = this._camera.position, i2 = this._camera.forward(), { pitch: o2, bearing: r2 } = this._camera.getPitchBearing(), n2 = e.mercatorZfromAltitude(this._centerAltitude, this.center.lat), a2 = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e.degToRad(this._maxPitch)), s2 = Math.max((t2[2] - n2) / Math.cos(o2), a2), l2 = this._zoomFromMercatorZ(s2);
          e.scaleAndAdd(t2, t2, i2, s2), this._pitch = e.clamp(o2, e.degToRad(this.minPitch), e.degToRad(this.maxPitch)), this.angle = e.wrap(r2, -Math.PI, Math.PI), this._setZoom(e.clamp(l2, this._minZoom, this._maxZoom)), this._terrainEnabled() && this._updateCameraOnTerrain(), this._center = new e.MercatorCoordinate(t2[0], t2[1], t2[2]).toLngLat(), this._unmodified = false, this._constrain(), this._calcMatrices();
        }
        _worldSizeFromZoom(e2) {
          return Math.pow(2, e2) * this.tileSize;
        }
        _mercatorZfromZoom(e2) {
          return this.cameraToCenterDistance / this._worldSizeFromZoom(e2);
        }
        _minimumHeightOverTerrain() {
          const e2 = Math.min((null != this._cameraZoom ? this._cameraZoom : this._zoom) + 2, this._maxZoom);
          return this._mercatorZfromZoom(e2);
        }
        _zoomFromMercatorZ(e2) {
          return this.scaleZoom(this.cameraToCenterDistance / (e2 * this.tileSize));
        }
        _terrainEnabled() {
          return !!this._elevation;
        }
        isCornerOffEdge(t2, i2) {
          const o2 = Math.min(t2.x, i2.x), r2 = Math.max(t2.x, i2.x), n2 = Math.min(t2.y, i2.y), a2 = Math.max(t2.y, i2.y);
          if (n2 < this.horizonLineFromTop(false))
            return true;
          const s2 = [new e.pointGeometry(o2, n2), new e.pointGeometry(r2, a2), new e.pointGeometry(o2, a2), new e.pointGeometry(r2, n2)], l2 = this._renderWorldCopies ? -3 : 0, c2 = this._renderWorldCopies ? 4 : 1;
          for (const e2 of s2) {
            const t3 = this.pointRayIntersection(e2);
            if (t3.t < 0)
              return true;
            const i3 = this.rayIntersectionCoordinate(t3);
            if (i3.x < l2 || i3.y < 0 || i3.x > c2 || i3.y > 1)
              return true;
          }
          return false;
        }
        isHorizonVisible() {
          return this.pitch + e.radToDeg(this.fovAboveCenter) > 88 || this.isCornerOffEdge(new e.pointGeometry(0, 0), new e.pointGeometry(this.width, this.height));
        }
        zoomDeltaToMovement(t2, i2) {
          const o2 = e.length(e.sub([], this._camera.position, t2)), r2 = this._zoomFromMercatorZ(o2) + i2;
          return o2 - this._mercatorZfromZoom(r2);
        }
        getCameraPoint() {
          const t2 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
          return this.centerPoint.add(new e.pointGeometry(0, t2));
        }
      }
      function Co(e2, t2) {
        let i2 = false, o2 = null;
        const r2 = () => {
          o2 = null, i2 && (e2(), o2 = setTimeout(r2, t2), i2 = false);
        };
        return () => (i2 = true, o2 || r2(), o2);
      }
      class So {
        constructor(t2) {
          this._hashName = t2 && encodeURIComponent(t2), e.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = Co(this._updateHashUnthrottled.bind(this), 300);
        }
        addTo(t2) {
          return this._map = t2, e.window.addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
        }
        remove() {
          return e.window.removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
        }
        getHashString(t2) {
          const i2 = this._map.getCenter(), o2 = Math.round(100 * this._map.getZoom()) / 100, r2 = Math.ceil((o2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), n2 = Math.pow(10, r2), a2 = Math.round(i2.lng * n2) / n2, s2 = Math.round(i2.lat * n2) / n2, l2 = this._map.getBearing(), c2 = this._map.getPitch();
          let h2 = "";
          if (h2 += t2 ? `/${a2}/${s2}/${o2}` : `${o2}/${s2}/${a2}`, (l2 || c2) && (h2 += "/" + Math.round(10 * l2) / 10), c2 && (h2 += `/${Math.round(c2)}`), this._hashName) {
            const t3 = this._hashName;
            let i3 = false;
            const o3 = e.window.location.hash.slice(1).split("&").map((e2) => {
              const o4 = e2.split("=")[0];
              return o4 === t3 ? (i3 = true, `${o4}=${h2}`) : e2;
            }).filter((e2) => e2);
            return i3 || o3.push(`${t3}=${h2}`), `#${o3.join("&")}`;
          }
          return `#${h2}`;
        }
        _getCurrentHash() {
          const t2 = e.window.location.hash.replace("#", "");
          if (this._hashName) {
            let e2;
            return t2.split("&").map((e3) => e3.split("=")).forEach((t3) => {
              t3[0] === this._hashName && (e2 = t3);
            }), (e2 && e2[1] || "").split("/");
          }
          return t2.split("/");
        }
        _onHashChange() {
          const e2 = this._getCurrentHash();
          if (e2.length >= 3 && !e2.some((e3) => isNaN(e3))) {
            const t2 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(e2[3] || 0) : this._map.getBearing();
            return this._map.jumpTo({ center: [+e2[2], +e2[1]], zoom: +e2[0], bearing: t2, pitch: +(e2[4] || 0) }), true;
          }
          return false;
        }
        _updateHashUnthrottled() {
          const t2 = e.window.location.href.replace(/(#.+)?$/, this.getHashString());
          e.window.history.replaceState(e.window.history.state, null, t2);
        }
      }
      const Mo = { linearity: 0.3, easing: e.bezier(0, 0, 0.3, 1) }, Io = e.extend({ deceleration: 2500, maxSpeed: 1400 }, Mo), Do = e.extend({ deceleration: 20, maxSpeed: 1400 }, Mo), Ao = e.extend({ deceleration: 1e3, maxSpeed: 360 }, Mo), zo = e.extend({ deceleration: 1e3, maxSpeed: 90 }, Mo);
      class Po {
        constructor(e2) {
          this._map = e2, this.clear();
        }
        clear() {
          this._inertiaBuffer = [];
        }
        record(t2) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: e.exported.now(), settings: t2 });
        }
        _drainInertiaBuffer() {
          const t2 = this._inertiaBuffer, i2 = e.exported.now();
          for (; t2.length > 0 && i2 - t2[0].time > 160; )
            t2.shift();
        }
        _onMoveEnd(t2) {
          if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
            return;
          const i2 = { zoom: 0, bearing: 0, pitch: 0, pan: new e.pointGeometry(0, 0), pinchAround: void 0, around: void 0 };
          for (const { settings: e2 } of this._inertiaBuffer)
            i2.zoom += e2.zoomDelta || 0, i2.bearing += e2.bearingDelta || 0, i2.pitch += e2.pitchDelta || 0, e2.panDelta && i2.pan._add(e2.panDelta), e2.around && (i2.around = e2.around), e2.pinchAround && (i2.pinchAround = e2.pinchAround);
          const o2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, r2 = {};
          if (i2.pan.mag()) {
            const n2 = Ro(i2.pan.mag(), o2, e.extend({}, Io, t2 || {}));
            r2.offset = i2.pan.mult(n2.amount / i2.pan.mag()), r2.center = this._map.transform.center, Lo(r2, n2);
          }
          if (i2.zoom) {
            const e2 = Ro(i2.zoom, o2, Do);
            r2.zoom = this._map.transform.zoom + e2.amount, Lo(r2, e2);
          }
          if (i2.bearing) {
            const t3 = Ro(i2.bearing, o2, Ao);
            r2.bearing = this._map.transform.bearing + e.clamp(t3.amount, -179, 179), Lo(r2, t3);
          }
          if (i2.pitch) {
            const e2 = Ro(i2.pitch, o2, zo);
            r2.pitch = this._map.transform.pitch + e2.amount, Lo(r2, e2);
          }
          if (r2.zoom || r2.bearing) {
            const e2 = void 0 === i2.pinchAround ? i2.around : i2.pinchAround;
            r2.around = e2 ? this._map.unproject(e2) : this._map.getCenter();
          }
          return this.clear(), e.extend(r2, { noMoveStart: true });
        }
      }
      function Lo(e2, t2) {
        (!e2.duration || e2.duration < t2.duration) && (e2.duration = t2.duration, e2.easing = t2.easing);
      }
      function Ro(t2, i2, o2) {
        const { maxSpeed: r2, linearity: n2, deceleration: a2 } = o2, s2 = e.clamp(t2 * n2 / (i2 / 1e3), -r2, r2), l2 = Math.abs(s2) / (a2 * n2);
        return { easing: o2.easing, duration: 1e3 * l2, amount: s2 * (l2 / 2) };
      }
      class ko extends e.Event {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t2, i2, o2, r2 = {}) {
          const a2 = n.mousePos(i2.getCanvasContainer(), o2), s2 = i2.unproject(a2);
          super(t2, e.extend({ point: a2, lngLat: s2, originalEvent: o2 }, r2)), this._defaultPrevented = false, this.target = i2;
        }
      }
      class Fo extends e.Event {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t2, i2, o2) {
          const r2 = "touchend" === t2 ? o2.changedTouches : o2.touches, a2 = n.touchPos(i2.getCanvasContainer(), r2), s2 = a2.map((e2) => i2.unproject(e2)), l2 = a2.reduce((e2, t3, i3, o3) => e2.add(t3.div(o3.length)), new e.pointGeometry(0, 0));
          super(t2, { points: a2, point: l2, lngLats: s2, lngLat: i2.unproject(l2), originalEvent: o2 }), this._defaultPrevented = false;
        }
      }
      class Oo extends e.Event {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(e2, t2, i2) {
          super(e2, { originalEvent: i2 }), this._defaultPrevented = false;
        }
      }
      class Bo {
        constructor(e2, t2) {
          this._map = e2, this._clickTolerance = t2.clickTolerance;
        }
        reset() {
          delete this._mousedownPos;
        }
        wheel(e2) {
          return this._firePreventable(new Oo(e2.type, this._map, e2));
        }
        mousedown(e2, t2) {
          return this._mousedownPos = t2, this._firePreventable(new ko(e2.type, this._map, e2));
        }
        mouseup(e2) {
          this._map.fire(new ko(e2.type, this._map, e2));
        }
        preclick(t2) {
          const i2 = e.extend({}, t2);
          i2.type = "preclick", this._map.fire(new ko(i2.type, this._map, i2));
        }
        click(e2, t2) {
          this._mousedownPos && this._mousedownPos.dist(t2) >= this._clickTolerance || (this.preclick(e2), this._map.fire(new ko(e2.type, this._map, e2)));
        }
        dblclick(e2) {
          return this._firePreventable(new ko(e2.type, this._map, e2));
        }
        mouseover(e2) {
          this._map.fire(new ko(e2.type, this._map, e2));
        }
        mouseout(e2) {
          this._map.fire(new ko(e2.type, this._map, e2));
        }
        touchstart(e2) {
          return this._firePreventable(new Fo(e2.type, this._map, e2));
        }
        touchmove(e2) {
          this._map.fire(new Fo(e2.type, this._map, e2));
        }
        touchend(e2) {
          this._map.fire(new Fo(e2.type, this._map, e2));
        }
        touchcancel(e2) {
          this._map.fire(new Fo(e2.type, this._map, e2));
        }
        _firePreventable(e2) {
          if (this._map.fire(e2), e2.defaultPrevented)
            return {};
        }
        isEnabled() {
          return true;
        }
        isActive() {
          return false;
        }
        enable() {
        }
        disable() {
        }
      }
      class Uo {
        constructor(e2) {
          this._map = e2;
        }
        reset() {
          this._delayContextMenu = false, delete this._contextMenuEvent;
        }
        mousemove(e2) {
          this._map.fire(new ko(e2.type, this._map, e2));
        }
        mousedown() {
          this._delayContextMenu = true;
        }
        mouseup() {
          this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new ko("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }
        contextmenu(e2) {
          this._delayContextMenu ? this._contextMenuEvent = e2 : this._map.fire(new ko(e2.type, this._map, e2)), this._map.listens("contextmenu") && e2.preventDefault();
        }
        isEnabled() {
          return true;
        }
        isActive() {
          return false;
        }
        enable() {
        }
        disable() {
        }
      }
      class No {
        constructor(e2, t2) {
          this._map = e2, this._el = e2.getCanvasContainer(), this._container = e2.getContainer(), this._clickTolerance = t2.clickTolerance || 1;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        enable() {
          this.isEnabled() || (this._enabled = true);
        }
        disable() {
          this.isEnabled() && (this._enabled = false);
        }
        mousedown(e2, t2) {
          this.isEnabled() && e2.shiftKey && 0 === e2.button && (n.disableDrag(), this._startPos = this._lastPos = t2, this._active = true);
        }
        mousemoveWindow(e2, t2) {
          if (!this._active)
            return;
          const i2 = t2;
          if (this._lastPos.equals(i2) || !this._box && i2.dist(this._startPos) < this._clickTolerance)
            return;
          const o2 = this._startPos;
          this._lastPos = i2, this._box || (this._box = n.create("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e2));
          const r2 = Math.min(o2.x, i2.x), a2 = Math.max(o2.x, i2.x), s2 = Math.min(o2.y, i2.y), l2 = Math.max(o2.y, i2.y);
          this._map._requestDomTask(() => {
            this._box && (n.setTransform(this._box, `translate(${r2}px,${s2}px)`), this._box.style.width = a2 - r2 + "px", this._box.style.height = l2 - s2 + "px");
          });
        }
        mouseupWindow(t2, i2) {
          if (!this._active)
            return;
          if (0 !== t2.button)
            return;
          const o2 = this._startPos, r2 = i2;
          if (this.reset(), n.suppressClick(), o2.x !== r2.x || o2.y !== r2.y)
            return this._map.fire(new e.Event("boxzoomend", { originalEvent: t2 })), { cameraAnimation: (e2) => e2.fitScreenCoordinates(o2, r2, this._map.getBearing(), { linear: false }) };
          this._fireEvent("boxzoomcancel", t2);
        }
        keydown(e2) {
          this._active && 27 === e2.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e2));
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false, this._container.classList.remove("mapboxgl-crosshair"), this._box && (n.remove(this._box), this._box = null), n.enableDrag(), delete this._startPos, delete this._lastPos;
        }
        _fireEvent(t2, i2) {
          return this._map.fire(new e.Event(t2, { originalEvent: i2 }));
        }
      }
      function Go(e2, t2) {
        const i2 = {};
        for (let o2 = 0; o2 < e2.length; o2++)
          i2[e2[o2].identifier] = t2[o2];
        return i2;
      }
      class Zo {
        constructor(e2) {
          this.reset(), this.numTouches = e2.numTouches;
        }
        reset() {
          delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
        }
        touchstart(t2, i2, o2) {
          (this.centroid || o2.length > this.numTouches) && (this.aborted = true), this.aborted || (void 0 === this.startTime && (this.startTime = t2.timeStamp), o2.length === this.numTouches && (this.centroid = function(t3) {
            const i3 = new e.pointGeometry(0, 0);
            for (const e2 of t3)
              i3._add(e2);
            return i3.div(t3.length);
          }(i2), this.touches = Go(o2, i2)));
        }
        touchmove(e2, t2, i2) {
          if (this.aborted || !this.centroid)
            return;
          const o2 = Go(i2, t2);
          for (const e3 in this.touches) {
            const t3 = this.touches[e3], i3 = o2[e3];
            (!i3 || i3.dist(t3) > 30) && (this.aborted = true);
          }
        }
        touchend(e2, t2, i2) {
          if ((!this.centroid || e2.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i2.length) {
            const e3 = !this.aborted && this.centroid;
            if (this.reset(), e3)
              return e3;
          }
        }
      }
      class Vo {
        constructor(e2) {
          this.singleTap = new Zo(e2), this.numTaps = e2.numTaps, this.reset();
        }
        reset() {
          this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
        }
        touchstart(e2, t2, i2) {
          this.singleTap.touchstart(e2, t2, i2);
        }
        touchmove(e2, t2, i2) {
          this.singleTap.touchmove(e2, t2, i2);
        }
        touchend(e2, t2, i2) {
          const o2 = this.singleTap.touchend(e2, t2, i2);
          if (o2) {
            const t3 = e2.timeStamp - this.lastTime < 500, i3 = !this.lastTap || this.lastTap.dist(o2) < 30;
            if (t3 && i3 || this.reset(), this.count++, this.lastTime = e2.timeStamp, this.lastTap = o2, this.count === this.numTaps)
              return this.reset(), o2;
          }
        }
      }
      class jo {
        constructor() {
          this._zoomIn = new Vo({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Vo({ numTouches: 2, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
        }
        touchstart(e2, t2, i2) {
          this._zoomIn.touchstart(e2, t2, i2), this._zoomOut.touchstart(e2, t2, i2);
        }
        touchmove(e2, t2, i2) {
          this._zoomIn.touchmove(e2, t2, i2), this._zoomOut.touchmove(e2, t2, i2);
        }
        touchend(e2, t2, i2) {
          const o2 = this._zoomIn.touchend(e2, t2, i2), r2 = this._zoomOut.touchend(e2, t2, i2);
          return o2 ? (this._active = true, e2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: t3.getZoom() + 1, around: t3.unproject(o2) }, { originalEvent: e2 }) }) : r2 ? (this._active = true, e2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: t3.getZoom() - 1, around: t3.unproject(r2) }, { originalEvent: e2 }) }) : void 0;
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      const qo = { 0: 1, 2: 2 };
      class Wo {
        constructor(e2) {
          this.reset(), this._clickTolerance = e2.clickTolerance || 1;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false, this._moved = false, delete this._lastPoint, delete this._eventButton;
        }
        _correctButton(e2, t2) {
          return false;
        }
        _move(e2, t2) {
          return {};
        }
        mousedown(e2, t2) {
          if (this._lastPoint)
            return;
          const i2 = n.mouseButton(e2);
          this._correctButton(e2, i2) && (this._lastPoint = t2, this._eventButton = i2);
        }
        mousemoveWindow(e2, t2) {
          const i2 = this._lastPoint;
          if (i2) {
            if (e2.preventDefault(), function(e3, t3) {
              const i3 = qo[t3];
              return void 0 === e3.buttons || (e3.buttons & i3) !== i3;
            }(e2, this._eventButton))
              this.reset();
            else if (this._moved || !(t2.dist(i2) < this._clickTolerance))
              return this._moved = true, this._lastPoint = t2, this._move(i2, t2);
          }
        }
        mouseupWindow(e2) {
          this._lastPoint && n.mouseButton(e2) === this._eventButton && (this._moved && n.suppressClick(), this.reset());
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class $o extends Wo {
        mousedown(e2, t2) {
          super.mousedown(e2, t2), this._lastPoint && (this._active = true);
        }
        _correctButton(e2, t2) {
          return 0 === t2 && !e2.ctrlKey;
        }
        _move(e2, t2) {
          return { around: t2, panDelta: t2.sub(e2) };
        }
      }
      class Xo extends Wo {
        _correctButton(e2, t2) {
          return 0 === t2 && e2.ctrlKey || 2 === t2;
        }
        _move(e2, t2) {
          const i2 = 0.8 * (t2.x - e2.x);
          if (i2)
            return this._active = true, { bearingDelta: i2 };
        }
        contextmenu(e2) {
          e2.preventDefault();
        }
      }
      class Ho extends Wo {
        _correctButton(e2, t2) {
          return 0 === t2 && e2.ctrlKey || 2 === t2;
        }
        _move(e2, t2) {
          const i2 = -0.5 * (t2.y - e2.y);
          if (i2)
            return this._active = true, { pitchDelta: i2 };
        }
        contextmenu(e2) {
          e2.preventDefault();
        }
      }
      class Ko {
        constructor(e2) {
          this._minTouches = 1, this._clickTolerance = e2.clickTolerance || 1, this.reset();
        }
        reset() {
          this._active = false, this._touches = {}, this._sum = new e.pointGeometry(0, 0);
        }
        touchstart(e2, t2, i2) {
          return this._calculateTransform(e2, t2, i2);
        }
        touchmove(e2, t2, i2) {
          if (this._active && !(i2.length < this._minTouches))
            return e2.preventDefault(), this._calculateTransform(e2, t2, i2);
        }
        touchend(e2, t2, i2) {
          this._calculateTransform(e2, t2, i2), this._active && i2.length < this._minTouches && this.reset();
        }
        touchcancel() {
          this.reset();
        }
        _calculateTransform(t2, i2, o2) {
          o2.length > 0 && (this._active = true);
          const r2 = Go(o2, i2), n2 = new e.pointGeometry(0, 0), a2 = new e.pointGeometry(0, 0);
          let s2 = 0;
          for (const e2 in r2) {
            const t3 = r2[e2], i3 = this._touches[e2];
            i3 && (n2._add(t3), a2._add(t3.sub(i3)), s2++, r2[e2] = t3);
          }
          if (this._touches = r2, s2 < this._minTouches || !a2.mag())
            return;
          const l2 = a2.div(s2);
          return this._sum._add(l2), this._sum.mag() < this._clickTolerance ? void 0 : { around: n2.div(s2), panDelta: l2 };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class Yo {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = false, delete this._firstTwoTouches;
        }
        _start(e2) {
        }
        _move(e2, t2, i2) {
          return {};
        }
        touchstart(e2, t2, i2) {
          this._firstTwoTouches || i2.length < 2 || (this._firstTwoTouches = [i2[0].identifier, i2[1].identifier], this._start([t2[0], t2[1]]));
        }
        touchmove(e2, t2, i2) {
          if (!this._firstTwoTouches)
            return;
          e2.preventDefault();
          const [o2, r2] = this._firstTwoTouches, n2 = Jo(i2, t2, o2), a2 = Jo(i2, t2, r2);
          if (!n2 || !a2)
            return;
          const s2 = this._aroundCenter ? null : n2.add(a2).div(2);
          return this._move([n2, a2], s2, e2);
        }
        touchend(e2, t2, i2) {
          if (!this._firstTwoTouches)
            return;
          const [o2, r2] = this._firstTwoTouches, a2 = Jo(i2, t2, o2), s2 = Jo(i2, t2, r2);
          a2 && s2 || (this._active && n.suppressClick(), this.reset());
        }
        touchcancel() {
          this.reset();
        }
        enable(e2) {
          this._enabled = true, this._aroundCenter = !!e2 && "center" === e2.around;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      function Jo(e2, t2, i2) {
        for (let o2 = 0; o2 < e2.length; o2++)
          if (e2[o2].identifier === i2)
            return t2[o2];
      }
      function Qo(e2, t2) {
        return Math.log(e2 / t2) / Math.LN2;
      }
      class er extends Yo {
        reset() {
          super.reset(), delete this._distance, delete this._startDistance;
        }
        _start(e2) {
          this._startDistance = this._distance = e2[0].dist(e2[1]);
        }
        _move(e2, t2) {
          const i2 = this._distance;
          if (this._distance = e2[0].dist(e2[1]), this._active || !(Math.abs(Qo(this._distance, this._startDistance)) < 0.1))
            return this._active = true, { zoomDelta: Qo(this._distance, i2), pinchAround: t2 };
        }
      }
      function tr(e2, t2) {
        return 180 * e2.angleWith(t2) / Math.PI;
      }
      class ir extends Yo {
        reset() {
          super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
        }
        _start(e2) {
          this._startVector = this._vector = e2[0].sub(e2[1]), this._minDiameter = e2[0].dist(e2[1]);
        }
        _move(e2, t2) {
          const i2 = this._vector;
          if (this._vector = e2[0].sub(e2[1]), this._active || !this._isBelowThreshold(this._vector))
            return this._active = true, { bearingDelta: tr(this._vector, i2), pinchAround: t2 };
        }
        _isBelowThreshold(e2) {
          this._minDiameter = Math.min(this._minDiameter, e2.mag());
          const t2 = 25 / (Math.PI * this._minDiameter) * 360, i2 = tr(e2, this._startVector);
          return Math.abs(i2) < t2;
        }
      }
      function or(e2) {
        return Math.abs(e2.y) > Math.abs(e2.x);
      }
      class rr extends Yo {
        reset() {
          super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
        }
        _start(e2) {
          this._lastPoints = e2, or(e2[0].sub(e2[1])) && (this._valid = false);
        }
        _move(e2, t2, i2) {
          const o2 = e2[0].sub(this._lastPoints[0]), r2 = e2[1].sub(this._lastPoints[1]);
          if (this._valid = this.gestureBeginsVertically(o2, r2, i2.timeStamp), this._valid)
            return this._lastPoints = e2, this._active = true, { pitchDelta: (o2.y + r2.y) / 2 * -0.5 };
        }
        gestureBeginsVertically(e2, t2, i2) {
          if (void 0 !== this._valid)
            return this._valid;
          const o2 = e2.mag() >= 2, r2 = t2.mag() >= 2;
          if (!o2 && !r2)
            return;
          if (!o2 || !r2)
            return void 0 === this._firstMove && (this._firstMove = i2), i2 - this._firstMove < 100 && void 0;
          const n2 = e2.y > 0 == t2.y > 0;
          return or(e2) && or(t2) && n2;
        }
      }
      const nr = { panStep: 100, bearingStep: 15, pitchStep: 10 };
      class ar {
        constructor() {
          const e2 = nr;
          this._panStep = e2.panStep, this._bearingStep = e2.bearingStep, this._pitchStep = e2.pitchStep, this._rotationDisabled = false;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false;
        }
        keydown(e2) {
          if (e2.altKey || e2.ctrlKey || e2.metaKey)
            return;
          let t2 = 0, i2 = 0, o2 = 0, r2 = 0, n2 = 0;
          switch (e2.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              t2 = 1;
              break;
            case 189:
            case 109:
            case 173:
              t2 = -1;
              break;
            case 37:
              e2.shiftKey ? i2 = -1 : (e2.preventDefault(), r2 = -1);
              break;
            case 39:
              e2.shiftKey ? i2 = 1 : (e2.preventDefault(), r2 = 1);
              break;
            case 38:
              e2.shiftKey ? o2 = 1 : (e2.preventDefault(), n2 = -1);
              break;
            case 40:
              e2.shiftKey ? o2 = -1 : (e2.preventDefault(), n2 = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (i2 = 0, o2 = 0), { cameraAnimation: (a2) => {
            const s2 = a2.getZoom();
            a2.easeTo({ duration: 300, easeId: "keyboardHandler", easing: sr, zoom: t2 ? Math.round(s2) + t2 * (e2.shiftKey ? 2 : 1) : s2, bearing: a2.getBearing() + i2 * this._bearingStep, pitch: a2.getPitch() + o2 * this._pitchStep, offset: [-r2 * this._panStep, -n2 * this._panStep], center: a2.getCenter() }, { originalEvent: e2 });
          } };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        disableRotation() {
          this._rotationDisabled = true;
        }
        enableRotation() {
          this._rotationDisabled = false;
        }
      }
      function sr(e2) {
        return e2 * (2 - e2);
      }
      const lr = 4.000244140625;
      class cr {
        constructor(t2, i2) {
          this._map = t2, this._el = t2.getCanvasContainer(), this._handler = i2, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222, e.bindAll(["_onTimeout"], this);
        }
        setZoomRate(e2) {
          this._defaultZoomRate = e2;
        }
        setWheelZoomRate(e2) {
          this._wheelZoomRate = e2;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active || void 0 !== this._finishTimeout;
        }
        isZooming() {
          return !!this._zooming;
        }
        enable(e2) {
          this.isEnabled() || (this._enabled = true, this._aroundCenter = e2 && "center" === e2.around);
        }
        disable() {
          this.isEnabled() && (this._enabled = false);
        }
        wheel(t2) {
          if (!this.isEnabled())
            return;
          let i2 = t2.deltaMode === e.window.WheelEvent.DOM_DELTA_LINE ? 40 * t2.deltaY : t2.deltaY;
          const o2 = e.exported.now(), r2 = o2 - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = o2, 0 !== i2 && i2 % lr == 0 ? this._type = "wheel" : 0 !== i2 && Math.abs(i2) < 4 ? this._type = "trackpad" : r2 > 400 ? (this._type = null, this._lastValue = i2, this._timeout = setTimeout(this._onTimeout, 40, t2)) : this._type || (this._type = Math.abs(r2 * i2) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i2 += this._lastValue)), t2.shiftKey && i2 && (i2 /= 4), this._type && (this._lastWheelEvent = t2, this._delta -= i2, this._active || this._start(t2)), t2.preventDefault();
        }
        _onTimeout(e2) {
          this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e2);
        }
        _start(e2) {
          if (!this._delta)
            return;
          this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          const t2 = n.mousePos(this._el, e2);
          this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t2, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = true, this._handler._triggerRenderFrame());
        }
        renderFrame() {
          if (!this._frameId)
            return;
          if (this._frameId = null, !this.isActive())
            return;
          const t2 = this._map.transform, i2 = () => t2._terrainEnabled() ? t2.computeZoomRelativeTo(this._aroundCoord) : t2.zoom;
          if (0 !== this._delta) {
            const e2 = "wheel" === this._type && Math.abs(this._delta) > lr ? this._wheelZoomRate : this._defaultZoomRate;
            let o3 = 2 / (1 + Math.exp(-Math.abs(this._delta * e2)));
            this._delta < 0 && 0 !== o3 && (o3 = 1 / o3);
            const r3 = i2(), n3 = Math.pow(2, r3), a3 = "number" == typeof this._targetZoom ? t2.zoomScale(this._targetZoom) : n3;
            this._targetZoom = Math.min(t2.maxZoom, Math.max(t2.minZoom, t2.scaleZoom(a3 * o3))), "wheel" === this._type && (this._startZoom = i2(), this._easing = this._smoothOutEasing(200)), this._delta = 0;
          }
          const o2 = "number" == typeof this._targetZoom ? this._targetZoom : i2(), r2 = this._startZoom, n2 = this._easing;
          let a2, s2 = false;
          if ("wheel" === this._type && r2 && n2) {
            const t3 = Math.min((e.exported.now() - this._lastWheelEventTime) / 200, 1), i3 = n2(t3);
            a2 = e.number(r2, o2, i3), t3 < 1 ? this._frameId || (this._frameId = true) : s2 = true;
          } else
            a2 = o2, s2 = true;
          return this._active = true, s2 && (this._active = false, this._finishTimeout = setTimeout(() => {
            this._zooming = false, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
          }, 200)), { noInertia: true, needsRenderFrame: !s2, zoomDelta: a2 - i2(), around: this._aroundPoint, aroundCoord: this._aroundCoord, originalEvent: this._lastWheelEvent };
        }
        _smoothOutEasing(t2) {
          let i2 = e.ease;
          if (this._prevEase) {
            const t3 = this._prevEase, o2 = (e.exported.now() - t3.start) / t3.duration, r2 = t3.easing(o2 + 0.01) - t3.easing(o2), n2 = 0.27 / Math.sqrt(r2 * r2 + 1e-4) * 0.01, a2 = Math.sqrt(0.0729 - n2 * n2);
            i2 = e.bezier(n2, a2, 0.25, 1);
          }
          return this._prevEase = { start: e.exported.now(), duration: t2, easing: i2 }, i2;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = false;
        }
      }
      class hr {
        constructor(e2, t2) {
          this._clickZoom = e2, this._tapZoom = t2;
        }
        enable() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }
        disable() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }
        isEnabled() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }
        isActive() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        }
      }
      class ur {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = false;
        }
        blur() {
          this.reset();
        }
        dblclick(e2, t2) {
          return e2.preventDefault(), { cameraAnimation: (i2) => {
            i2.easeTo({ duration: 300, zoom: i2.getZoom() + (e2.shiftKey ? -1 : 1), around: i2.unproject(t2) }, { originalEvent: e2 });
          } };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class dr {
        constructor() {
          this._tap = new Vo({ numTouches: 1, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, this._tap.reset();
        }
        touchstart(e2, t2, i2) {
          this._swipePoint || (this._tapTime && e2.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i2.length > 0 && (this._swipePoint = t2[0], this._swipeTouch = i2[0].identifier) : this._tap.touchstart(e2, t2, i2));
        }
        touchmove(e2, t2, i2) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (i2[0].identifier !== this._swipeTouch)
                return;
              const o2 = t2[0], r2 = o2.y - this._swipePoint.y;
              return this._swipePoint = o2, e2.preventDefault(), this._active = true, { zoomDelta: r2 / 128 };
            }
          } else
            this._tap.touchmove(e2, t2, i2);
        }
        touchend(e2, t2, i2) {
          this._tapTime ? this._swipePoint && 0 === i2.length && this.reset() : this._tap.touchend(e2, t2, i2) && (this._tapTime = e2.timeStamp);
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class _r {
        constructor(e2, t2, i2) {
          this._el = e2, this._mousePan = t2, this._touchPan = i2;
        }
        enable(e2) {
          this._inertiaOptions = e2 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
        }
        disable() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
        }
        isEnabled() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }
        isActive() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        }
      }
      class pr {
        constructor(e2, t2, i2) {
          this._pitchWithRotate = e2.pitchWithRotate, this._mouseRotate = t2, this._mousePitch = i2;
        }
        enable() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
        }
        disable() {
          this._mouseRotate.disable(), this._mousePitch.disable();
        }
        isEnabled() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
        }
        isActive() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive();
        }
      }
      class mr {
        constructor(e2, t2, i2, o2) {
          this._el = e2, this._touchZoom = t2, this._touchRotate = i2, this._tapDragZoom = o2, this._rotationDisabled = false, this._enabled = true;
        }
        enable(e2) {
          this._touchZoom.enable(e2), this._rotationDisabled || this._touchRotate.enable(e2), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
        }
        disable() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
        }
        isEnabled() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }
        isActive() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }
        disableRotation() {
          this._rotationDisabled = true, this._touchRotate.disable();
        }
        enableRotation() {
          this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
        }
      }
      const fr = (e2) => e2.zoom || e2.drag || e2.pitch || e2.rotate;
      class gr extends e.Event {
      }
      class vr {
        constructor() {
          this.constants = [1, 1, 0.01], this.radius = 0;
        }
        setup(t2, i2) {
          const o2 = e.sub([], i2, t2);
          this.radius = e.length(o2[2] < 0 ? e.div([], o2, this.constants) : [o2[0], o2[1], 0]);
        }
        projectRay(t2) {
          e.div(t2, t2, this.constants), e.normalize(t2, t2), e.mul$2(t2, t2, this.constants);
          const i2 = e.scale([], t2, this.radius);
          if (i2[2] > 0) {
            const t3 = e.scale([], [0, 0, 1], e.dot(i2, [0, 0, 1])), o2 = e.scale([], e.normalize([], [i2[0], i2[1], 0]), this.radius), r2 = e.add([], i2, e.scale([], e.sub([], e.add([], o2, t3), i2), 2));
            i2[0] = r2[0], i2[1] = r2[1];
          }
          return i2;
        }
      }
      function xr(e2) {
        return e2.panDelta && e2.panDelta.mag() || e2.zoomDelta || e2.bearingDelta || e2.pitchDelta;
      }
      class yr {
        constructor(t2, i2) {
          this._map = t2, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Po(t2), this._bearingSnap = i2.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new vr(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i2), e.bindAll(["handleEvent", "handleWindowEvent"], this);
          const o2 = this._el;
          this._listeners = [[o2, "touchstart", { passive: true }], [o2, "touchmove", { passive: false }], [o2, "touchend", void 0], [o2, "touchcancel", void 0], [o2, "mousedown", void 0], [o2, "mousemove", void 0], [o2, "mouseup", void 0], [e.window.document, "mousemove", { capture: true }], [e.window.document, "mouseup", void 0], [o2, "mouseover", void 0], [o2, "mouseout", void 0], [o2, "dblclick", void 0], [o2, "click", void 0], [o2, "keydown", { capture: false }], [o2, "keyup", void 0], [o2, "wheel", { passive: false }], [o2, "contextmenu", void 0], [e.window, "blur", void 0]];
          for (const [t3, i3, o3] of this._listeners)
            n.addEventListener(t3, i3, t3 === e.window.document ? this.handleWindowEvent : this.handleEvent, o3);
        }
        destroy() {
          for (const [t2, i2, o2] of this._listeners)
            n.removeEventListener(t2, i2, t2 === e.window.document ? this.handleWindowEvent : this.handleEvent, o2);
        }
        _addDefaultHandlers(e2) {
          const t2 = this._map, i2 = t2.getCanvasContainer();
          this._add("mapEvent", new Bo(t2, e2));
          const o2 = t2.boxZoom = new No(t2, e2);
          this._add("boxZoom", o2);
          const r2 = new jo(), n2 = new ur();
          t2.doubleClickZoom = new hr(n2, r2), this._add("tapZoom", r2), this._add("clickZoom", n2);
          const a2 = new dr();
          this._add("tapDragZoom", a2);
          const s2 = t2.touchPitch = new rr();
          this._add("touchPitch", s2);
          const l2 = new Xo(e2), c2 = new Ho(e2);
          t2.dragRotate = new pr(e2, l2, c2), this._add("mouseRotate", l2, ["mousePitch"]), this._add("mousePitch", c2, ["mouseRotate"]);
          const h2 = new $o(e2), u2 = new Ko(e2);
          t2.dragPan = new _r(i2, h2, u2), this._add("mousePan", h2), this._add("touchPan", u2, ["touchZoom", "touchRotate"]);
          const d2 = new ir(), _2 = new er();
          t2.touchZoomRotate = new mr(i2, _2, d2, a2), this._add("touchRotate", d2, ["touchPan", "touchZoom"]), this._add("touchZoom", _2, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new Uo(t2));
          const p2 = t2.scrollZoom = new cr(t2, this);
          this._add("scrollZoom", p2, ["mousePan"]);
          const m2 = t2.keyboard = new ar();
          this._add("keyboard", m2);
          for (const i3 of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"])
            e2.interactive && e2[i3] && t2[i3].enable(e2[i3]);
        }
        _add(e2, t2, i2) {
          this._handlers.push({ handlerName: e2, handler: t2, allowed: i2 }), this._handlersById[e2] = t2;
        }
        stop(e2) {
          if (!this._updatingCamera) {
            for (const { handler: e3 } of this._handlers)
              e3.reset();
            this._inertia.clear(), this._fireEvents({}, {}, e2), this._changes = [];
          }
        }
        isActive() {
          for (const { handler: e2 } of this._handlers)
            if (e2.isActive())
              return true;
          return false;
        }
        isZooming() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }
        isRotating() {
          return !!this._eventsInProgress.rotate;
        }
        isMoving() {
          return Boolean(fr(this._eventsInProgress)) || this.isZooming();
        }
        _blockedByActive(e2, t2, i2) {
          for (const o2 in e2)
            if (o2 !== i2 && (!t2 || t2.indexOf(o2) < 0))
              return true;
          return false;
        }
        handleWindowEvent(e2) {
          this.handleEvent(e2, `${e2.type}Window`);
        }
        _getMapTouches(e2) {
          const t2 = [];
          for (const i2 of e2)
            this._el.contains(i2.target) && t2.push(i2);
          return t2;
        }
        handleEvent(e2, t2) {
          this._updatingCamera = true;
          const i2 = "renderFrame" === e2.type, o2 = i2 ? void 0 : e2, r2 = { needsRenderFrame: false }, a2 = {}, s2 = {}, l2 = e2.touches ? this._getMapTouches(e2.touches) : void 0, c2 = l2 ? n.touchPos(this._el, l2) : i2 ? void 0 : n.mousePos(this._el, e2);
          for (const { handlerName: i3, handler: n2, allowed: h3 } of this._handlers) {
            if (!n2.isEnabled())
              continue;
            let u3;
            this._blockedByActive(s2, h3, i3) ? n2.reset() : n2[t2 || e2.type] && (u3 = n2[t2 || e2.type](e2, c2, l2), this.mergeHandlerResult(r2, a2, u3, i3, o2), u3 && u3.needsRenderFrame && this._triggerRenderFrame()), (u3 || n2.isActive()) && (s2[i3] = n2);
          }
          const h2 = {};
          for (const e3 in this._previousActiveHandlers)
            s2[e3] || (h2[e3] = o2);
          this._previousActiveHandlers = s2, (Object.keys(h2).length || xr(r2)) && (this._changes.push([r2, a2, h2]), this._triggerRenderFrame()), (Object.keys(s2).length || xr(r2)) && this._map._stop(true), this._updatingCamera = false;
          const { cameraAnimation: u2 } = r2;
          u2 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], u2(this._map));
        }
        mergeHandlerResult(t2, i2, o2, r2, n2) {
          if (!o2)
            return;
          e.extend(t2, o2);
          const a2 = { handlerName: r2, originalEvent: o2.originalEvent || n2 };
          void 0 !== o2.zoomDelta && (i2.zoom = a2), void 0 !== o2.panDelta && (i2.drag = a2), void 0 !== o2.pitchDelta && (i2.pitch = a2), void 0 !== o2.bearingDelta && (i2.rotate = a2);
        }
        _applyChanges() {
          const t2 = {}, i2 = {}, o2 = {};
          for (const [r2, n2, a2] of this._changes)
            r2.panDelta && (t2.panDelta = (t2.panDelta || new e.pointGeometry(0, 0))._add(r2.panDelta)), r2.zoomDelta && (t2.zoomDelta = (t2.zoomDelta || 0) + r2.zoomDelta), r2.bearingDelta && (t2.bearingDelta = (t2.bearingDelta || 0) + r2.bearingDelta), r2.pitchDelta && (t2.pitchDelta = (t2.pitchDelta || 0) + r2.pitchDelta), void 0 !== r2.around && (t2.around = r2.around), void 0 !== r2.aroundCoord && (t2.aroundCoord = r2.aroundCoord), void 0 !== r2.pinchAround && (t2.pinchAround = r2.pinchAround), r2.noInertia && (t2.noInertia = r2.noInertia), e.extend(i2, n2), e.extend(o2, a2);
          this._updateMapTransform(t2, i2, o2), this._changes = [];
        }
        _updateMapTransform(t2, i2, o2) {
          const r2 = this._map, n2 = r2.transform, a2 = (e2) => [e2.x, e2.y, e2.z];
          if (((e2) => {
            const t3 = this._eventsInProgress.drag;
            return t3 && !this._handlersById[t3.handlerName].isActive();
          })() && !xr(t2)) {
            const e2 = n2.zoom;
            n2.cameraElevationReference = "sea", n2.recenterOnTerrain(), n2.cameraElevationReference = "ground", e2 !== n2.zoom && this._map._update(true);
          }
          if (!xr(t2))
            return this._fireEvents(i2, o2, true);
          let { panDelta: s2, zoomDelta: l2, bearingDelta: c2, pitchDelta: h2, around: u2, aroundCoord: d2, pinchAround: _2 } = t2;
          void 0 !== _2 && (u2 = _2), ((e2) => i2.drag && !this._eventsInProgress.drag)() && u2 && (this._dragOrigin = a2(n2.pointCoordinate3D(u2)), this._trackingEllipsoid.setup(n2._camera.position, this._dragOrigin)), n2.cameraElevationReference = "sea", r2._stop(true), u2 = u2 || r2.transform.centerPoint, c2 && (n2.bearing += c2), h2 && (n2.pitch += h2), n2._updateCameraState();
          const p2 = [0, 0, 0];
          if (s2) {
            const e2 = n2.screenPointToMercatorRay(u2), t3 = n2.screenPointToMercatorRay(u2.sub(s2)), i3 = this._trackingEllipsoid.projectRay(e2.dir), o3 = this._trackingEllipsoid.projectRay(t3.dir);
            p2[0] = o3[0] - i3[0], p2[1] = o3[1] - i3[1];
          }
          const m2 = n2.zoom, f2 = [0, 0, 0];
          if (l2) {
            const t3 = a2(d2 || n2.pointCoordinate3D(u2)), i3 = { dir: e.normalize([], e.sub([], t3, n2._camera.position)) }, o3 = n2.screenPointToMercatorRay(n2.centerPoint);
            if (i3.dir[2] < 0) {
              const r3 = e.altitudeFromMercatorZ(t3[2], t3[1]), s3 = n2.rayIntersectionCoordinate(n2.pointRayIntersection(n2.centerPoint, r3)), c3 = n2.zoomDeltaToMovement(a2(s3), l2) * (o3.dir[2] / i3.dir[2]);
              e.scale(f2, i3.dir, c3);
            } else if (n2._terrainEnabled()) {
              const o4 = n2.zoomDeltaToMovement(t3, l2);
              e.scale(f2, i3.dir, o4);
            }
          }
          const g2 = e.add(p2, p2, f2);
          n2._translateCameraConstrained(g2), l2 && Math.abs(n2.zoom - m2) > 1e-4 && n2.recenterOnTerrain(), n2.cameraElevationReference = "ground", this._map._update(), t2.noInertia || this._inertia.record(t2), this._fireEvents(i2, o2, true);
        }
        _fireEvents(t2, i2, o2) {
          const r2 = fr(this._eventsInProgress), n2 = fr(t2), a2 = {};
          for (const e2 in t2) {
            const { originalEvent: i3 } = t2[e2];
            this._eventsInProgress[e2] || (a2[`${e2}start`] = i3), this._eventsInProgress[e2] = t2[e2];
          }
          !r2 && n2 && this._fireEvent("movestart", n2.originalEvent);
          for (const e2 in a2)
            this._fireEvent(e2, a2[e2]);
          n2 && this._fireEvent("move", n2.originalEvent);
          for (const e2 in t2) {
            const { originalEvent: i3 } = t2[e2];
            this._fireEvent(e2, i3);
          }
          const s2 = {};
          let l2;
          for (const e2 in this._eventsInProgress) {
            const { handlerName: t3, originalEvent: o3 } = this._eventsInProgress[e2];
            this._handlersById[t3].isActive() || (delete this._eventsInProgress[e2], l2 = i2[t3] || o3, s2[`${e2}end`] = l2);
          }
          for (const e2 in s2)
            this._fireEvent(e2, s2[e2]);
          const c2 = fr(this._eventsInProgress);
          if (o2 && (r2 || n2) && !c2) {
            this._updatingCamera = true;
            const t3 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i3 = (e2) => 0 !== e2 && -this._bearingSnap < e2 && e2 < this._bearingSnap;
            t3 ? (i3(t3.bearing || this._map.getBearing()) && (t3.bearing = 0), this._map.easeTo(t3, { originalEvent: l2 })) : (this._map.fire(new e.Event("moveend", { originalEvent: l2 })), i3(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
          }
        }
        _fireEvent(t2, i2) {
          this._map.fire(new e.Event(t2, i2 ? { originalEvent: i2 } : {}));
        }
        _requestFrame() {
          return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e2) => {
            delete this._frameId, this.handleEvent(new gr("renderFrame", { timeStamp: e2 })), this._applyChanges();
          });
        }
        _triggerRenderFrame() {
          void 0 === this._frameId && (this._frameId = this._requestFrame());
        }
      }
      class br extends e.Evented {
        constructor(t2, i2) {
          super(), this._moving = false, this._zooming = false, this.transform = t2, this._bearingSnap = i2.bearingSnap, e.bindAll(["_renderFrameCallback"], this);
        }
        getCenter() {
          return new e.LngLat(this.transform.center.lng, this.transform.center.lat);
        }
        setCenter(e2, t2) {
          return this.jumpTo({ center: e2 }, t2);
        }
        panBy(t2, i2, o2) {
          return t2 = e.pointGeometry.convert(t2).mult(-1), this.panTo(this.transform.center, e.extend({ offset: t2 }, i2), o2);
        }
        panTo(t2, i2, o2) {
          return this.easeTo(e.extend({ center: t2 }, i2), o2);
        }
        getZoom() {
          return this.transform.zoom;
        }
        setZoom(e2, t2) {
          return this.jumpTo({ zoom: e2 }, t2), this;
        }
        zoomTo(t2, i2, o2) {
          return this.easeTo(e.extend({ zoom: t2 }, i2), o2);
        }
        zoomIn(e2, t2) {
          return this.zoomTo(this.getZoom() + 1, e2, t2), this;
        }
        zoomOut(e2, t2) {
          return this.zoomTo(this.getZoom() - 1, e2, t2), this;
        }
        getBearing() {
          return this.transform.bearing;
        }
        setBearing(e2, t2) {
          return this.jumpTo({ bearing: e2 }, t2), this;
        }
        getPadding() {
          return this.transform.padding;
        }
        setPadding(e2, t2) {
          return this.jumpTo({ padding: e2 }, t2), this;
        }
        rotateTo(t2, i2, o2) {
          return this.easeTo(e.extend({ bearing: t2 }, i2), o2);
        }
        resetNorth(t2, i2) {
          return this.rotateTo(0, e.extend({ duration: 1e3 }, t2), i2), this;
        }
        resetNorthPitch(t2, i2) {
          return this.easeTo(e.extend({ bearing: 0, pitch: 0, duration: 1e3 }, t2), i2), this;
        }
        snapToNorth(e2, t2) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e2, t2) : this;
        }
        getPitch() {
          return this.transform.pitch;
        }
        setPitch(e2, t2) {
          return this.jumpTo({ pitch: e2 }, t2), this;
        }
        cameraForBounds(t2, i2) {
          t2 = e.LngLatBounds.convert(t2);
          const o2 = i2 && i2.bearing || 0;
          return this._cameraForBoxAndBearing(t2.getNorthWest(), t2.getSouthEast(), o2, i2);
        }
        _extendCameraOptions(t2) {
          const i2 = { top: 0, bottom: 0, right: 0, left: 0 };
          if ("number" == typeof (t2 = e.extend({ padding: i2, offset: [0, 0], maxZoom: this.transform.maxZoom }, t2)).padding) {
            const e2 = t2.padding;
            t2.padding = { top: e2, bottom: e2, right: e2, left: e2 };
          }
          return t2.padding = e.extend(i2, t2.padding), t2;
        }
        _cameraForBoxAndBearing(t2, i2, o2, r2) {
          const n2 = this._extendCameraOptions(r2), a2 = this.transform, s2 = a2.padding, l2 = a2.project(e.LngLat.convert(t2)), c2 = a2.project(e.LngLat.convert(i2)), h2 = l2.rotate(-e.degToRad(o2)), u2 = c2.rotate(-e.degToRad(o2)), d2 = new e.pointGeometry(Math.max(h2.x, u2.x), Math.max(h2.y, u2.y)), _2 = new e.pointGeometry(Math.min(h2.x, u2.x), Math.min(h2.y, u2.y)), p2 = d2.sub(_2), m2 = (a2.width - (s2.left + s2.right + n2.padding.left + n2.padding.right)) / p2.x, f2 = (a2.height - (s2.top + s2.bottom + n2.padding.top + n2.padding.bottom)) / p2.y;
          if (f2 < 0 || m2 < 0)
            return void e.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          const g2 = Math.min(a2.scaleZoom(a2.scale * Math.min(m2, f2)), n2.maxZoom), v2 = "number" == typeof n2.offset.x ? new e.pointGeometry(n2.offset.x, n2.offset.y) : e.pointGeometry.convert(n2.offset), x2 = new e.pointGeometry((n2.padding.left - n2.padding.right) / 2, (n2.padding.top - n2.padding.bottom) / 2).rotate(o2 * Math.PI / 180), y2 = v2.add(x2).mult(a2.scale / a2.zoomScale(g2));
          return { center: a2.unproject(l2.add(c2).div(2).sub(y2)), zoom: g2, bearing: o2 };
        }
        _cameraForBox(t2, i2, o2, r2, n2) {
          const a2 = this._extendCameraOptions(n2);
          o2 = o2 || 0, r2 = r2 || 0, t2 = e.LngLat.convert(t2), i2 = e.LngLat.convert(i2);
          const s2 = this.transform.clone();
          s2.padding = a2.padding;
          const l2 = this.getFreeCameraOptions(), c2 = new e.LngLat(0.5 * (t2.lng + i2.lng), 0.5 * (t2.lat + i2.lat)), h2 = 0.5 * (o2 + r2);
          if (s2._camera.position[2] < e.mercatorZfromAltitude(h2, c2.lat))
            return void e.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          l2.lookAtPoint(c2), s2.setFreeCameraOptions(l2);
          const u2 = e.MercatorCoordinate.fromLngLat(t2), d2 = e.MercatorCoordinate.fromLngLat(i2), m2 = s2.pointRayIntersection(s2.centerPoint, h2), f2 = [(g2 = s2.rayIntersectionCoordinate(m2)).x, g2.y, g2.z];
          var g2;
          const v2 = s2.screenPointToMercatorRay(s2.centerPoint);
          let x2, y2 = 0;
          do {
            const t3 = Math.floor(s2.zoom), i3 = 1 << t3, n3 = Math.min(i3 * u2.x, i3 * d2.x), a3 = Math.min(i3 * u2.y, i3 * d2.y), l3 = Math.max(i3 * u2.x, i3 * d2.x), c3 = Math.max(i3 * u2.y, i3 * d2.y), h3 = new p([n3, a3, o2], [l3, c3, r2]), m3 = _.fromInvProjectionMatrix(s2.invProjMatrix, s2.worldSize, t3);
            if (2 !== h3.intersects(m3)) {
              x2 && (s2._camera.position = e.scaleAndAdd([], s2._camera.position, v2.dir, -x2), s2._updateStateFromCamera());
              break;
            }
            const g3 = e.sub([], s2._camera.position, f2);
            x2 = 0.5 * e.length(g3), s2._camera.position = e.scaleAndAdd([], s2._camera.position, v2.dir, x2);
            try {
              s2._updateStateFromCamera();
            } catch (t4) {
              return void e.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
            }
          } while (++y2 < 10);
          return { center: s2.center, zoom: s2.zoom, bearing: s2.bearing, pitch: s2.pitch };
        }
        fitBounds(e2, t2, i2) {
          return this._fitInternal(this.cameraForBounds(e2, t2), t2, i2);
        }
        _raycastElevationBox(t2, i2) {
          const o2 = this.transform.elevation;
          if (!o2)
            return;
          const r2 = new e.pointGeometry(t2.x, i2.y), n2 = new e.pointGeometry(i2.x, t2.y), a2 = o2.pointCoordinate(t2);
          if (!a2)
            return;
          const s2 = o2.pointCoordinate(i2);
          if (!s2)
            return;
          const l2 = o2.pointCoordinate(r2);
          if (!l2)
            return;
          const c2 = o2.pointCoordinate(n2);
          if (!c2)
            return;
          const h2 = new e.MercatorCoordinate(a2[0], a2[1]).toLngLat(), u2 = new e.MercatorCoordinate(s2[0], s2[1]).toLngLat(), d2 = new e.MercatorCoordinate(l2[0], l2[1]).toLngLat(), _2 = new e.MercatorCoordinate(c2[0], c2[1]).toLngLat(), p2 = Math.min(h2.lng, Math.min(u2.lng, Math.min(d2.lng, _2.lng))), m2 = Math.min(h2.lat, Math.min(u2.lat, Math.min(d2.lat, _2.lat))), f2 = Math.max(h2.lng, Math.max(u2.lng, Math.max(d2.lng, _2.lng))), g2 = Math.max(h2.lat, Math.max(u2.lat, Math.max(d2.lat, _2.lat))), v2 = Math.min(a2[3], Math.min(s2[3], Math.min(l2[3], c2[3]))), x2 = Math.max(a2[3], Math.max(s2[3], Math.max(l2[3], c2[3])));
          return { minLngLat: new e.LngLat(p2, m2), maxLngLat: new e.LngLat(f2, g2), minAltitude: v2, maxAltitude: x2 };
        }
        fitScreenCoordinates(t2, i2, o2, r2, n2) {
          let a2, s2, l2, c2;
          const h2 = e.pointGeometry.convert(t2), u2 = e.pointGeometry.convert(i2), d2 = this._raycastElevationBox(h2, u2);
          if (d2)
            a2 = d2.minLngLat, s2 = d2.maxLngLat, l2 = d2.minAltitude, c2 = d2.maxAltitude;
          else {
            if (this.transform.isCornerOffEdge(h2, u2))
              return this;
            a2 = this.transform.pointLocation(h2), s2 = this.transform.pointLocation(u2);
          }
          return this._fitInternal(0 === this.transform.pitch ? this._cameraForBoxAndBearing(this.transform.pointLocation(e.pointGeometry.convert(t2)), this.transform.pointLocation(e.pointGeometry.convert(i2)), o2, r2) : this._cameraForBox(a2, s2, l2, c2, r2), r2, n2);
        }
        _fitInternal(t2, i2, o2) {
          return t2 ? (delete (i2 = e.extend(t2, i2)).padding, i2.linear ? this.easeTo(i2, o2) : this.flyTo(i2, o2)) : this;
        }
        jumpTo(t2, i2) {
          this.stop();
          const o2 = this.transform;
          let r2 = false, n2 = false, a2 = false;
          return "zoom" in t2 && o2.zoom !== +t2.zoom && (r2 = true, o2.zoom = +t2.zoom), void 0 !== t2.center && (o2.center = e.LngLat.convert(t2.center)), "bearing" in t2 && o2.bearing !== +t2.bearing && (n2 = true, o2.bearing = +t2.bearing), "pitch" in t2 && o2.pitch !== +t2.pitch && (a2 = true, o2.pitch = +t2.pitch), null == t2.padding || o2.isPaddingEqual(t2.padding) || (o2.padding = t2.padding), this.fire(new e.Event("movestart", i2)).fire(new e.Event("move", i2)), r2 && this.fire(new e.Event("zoomstart", i2)).fire(new e.Event("zoom", i2)).fire(new e.Event("zoomend", i2)), n2 && this.fire(new e.Event("rotatestart", i2)).fire(new e.Event("rotate", i2)).fire(new e.Event("rotateend", i2)), a2 && this.fire(new e.Event("pitchstart", i2)).fire(new e.Event("pitch", i2)).fire(new e.Event("pitchend", i2)), this.fire(new e.Event("moveend", i2));
        }
        getFreeCameraOptions() {
          return this.transform.getFreeCameraOptions();
        }
        setFreeCameraOptions(t2, i2) {
          this.stop();
          const o2 = this.transform, r2 = o2.zoom, n2 = o2.pitch, a2 = o2.bearing;
          o2.setFreeCameraOptions(t2);
          const s2 = r2 !== o2.zoom, l2 = n2 !== o2.pitch, c2 = a2 !== o2.bearing;
          return this.fire(new e.Event("movestart", i2)).fire(new e.Event("move", i2)), s2 && this.fire(new e.Event("zoomstart", i2)).fire(new e.Event("zoom", i2)).fire(new e.Event("zoomend", i2)), c2 && this.fire(new e.Event("rotatestart", i2)).fire(new e.Event("rotate", i2)).fire(new e.Event("rotateend", i2)), l2 && this.fire(new e.Event("pitchstart", i2)).fire(new e.Event("pitch", i2)).fire(new e.Event("pitchend", i2)), this.fire(new e.Event("moveend", i2)), this;
        }
        easeTo(t2, i2) {
          this._stop(false, t2.easeId), (false === (t2 = e.extend({ offset: [0, 0], duration: 500, easing: e.ease }, t2)).animate || !t2.essential && e.exported.prefersReducedMotion) && (t2.duration = 0);
          const o2 = this.transform, r2 = this.getZoom(), n2 = this.getBearing(), a2 = this.getPitch(), s2 = this.getPadding(), l2 = "zoom" in t2 ? +t2.zoom : r2, c2 = "bearing" in t2 ? this._normalizeBearing(t2.bearing, n2) : n2, h2 = "pitch" in t2 ? +t2.pitch : a2, u2 = "padding" in t2 ? t2.padding : o2.padding, d2 = e.pointGeometry.convert(t2.offset);
          let _2 = o2.centerPoint.add(d2);
          const p2 = o2.pointLocation(_2), m2 = e.LngLat.convert(t2.center || p2);
          this._normalizeCenter(m2);
          const f2 = o2.project(p2), g2 = o2.project(m2).sub(f2), v2 = o2.zoomScale(l2 - r2);
          let x2, y2;
          t2.around && (x2 = e.LngLat.convert(t2.around), y2 = o2.locationPoint(x2));
          const b2 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
          return this._zooming = this._zooming || l2 !== r2, this._rotating = this._rotating || n2 !== c2, this._pitching = this._pitching || h2 !== a2, this._padding = !o2.isPaddingEqual(u2), this._easeId = t2.easeId, this._prepareEase(i2, t2.noMoveStart, b2), this._ease((t3) => {
            if (this._zooming && (o2.zoom = e.number(r2, l2, t3)), this._rotating && (o2.bearing = e.number(n2, c2, t3)), this._pitching && (o2.pitch = e.number(a2, h2, t3)), this._padding && (o2.interpolatePadding(s2, u2, t3), _2 = o2.centerPoint.add(d2)), x2)
              o2.setLocationAtPoint(x2, y2);
            else {
              const e2 = o2.zoomScale(o2.zoom - r2), i3 = l2 > r2 ? Math.min(2, v2) : Math.max(0.5, v2), n3 = Math.pow(i3, 1 - t3), a3 = o2.unproject(f2.add(g2.mult(t3 * n3)).mult(e2));
              o2.setLocationAtPoint(o2.renderWorldCopies ? a3.wrap() : a3, _2);
            }
            this._fireMoveEvents(i2);
          }, (e2) => {
            o2.recenterOnTerrain(), this._afterEase(i2, e2);
          }, t2), this;
        }
        _prepareEase(t2, i2, o2 = {}) {
          this._moving = true, this.transform.cameraElevationReference = "sea", i2 || o2.moving || this.fire(new e.Event("movestart", t2)), this._zooming && !o2.zooming && this.fire(new e.Event("zoomstart", t2)), this._rotating && !o2.rotating && this.fire(new e.Event("rotatestart", t2)), this._pitching && !o2.pitching && this.fire(new e.Event("pitchstart", t2));
        }
        _fireMoveEvents(t2) {
          this.fire(new e.Event("move", t2)), this._zooming && this.fire(new e.Event("zoom", t2)), this._rotating && this.fire(new e.Event("rotate", t2)), this._pitching && this.fire(new e.Event("pitch", t2));
        }
        _afterEase(t2, i2) {
          if (this._easeId && i2 && this._easeId === i2)
            return;
          delete this._easeId, this.transform.cameraElevationReference = "ground";
          const o2 = this._zooming, r2 = this._rotating, n2 = this._pitching;
          this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, o2 && this.fire(new e.Event("zoomend", t2)), r2 && this.fire(new e.Event("rotateend", t2)), n2 && this.fire(new e.Event("pitchend", t2)), this.fire(new e.Event("moveend", t2));
        }
        flyTo(t2, i2) {
          if (!t2.essential && e.exported.prefersReducedMotion) {
            const o3 = e.pick(t2, ["center", "zoom", "bearing", "pitch", "around"]);
            return this.jumpTo(o3, i2);
          }
          this.stop(), t2 = e.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: e.ease }, t2);
          const o2 = this.transform, r2 = this.getZoom(), n2 = this.getBearing(), a2 = this.getPitch(), s2 = this.getPadding(), l2 = "zoom" in t2 ? e.clamp(+t2.zoom, o2.minZoom, o2.maxZoom) : r2, c2 = "bearing" in t2 ? this._normalizeBearing(t2.bearing, n2) : n2, h2 = "pitch" in t2 ? +t2.pitch : a2, u2 = "padding" in t2 ? t2.padding : o2.padding, d2 = o2.zoomScale(l2 - r2), _2 = e.pointGeometry.convert(t2.offset);
          let p2 = o2.centerPoint.add(_2);
          const m2 = o2.pointLocation(p2), f2 = e.LngLat.convert(t2.center || m2);
          this._normalizeCenter(f2);
          const g2 = o2.project(m2), v2 = o2.project(f2).sub(g2);
          let x2 = t2.curve;
          const y2 = Math.max(o2.width, o2.height), b2 = y2 / d2, w2 = v2.mag();
          if ("minZoom" in t2) {
            const i3 = e.clamp(Math.min(t2.minZoom, r2, l2), o2.minZoom, o2.maxZoom), n3 = y2 / o2.zoomScale(i3 - r2);
            x2 = Math.sqrt(n3 / w2 * 2);
          }
          const T2 = x2 * x2;
          function E2(e2) {
            const t3 = (b2 * b2 - y2 * y2 + (e2 ? -1 : 1) * T2 * T2 * w2 * w2) / (2 * (e2 ? b2 : y2) * T2 * w2);
            return Math.log(Math.sqrt(t3 * t3 + 1) - t3);
          }
          function C2(e2) {
            return (Math.exp(e2) - Math.exp(-e2)) / 2;
          }
          function S2(e2) {
            return (Math.exp(e2) + Math.exp(-e2)) / 2;
          }
          const M2 = E2(0);
          let I2 = function(e2) {
            return S2(M2) / S2(M2 + x2 * e2);
          }, D2 = function(e2) {
            return y2 * ((S2(M2) * (C2(t3 = M2 + x2 * e2) / S2(t3)) - C2(M2)) / T2) / w2;
            var t3;
          }, A2 = (E2(1) - M2) / x2;
          if (Math.abs(w2) < 1e-6 || !isFinite(A2)) {
            if (Math.abs(y2 - b2) < 1e-6)
              return this.easeTo(t2, i2);
            const e2 = b2 < y2 ? -1 : 1;
            A2 = Math.abs(Math.log(b2 / y2)) / x2, D2 = function() {
              return 0;
            }, I2 = function(t3) {
              return Math.exp(e2 * x2 * t3);
            };
          }
          return t2.duration = "duration" in t2 ? +t2.duration : 1e3 * A2 / ("screenSpeed" in t2 ? +t2.screenSpeed / x2 : +t2.speed), t2.maxDuration && t2.duration > t2.maxDuration && (t2.duration = 0), this._zooming = true, this._rotating = n2 !== c2, this._pitching = h2 !== a2, this._padding = !o2.isPaddingEqual(u2), this._prepareEase(i2, false), this._ease((t3) => {
            const d3 = t3 * A2, m3 = 1 / I2(d3);
            o2.zoom = 1 === t3 ? l2 : r2 + o2.scaleZoom(m3), this._rotating && (o2.bearing = e.number(n2, c2, t3)), this._pitching && (o2.pitch = e.number(a2, h2, t3)), this._padding && (o2.interpolatePadding(s2, u2, t3), p2 = o2.centerPoint.add(_2));
            const x3 = 1 === t3 ? f2 : o2.unproject(g2.add(v2.mult(D2(d3))).mult(m3));
            o2.setLocationAtPoint(o2.renderWorldCopies ? x3.wrap() : x3, p2), o2._updateCenterElevation(), this._fireMoveEvents(i2);
          }, () => this._afterEase(i2), t2), this;
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        stop() {
          return this._stop();
        }
        _stop(e2, t2) {
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
            const e3 = this._onEaseEnd;
            delete this._onEaseEnd, e3.call(this, t2);
          }
          if (!e2) {
            const e3 = this.handlers;
            e3 && e3.stop(false);
          }
          return this;
        }
        _ease(t2, i2, o2) {
          false === o2.animate || 0 === o2.duration ? (t2(1), i2()) : (this._easeStart = e.exported.now(), this._easeOptions = o2, this._onEaseFrame = t2, this._onEaseEnd = i2, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }
        _renderFrameCallback() {
          const t2 = Math.min((e.exported.now() - this._easeStart) / this._easeOptions.duration, 1);
          this._onEaseFrame(this._easeOptions.easing(t2)), t2 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
        }
        _normalizeBearing(t2, i2) {
          t2 = e.wrap(t2, -180, 180);
          const o2 = Math.abs(t2 - i2);
          return Math.abs(t2 - 360 - i2) < o2 && (t2 -= 360), Math.abs(t2 + 360 - i2) < o2 && (t2 += 360), t2;
        }
        _normalizeCenter(e2) {
          const t2 = this.transform;
          if (!t2.renderWorldCopies || t2.lngRange)
            return;
          const i2 = e2.lng - t2.center.lng;
          e2.lng += i2 > 180 ? -360 : i2 < -180 ? 360 : 0;
        }
      }
      class wr {
        constructor(t2 = {}) {
          this.options = t2, e.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
        }
        getDefaultPosition() {
          return "bottom-right";
        }
        onAdd(e2) {
          const t2 = this.options && this.options.compact;
          return this._map = e2, this._container = n.create("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = n.create("button", "mapboxgl-ctrl-attrib-button", this._container), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = n.create("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), t2 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === t2 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
        }
        onRemove() {
          n.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
        }
        _setElementTitle(e2, t2) {
          const i2 = this._map._getUIString(`AttributionControl.${t2}`);
          e2.title = i2, e2.setAttribute("aria-label", i2);
        }
        _toggleAttribution() {
          this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-pressed", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-pressed", "true"));
        }
        _updateEditLink() {
          let t2 = this._editLink;
          t2 || (t2 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
          const i2 = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || e.config.ACCESS_TOKEN }];
          if (t2) {
            const o2 = i2.reduce((e2, t3, o3) => (t3.value && (e2 += `${t3.key}=${t3.value}${o3 < i2.length - 1 ? "&" : ""}`), e2), "?");
            t2.href = `${e.config.FEEDBACK_URL}/${o2}${this._map._hash ? this._map._hash.getHashString(true) : ""}`, t2.rel = "noopener nofollow", this._setElementTitle(t2, "MapFeedback");
          }
        }
        _updateData(e2) {
          !e2 || "metadata" !== e2.sourceDataType && "visibility" !== e2.sourceDataType && "style" !== e2.dataType || (this._updateAttributions(), this._updateEditLink());
        }
        _updateAttributions() {
          if (!this._map.style)
            return;
          let e2 = [];
          if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e2 = e2.concat(this.options.customAttribution.map((e3) => "string" != typeof e3 ? "" : e3)) : "string" == typeof this.options.customAttribution && e2.push(this.options.customAttribution)), this._map.style.stylesheet) {
            const e3 = this._map.style.stylesheet;
            this.styleOwner = e3.owner, this.styleId = e3.id;
          }
          const t2 = this._map.style._sourceCaches;
          for (const i3 in t2) {
            const o2 = t2[i3];
            if (o2.used) {
              const t3 = o2.getSource();
              t3.attribution && e2.indexOf(t3.attribution) < 0 && e2.push(t3.attribution);
            }
          }
          e2.sort((e3, t3) => e3.length - t3.length), e2 = e2.filter((t3, i3) => {
            for (let o2 = i3 + 1; o2 < e2.length; o2++)
              if (e2[o2].indexOf(t3) >= 0)
                return false;
            return true;
          });
          const i2 = e2.join(" | ");
          i2 !== this._attribHTML && (this._attribHTML = i2, e2.length ? (this._innerContainer.innerHTML = i2, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
        }
        _updateCompact() {
          this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
        }
      }
      class Tr {
        constructor() {
          e.bindAll(["_updateLogo"], this), e.bindAll(["_updateCompact"], this);
        }
        onAdd(e2) {
          this._map = e2, this._container = n.create("div", "mapboxgl-ctrl");
          const t2 = n.create("a", "mapboxgl-ctrl-logo");
          return t2.target = "_blank", t2.rel = "noopener nofollow", t2.href = "https://www.mapbox.com/", t2.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t2.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t2), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }
        onRemove() {
          n.remove(this._container), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        _updateLogo(e2) {
          e2 && "metadata" !== e2.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
        }
        _logoRequired() {
          if (!this._map.style)
            return true;
          const e2 = this._map.style._sourceCaches;
          if (0 === Object.entries(e2).length)
            return true;
          for (const t2 in e2) {
            const i2 = e2[t2].getSource();
            if (i2.hasOwnProperty("mapbox_logo") && !i2.mapbox_logo)
              return false;
          }
          return true;
        }
        _updateCompact() {
          const e2 = this._container.children;
          if (e2.length) {
            const t2 = e2[0];
            this._map.getCanvasContainer().offsetWidth < 250 ? t2.classList.add("mapboxgl-compact") : t2.classList.remove("mapboxgl-compact");
          }
        }
      }
      class Er {
        constructor() {
          this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
        }
        add(e2) {
          const t2 = ++this._id;
          return this._queue.push({ callback: e2, id: t2, cancelled: false }), t2;
        }
        remove(e2) {
          const t2 = this._currentlyRunning, i2 = t2 ? this._queue.concat(t2) : this._queue;
          for (const t3 of i2)
            if (t3.id === e2)
              return void (t3.cancelled = true);
        }
        run(e2 = 0) {
          const t2 = this._currentlyRunning = this._queue;
          this._queue = [];
          for (const i2 of t2)
            if (!i2.cancelled && (i2.callback(e2), this._cleared))
              break;
          this._cleared = false, this._currentlyRunning = false;
        }
        clear() {
          this._currentlyRunning && (this._cleared = true), this._queue = [];
        }
      }
      function Cr(t2, i2, o2) {
        if (t2 = new e.LngLat(t2.lng, t2.lat), i2) {
          const r2 = new e.LngLat(t2.lng - 360, t2.lat), n2 = new e.LngLat(t2.lng + 360, t2.lat), a2 = 360 * Math.ceil(Math.abs(t2.lng - o2.center.lng) / 360), s2 = o2.locationPoint(t2).distSqr(i2), l2 = i2.x < 0 || i2.y < 0 || i2.x > o2.width || i2.y > o2.height;
          o2.locationPoint(r2).distSqr(i2) < s2 && (l2 || Math.abs(r2.lng - o2.center.lng) < a2) ? t2 = r2 : o2.locationPoint(n2).distSqr(i2) < s2 && (l2 || Math.abs(n2.lng - o2.center.lng) < a2) && (t2 = n2);
        }
        for (; Math.abs(t2.lng - o2.center.lng) > 180; ) {
          const e2 = o2.locationPoint(t2);
          if (e2.x >= 0 && e2.y >= 0 && e2.x <= o2.width && e2.y <= o2.height)
            break;
          t2.lng > o2.center.lng ? t2.lng -= 360 : t2.lng += 360;
        }
        return t2;
      }
      const Sr = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
      class Mr extends e.Evented {
        constructor(t2, i2) {
          if (super(), (t2 instanceof e.window.HTMLElement || i2) && (t2 = e.extend({ element: t2 }, i2)), e.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this), this._anchor = t2 && t2.anchor || "center", this._color = t2 && t2.color || "#3FB1CE", this._scale = t2 && t2.scale || 1, this._draggable = t2 && t2.draggable || false, this._clickTolerance = t2 && t2.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = t2 && t2.rotation || 0, this._rotationAlignment = t2 && t2.rotationAlignment || "auto", this._pitchAlignment = t2 && t2.pitchAlignment && "auto" !== t2.pitchAlignment ? t2.pitchAlignment : this._rotationAlignment, t2 && t2.element)
            this._element = t2.element, this._offset = e.pointGeometry.convert(t2 && t2.offset || [0, 0]);
          else {
            this._defaultMarker = true, this._element = n.create("div"), this._element.setAttribute("aria-label", "Map marker");
            const i3 = n.createNS("http://www.w3.org/2000/svg", "svg"), o3 = 41, r2 = 27;
            i3.setAttributeNS(null, "display", "block"), i3.setAttributeNS(null, "height", `${o3}px`), i3.setAttributeNS(null, "width", `${r2}px`), i3.setAttributeNS(null, "viewBox", `0 0 ${r2} ${o3}`);
            const a2 = n.createNS("http://www.w3.org/2000/svg", "g");
            a2.setAttributeNS(null, "stroke", "none"), a2.setAttributeNS(null, "stroke-width", "1"), a2.setAttributeNS(null, "fill", "none"), a2.setAttributeNS(null, "fill-rule", "evenodd");
            const s2 = n.createNS("http://www.w3.org/2000/svg", "g");
            s2.setAttributeNS(null, "fill-rule", "nonzero");
            const l2 = n.createNS("http://www.w3.org/2000/svg", "g");
            l2.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l2.setAttributeNS(null, "fill", "#000000");
            const c2 = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
            for (const e2 of c2) {
              const t3 = n.createNS("http://www.w3.org/2000/svg", "ellipse");
              t3.setAttributeNS(null, "opacity", "0.04"), t3.setAttributeNS(null, "cx", "10.5"), t3.setAttributeNS(null, "cy", "5.80029008"), t3.setAttributeNS(null, "rx", e2.rx), t3.setAttributeNS(null, "ry", e2.ry), l2.appendChild(t3);
            }
            const h2 = n.createNS("http://www.w3.org/2000/svg", "g");
            h2.setAttributeNS(null, "fill", this._color);
            const u2 = n.createNS("http://www.w3.org/2000/svg", "path");
            u2.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), h2.appendChild(u2);
            const d2 = n.createNS("http://www.w3.org/2000/svg", "g");
            d2.setAttributeNS(null, "opacity", "0.25"), d2.setAttributeNS(null, "fill", "#000000");
            const _2 = n.createNS("http://www.w3.org/2000/svg", "path");
            _2.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), d2.appendChild(_2);
            const p2 = n.createNS("http://www.w3.org/2000/svg", "g");
            p2.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), p2.setAttributeNS(null, "fill", "#FFFFFF");
            const m2 = n.createNS("http://www.w3.org/2000/svg", "g");
            m2.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
            const f2 = n.createNS("http://www.w3.org/2000/svg", "circle");
            f2.setAttributeNS(null, "fill", "#000000"), f2.setAttributeNS(null, "opacity", "0.25"), f2.setAttributeNS(null, "cx", "5.5"), f2.setAttributeNS(null, "cy", "5.5"), f2.setAttributeNS(null, "r", "5.4999962");
            const g2 = n.createNS("http://www.w3.org/2000/svg", "circle");
            g2.setAttributeNS(null, "fill", "#FFFFFF"), g2.setAttributeNS(null, "cx", "5.5"), g2.setAttributeNS(null, "cy", "5.5"), g2.setAttributeNS(null, "r", "5.4999962"), m2.appendChild(f2), m2.appendChild(g2), s2.appendChild(l2), s2.appendChild(h2), s2.appendChild(d2), s2.appendChild(p2), s2.appendChild(m2), i3.appendChild(s2), i3.setAttributeNS(null, "height", o3 * this._scale + "px"), i3.setAttributeNS(null, "width", r2 * this._scale + "px"), this._element.appendChild(i3), this._offset = e.pointGeometry.convert(t2 && t2.offset || [0, -14]);
          }
          this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (e2) => {
            e2.preventDefault();
          }), this._element.addEventListener("mousedown", (e2) => {
            e2.preventDefault();
          });
          const o2 = this._element.classList;
          for (const e2 in Sr)
            o2.remove(`mapboxgl-marker-anchor-${e2}`);
          o2.add(`mapboxgl-marker-anchor-${this._anchor}`), this._popup = null;
        }
        addTo(e2) {
          return this.remove(), this._map = e2, e2.getCanvasContainer().appendChild(this._element), e2.on("move", this._update), e2.on("moveend", this._update), e2.on("remove", this._clearFadeTimer), e2._addMarker(this), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
        }
        remove() {
          return this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._map.off("remove", this._clearFadeTimer), this._map._removeMarker(this), delete this._map), this._clearFadeTimer(), n.remove(this._element), this._popup && this._popup.remove(), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(t2) {
          return this._lngLat = e.LngLat.convert(t2), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
        }
        getElement() {
          return this._element;
        }
        setPopup(e2) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e2) {
            if (!("offset" in e2.options)) {
              const t2 = 38.1, i2 = 13.5, o2 = Math.sqrt(Math.pow(i2, 2) / 2);
              e2.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -t2], "bottom-left": [o2, -1 * (t2 - i2 + o2)], "bottom-right": [-o2, -1 * (t2 - i2 + o2)], left: [i2, -1 * (t2 - i2)], right: [-i2, -1 * (t2 - i2)] } : this._offset;
            }
            this._popup = e2, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
          }
          return this;
        }
        _onKeyPress(e2) {
          const t2 = e2.code, i2 = e2.charCode || e2.keyCode;
          "Space" !== t2 && "Enter" !== t2 && 32 !== i2 && 13 !== i2 || this.togglePopup();
        }
        _onMapClick(e2) {
          const t2 = e2.originalEvent.target, i2 = this._element;
          this._popup && (t2 === i2 || i2.contains(t2)) && this.togglePopup();
        }
        getPopup() {
          return this._popup;
        }
        togglePopup() {
          const e2 = this._popup;
          return e2 ? (e2.isOpen() ? e2.remove() : e2.addTo(this._map), this) : this;
        }
        _evaluateOpacity() {
          const e2 = this._pos ? this._pos.sub(this._transformedOffset()) : null;
          if (!this._withinScreenBounds(e2))
            return void this._clearFadeTimer();
          const t2 = this._map.unproject(e2);
          let i2 = false;
          if (this._map.getTerrain()) {
            const e3 = this._map.getFreeCameraOptions();
            if (e3.position) {
              const o3 = e3.position.toLngLat();
              i2 = o3.distanceTo(t2) < 0.9 * o3.distanceTo(this._lngLat);
            }
          }
          const o2 = (1 - this._map._queryFogOpacity(t2)) * (i2 ? 0.2 : 1);
          this._element.style.opacity = `${o2}`, this._popup && this._popup._setOpacity(`${o2}`), this._fadeTimer = null;
        }
        _clearFadeTimer() {
          this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
        }
        _withinScreenBounds(e2) {
          const t2 = this._map.transform;
          return !!e2 && e2.x >= 0 && e2.x < t2.width && e2.y >= 0 && e2.y < t2.height;
        }
        _update(e2) {
          if (!this._map)
            return;
          this._map.transform.renderWorldCopies && (this._lngLat = Cr(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._transformedOffset());
          let t2 = "";
          "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? t2 = `rotateZ(${this._rotation}deg)` : "map" === this._rotationAlignment && (t2 = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
          let i2 = "";
          "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? i2 = "rotateX(0deg)" : "map" === this._pitchAlignment && (i2 = `rotateX(${this._map.getPitch()}deg)`), e2 && "moveend" !== e2.type || (this._pos = this._pos.round()), this._map._requestDomTask(() => {
            this._map && (this._element && this._pos && this._anchor && n.setTransform(this._element, `${Sr[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${i2} ${t2}`), !this._map.getTerrain() && !this._map.getFog() || this._fadeTimer || (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)));
          });
        }
        _transformedOffset() {
          if (!this._defaultMarker)
            return this._offset;
          const e2 = this._map.transform, t2 = this._offset.mult(this._scale);
          return "map" === this._rotationAlignment && t2._rotate(e2.angle), "map" === this._pitchAlignment && (t2.y *= Math.cos(e2._pitch)), t2;
        }
        getOffset() {
          return this._offset;
        }
        setOffset(t2) {
          return this._offset = e.pointGeometry.convert(t2), this._update(), this;
        }
        _onMove(t2) {
          if (!this._isDragging) {
            const e2 = this._clickTolerance || this._map._clickTolerance;
            this._isDragging = t2.point.dist(this._pointerdownPos) >= e2;
          }
          this._isDragging && (this._pos = t2.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new e.Event("dragstart"))), this.fire(new e.Event("drag")));
        }
        _onUp() {
          this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new e.Event("dragend")), this._state = "inactive";
        }
        _addDragHandler(e2) {
          this._element.contains(e2.originalEvent.target) && (e2.preventDefault(), this._positionDelta = e2.point.sub(this._pos).add(this._transformedOffset()), this._pointerdownPos = e2.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
        }
        setDraggable(e2) {
          return this._draggable = !!e2, this._map && (e2 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
        }
        isDraggable() {
          return this._draggable;
        }
        setRotation(e2) {
          return this._rotation = e2 || 0, this._update(), this;
        }
        getRotation() {
          return this._rotation;
        }
        setRotationAlignment(e2) {
          return this._rotationAlignment = e2 || "auto", this._update(), this;
        }
        getRotationAlignment() {
          return this._rotationAlignment;
        }
        setPitchAlignment(e2) {
          return this._pitchAlignment = e2 && "auto" !== e2 ? e2 : this._rotationAlignment, this._update(), this;
        }
        getPitchAlignment() {
          return this._pitchAlignment;
        }
      }
      class Ir {
        constructor(e2) {
          this.jumpTo(e2);
        }
        getValue(t2) {
          if (t2 <= this._startTime)
            return this._start;
          if (t2 >= this._endTime)
            return this._end;
          const i2 = e.easeCubicInOut((t2 - this._startTime) / (this._endTime - this._startTime));
          return this._start * (1 - i2) + this._end * i2;
        }
        isEasing(e2) {
          return e2 >= this._startTime && e2 <= this._endTime;
        }
        jumpTo(e2) {
          this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e2, this._end = e2;
        }
        easeTo(e2, t2, i2) {
          this._start = this.getValue(t2), this._end = e2, this._startTime = t2, this._endTime = t2 + i2;
        }
      }
      const Dr = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm" }, { HTMLImageElement: Ar, HTMLElement: zr, ImageBitmap: Pr } = e.window, Lr = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 85, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, optimizeForTerrain: true, renderWorldCopies: true, refreshExpiredTiles: true, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", localFontFamily: null, transformRequest: null, accessToken: null, fadeDuration: 300, crossSourceCollisions: true };
      function Rr(e2) {
        e2.parentNode && e2.parentNode.removeChild(e2);
      }
      const kr = { showCompass: true, showZoom: true, visualizePitch: false };
      class Fr {
        constructor(t2, i2, o2 = false) {
          this._clickTolerance = 10, this.element = i2, this.mouseRotate = new Xo({ clickTolerance: t2.dragRotate._mouseRotate._clickTolerance }), this.map = t2, o2 && (this.mousePitch = new Ho({ clickTolerance: t2.dragRotate._mousePitch._clickTolerance })), e.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), n.addEventListener(i2, "mousedown", this.mousedown), n.addEventListener(i2, "touchstart", this.touchstart, { passive: false }), n.addEventListener(i2, "touchmove", this.touchmove), n.addEventListener(i2, "touchend", this.touchend), n.addEventListener(i2, "touchcancel", this.reset);
        }
        down(e2, t2) {
          this.mouseRotate.mousedown(e2, t2), this.mousePitch && this.mousePitch.mousedown(e2, t2), n.disableDrag();
        }
        move(e2, t2) {
          const i2 = this.map, o2 = this.mouseRotate.mousemoveWindow(e2, t2);
          if (o2 && o2.bearingDelta && i2.setBearing(i2.getBearing() + o2.bearingDelta), this.mousePitch) {
            const o3 = this.mousePitch.mousemoveWindow(e2, t2);
            o3 && o3.pitchDelta && i2.setPitch(i2.getPitch() + o3.pitchDelta);
          }
        }
        off() {
          const e2 = this.element;
          n.removeEventListener(e2, "mousedown", this.mousedown), n.removeEventListener(e2, "touchstart", this.touchstart, { passive: false }), n.removeEventListener(e2, "touchmove", this.touchmove), n.removeEventListener(e2, "touchend", this.touchend), n.removeEventListener(e2, "touchcancel", this.reset), this.offTemp();
        }
        offTemp() {
          n.enableDrag(), n.removeEventListener(e.window, "mousemove", this.mousemove), n.removeEventListener(e.window, "mouseup", this.mouseup);
        }
        mousedown(t2) {
          this.down(e.extend({}, t2, { ctrlKey: true, preventDefault: () => t2.preventDefault() }), n.mousePos(this.element, t2)), n.addEventListener(e.window, "mousemove", this.mousemove), n.addEventListener(e.window, "mouseup", this.mouseup);
        }
        mousemove(e2) {
          this.move(e2, n.mousePos(this.element, e2));
        }
        mouseup(e2) {
          this.mouseRotate.mouseupWindow(e2), this.mousePitch && this.mousePitch.mouseupWindow(e2), this.offTemp();
        }
        touchstart(e2) {
          1 !== e2.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = n.touchPos(this.element, e2.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: true, preventDefault: () => e2.preventDefault() }, this._startPos));
        }
        touchmove(e2) {
          1 !== e2.targetTouches.length ? this.reset() : (this._lastPos = n.touchPos(this.element, e2.targetTouches)[0], this.move({ preventDefault: () => e2.preventDefault() }, this._lastPos));
        }
        touchend(e2) {
          0 === e2.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
        }
        reset() {
          this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
        }
      }
      const Or = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true, showUserHeading: false };
      let Br, Ur = 0, Nr = false;
      const Gr = { maxWidth: 100, unit: "metric" };
      function Zr(e2, t2, i2) {
        const o2 = i2 && i2.maxWidth || 100, r2 = e2._container.getBoundingClientRect().height / 2, n2 = e2.unproject([0, r2]), a2 = e2.unproject([o2, r2]), s2 = n2.distanceTo(a2);
        if (i2 && "imperial" === i2.unit) {
          const i3 = 3.2808 * s2;
          i3 > 5280 ? Vr(t2, o2, i3 / 5280, e2._getUIString("ScaleControl.Miles"), e2) : Vr(t2, o2, i3, e2._getUIString("ScaleControl.Feet"), e2);
        } else
          i2 && "nautical" === i2.unit ? Vr(t2, o2, s2 / 1852, e2._getUIString("ScaleControl.NauticalMiles"), e2) : s2 >= 1e3 ? Vr(t2, o2, s2 / 1e3, e2._getUIString("ScaleControl.Kilometers"), e2) : Vr(t2, o2, s2, e2._getUIString("ScaleControl.Meters"), e2);
      }
      function Vr(e2, t2, i2, o2, r2) {
        const n2 = function(e3) {
          const t3 = Math.pow(10, `${Math.floor(e3)}`.length - 1);
          let i3 = e3 / t3;
          return i3 = i3 >= 10 ? 10 : i3 >= 5 ? 5 : i3 >= 3 ? 3 : i3 >= 2 ? 2 : i3 >= 1 ? 1 : function(e4) {
            const t4 = Math.pow(10, Math.ceil(-Math.log(e4) / Math.LN10));
            return Math.round(e4 * t4) / t4;
          }(i3), t3 * i3;
        }(i2), a2 = n2 / i2;
        r2._requestDomTask(() => {
          e2.style.width = t2 * a2 + "px", e2.innerHTML = `${n2}&nbsp;${o2}`;
        });
      }
      const jr = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px" }, qr = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", "), Wr = { version: e.version, supported: t, setRTLTextPlugin: e.setRTLTextPlugin, getRTLTextPluginStatus: e.getRTLTextPluginStatus, Map: class extends br {
        constructor(t2) {
          if (null != (t2 = e.extend({}, Lr, t2)).minZoom && null != t2.maxZoom && t2.minZoom > t2.maxZoom)
            throw new Error("maxZoom must be greater than or equal to minZoom");
          if (null != t2.minPitch && null != t2.maxPitch && t2.minPitch > t2.maxPitch)
            throw new Error("maxPitch must be greater than or equal to minPitch");
          if (null != t2.minPitch && t2.minPitch < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (null != t2.maxPitch && t2.maxPitch > 85)
            throw new Error("maxPitch must be less than or equal to 85");
          if (super(new Eo(t2.minZoom, t2.maxZoom, t2.minPitch, t2.maxPitch, t2.renderWorldCopies), t2), this._interactive = t2.interactive, this._maxTileCacheSize = t2.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t2.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t2.preserveDrawingBuffer, this._antialias = t2.antialias, this._trackResize = t2.trackResize, this._bearingSnap = t2.bearingSnap, this._refreshExpiredTiles = t2.refreshExpiredTiles, this._fadeDuration = t2.fadeDuration, this._isInitialLoad = true, this._crossSourceCollisions = t2.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = t2.collectResourceTiming, this._optimizeForTerrain = t2.optimizeForTerrain, this._renderTaskQueue = new Er(), this._domRenderTaskQueue = new Er(), this._controls = [], this._markers = [], this._mapId = e.uniqueId(), this._locale = e.extend({}, Dr, t2.locale), this._clickTolerance = t2.clickTolerance, this._averageElevationLastSampledAt = -1 / 0, this._averageElevation = new Ir(0), this._requestManager = new e.RequestManager(t2.transformRequest, t2.accessToken, t2.testMode), this._silenceAuthErrors = !!t2.testMode, "string" == typeof t2.container) {
            if (this._container = e.window.document.getElementById(t2.container), !this._container)
              throw new Error(`Container '${t2.container}' not found.`);
          } else {
            if (!(t2.container instanceof zr))
              throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = t2.container;
          }
          if (t2.maxBounds && this.setMaxBounds(t2.maxBounds), e.bindAll(["_onWindowOnline", "_onWindowResize", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter)
            throw new Error("Failed to initialize WebGL.");
          this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), void 0 !== e.window && (e.window.addEventListener("online", this._onWindowOnline, false), e.window.addEventListener("resize", this._onWindowResize, false), e.window.addEventListener("orientationchange", this._onWindowResize, false), e.window.addEventListener("webkitfullscreenchange", this._onWindowResize, false)), this.handlers = new yr(this, t2), this._hash = t2.hash && new So("string" == typeof t2.hash && t2.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: t2.center, zoom: t2.zoom, bearing: t2.bearing, pitch: t2.pitch }), t2.bounds && (this.resize(), this.fitBounds(t2.bounds, e.extend({}, t2.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localFontFamily = t2.localFontFamily, this._localIdeographFontFamily = t2.localIdeographFontFamily, t2.style && this.setStyle(t2.style, { localFontFamily: this._localFontFamily, localIdeographFontFamily: this._localIdeographFontFamily }), t2.attributionControl && this.addControl(new wr({ customAttribution: t2.customAttribution })), this._logoControl = new Tr(), this.addControl(this._logoControl, t2.logoPosition), this.on("style.load", () => {
            this.transform.unmodified && this.jumpTo(this.style.stylesheet);
          }), this.on("data", (t3) => {
            this._update("style" === t3.dataType), this.fire(new e.Event(`${t3.dataType}data`, t3));
          }), this.on("dataloading", (t3) => {
            this.fire(new e.Event(`${t3.dataType}dataloading`, t3));
          });
        }
        _getMapId() {
          return this._mapId;
        }
        addControl(t2, i2) {
          if (void 0 === i2 && (i2 = t2.getDefaultPosition ? t2.getDefaultPosition() : "top-right"), !t2 || !t2.onAdd)
            return this.fire(new e.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          const o2 = t2.onAdd(this);
          this._controls.push(t2);
          const r2 = this._controlPositions[i2];
          return -1 !== i2.indexOf("bottom") ? r2.insertBefore(o2, r2.firstChild) : r2.appendChild(o2), this;
        }
        removeControl(t2) {
          if (!t2 || !t2.onRemove)
            return this.fire(new e.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          const i2 = this._controls.indexOf(t2);
          return i2 > -1 && this._controls.splice(i2, 1), t2.onRemove(this), this;
        }
        hasControl(e2) {
          return this._controls.indexOf(e2) > -1;
        }
        getContainer() {
          return this._container;
        }
        getCanvasContainer() {
          return this._canvasContainer;
        }
        getCanvas() {
          return this._canvas;
        }
        resize(t2) {
          const [i2, o2] = this._containerDimensions();
          if (i2 === this.transform.width && o2 === this.transform.height)
            return this;
          this._resizeCanvas(i2, o2), this.transform.resize(i2, o2), this.painter.resize(Math.ceil(i2), Math.ceil(o2));
          const r2 = !this._moving;
          return r2 && this.fire(new e.Event("movestart", t2)).fire(new e.Event("move", t2)), this.fire(new e.Event("resize", t2)), r2 && this.fire(new e.Event("moveend", t2)), this;
        }
        getBounds() {
          return this.transform.getBounds();
        }
        getMaxBounds() {
          return this.transform.getMaxBounds();
        }
        setMaxBounds(t2) {
          return this.transform.setMaxBounds(e.LngLatBounds.convert(t2)), this._update();
        }
        setMinZoom(e2) {
          if ((e2 = null == e2 ? -2 : e2) >= -2 && e2 <= this.transform.maxZoom)
            return this.transform.minZoom = e2, this._update(), this.getZoom() < e2 && this.setZoom(e2), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }
        getMinZoom() {
          return this.transform.minZoom;
        }
        setMaxZoom(e2) {
          if ((e2 = null == e2 ? 22 : e2) >= this.transform.minZoom)
            return this.transform.maxZoom = e2, this._update(), this.getZoom() > e2 && this.setZoom(e2), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }
        getMaxZoom() {
          return this.transform.maxZoom;
        }
        setMinPitch(e2) {
          if ((e2 = null == e2 ? 0 : e2) < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (e2 >= 0 && e2 <= this.transform.maxPitch)
            return this.transform.minPitch = e2, this._update(), this.getPitch() < e2 && this.setPitch(e2), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }
        getMinPitch() {
          return this.transform.minPitch;
        }
        setMaxPitch(e2) {
          if ((e2 = null == e2 ? 85 : e2) > 85)
            throw new Error("maxPitch must be less than or equal to 85");
          if (e2 >= this.transform.minPitch)
            return this.transform.maxPitch = e2, this._update(), this.getPitch() > e2 && this.setPitch(e2), this;
          throw new Error("maxPitch must be greater than the current minPitch");
        }
        getMaxPitch() {
          return this.transform.maxPitch;
        }
        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }
        setRenderWorldCopies(e2) {
          return this.transform.renderWorldCopies = e2, this._update();
        }
        project(t2) {
          return this.transform.locationPoint3D(e.LngLat.convert(t2));
        }
        unproject(t2) {
          return this.transform.pointLocation3D(e.pointGeometry.convert(t2));
        }
        isMoving() {
          return this._moving || this.handlers && this.handlers.isMoving();
        }
        isZooming() {
          return this._zooming || this.handlers && this.handlers.isZooming();
        }
        isRotating() {
          return this._rotating || this.handlers && this.handlers.isRotating();
        }
        _createDelegatedListener(e2, t2, i2) {
          if ("mouseenter" === e2 || "mouseover" === e2) {
            let o2 = false;
            const r2 = (r3) => {
              const n2 = this.getLayer(t2) ? this.queryRenderedFeatures(r3.point, { layers: [t2] }) : [];
              n2.length ? o2 || (o2 = true, i2.call(this, new ko(e2, this, r3.originalEvent, { features: n2 }))) : o2 = false;
            };
            return { layer: t2, listener: i2, delegates: { mousemove: r2, mouseout: () => {
              o2 = false;
            } } };
          }
          if ("mouseleave" === e2 || "mouseout" === e2) {
            let o2 = false;
            const r2 = (r3) => {
              (this.getLayer(t2) ? this.queryRenderedFeatures(r3.point, { layers: [t2] }) : []).length ? o2 = true : o2 && (o2 = false, i2.call(this, new ko(e2, this, r3.originalEvent)));
            }, n2 = (t3) => {
              o2 && (o2 = false, i2.call(this, new ko(e2, this, t3.originalEvent)));
            };
            return { layer: t2, listener: i2, delegates: { mousemove: r2, mouseout: n2 } };
          }
          {
            const o2 = (e3) => {
              const o3 = this.getLayer(t2) ? this.queryRenderedFeatures(e3.point, { layers: [t2] }) : [];
              o3.length && (e3.features = o3, i2.call(this, e3), delete e3.features);
            };
            return { layer: t2, listener: i2, delegates: { [e2]: o2 } };
          }
        }
        on(e2, t2, i2) {
          if (void 0 === i2)
            return super.on(e2, t2);
          const o2 = this._createDelegatedListener(e2, t2, i2);
          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e2] = this._delegatedListeners[e2] || [], this._delegatedListeners[e2].push(o2);
          for (const e3 in o2.delegates)
            this.on(e3, o2.delegates[e3]);
          return this;
        }
        once(e2, t2, i2) {
          if (void 0 === i2)
            return super.once(e2, t2);
          const o2 = this._createDelegatedListener(e2, t2, i2);
          for (const e3 in o2.delegates)
            this.once(e3, o2.delegates[e3]);
          return this;
        }
        off(e2, t2, i2) {
          return void 0 === i2 ? super.off(e2, t2) : (this._delegatedListeners && this._delegatedListeners[e2] && ((o2) => {
            const r2 = this._delegatedListeners[e2];
            for (let e3 = 0; e3 < r2.length; e3++) {
              const o3 = r2[e3];
              if (o3.layer === t2 && o3.listener === i2) {
                for (const e4 in o3.delegates)
                  this.off(e4, o3.delegates[e4]);
                return r2.splice(e3, 1), this;
              }
            }
          })(), this);
        }
        queryRenderedFeatures(t2, i2) {
          return this.style ? (void 0 !== i2 || void 0 === t2 || t2 instanceof e.pointGeometry || Array.isArray(t2) || (i2 = t2, t2 = void 0), this.style.queryRenderedFeatures(t2 = t2 || [[0, 0], [this.transform.width, this.transform.height]], i2 = i2 || {}, this.transform)) : [];
        }
        querySourceFeatures(e2, t2) {
          return this.style.querySourceFeatures(e2, t2);
        }
        queryTerrainElevation(t2, i2) {
          const o2 = this.transform.elevation;
          return o2 ? (i2 = e.extend({}, { exaggerated: true }, i2), o2.getAtPoint(e.MercatorCoordinate.fromLngLat(t2), null, i2.exaggerated)) : null;
        }
        setStyle(t2, i2) {
          return false !== (i2 = e.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily, localFontFamily: this._localFontFamily }, i2)).diff && i2.localIdeographFontFamily === this._localIdeographFontFamily && i2.localFontFamily === this._localFontFamily && this.style && t2 ? (this._diffStyle(t2, i2), this) : (this._localIdeographFontFamily = i2.localIdeographFontFamily, this._localFontFamily = i2.localFontFamily, this._updateStyle(t2, i2));
        }
        _getUIString(e2) {
          const t2 = this._locale[e2];
          if (null == t2)
            throw new Error(`Missing UI string '${e2}'`);
          return t2;
        }
        _updateStyle(e2, t2) {
          return this.style && (this.style.setEventedParent(null), this.style._remove(), delete this.style), e2 && (this.style = new Vt(this, t2 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof e2 ? this.style.loadURL(e2) : this.style.loadJSON(e2)), this._updateTerrain(), this;
        }
        _lazyInitEmptyStyle() {
          this.style || (this.style = new Vt(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }
        _diffStyle(t2, i2) {
          if ("string" == typeof t2) {
            const o2 = this._requestManager.normalizeStyleURL(t2), r2 = this._requestManager.transformRequest(o2, e.ResourceType.Style);
            e.getJSON(r2, (t3, o3) => {
              t3 ? this.fire(new e.ErrorEvent(t3)) : o3 && this._updateDiff(o3, i2);
            });
          } else
            "object" == typeof t2 && this._updateDiff(t2, i2);
        }
        _updateDiff(t2, i2) {
          try {
            this.style.setState(t2) && this._update(true);
          } catch (o2) {
            e.warnOnce(`Unable to perform style diff: ${o2.message || o2.error || o2}.  Rebuilding the style from scratch.`), this._updateStyle(t2, i2);
          }
        }
        getStyle() {
          if (this.style)
            return this.style.serialize();
        }
        isStyleLoaded() {
          return this.style ? this.style.loaded() : e.warnOnce("There is no style added to the map.");
        }
        addSource(e2, t2) {
          return this._lazyInitEmptyStyle(), this.style.addSource(e2, t2), this._update(true);
        }
        isSourceLoaded(t2) {
          const i2 = this.style && this.style._getSourceCaches(t2);
          if (0 !== i2.length)
            return i2.every((e2) => e2.loaded());
          this.fire(new e.ErrorEvent(new Error(`There is no source with ID '${t2}'`)));
        }
        areTilesLoaded() {
          const e2 = this.style && this.style._sourceCaches;
          for (const t2 in e2) {
            const i2 = e2[t2]._tiles;
            for (const e3 in i2) {
              const t3 = i2[e3];
              if ("loaded" !== t3.state && "errored" !== t3.state)
                return false;
            }
          }
          return true;
        }
        addSourceType(e2, t2, i2) {
          return this._lazyInitEmptyStyle(), this.style.addSourceType(e2, t2, i2);
        }
        removeSource(e2) {
          return this.style.removeSource(e2), this._updateTerrain(), this._update(true);
        }
        getSource(e2) {
          return this.style.getSource(e2);
        }
        addImage(t2, i2, { pixelRatio: o2 = 1, sdf: r2 = false, stretchX: n2, stretchY: a2, content: s2 } = {}) {
          if (this._lazyInitEmptyStyle(), i2 instanceof Ar || Pr && i2 instanceof Pr) {
            const { width: l2, height: c2, data: h2 } = e.exported.getImageData(i2);
            this.style.addImage(t2, { data: new e.RGBAImage({ width: l2, height: c2 }, h2), pixelRatio: o2, stretchX: n2, stretchY: a2, content: s2, sdf: r2, version: 0 });
          } else {
            if (void 0 === i2.width || void 0 === i2.height)
              return this.fire(new e.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            {
              const { width: l2, height: c2, data: h2 } = i2, u2 = i2;
              this.style.addImage(t2, { data: new e.RGBAImage({ width: l2, height: c2 }, new Uint8Array(h2)), pixelRatio: o2, stretchX: n2, stretchY: a2, content: s2, sdf: r2, version: 0, userImage: u2 }), u2.onAdd && u2.onAdd(this, t2);
            }
          }
        }
        updateImage(t2, i2) {
          const o2 = this.style.getImage(t2);
          if (!o2)
            return this.fire(new e.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          const r2 = i2 instanceof Ar || Pr && i2 instanceof Pr ? e.exported.getImageData(i2) : i2, { width: n2, height: a2, data: s2 } = r2;
          return void 0 === n2 || void 0 === a2 ? this.fire(new e.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))) : n2 !== o2.data.width || a2 !== o2.data.height ? this.fire(new e.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image"))) : (o2.data.replace(s2, !(i2 instanceof Ar || Pr && i2 instanceof Pr)), void this.style.updateImage(t2, o2));
        }
        hasImage(t2) {
          return t2 ? !!this.style.getImage(t2) : (this.fire(new e.ErrorEvent(new Error("Missing required image id"))), false);
        }
        removeImage(e2) {
          this.style.removeImage(e2);
        }
        loadImage(t2, i2) {
          e.getImage(this._requestManager.transformRequest(t2, e.ResourceType.Image), (t3, o2) => {
            i2(t3, o2 instanceof Ar ? e.exported.getImageData(o2) : o2);
          });
        }
        listImages() {
          return this.style.listImages();
        }
        addLayer(e2, t2) {
          return this._lazyInitEmptyStyle(), this.style.addLayer(e2, t2), this._update(true);
        }
        moveLayer(e2, t2) {
          return this.style.moveLayer(e2, t2), this._update(true);
        }
        removeLayer(e2) {
          return this.style.removeLayer(e2), this._update(true);
        }
        getLayer(e2) {
          return this.style.getLayer(e2);
        }
        setLayerZoomRange(e2, t2, i2) {
          return this.style.setLayerZoomRange(e2, t2, i2), this._update(true);
        }
        setFilter(e2, t2, i2 = {}) {
          return this.style.setFilter(e2, t2, i2), this._update(true);
        }
        getFilter(e2) {
          return this.style.getFilter(e2);
        }
        setPaintProperty(e2, t2, i2, o2 = {}) {
          return this.style.setPaintProperty(e2, t2, i2, o2), this._update(true);
        }
        getPaintProperty(e2, t2) {
          return this.style.getPaintProperty(e2, t2);
        }
        setLayoutProperty(e2, t2, i2, o2 = {}) {
          return this.style.setLayoutProperty(e2, t2, i2, o2), this._update(true);
        }
        getLayoutProperty(e2, t2) {
          return this.style.getLayoutProperty(e2, t2);
        }
        setLight(e2, t2 = {}) {
          return this._lazyInitEmptyStyle(), this.style.setLight(e2, t2), this._update(true);
        }
        getLight() {
          return this.style.getLight();
        }
        setTerrain(e2) {
          return this._lazyInitEmptyStyle(), this.style.setTerrain(e2), this._averageElevationLastSampledAt = -1 / 0, this._update(true);
        }
        getTerrain() {
          return this.style ? this.style.getTerrain() : null;
        }
        setFog(e2) {
          return this._lazyInitEmptyStyle(), this.style.setFog(e2), this._update(true);
        }
        getFog() {
          return this.style ? this.style.getFog() : null;
        }
        _queryFogOpacity(t2) {
          return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e.LngLat.convert(t2), this.transform) : 0;
        }
        setFeatureState(e2, t2) {
          return this.style.setFeatureState(e2, t2), this._update();
        }
        removeFeatureState(e2, t2) {
          return this.style.removeFeatureState(e2, t2), this._update();
        }
        getFeatureState(e2) {
          return this.style.getFeatureState(e2);
        }
        _containerDimensions() {
          let e2 = 0, t2 = 0;
          return this._container && (e2 = this._container.getBoundingClientRect().width || 400, t2 = this._container.getBoundingClientRect().height || 300), [e2, t2];
        }
        _detectMissingCSS() {
          "rgb(250, 128, 114)" !== e.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && e.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
        }
        _setupContainer() {
          const e2 = this._container;
          e2.classList.add("mapboxgl-map"), (this._missingCSSCanary = n.create("div", "mapboxgl-canary", e2)).style.visibility = "hidden", this._detectMissingCSS();
          const t2 = this._canvasContainer = n.create("div", "mapboxgl-canvas-container", e2);
          this._interactive && t2.classList.add("mapboxgl-interactive"), this._canvas = n.create("canvas", "mapboxgl-canvas", t2), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");
          const i2 = this._containerDimensions();
          this._resizeCanvas(i2[0], i2[1]);
          const o2 = this._controlContainer = n.create("div", "mapboxgl-control-container", e2), r2 = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((e3) => {
            r2[e3] = n.create("div", `mapboxgl-ctrl-${e3}`, o2);
          }), this._container.addEventListener("scroll", this._onMapScroll, false);
        }
        _resizeCanvas(t2, i2) {
          const o2 = e.exported.devicePixelRatio || 1;
          this._canvas.width = o2 * Math.ceil(t2), this._canvas.height = o2 * Math.ceil(i2), this._canvas.style.width = `${t2}px`, this._canvas.style.height = `${i2}px`;
        }
        _addMarker(e2) {
          this._markers.push(e2);
        }
        _removeMarker(e2) {
          const t2 = this._markers.indexOf(e2);
          -1 !== t2 && this._markers.splice(t2, 1);
        }
        _setupPainter() {
          const i2 = e.extend({}, t.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }), o2 = this._canvas.getContext("webgl", i2) || this._canvas.getContext("experimental-webgl", i2);
          o2 ? (e.storeAuthState(o2, true), this.painter = new po(o2, this.transform), this.on("data", (e2) => {
            "source" === e2.dataType && this.painter.setTileLoadedFlag(true);
          }), e.exported$1.testSupport(o2)) : this.fire(new e.ErrorEvent(new Error("Failed to initialize WebGL")));
        }
        _contextLost(t2) {
          t2.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e.Event("webglcontextlost", { originalEvent: t2 }));
        }
        _contextRestored(t2) {
          this._setupPainter(), this.resize(), this._update(), this.fire(new e.Event("webglcontextrestored", { originalEvent: t2 }));
        }
        _onMapScroll(e2) {
          if (e2.target === this._container)
            return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
        }
        loaded() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }
        _update(e2) {
          return this.style ? (this._styleDirty = this._styleDirty || e2, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
        }
        _requestRenderFrame(e2) {
          return this._update(), this._renderTaskQueue.add(e2);
        }
        _cancelRenderFrame(e2) {
          this._renderTaskQueue.remove(e2);
        }
        _requestDomTask(e2) {
          !this.isMoving() && this.loaded() ? e2() : this._domRenderTaskQueue.add(e2);
        }
        _render(t2) {
          let i2;
          const o2 = this.painter.context.extTimerQuery, r2 = e.exported.now();
          this.listens("gpu-timing-frame") && (i2 = o2.createQueryEXT(), o2.beginQueryEXT(o2.TIME_ELAPSED_EXT, i2));
          let n2 = this._updateAverageElevation(r2);
          if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(t2), this._domRenderTaskQueue.run(t2), this._removed)
            return;
          let a2 = false;
          const s2 = this._isInitialLoad ? 0 : this._fadeDuration;
          if (this.style && this._styleDirty) {
            this._styleDirty = false;
            const t3 = this.transform.zoom, i3 = e.exported.now();
            this.style.zoomHistory.update(t3, i3);
            const o3 = new e.EvaluationParameters(t3, { now: i3, fadeDuration: s2, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), r3 = o3.crossFadingFactor();
            1 === r3 && r3 === this._crossFadingFactor || (a2 = true, this._crossFadingFactor = r3), this.style.update(o3);
          }
          if (this.style && this.style.fog && this.style.fog.hasTransition() && (this.style._markersNeedUpdate = true, this._sourcesDirty = true), this.style && this._sourcesDirty && (this._sourcesDirty = false, this.painter._updateFog(this.style), this._updateTerrain(), this.style._updateSources(this.transform), this._forceMarkerUpdate()), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, s2, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showTerrainWireframe: this.showTerrainWireframe, showOverdrawInspector: this._showOverdrawInspector, showQueryGeometry: !!this._showQueryGeometry, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: s2, isInitialLoad: this._isInitialLoad, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer"), speedIndexTiming: this.speedIndexTiming }), this.fire(new e.Event("render")), this.loaded() && !this._loaded && (this._loaded = true, this.fire(new e.Event("load"))), this.style && (this.style.hasTransitions() || a2) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), this.listens("gpu-timing-frame")) {
            const t3 = e.exported.now() - r2;
            o2.endQueryEXT(o2.TIME_ELAPSED_EXT, i2), setTimeout(() => {
              const r3 = o2.getQueryObjectEXT(i2, o2.QUERY_RESULT_EXT) / 1e6;
              o2.deleteQueryEXT(i2), this.fire(new e.Event("gpu-timing-frame", { cpuTime: t3, gpuTime: r3 }));
            }, 50);
          }
          if (this.listens("gpu-timing-layer")) {
            const t3 = this.painter.collectGpuTimers();
            setTimeout(() => {
              const i3 = this.painter.queryGpuTimers(t3);
              this.fire(new e.Event("gpu-timing-layer", { layerTimes: i3 }));
            }, 50);
          }
          const l2 = this._sourcesDirty || this._styleDirty || this._placementDirty || n2;
          if (l2 || this._repaint)
            this.triggerRepaint();
          else {
            const t3 = !this.isMoving() && this.loaded();
            if (t3 && (n2 = this._updateAverageElevation(r2, true)), n2)
              this.triggerRepaint();
            else if (this._triggerFrame(false), t3 && (this.fire(new e.Event("idle")), this._isInitialLoad = false, this.speedIndexTiming)) {
              const t4 = this._calculateSpeedIndex();
              this.fire(new e.Event("speedindexcompleted", { speedIndex: t4 })), this.speedIndexTiming = false;
            }
          }
          return !this._loaded || this._fullyLoaded || l2 || (this._fullyLoaded = true, this._authenticate()), this;
        }
        _forceMarkerUpdate() {
          for (const e2 of this._markers)
            e2._update();
        }
        _updateAverageElevation(e2, t2 = false) {
          const i2 = (e3) => (this.transform.averageElevation = e3, this._update(false), true);
          if (!this.painter.averageElevationNeedsEasing())
            return 0 !== this.transform.averageElevation && i2(0);
          if ((t2 || e2 - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e2)) {
            const t3 = this.transform.averageElevation;
            let o2 = this.transform.sampleAverageElevation();
            isNaN(o2) ? o2 = 0 : this._averageElevationLastSampledAt = e2;
            const r2 = Math.abs(t3 - o2);
            if (r2 > 1) {
              if (this._isInitialLoad)
                return this._averageElevation.jumpTo(o2), i2(o2);
              this._averageElevation.easeTo(o2, e2, 300);
            } else if (r2 > 1e-4)
              return this._averageElevation.jumpTo(o2), i2(o2);
          }
          return !!this._averageElevation.isEasing(e2) && i2(this._averageElevation.getValue(e2));
        }
        _authenticate() {
          e.getMapSessionAPI(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (t2) => {
            if (t2 && (t2.message === e.AUTH_ERR_MSG || 401 === t2.status)) {
              const t3 = this.painter.context.gl;
              e.storeAuthState(t3, false), this._logoControl instanceof Tr && this._logoControl._updateLogo(), t3 && t3.clear(t3.DEPTH_BUFFER_BIT | t3.COLOR_BUFFER_BIT | t3.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e.ErrorEvent(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
            }
          }), e.postMapLoadEvent(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {
          });
        }
        _updateTerrain() {
          this.painter.updateTerrain(this.style, this.isMoving() || this.isRotating() || this.isZooming());
        }
        _calculateSpeedIndex() {
          const e2 = this.painter.canvasCopy(), t2 = this.painter.getCanvasCopiesAndTimestamps();
          t2.timeStamps.push(performance.now());
          const i2 = this.painter.context.gl, o2 = i2.createFramebuffer();
          function r2(e3) {
            i2.framebufferTexture2D(i2.FRAMEBUFFER, i2.COLOR_ATTACHMENT0, i2.TEXTURE_2D, e3, 0);
            const t3 = new Uint8Array(i2.drawingBufferWidth * i2.drawingBufferHeight * 4);
            return i2.readPixels(0, 0, i2.drawingBufferWidth, i2.drawingBufferHeight, i2.RGBA, i2.UNSIGNED_BYTE, t3), t3;
          }
          return i2.bindFramebuffer(i2.FRAMEBUFFER, o2), this._canvasPixelComparison(r2(e2), t2.canvasCopies.map(r2), t2.timeStamps);
        }
        _canvasPixelComparison(e2, t2, i2) {
          let o2 = i2[1] - i2[0];
          const r2 = e2.length / 4;
          for (let n2 = 0; n2 < t2.length; n2++) {
            const a2 = t2[n2];
            let s2 = 0;
            for (let t3 = 0; t3 < a2.length; t3 += 4)
              a2[t3] === e2[t3] && a2[t3 + 1] === e2[t3 + 1] && a2[t3 + 2] === e2[t3 + 2] && a2[t3 + 3] === e2[t3 + 3] && (s2 += 1);
            o2 += (i2[n2 + 2] - i2[n2 + 1]) * (1 - s2 / r2);
          }
          return o2;
        }
        remove() {
          this._hash && this._hash.remove();
          for (const e2 of this._controls)
            e2.onRemove(this);
          this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), void 0 !== e.window && (e.window.removeEventListener("resize", this._onWindowResize, false), e.window.removeEventListener("orientationchange", this._onWindowResize, false), e.window.removeEventListener("webkitfullscreenchange", this._onWindowResize, false), e.window.removeEventListener("online", this._onWindowOnline, false));
          const t2 = this.painter.context.gl.getExtension("WEBGL_lose_context");
          t2 && t2.loseContext(), Rr(this._canvasContainer), Rr(this._controlContainer), Rr(this._missingCSSCanary), this._container.classList.remove("mapboxgl-map"), e.removeAuthState(this.painter.context.gl), this._removed = true, this.fire(new e.Event("remove"));
        }
        triggerRepaint() {
          this._triggerFrame(true);
        }
        _triggerFrame(t2) {
          this._renderNextFrame = this._renderNextFrame || t2, this.style && !this._frame && (this._frame = e.exported.frame((e2) => {
            const t3 = !!this._renderNextFrame;
            this._frame = null, this._renderNextFrame = null, t3 && this._render(e2);
          }));
        }
        _onWindowOnline() {
          this._update();
        }
        _onWindowResize(e2) {
          this._trackResize && this.resize({ originalEvent: e2 })._update();
        }
        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }
        set showTileBoundaries(e2) {
          this._showTileBoundaries !== e2 && (this._showTileBoundaries = e2, this._update());
        }
        get showTerrainWireframe() {
          return !!this._showTerrainWireframe;
        }
        set showTerrainWireframe(e2) {
          this._showTerrainWireframe !== e2 && (this._showTerrainWireframe = e2, this._update());
        }
        get speedIndexTiming() {
          return !!this._speedIndexTiming;
        }
        set speedIndexTiming(e2) {
          this._speedIndexTiming !== e2 && (this._speedIndexTiming = e2, this._update());
        }
        get showPadding() {
          return !!this._showPadding;
        }
        set showPadding(e2) {
          this._showPadding !== e2 && (this._showPadding = e2, this._update());
        }
        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }
        set showCollisionBoxes(e2) {
          this._showCollisionBoxes !== e2 && (this._showCollisionBoxes = e2, e2 ? this.style._generateCollisionBoxes() : this._update());
        }
        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }
        set showOverdrawInspector(e2) {
          this._showOverdrawInspector !== e2 && (this._showOverdrawInspector = e2, this._update());
        }
        get repaint() {
          return !!this._repaint;
        }
        set repaint(e2) {
          this._repaint !== e2 && (this._repaint = e2, this.triggerRepaint());
        }
        get vertices() {
          return !!this._vertices;
        }
        set vertices(e2) {
          this._vertices = e2, this._update();
        }
        _setCacheLimits(t2, i2) {
          e.setCacheLimits(t2, i2);
        }
        get version() {
          return e.version;
        }
      }, NavigationControl: class {
        constructor(t2) {
          this.options = e.extend({}, kr, t2), this._container = n.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (e2) => e2.preventDefault()), this.options.showZoom && (e.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (e2) => this._map.zoomIn({}, { originalEvent: e2 })), n.create("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", true), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (e2) => this._map.zoomOut({}, { originalEvent: e2 })), n.create("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", true)), this.options.showCompass && (e.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (e2) => {
            this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e2 }) : this._map.resetNorth({}, { originalEvent: e2 });
          }), this._compassIcon = n.create("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", true));
        }
        _updateZoomButtons() {
          const e2 = this._map.getZoom(), t2 = e2 === this._map.getMaxZoom(), i2 = e2 === this._map.getMinZoom();
          this._zoomInButton.disabled = t2, this._zoomOutButton.disabled = i2, this._zoomInButton.setAttribute("aria-disabled", t2.toString()), this._zoomOutButton.setAttribute("aria-disabled", i2.toString());
        }
        _rotateCompassArrow() {
          const e2 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
          this._map._requestDomTask(() => {
            this._compassIcon && (this._compassIcon.style.transform = e2);
          });
        }
        onAdd(e2) {
          return this._map = e2, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Fr(this._map, this._compass, this.options.visualizePitch)), this._container;
        }
        onRemove() {
          n.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
        }
        _createButton(e2, t2) {
          const i2 = n.create("button", e2, this._container);
          return i2.type = "button", i2.addEventListener("click", t2), i2;
        }
        _setButtonTitle(e2, t2) {
          const i2 = this._map._getUIString(`NavigationControl.${t2}`);
          e2.title = i2, e2.setAttribute("aria-label", i2);
        }
      }, GeolocateControl: class extends e.Evented {
        constructor(t2) {
          super(), this.options = e.extend({}, Or, t2), e.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation"], this), this._onDeviceOrientationListener = this._onDeviceOrientation.bind(this), this._updateMarkerRotationThrottled = Co(this._updateMarkerRotation, 20);
        }
        onAdd(t2) {
          var i2;
          return this._map = t2, this._container = n.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), i2 = this._setupUI, void 0 !== Br ? i2(Br) : void 0 !== e.window.navigator.permissions ? e.window.navigator.permissions.query({ name: "geolocation" }).then((e2) => {
            Br = "denied" !== e2.state, i2(Br);
          }) : (Br = !!e.window.navigator.geolocation, i2(Br)), this._container;
        }
        onRemove() {
          void 0 !== this._geolocationWatchID && (e.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), n.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Ur = 0, Nr = false;
        }
        _isOutOfMapMaxBounds(e2) {
          const t2 = this._map.getMaxBounds(), i2 = e2.coords;
          return t2 && (i2.longitude < t2.getWest() || i2.longitude > t2.getEast() || i2.latitude < t2.getSouth() || i2.latitude > t2.getNorth());
        }
        _setErrorState() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
          }
        }
        _onSuccess(t2) {
          if (this._map) {
            if (this._isOutOfMapMaxBounds(t2))
              return this._setErrorState(), this.fire(new e.Event("outofmaxbounds", t2)), this._updateMarker(), void this._finish();
            if (this.options.trackUserLocation)
              switch (this._lastKnownPosition = t2, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
              }
            this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t2), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(t2), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new e.Event("geolocate", t2)), this._finish();
          }
        }
        _updateCamera(t2) {
          const i2 = new e.LngLat(t2.coords.longitude, t2.coords.latitude), o2 = t2.coords.accuracy, r2 = this._map.getBearing(), n2 = e.extend({ bearing: r2 }, this.options.fitBoundsOptions);
          this._map.fitBounds(i2.toBounds(o2), n2, { geolocateSource: true });
        }
        _updateMarker(t2) {
          if (t2) {
            const i2 = new e.LngLat(t2.coords.longitude, t2.coords.latitude);
            this._accuracyCircleMarker.setLngLat(i2).addTo(this._map), this._userLocationDotMarker.setLngLat(i2).addTo(this._map), this._accuracy = t2.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          } else
            this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
        }
        _updateCircleRadius() {
          const e2 = this._map._container.getBoundingClientRect().height / 2, t2 = this._map.unproject([0, e2]), i2 = this._map.unproject([100, e2]), o2 = t2.distanceTo(i2) / 100, r2 = Math.ceil(2 * this._accuracy / o2);
          this._circleElement.style.width = `${r2}px`, this._circleElement.style.height = `${r2}px`;
        }
        _onZoom() {
          this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
        }
        _updateMarkerRotation() {
          this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._dotElement.classList.add("mapboxgl-user-location-show-heading")) : (this._dotElement.classList.remove("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
        }
        _onError(t2) {
          if (this._map) {
            if (this.options.trackUserLocation)
              if (1 === t2.code) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                const e2 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.title = e2, this._geolocateButton.setAttribute("aria-label", e2), void 0 !== this._geolocationWatchID && this._clearWatch();
              } else {
                if (3 === t2.code && Nr)
                  return;
                this._setErrorState();
              }
            "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new e.Event("error", t2)), this._finish();
          }
        }
        _finish() {
          this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
        }
        _setupUI(t2) {
          if (this._container.addEventListener("contextmenu", (e2) => e2.preventDefault()), this._geolocateButton = n.create("button", "mapboxgl-ctrl-geolocate", this._container), n.create("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", true), this._geolocateButton.type = "button", false === t2) {
            e.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
            const t3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
            this._geolocateButton.disabled = true, this._geolocateButton.title = t3, this._geolocateButton.setAttribute("aria-label", t3);
          } else {
            const e2 = this._map._getUIString("GeolocateControl.FindMyLocation");
            this._geolocateButton.title = e2, this._geolocateButton.setAttribute("aria-label", e2);
          }
          this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = n.create("div", "mapboxgl-user-location"), this._dotElement.appendChild(n.create("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(n.create("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new Mr({ element: this._dotElement, rotationAlignment: "map", pitchAlignment: "map" }), this._circleElement = n.create("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Mr({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (t3) => {
            t3.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t3.originalEvent && "resize" === t3.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new e.Event("trackuserlocationend")));
          });
        }
        _onDeviceOrientation(e2) {
          this._userLocationDotMarker && (e2.webkitCompassHeading ? this._heading = e2.webkitCompassHeading : true === e2.absolute && (this._heading = -1 * e2.alpha), this._updateMarkerRotationThrottled());
        }
        trigger() {
          if (!this._setup)
            return e.warnOnce("Geolocate control triggered before added to a map"), false;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new e.Event("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                Ur--, Nr = false, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new e.Event("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.Event("trackuserlocationstart"));
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                break;
              case "ACTIVE_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                break;
              case "BACKGROUND":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                break;
              case "BACKGROUND_ERROR":
                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
            }
            if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID)
              this._clearWatch();
            else if (void 0 === this._geolocationWatchID) {
              let t2;
              this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Ur++, Ur > 1 ? (t2 = { maximumAge: 6e5, timeout: 0 }, Nr = true) : (t2 = this.options.positionOptions, Nr = false), this._geolocationWatchID = e.window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, t2), this.options.showUserHeading && this._addDeviceOrientationListener();
            }
          } else
            e.window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
          return true;
        }
        _addDeviceOrientationListener() {
          const t2 = () => {
            e.window.addEventListener("ondeviceorientationabsolute" in e.window ? "deviceorientationabsolute" : "deviceorientation", this._onDeviceOrientationListener);
          };
          void 0 !== e.window.DeviceMotionEvent && "function" == typeof e.window.DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then((e2) => {
            "granted" === e2 && t2();
          }).catch(console.error) : t2();
        }
        _clearWatch() {
          e.window.navigator.geolocation.clearWatch(this._geolocationWatchID), e.window.removeEventListener("deviceorientation", this._onDeviceOrientationListener), e.window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientationListener), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }
      }, AttributionControl: wr, ScaleControl: class {
        constructor(t2) {
          this.options = e.extend({}, Gr, t2), e.bindAll(["_onMove", "setUnit"], this);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        _onMove() {
          Zr(this._map, this._container, this.options);
        }
        onAdd(e2) {
          return this._map = e2, this._container = n.create("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e2.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
        }
        onRemove() {
          n.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
        }
        setUnit(e2) {
          this.options.unit = e2, Zr(this._map, this._container, this.options);
        }
      }, FullscreenControl: class {
        constructor(t2) {
          this._fullscreen = false, t2 && t2.container && (t2.container instanceof e.window.HTMLElement ? this._container = t2.container : e.warnOnce("Full screen control 'container' must be a DOM element.")), e.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in e.window.document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in e.window.document && (this._fullscreenchange = "webkitfullscreenchange");
        }
        onAdd(t2) {
          return this._map = t2, this._container || (this._container = this._map.getContainer()), this._controlContainer = n.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", e.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
        }
        onRemove() {
          n.remove(this._controlContainer), this._map = null, e.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
        }
        _checkFullscreenSupport() {
          return !(!e.window.document.fullscreenEnabled && !e.window.document.webkitFullscreenEnabled);
        }
        _setupUI() {
          const t2 = this._fullscreenButton = n.create("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
          n.create("span", "mapboxgl-ctrl-icon", t2).setAttribute("aria-hidden", true), t2.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), e.window.document.addEventListener(this._fullscreenchange, this._changeIcon);
        }
        _updateTitle() {
          const e2 = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", e2), this._fullscreenButton.title = e2;
        }
        _getTitle() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }
        _isFullscreen() {
          return this._fullscreen;
        }
        _changeIcon() {
          (e.window.document.fullscreenElement || e.window.document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
        }
        _onClickFullscreen() {
          this._isFullscreen() ? e.window.document.exitFullscreen ? e.window.document.exitFullscreen() : e.window.document.webkitCancelFullScreen && e.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
        }
      }, Popup: class extends e.Evented {
        constructor(t2) {
          super(), this.options = e.extend(Object.create(jr), t2), e.bindAll(["_update", "_onClose", "remove", "_onMouseMove", "_onMouseUp", "_onDrag"], this), this._classList = new Set(t2 && t2.className ? t2.className.trim().split(/\s+/) : []);
        }
        addTo(t2) {
          return this._map && this.remove(), this._map = t2, this.options.closeOnClick && this._map.on("preclick", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")) : this._map.on("move", this._update), this.fire(new e.Event("open")), this;
        }
        isOpen() {
          return !!this._map;
        }
        remove() {
          return this._content && n.remove(this._content), this._container && (n.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new e.Event("close")), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(t2) {
          return this._lngLat = e.LngLat.convert(t2), this._pos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._map._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
        }
        trackPointer() {
          return this._trackPointer = true, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
        }
        getElement() {
          return this._container;
        }
        setText(t2) {
          return this.setDOMContent(e.window.document.createTextNode(t2));
        }
        setHTML(t2) {
          const i2 = e.window.document.createDocumentFragment(), o2 = e.window.document.createElement("body");
          let r2;
          for (o2.innerHTML = t2; r2 = o2.firstChild, r2; )
            i2.appendChild(r2);
          return this.setDOMContent(i2);
        }
        getMaxWidth() {
          return this._container && this._container.style.maxWidth;
        }
        setMaxWidth(e2) {
          return this.options.maxWidth = e2, this._update(), this;
        }
        setDOMContent(e2) {
          if (this._content)
            for (; this._content.hasChildNodes(); )
              this._content.firstChild && this._content.removeChild(this._content.firstChild);
          else
            this._content = n.create("div", "mapboxgl-popup-content", this._container);
          return this._content.appendChild(e2), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
        }
        addClassName(e2) {
          return this._classList.add(e2), this._container && this._updateClassList(), this;
        }
        removeClassName(e2) {
          return this._classList.delete(e2), this._container && this._updateClassList(), this;
        }
        setOffset(e2) {
          return this.options.offset = e2, this._update(), this;
        }
        toggleClassName(e2) {
          let t2;
          return this._classList.delete(e2) ? t2 = false : (this._classList.add(e2), t2 = true), this._container && this._updateClassList(), t2;
        }
        _createCloseButton() {
          this.options.closeButton && (this._closeButton = n.create("button", "mapboxgl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
        }
        _onMouseUp(e2) {
          this._update(e2.point);
        }
        _onMouseMove(e2) {
          this._update(e2.point);
        }
        _onDrag(e2) {
          this._update(e2.point);
        }
        _getAnchor(e2) {
          if (this.options.anchor)
            return this.options.anchor;
          const t2 = this._pos, i2 = this._container.offsetWidth, o2 = this._container.offsetHeight;
          let r2;
          return r2 = t2.y + e2.bottom.y < o2 ? ["top"] : t2.y > this._map.transform.height - o2 ? ["bottom"] : [], t2.x < i2 / 2 ? r2.push("left") : t2.x > this._map.transform.width - i2 / 2 && r2.push("right"), 0 === r2.length ? "bottom" : r2.join("-");
        }
        _updateClassList() {
          const e2 = [...this._classList];
          e2.push("mapboxgl-popup"), this._anchor && e2.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && e2.push("mapboxgl-popup-track-pointer"), this._container.className = e2.join(" ");
        }
        _update(t2) {
          if (this._map && (this._lngLat || this._trackPointer) && this._content) {
            if (this._container || (this._container = n.create("div", "mapboxgl-popup", this._map.getContainer()), this._tip = n.create("div", "mapboxgl-popup-tip", this._container), this._container.appendChild(this._content)), this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Cr(this._lngLat, this._pos, this._map.transform)), !this._trackPointer || t2) {
              const i2 = this._pos = this._trackPointer && t2 ? t2 : this._map.project(this._lngLat), o2 = function(t3) {
                if (t3 || (t3 = new e.pointGeometry(0, 0)), "number" == typeof t3) {
                  const i3 = Math.round(Math.sqrt(0.5 * Math.pow(t3, 2)));
                  return { center: new e.pointGeometry(0, 0), top: new e.pointGeometry(0, t3), "top-left": new e.pointGeometry(i3, i3), "top-right": new e.pointGeometry(-i3, i3), bottom: new e.pointGeometry(0, -t3), "bottom-left": new e.pointGeometry(i3, -i3), "bottom-right": new e.pointGeometry(-i3, -i3), left: new e.pointGeometry(t3, 0), right: new e.pointGeometry(-t3, 0) };
                }
                if (t3 instanceof e.pointGeometry || Array.isArray(t3)) {
                  const i3 = e.pointGeometry.convert(t3);
                  return { center: i3, top: i3, "top-left": i3, "top-right": i3, bottom: i3, "bottom-left": i3, "bottom-right": i3, left: i3, right: i3 };
                }
                return { center: e.pointGeometry.convert(t3.center || [0, 0]), top: e.pointGeometry.convert(t3.top || [0, 0]), "top-left": e.pointGeometry.convert(t3["top-left"] || [0, 0]), "top-right": e.pointGeometry.convert(t3["top-right"] || [0, 0]), bottom: e.pointGeometry.convert(t3.bottom || [0, 0]), "bottom-left": e.pointGeometry.convert(t3["bottom-left"] || [0, 0]), "bottom-right": e.pointGeometry.convert(t3["bottom-right"] || [0, 0]), left: e.pointGeometry.convert(t3.left || [0, 0]), right: e.pointGeometry.convert(t3.right || [0, 0]) };
              }(this.options.offset), r2 = this._anchor = this._getAnchor(o2), a2 = i2.add(o2[r2]).round();
              this._map._requestDomTask(() => {
                this._container && r2 && n.setTransform(this._container, `${Sr[r2]} translate(${a2.x}px,${a2.y}px)`);
              });
            }
            this._updateClassList();
          }
        }
        _focusFirstElement() {
          if (!this.options.focusAfterOpen || !this._container)
            return;
          const e2 = this._container.querySelector(qr);
          e2 && e2.focus();
        }
        _onClose() {
          this.remove();
        }
        _setOpacity(e2) {
          this._content && (this._content.style.opacity = e2), this._tip && (this._tip.style.opacity = e2);
        }
      }, Marker: Mr, Style: Vt, LngLat: e.LngLat, LngLatBounds: e.LngLatBounds, Point: e.pointGeometry, MercatorCoordinate: e.MercatorCoordinate, FreeCameraOptions: wo, Evented: e.Evented, config: e.config, prewarm: function() {
        ke().acquire(Pe);
      }, clearPrewarmedResources: function() {
        const e2 = Re;
        e2 && (e2.isPreloaded() && 1 === e2.numActive() ? (e2.release(Pe), Re = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, get accessToken() {
        return e.config.ACCESS_TOKEN;
      }, set accessToken(t2) {
        e.config.ACCESS_TOKEN = t2;
      }, get baseApiUrl() {
        return e.config.API_URL;
      }, set baseApiUrl(t2) {
        e.config.API_URL = t2;
      }, get workerCount() {
        return Le.workerCount;
      }, set workerCount(e2) {
        Le.workerCount = e2;
      }, get maxParallelImageRequests() {
        return e.config.MAX_PARALLEL_IMAGE_REQUESTS;
      }, set maxParallelImageRequests(t2) {
        e.config.MAX_PARALLEL_IMAGE_REQUESTS = t2;
      }, clearStorage(t2) {
        e.clearTileCache(t2);
      }, workerUrl: "", workerClass: null, setNow: e.exported.setNow, restoreNow: e.exported.restoreNow };
      return Wr;
    });
    var mapboxgl$1 = mapboxgl2;
    return mapboxgl$1;
  });
})(mapboxGl);
const mapboxgl = mapboxGlExports;
var lib = {};
var flattenNames$1 = {};
var freeGlobal$3 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$3;
var freeGlobal$2 = _freeGlobal;
var freeSelf$1 = typeof self == "object" && self && self.Object === Object && self;
var root$a = freeGlobal$2 || freeSelf$1 || Function("return this")();
var _root = root$a;
var root$9 = _root;
var Symbol$8 = root$9.Symbol;
var _Symbol = Symbol$8;
var Symbol$7 = _Symbol;
var objectProto$u = Object.prototype;
var hasOwnProperty$o = objectProto$u.hasOwnProperty;
var nativeObjectToString$3 = objectProto$u.toString;
var symToStringTag$3 = Symbol$7 ? Symbol$7.toStringTag : void 0;
function getRawTag$2(value) {
  var isOwn = hasOwnProperty$o.call(value, symToStringTag$3), tag = value[symToStringTag$3];
  try {
    value[symToStringTag$3] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$3.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$3] = tag;
    } else {
      delete value[symToStringTag$3];
    }
  }
  return result;
}
var _getRawTag = getRawTag$2;
var objectProto$t = Object.prototype;
var nativeObjectToString$2 = objectProto$t.toString;
function objectToString$2(value) {
  return nativeObjectToString$2.call(value);
}
var _objectToString = objectToString$2;
var Symbol$6 = _Symbol, getRawTag$1 = _getRawTag, objectToString$1 = _objectToString;
var nullTag$1 = "[object Null]", undefinedTag$1 = "[object Undefined]";
var symToStringTag$2 = Symbol$6 ? Symbol$6.toStringTag : void 0;
function baseGetTag$8(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag$1 : nullTag$1;
  }
  return symToStringTag$2 && symToStringTag$2 in Object(value) ? getRawTag$1(value) : objectToString$1(value);
}
var _baseGetTag = baseGetTag$8;
var isArray$d = Array.isArray;
var isArray_1 = isArray$d;
function isObjectLike$a(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$a;
var baseGetTag$7 = _baseGetTag, isArray$c = isArray_1, isObjectLike$9 = isObjectLike_1;
var stringTag$6 = "[object String]";
function isString(value) {
  return typeof value == "string" || !isArray$c(value) && isObjectLike$9(value) && baseGetTag$7(value) == stringTag$6;
}
var isString_1 = isString;
function createBaseFor$2(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var _createBaseFor = createBaseFor$2;
var createBaseFor$1 = _createBaseFor;
var baseFor$3 = createBaseFor$1();
var _baseFor = baseFor$3;
function baseTimes$2(n, iteratee) {
  var index = -1, result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}
var _baseTimes = baseTimes$2;
var baseGetTag$6 = _baseGetTag, isObjectLike$8 = isObjectLike_1;
var argsTag$6 = "[object Arguments]";
function baseIsArguments$2(value) {
  return isObjectLike$8(value) && baseGetTag$6(value) == argsTag$6;
}
var _baseIsArguments = baseIsArguments$2;
var baseIsArguments$1 = _baseIsArguments, isObjectLike$7 = isObjectLike_1;
var objectProto$s = Object.prototype;
var hasOwnProperty$n = objectProto$s.hasOwnProperty;
var propertyIsEnumerable$3 = objectProto$s.propertyIsEnumerable;
var isArguments$4 = baseIsArguments$1(function() {
  return arguments;
}()) ? baseIsArguments$1 : function(value) {
  return isObjectLike$7(value) && hasOwnProperty$n.call(value, "callee") && !propertyIsEnumerable$3.call(value, "callee");
};
var isArguments_1 = isArguments$4;
var isBufferExports = {};
var isBuffer$5 = {
  get exports() {
    return isBufferExports;
  },
  set exports(v) {
    isBufferExports = v;
  }
};
function stubFalse$1() {
  return false;
}
var stubFalse_1 = stubFalse$1;
(function(module2, exports2) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports2 = exports2 && !exports2.nodeType && exports2;
  var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
  var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
  var Buffer2 = moduleExports2 ? root2.Buffer : void 0;
  var nativeIsBuffer2 = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer2 || stubFalse2;
  module2.exports = isBuffer2;
})(isBuffer$5, isBufferExports);
var MAX_SAFE_INTEGER$3 = 9007199254740991;
var reIsUint$1 = /^(?:0|[1-9]\d*)$/;
function isIndex$3(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$3 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint$1.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var _isIndex = isIndex$3;
var MAX_SAFE_INTEGER$2 = 9007199254740991;
function isLength$4(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$2;
}
var isLength_1 = isLength$4;
var baseGetTag$5 = _baseGetTag, isLength$3 = isLength_1, isObjectLike$6 = isObjectLike_1;
var argsTag$5 = "[object Arguments]", arrayTag$4 = "[object Array]", boolTag$5 = "[object Boolean]", dateTag$5 = "[object Date]", errorTag$4 = "[object Error]", funcTag$4 = "[object Function]", mapTag$8 = "[object Map]", numberTag$5 = "[object Number]", objectTag$8 = "[object Object]", regexpTag$5 = "[object RegExp]", setTag$8 = "[object Set]", stringTag$5 = "[object String]", weakMapTag$4 = "[object WeakMap]";
var arrayBufferTag$5 = "[object ArrayBuffer]", dataViewTag$7 = "[object DataView]", float32Tag$3 = "[object Float32Array]", float64Tag$3 = "[object Float64Array]", int8Tag$3 = "[object Int8Array]", int16Tag$3 = "[object Int16Array]", int32Tag$3 = "[object Int32Array]", uint8Tag$3 = "[object Uint8Array]", uint8ClampedTag$3 = "[object Uint8ClampedArray]", uint16Tag$3 = "[object Uint16Array]", uint32Tag$3 = "[object Uint32Array]";
var typedArrayTags$1 = {};
typedArrayTags$1[float32Tag$3] = typedArrayTags$1[float64Tag$3] = typedArrayTags$1[int8Tag$3] = typedArrayTags$1[int16Tag$3] = typedArrayTags$1[int32Tag$3] = typedArrayTags$1[uint8Tag$3] = typedArrayTags$1[uint8ClampedTag$3] = typedArrayTags$1[uint16Tag$3] = typedArrayTags$1[uint32Tag$3] = true;
typedArrayTags$1[argsTag$5] = typedArrayTags$1[arrayTag$4] = typedArrayTags$1[arrayBufferTag$5] = typedArrayTags$1[boolTag$5] = typedArrayTags$1[dataViewTag$7] = typedArrayTags$1[dateTag$5] = typedArrayTags$1[errorTag$4] = typedArrayTags$1[funcTag$4] = typedArrayTags$1[mapTag$8] = typedArrayTags$1[numberTag$5] = typedArrayTags$1[objectTag$8] = typedArrayTags$1[regexpTag$5] = typedArrayTags$1[setTag$8] = typedArrayTags$1[stringTag$5] = typedArrayTags$1[weakMapTag$4] = false;
function baseIsTypedArray$2(value) {
  return isObjectLike$6(value) && isLength$3(value.length) && !!typedArrayTags$1[baseGetTag$5(value)];
}
var _baseIsTypedArray = baseIsTypedArray$2;
function baseUnary$4(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$4;
var _nodeUtilExports = {};
var _nodeUtil = {
  get exports() {
    return _nodeUtilExports;
  },
  set exports(v) {
    _nodeUtilExports = v;
  }
};
(function(module2, exports2) {
  var freeGlobal2 = _freeGlobal;
  var freeExports2 = exports2 && !exports2.nodeType && exports2;
  var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
  var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
  var freeProcess2 = moduleExports2 && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
    } catch (e) {
    }
  }();
  module2.exports = nodeUtil2;
})(_nodeUtil, _nodeUtilExports);
var baseIsTypedArray$1 = _baseIsTypedArray, baseUnary$3 = _baseUnary, nodeUtil$4 = _nodeUtilExports;
var nodeIsTypedArray$1 = nodeUtil$4 && nodeUtil$4.isTypedArray;
var isTypedArray$4 = nodeIsTypedArray$1 ? baseUnary$3(nodeIsTypedArray$1) : baseIsTypedArray$1;
var isTypedArray_1 = isTypedArray$4;
var baseTimes$1 = _baseTimes, isArguments$3 = isArguments_1, isArray$b = isArray_1, isBuffer$4 = isBufferExports, isIndex$2 = _isIndex, isTypedArray$3 = isTypedArray_1;
var objectProto$r = Object.prototype;
var hasOwnProperty$m = objectProto$r.hasOwnProperty;
function arrayLikeKeys$3(value, inherited) {
  var isArr = isArray$b(value), isArg = !isArr && isArguments$3(value), isBuff = !isArr && !isArg && isBuffer$4(value), isType = !isArr && !isArg && !isBuff && isTypedArray$3(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes$1(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$m.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex$2(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$3;
var objectProto$q = Object.prototype;
function isPrototype$4(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$q;
  return value === proto;
}
var _isPrototype = isPrototype$4;
function overArg$3(func, transform2) {
  return function(arg) {
    return func(transform2(arg));
  };
}
var _overArg = overArg$3;
var overArg$2 = _overArg;
var nativeKeys$3 = overArg$2(Object.keys, Object);
var _nativeKeys = nativeKeys$3;
var isPrototype$3 = _isPrototype, nativeKeys$2 = _nativeKeys;
var objectProto$p = Object.prototype;
var hasOwnProperty$l = objectProto$p.hasOwnProperty;
function baseKeys$2(object) {
  if (!isPrototype$3(object)) {
    return nativeKeys$2(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$l.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys$2;
function isObject$7(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_1 = isObject$7;
var baseGetTag$4 = _baseGetTag, isObject$6 = isObject_1;
var asyncTag$1 = "[object AsyncFunction]", funcTag$3 = "[object Function]", genTag$2 = "[object GeneratorFunction]", proxyTag$1 = "[object Proxy]";
function isFunction$3(value) {
  if (!isObject$6(value)) {
    return false;
  }
  var tag = baseGetTag$4(value);
  return tag == funcTag$3 || tag == genTag$2 || tag == asyncTag$1 || tag == proxyTag$1;
}
var isFunction_1 = isFunction$3;
var isFunction$2 = isFunction_1, isLength$2 = isLength_1;
function isArrayLike$5(value) {
  return value != null && isLength$2(value.length) && !isFunction$2(value);
}
var isArrayLike_1 = isArrayLike$5;
var arrayLikeKeys$2 = _arrayLikeKeys, baseKeys$1 = _baseKeys, isArrayLike$4 = isArrayLike_1;
function keys$6(object) {
  return isArrayLike$4(object) ? arrayLikeKeys$2(object) : baseKeys$1(object);
}
var keys_1 = keys$6;
var baseFor$2 = _baseFor, keys$5 = keys_1;
function baseForOwn$3(object, iteratee) {
  return object && baseFor$2(object, iteratee, keys$5);
}
var _baseForOwn = baseForOwn$3;
function identity$3(value) {
  return value;
}
var identity_1 = identity$3;
var identity$2 = identity_1;
function castFunction$2(value) {
  return typeof value == "function" ? value : identity$2;
}
var _castFunction = castFunction$2;
var baseForOwn$2 = _baseForOwn, castFunction$1 = _castFunction;
function forOwn(object, iteratee) {
  return object && baseForOwn$2(object, castFunction$1(iteratee));
}
var forOwn_1 = forOwn;
var overArg$1 = _overArg;
var getPrototype$5 = overArg$1(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$5;
var baseGetTag$3 = _baseGetTag, getPrototype$4 = _getPrototype, isObjectLike$5 = isObjectLike_1;
var objectTag$7 = "[object Object]";
var funcProto$5 = Function.prototype, objectProto$o = Object.prototype;
var funcToString$5 = funcProto$5.toString;
var hasOwnProperty$k = objectProto$o.hasOwnProperty;
var objectCtorString$1 = funcToString$5.call(Object);
function isPlainObject$1(value) {
  if (!isObjectLike$5(value) || baseGetTag$3(value) != objectTag$7) {
    return false;
  }
  var proto = getPrototype$4(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$k.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString$5.call(Ctor) == objectCtorString$1;
}
var isPlainObject_1 = isPlainObject$1;
function arrayMap$3(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
var _arrayMap = arrayMap$3;
function listCacheClear$2() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$2;
function eq$4(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$4;
var eq$3 = eq_1;
function assocIndexOf$5(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$3(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$5;
var assocIndexOf$4 = _assocIndexOf;
var arrayProto$1 = Array.prototype;
var splice$1 = arrayProto$1.splice;
function listCacheDelete$2(key) {
  var data = this.__data__, index = assocIndexOf$4(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice$1.call(data, index, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$2;
var assocIndexOf$3 = _assocIndexOf;
function listCacheGet$2(key) {
  var data = this.__data__, index = assocIndexOf$3(data, key);
  return index < 0 ? void 0 : data[index][1];
}
var _listCacheGet = listCacheGet$2;
var assocIndexOf$2 = _assocIndexOf;
function listCacheHas$2(key) {
  return assocIndexOf$2(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$2;
var assocIndexOf$1 = _assocIndexOf;
function listCacheSet$2(key, value) {
  var data = this.__data__, index = assocIndexOf$1(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$2;
var listCacheClear$1 = _listCacheClear, listCacheDelete$1 = _listCacheDelete, listCacheGet$1 = _listCacheGet, listCacheHas$1 = _listCacheHas, listCacheSet$1 = _listCacheSet;
function ListCache$5(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache$5.prototype.clear = listCacheClear$1;
ListCache$5.prototype["delete"] = listCacheDelete$1;
ListCache$5.prototype.get = listCacheGet$1;
ListCache$5.prototype.has = listCacheHas$1;
ListCache$5.prototype.set = listCacheSet$1;
var _ListCache = ListCache$5;
var ListCache$4 = _ListCache;
function stackClear$2() {
  this.__data__ = new ListCache$4();
  this.size = 0;
}
var _stackClear = stackClear$2;
function stackDelete$2(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete$2;
function stackGet$2(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$2;
function stackHas$2(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$2;
var root$8 = _root;
var coreJsData$3 = root$8["__core-js_shared__"];
var _coreJsData = coreJsData$3;
var coreJsData$2 = _coreJsData;
var maskSrcKey$1 = function() {
  var uid = /[^.]+$/.exec(coreJsData$2 && coreJsData$2.keys && coreJsData$2.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$2(func) {
  return !!maskSrcKey$1 && maskSrcKey$1 in func;
}
var _isMasked = isMasked$2;
var funcProto$4 = Function.prototype;
var funcToString$4 = funcProto$4.toString;
function toSource$3(func) {
  if (func != null) {
    try {
      return funcToString$4.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var _toSource = toSource$3;
var isFunction$1 = isFunction_1, isMasked$1 = _isMasked, isObject$5 = isObject_1, toSource$2 = _toSource;
var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;
var funcProto$3 = Function.prototype, objectProto$n = Object.prototype;
var funcToString$3 = funcProto$3.toString;
var hasOwnProperty$j = objectProto$n.hasOwnProperty;
var reIsNative$1 = RegExp(
  "^" + funcToString$3.call(hasOwnProperty$j).replace(reRegExpChar$1, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$2(value) {
  if (!isObject$5(value) || isMasked$1(value)) {
    return false;
  }
  var pattern = isFunction$1(value) ? reIsNative$1 : reIsHostCtor$1;
  return pattern.test(toSource$2(value));
}
var _baseIsNative = baseIsNative$2;
function getValue$2(object, key) {
  return object == null ? void 0 : object[key];
}
var _getValue = getValue$2;
var baseIsNative$1 = _baseIsNative, getValue$1 = _getValue;
function getNative$8(object, key) {
  var value = getValue$1(object, key);
  return baseIsNative$1(value) ? value : void 0;
}
var _getNative = getNative$8;
var getNative$7 = _getNative, root$7 = _root;
var Map$5 = getNative$7(root$7, "Map");
var _Map = Map$5;
var getNative$6 = _getNative;
var nativeCreate$6 = getNative$6(Object, "create");
var _nativeCreate = nativeCreate$6;
var nativeCreate$5 = _nativeCreate;
function hashClear$2() {
  this.__data__ = nativeCreate$5 ? nativeCreate$5(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$2;
function hashDelete$2(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$2;
var nativeCreate$4 = _nativeCreate;
var HASH_UNDEFINED$5 = "__lodash_hash_undefined__";
var objectProto$m = Object.prototype;
var hasOwnProperty$i = objectProto$m.hasOwnProperty;
function hashGet$2(key) {
  var data = this.__data__;
  if (nativeCreate$4) {
    var result = data[key];
    return result === HASH_UNDEFINED$5 ? void 0 : result;
  }
  return hasOwnProperty$i.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$2;
var nativeCreate$3 = _nativeCreate;
var objectProto$l = Object.prototype;
var hasOwnProperty$h = objectProto$l.hasOwnProperty;
function hashHas$2(key) {
  var data = this.__data__;
  return nativeCreate$3 ? data[key] !== void 0 : hasOwnProperty$h.call(data, key);
}
var _hashHas = hashHas$2;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$4 = "__lodash_hash_undefined__";
function hashSet$2(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate$2 && value === void 0 ? HASH_UNDEFINED$4 : value;
  return this;
}
var _hashSet = hashSet$2;
var hashClear$1 = _hashClear, hashDelete$1 = _hashDelete, hashGet$1 = _hashGet, hashHas$1 = _hashHas, hashSet$1 = _hashSet;
function Hash$2(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash$2.prototype.clear = hashClear$1;
Hash$2.prototype["delete"] = hashDelete$1;
Hash$2.prototype.get = hashGet$1;
Hash$2.prototype.has = hashHas$1;
Hash$2.prototype.set = hashSet$1;
var _Hash = Hash$2;
var Hash$1 = _Hash, ListCache$3 = _ListCache, Map$4 = _Map;
function mapCacheClear$2() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash$1(),
    "map": new (Map$4 || ListCache$3)(),
    "string": new Hash$1()
  };
}
var _mapCacheClear = mapCacheClear$2;
function isKeyable$2(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$2;
var isKeyable$1 = _isKeyable;
function getMapData$5(map2, key) {
  var data = map2.__data__;
  return isKeyable$1(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$5;
var getMapData$4 = _getMapData;
function mapCacheDelete$2(key) {
  var result = getMapData$4(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$2;
var getMapData$3 = _getMapData;
function mapCacheGet$2(key) {
  return getMapData$3(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$2;
var getMapData$2 = _getMapData;
function mapCacheHas$2(key) {
  return getMapData$2(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$2;
var getMapData$1 = _getMapData;
function mapCacheSet$2(key, value) {
  var data = getMapData$1(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$2;
var mapCacheClear$1 = _mapCacheClear, mapCacheDelete$1 = _mapCacheDelete, mapCacheGet$1 = _mapCacheGet, mapCacheHas$1 = _mapCacheHas, mapCacheSet$1 = _mapCacheSet;
function MapCache$4(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache$4.prototype.clear = mapCacheClear$1;
MapCache$4.prototype["delete"] = mapCacheDelete$1;
MapCache$4.prototype.get = mapCacheGet$1;
MapCache$4.prototype.has = mapCacheHas$1;
MapCache$4.prototype.set = mapCacheSet$1;
var _MapCache = MapCache$4;
var ListCache$2 = _ListCache, Map$3 = _Map, MapCache$3 = _MapCache;
var LARGE_ARRAY_SIZE$1 = 200;
function stackSet$2(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$2) {
    var pairs = data.__data__;
    if (!Map$3 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$3(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$2;
var ListCache$1 = _ListCache, stackClear$1 = _stackClear, stackDelete$1 = _stackDelete, stackGet$1 = _stackGet, stackHas$1 = _stackHas, stackSet$1 = _stackSet;
function Stack$4(entries) {
  var data = this.__data__ = new ListCache$1(entries);
  this.size = data.size;
}
Stack$4.prototype.clear = stackClear$1;
Stack$4.prototype["delete"] = stackDelete$1;
Stack$4.prototype.get = stackGet$1;
Stack$4.prototype.has = stackHas$1;
Stack$4.prototype.set = stackSet$1;
var _Stack = Stack$4;
var HASH_UNDEFINED$3 = "__lodash_hash_undefined__";
function setCacheAdd$2(value) {
  this.__data__.set(value, HASH_UNDEFINED$3);
  return this;
}
var _setCacheAdd = setCacheAdd$2;
function setCacheHas$2(value) {
  return this.__data__.has(value);
}
var _setCacheHas = setCacheHas$2;
var MapCache$2 = _MapCache, setCacheAdd$1 = _setCacheAdd, setCacheHas$1 = _setCacheHas;
function SetCache$2(values) {
  var index = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache$2();
  while (++index < length) {
    this.add(values[index]);
  }
}
SetCache$2.prototype.add = SetCache$2.prototype.push = setCacheAdd$1;
SetCache$2.prototype.has = setCacheHas$1;
var _SetCache = SetCache$2;
function arraySome$2(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome$2;
function cacheHas$2(cache, key) {
  return cache.has(key);
}
var _cacheHas = cacheHas$2;
var SetCache$1 = _SetCache, arraySome$1 = _arraySome, cacheHas$1 = _cacheHas;
var COMPARE_PARTIAL_FLAG$b = 1, COMPARE_UNORDERED_FLAG$7 = 2;
function equalArrays$3(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$b, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$7 ? new SetCache$1() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index < arrLength) {
    var arrValue = array[index], othValue = other[index];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome$1(other, function(othValue2, othIndex) {
        if (!cacheHas$1(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
var _equalArrays = equalArrays$3;
var root$6 = _root;
var Uint8Array$5 = root$6.Uint8Array;
var _Uint8Array = Uint8Array$5;
function mapToArray$2(map2) {
  var index = -1, result = Array(map2.size);
  map2.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}
var _mapToArray = mapToArray$2;
function setToArray$2(set) {
  var index = -1, result = Array(set.size);
  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}
var _setToArray = setToArray$2;
var Symbol$5 = _Symbol, Uint8Array$4 = _Uint8Array, eq$2 = eq_1, equalArrays$2 = _equalArrays, mapToArray$1 = _mapToArray, setToArray$1 = _setToArray;
var COMPARE_PARTIAL_FLAG$a = 1, COMPARE_UNORDERED_FLAG$6 = 2;
var boolTag$4 = "[object Boolean]", dateTag$4 = "[object Date]", errorTag$3 = "[object Error]", mapTag$7 = "[object Map]", numberTag$4 = "[object Number]", regexpTag$4 = "[object RegExp]", setTag$7 = "[object Set]", stringTag$4 = "[object String]", symbolTag$5 = "[object Symbol]";
var arrayBufferTag$4 = "[object ArrayBuffer]", dataViewTag$6 = "[object DataView]";
var symbolProto$4 = Symbol$5 ? Symbol$5.prototype : void 0, symbolValueOf$2 = symbolProto$4 ? symbolProto$4.valueOf : void 0;
function equalByTag$2(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$6:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag$4:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$4(object), new Uint8Array$4(other))) {
        return false;
      }
      return true;
    case boolTag$4:
    case dateTag$4:
    case numberTag$4:
      return eq$2(+object, +other);
    case errorTag$3:
      return object.name == other.name && object.message == other.message;
    case regexpTag$4:
    case stringTag$4:
      return object == other + "";
    case mapTag$7:
      var convert = mapToArray$1;
    case setTag$7:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$a;
      convert || (convert = setToArray$1);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$6;
      stack.set(object, other);
      var result = equalArrays$2(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag$5:
      if (symbolValueOf$2) {
        return symbolValueOf$2.call(object) == symbolValueOf$2.call(other);
      }
  }
  return false;
}
var _equalByTag = equalByTag$2;
function arrayPush$3(array, values) {
  var index = -1, length = values.length, offset = array.length;
  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}
var _arrayPush = arrayPush$3;
var arrayPush$2 = _arrayPush, isArray$a = isArray_1;
function baseGetAllKeys$3(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$a(object) ? result : arrayPush$2(result, symbolsFunc(object));
}
var _baseGetAllKeys = baseGetAllKeys$3;
function arrayFilter$2(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$2;
function stubArray$3() {
  return [];
}
var stubArray_1 = stubArray$3;
var arrayFilter$1 = _arrayFilter, stubArray$2 = stubArray_1;
var objectProto$k = Object.prototype;
var propertyIsEnumerable$2 = objectProto$k.propertyIsEnumerable;
var nativeGetSymbols$2 = Object.getOwnPropertySymbols;
var getSymbols$5 = !nativeGetSymbols$2 ? stubArray$2 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter$1(nativeGetSymbols$2(object), function(symbol) {
    return propertyIsEnumerable$2.call(object, symbol);
  });
};
var _getSymbols = getSymbols$5;
var baseGetAllKeys$2 = _baseGetAllKeys, getSymbols$4 = _getSymbols, keys$4 = keys_1;
function getAllKeys$3(object) {
  return baseGetAllKeys$2(object, keys$4, getSymbols$4);
}
var _getAllKeys = getAllKeys$3;
var getAllKeys$2 = _getAllKeys;
var COMPARE_PARTIAL_FLAG$9 = 1;
var objectProto$j = Object.prototype;
var hasOwnProperty$g = objectProto$j.hasOwnProperty;
function equalObjects$2(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$9, objProps = getAllKeys$2(object), objLength = objProps.length, othProps = getAllKeys$2(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty$g.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var _equalObjects = equalObjects$2;
var getNative$5 = _getNative, root$5 = _root;
var DataView$3 = getNative$5(root$5, "DataView");
var _DataView = DataView$3;
var getNative$4 = _getNative, root$4 = _root;
var Promise$4 = getNative$4(root$4, "Promise");
var _Promise = Promise$4;
var getNative$3 = _getNative, root$3 = _root;
var Set$4 = getNative$3(root$3, "Set");
var _Set = Set$4;
var getNative$2 = _getNative, root$2 = _root;
var WeakMap$3 = getNative$2(root$2, "WeakMap");
var _WeakMap = WeakMap$3;
var DataView$2 = _DataView, Map$2 = _Map, Promise$3 = _Promise, Set$3 = _Set, WeakMap$2 = _WeakMap, baseGetTag$2 = _baseGetTag, toSource$1 = _toSource;
var mapTag$6 = "[object Map]", objectTag$6 = "[object Object]", promiseTag$1 = "[object Promise]", setTag$6 = "[object Set]", weakMapTag$3 = "[object WeakMap]";
var dataViewTag$5 = "[object DataView]";
var dataViewCtorString$1 = toSource$1(DataView$2), mapCtorString$1 = toSource$1(Map$2), promiseCtorString$1 = toSource$1(Promise$3), setCtorString$1 = toSource$1(Set$3), weakMapCtorString$1 = toSource$1(WeakMap$2);
var getTag$6 = baseGetTag$2;
if (DataView$2 && getTag$6(new DataView$2(new ArrayBuffer(1))) != dataViewTag$5 || Map$2 && getTag$6(new Map$2()) != mapTag$6 || Promise$3 && getTag$6(Promise$3.resolve()) != promiseTag$1 || Set$3 && getTag$6(new Set$3()) != setTag$6 || WeakMap$2 && getTag$6(new WeakMap$2()) != weakMapTag$3) {
  getTag$6 = function(value) {
    var result = baseGetTag$2(value), Ctor = result == objectTag$6 ? value.constructor : void 0, ctorString = Ctor ? toSource$1(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString$1:
          return dataViewTag$5;
        case mapCtorString$1:
          return mapTag$6;
        case promiseCtorString$1:
          return promiseTag$1;
        case setCtorString$1:
          return setTag$6;
        case weakMapCtorString$1:
          return weakMapTag$3;
      }
    }
    return result;
  };
}
var _getTag = getTag$6;
var Stack$3 = _Stack, equalArrays$1 = _equalArrays, equalByTag$1 = _equalByTag, equalObjects$1 = _equalObjects, getTag$5 = _getTag, isArray$9 = isArray_1, isBuffer$3 = isBufferExports, isTypedArray$2 = isTypedArray_1;
var COMPARE_PARTIAL_FLAG$8 = 1;
var argsTag$4 = "[object Arguments]", arrayTag$3 = "[object Array]", objectTag$5 = "[object Object]";
var objectProto$i = Object.prototype;
var hasOwnProperty$f = objectProto$i.hasOwnProperty;
function baseIsEqualDeep$2(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$9(object), othIsArr = isArray$9(other), objTag = objIsArr ? arrayTag$3 : getTag$5(object), othTag = othIsArr ? arrayTag$3 : getTag$5(other);
  objTag = objTag == argsTag$4 ? objectTag$5 : objTag;
  othTag = othTag == argsTag$4 ? objectTag$5 : othTag;
  var objIsObj = objTag == objectTag$5, othIsObj = othTag == objectTag$5, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$3(object)) {
    if (!isBuffer$3(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack$3());
    return objIsArr || isTypedArray$2(object) ? equalArrays$1(object, other, bitmask, customizer, equalFunc, stack) : equalByTag$1(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$8)) {
    var objIsWrapped = objIsObj && hasOwnProperty$f.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$f.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack$3());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack$3());
  return equalObjects$1(object, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep = baseIsEqualDeep$2;
var baseIsEqualDeep$1 = _baseIsEqualDeep, isObjectLike$4 = isObjectLike_1;
function baseIsEqual$3(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike$4(value) && !isObjectLike$4(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep$1(value, other, bitmask, customizer, baseIsEqual$3, stack);
}
var _baseIsEqual = baseIsEqual$3;
var Stack$2 = _Stack, baseIsEqual$2 = _baseIsEqual;
var COMPARE_PARTIAL_FLAG$7 = 1, COMPARE_UNORDERED_FLAG$5 = 2;
function baseIsMatch$2(object, source, matchData, customizer) {
  var index = matchData.length, length = index, noCustomizer = !customizer;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack$2();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual$2(srcValue, objValue, COMPARE_PARTIAL_FLAG$7 | COMPARE_UNORDERED_FLAG$5, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
var _baseIsMatch = baseIsMatch$2;
var isObject$4 = isObject_1;
function isStrictComparable$3(value) {
  return value === value && !isObject$4(value);
}
var _isStrictComparable = isStrictComparable$3;
var isStrictComparable$2 = _isStrictComparable, keys$3 = keys_1;
function getMatchData$2(object) {
  var result = keys$3(object), length = result.length;
  while (length--) {
    var key = result[length], value = object[key];
    result[length] = [key, value, isStrictComparable$2(value)];
  }
  return result;
}
var _getMatchData = getMatchData$2;
function matchesStrictComparable$3(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
var _matchesStrictComparable = matchesStrictComparable$3;
var baseIsMatch$1 = _baseIsMatch, getMatchData$1 = _getMatchData, matchesStrictComparable$2 = _matchesStrictComparable;
function baseMatches$2(source) {
  var matchData = getMatchData$1(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable$2(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch$1(object, source, matchData);
  };
}
var _baseMatches = baseMatches$2;
var baseGetTag$1 = _baseGetTag, isObjectLike$3 = isObjectLike_1;
var symbolTag$4 = "[object Symbol]";
function isSymbol$4(value) {
  return typeof value == "symbol" || isObjectLike$3(value) && baseGetTag$1(value) == symbolTag$4;
}
var isSymbol_1 = isSymbol$4;
var isArray$8 = isArray_1, isSymbol$3 = isSymbol_1;
var reIsDeepProp$1 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp$1 = /^\w*$/;
function isKey$4(value, object) {
  if (isArray$8(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$3(value)) {
    return true;
  }
  return reIsPlainProp$1.test(value) || !reIsDeepProp$1.test(value) || object != null && value in Object(object);
}
var _isKey = isKey$4;
var MapCache$1 = _MapCache;
var FUNC_ERROR_TEXT$3 = "Expected a function";
function memoize$2(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$3);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize$2.Cache || MapCache$1)();
  return memoized;
}
memoize$2.Cache = MapCache$1;
var memoize_1 = memoize$2;
var memoize$1 = memoize_1;
var MAX_MEMOIZE_SIZE$1 = 500;
function memoizeCapped$2(func) {
  var result = memoize$1(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE$1) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped$2;
var memoizeCapped$1 = _memoizeCapped;
var rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar$1 = /\\(\\)?/g;
var stringToPath$3 = memoizeCapped$1(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName$1, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar$1, "$1") : number || match);
  });
  return result;
});
var _stringToPath = stringToPath$3;
var Symbol$4 = _Symbol, arrayMap$2 = _arrayMap, isArray$7 = isArray_1, isSymbol$2 = isSymbol_1;
var INFINITY$3 = 1 / 0;
var symbolProto$3 = Symbol$4 ? Symbol$4.prototype : void 0, symbolToString$1 = symbolProto$3 ? symbolProto$3.toString : void 0;
function baseToString$2(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$7(value)) {
    return arrayMap$2(value, baseToString$2) + "";
  }
  if (isSymbol$2(value)) {
    return symbolToString$1 ? symbolToString$1.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$3 ? "-0" : result;
}
var _baseToString = baseToString$2;
var baseToString$1 = _baseToString;
function toString$2(value) {
  return value == null ? "" : baseToString$1(value);
}
var toString_1 = toString$2;
var isArray$6 = isArray_1, isKey$3 = _isKey, stringToPath$2 = _stringToPath, toString$1 = toString_1;
function castPath$3(value, object) {
  if (isArray$6(value)) {
    return value;
  }
  return isKey$3(value, object) ? [value] : stringToPath$2(toString$1(value));
}
var _castPath = castPath$3;
var isSymbol$1 = isSymbol_1;
var INFINITY$2 = 1 / 0;
function toKey$5(value) {
  if (typeof value == "string" || isSymbol$1(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$2 ? "-0" : result;
}
var _toKey = toKey$5;
var castPath$2 = _castPath, toKey$4 = _toKey;
function baseGet$3(object, path) {
  path = castPath$2(path, object);
  var index = 0, length = path.length;
  while (object != null && index < length) {
    object = object[toKey$4(path[index++])];
  }
  return index && index == length ? object : void 0;
}
var _baseGet = baseGet$3;
var baseGet$2 = _baseGet;
function get$3(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet$2(object, path);
  return result === void 0 ? defaultValue : result;
}
var get_1 = get$3;
function baseHasIn$2(object, key) {
  return object != null && key in Object(object);
}
var _baseHasIn = baseHasIn$2;
var castPath$1 = _castPath, isArguments$2 = isArguments_1, isArray$5 = isArray_1, isIndex$1 = _isIndex, isLength$1 = isLength_1, toKey$3 = _toKey;
function hasPath$2(object, path, hasFunc) {
  path = castPath$1(path, object);
  var index = -1, length = path.length, result = false;
  while (++index < length) {
    var key = toKey$3(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength$1(length) && isIndex$1(key, length) && (isArray$5(object) || isArguments$2(object));
}
var _hasPath = hasPath$2;
var baseHasIn$1 = _baseHasIn, hasPath$1 = _hasPath;
function hasIn$2(object, path) {
  return object != null && hasPath$1(object, path, baseHasIn$1);
}
var hasIn_1 = hasIn$2;
var baseIsEqual$1 = _baseIsEqual, get$2 = get_1, hasIn$1 = hasIn_1, isKey$2 = _isKey, isStrictComparable$1 = _isStrictComparable, matchesStrictComparable$1 = _matchesStrictComparable, toKey$2 = _toKey;
var COMPARE_PARTIAL_FLAG$6 = 1, COMPARE_UNORDERED_FLAG$4 = 2;
function baseMatchesProperty$2(path, srcValue) {
  if (isKey$2(path) && isStrictComparable$1(srcValue)) {
    return matchesStrictComparable$1(toKey$2(path), srcValue);
  }
  return function(object) {
    var objValue = get$2(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn$1(object, path) : baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG$6 | COMPARE_UNORDERED_FLAG$4);
  };
}
var _baseMatchesProperty = baseMatchesProperty$2;
function baseProperty$2(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
var _baseProperty = baseProperty$2;
var baseGet$1 = _baseGet;
function basePropertyDeep$2(path) {
  return function(object) {
    return baseGet$1(object, path);
  };
}
var _basePropertyDeep = basePropertyDeep$2;
var baseProperty$1 = _baseProperty, basePropertyDeep$1 = _basePropertyDeep, isKey$1 = _isKey, toKey$1 = _toKey;
function property$2(path) {
  return isKey$1(path) ? baseProperty$1(toKey$1(path)) : basePropertyDeep$1(path);
}
var property_1 = property$2;
var baseMatches$1 = _baseMatches, baseMatchesProperty$1 = _baseMatchesProperty, identity$1 = identity_1, isArray$4 = isArray_1, property$1 = property_1;
function baseIteratee$2(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity$1;
  }
  if (typeof value == "object") {
    return isArray$4(value) ? baseMatchesProperty$1(value[0], value[1]) : baseMatches$1(value);
  }
  return property$1(value);
}
var _baseIteratee = baseIteratee$2;
var isArrayLike$3 = isArrayLike_1;
function createBaseEach$2(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike$3(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index-- : ++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var _createBaseEach = createBaseEach$2;
var baseForOwn$1 = _baseForOwn, createBaseEach$1 = _createBaseEach;
var baseEach$3 = createBaseEach$1(baseForOwn$1);
var _baseEach = baseEach$3;
var baseEach$2 = _baseEach, isArrayLike$2 = isArrayLike_1;
function baseMap$2(collection, iteratee) {
  var index = -1, result = isArrayLike$2(collection) ? Array(collection.length) : [];
  baseEach$2(collection, function(value, key, collection2) {
    result[++index] = iteratee(value, key, collection2);
  });
  return result;
}
var _baseMap = baseMap$2;
var arrayMap$1 = _arrayMap, baseIteratee$1 = _baseIteratee, baseMap$1 = _baseMap, isArray$3 = isArray_1;
function map$1(collection, iteratee) {
  var func = isArray$3(collection) ? arrayMap$1 : baseMap$1;
  return func(collection, baseIteratee$1(iteratee));
}
var map_1 = map$1;
Object.defineProperty(flattenNames$1, "__esModule", {
  value: true
});
flattenNames$1.flattenNames = void 0;
var _isString2 = isString_1;
var _isString3 = _interopRequireDefault$7(_isString2);
var _forOwn2$2 = forOwn_1;
var _forOwn3$2 = _interopRequireDefault$7(_forOwn2$2);
var _isPlainObject2 = isPlainObject_1;
var _isPlainObject3 = _interopRequireDefault$7(_isPlainObject2);
var _map2 = map_1;
var _map3 = _interopRequireDefault$7(_map2);
function _interopRequireDefault$7(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var flattenNames = flattenNames$1.flattenNames = function flattenNames2() {
  var things = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var names = [];
  (0, _map3.default)(things, function(thing) {
    if (Array.isArray(thing)) {
      flattenNames2(thing).map(function(name) {
        return names.push(name);
      });
    } else if ((0, _isPlainObject3.default)(thing)) {
      (0, _forOwn3$2.default)(thing, function(value, key) {
        value === true && names.push(key);
        names.push(key + "-" + value);
      });
    } else if ((0, _isString3.default)(thing)) {
      names.push(thing);
    }
  });
  return names;
};
flattenNames$1.default = flattenNames;
var mergeClasses$1 = {};
function arrayEach$2(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}
var _arrayEach = arrayEach$2;
var getNative$1 = _getNative;
var defineProperty$3 = function() {
  try {
    var func = getNative$1(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var _defineProperty$1 = defineProperty$3;
var defineProperty$2 = _defineProperty$1;
function baseAssignValue$3(object, key, value) {
  if (key == "__proto__" && defineProperty$2) {
    defineProperty$2(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var _baseAssignValue = baseAssignValue$3;
var baseAssignValue$2 = _baseAssignValue, eq$1 = eq_1;
var objectProto$h = Object.prototype;
var hasOwnProperty$e = objectProto$h.hasOwnProperty;
function assignValue$3(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$e.call(object, key) && eq$1(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue$2(object, key, value);
  }
}
var _assignValue = assignValue$3;
var assignValue$2 = _assignValue, baseAssignValue$1 = _baseAssignValue;
function copyObject$5(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1, length = props.length;
  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue$1(object, key, newValue);
    } else {
      assignValue$2(object, key, newValue);
    }
  }
  return object;
}
var _copyObject = copyObject$5;
var copyObject$4 = _copyObject, keys$2 = keys_1;
function baseAssign$1(object, source) {
  return object && copyObject$4(source, keys$2(source), object);
}
var _baseAssign = baseAssign$1;
function nativeKeysIn$2(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var _nativeKeysIn = nativeKeysIn$2;
var isObject$3 = isObject_1, isPrototype$2 = _isPrototype, nativeKeysIn$1 = _nativeKeysIn;
var objectProto$g = Object.prototype;
var hasOwnProperty$d = objectProto$g.hasOwnProperty;
function baseKeysIn$2(object) {
  if (!isObject$3(object)) {
    return nativeKeysIn$1(object);
  }
  var isProto = isPrototype$2(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$d.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var _baseKeysIn = baseKeysIn$2;
var arrayLikeKeys$1 = _arrayLikeKeys, baseKeysIn$1 = _baseKeysIn, isArrayLike$1 = isArrayLike_1;
function keysIn$4(object) {
  return isArrayLike$1(object) ? arrayLikeKeys$1(object, true) : baseKeysIn$1(object);
}
var keysIn_1 = keysIn$4;
var copyObject$3 = _copyObject, keysIn$3 = keysIn_1;
function baseAssignIn$1(object, source) {
  return object && copyObject$3(source, keysIn$3(source), object);
}
var _baseAssignIn = baseAssignIn$1;
var _cloneBufferExports = {};
var _cloneBuffer = {
  get exports() {
    return _cloneBufferExports;
  },
  set exports(v) {
    _cloneBufferExports = v;
  }
};
(function(module2, exports2) {
  var root2 = _root;
  var freeExports2 = exports2 && !exports2.nodeType && exports2;
  var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
  var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
  var Buffer2 = moduleExports2 ? root2.Buffer : void 0, allocUnsafe2 = Buffer2 ? Buffer2.allocUnsafe : void 0;
  function cloneBuffer2(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe2 ? allocUnsafe2(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  module2.exports = cloneBuffer2;
})(_cloneBuffer, _cloneBufferExports);
function copyArray$2(source, array) {
  var index = -1, length = source.length;
  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}
var _copyArray = copyArray$2;
var copyObject$2 = _copyObject, getSymbols$3 = _getSymbols;
function copySymbols$1(source, object) {
  return copyObject$2(source, getSymbols$3(source), object);
}
var _copySymbols = copySymbols$1;
var arrayPush$1 = _arrayPush, getPrototype$3 = _getPrototype, getSymbols$2 = _getSymbols, stubArray$1 = stubArray_1;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbolsIn$2 = !nativeGetSymbols$1 ? stubArray$1 : function(object) {
  var result = [];
  while (object) {
    arrayPush$1(result, getSymbols$2(object));
    object = getPrototype$3(object);
  }
  return result;
};
var _getSymbolsIn = getSymbolsIn$2;
var copyObject$1 = _copyObject, getSymbolsIn$1 = _getSymbolsIn;
function copySymbolsIn$1(source, object) {
  return copyObject$1(source, getSymbolsIn$1(source), object);
}
var _copySymbolsIn = copySymbolsIn$1;
var baseGetAllKeys$1 = _baseGetAllKeys, getSymbolsIn = _getSymbolsIn, keysIn$2 = keysIn_1;
function getAllKeysIn$1(object) {
  return baseGetAllKeys$1(object, keysIn$2, getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn$1;
var objectProto$f = Object.prototype;
var hasOwnProperty$c = objectProto$f.hasOwnProperty;
function initCloneArray$1(array) {
  var length = array.length, result = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty$c.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var _initCloneArray = initCloneArray$1;
var Uint8Array$3 = _Uint8Array;
function cloneArrayBuffer$4(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$3(result).set(new Uint8Array$3(arrayBuffer));
  return result;
}
var _cloneArrayBuffer = cloneArrayBuffer$4;
var cloneArrayBuffer$3 = _cloneArrayBuffer;
function cloneDataView$1(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$3(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView = cloneDataView$1;
var reFlags = /\w*$/;
function cloneRegExp$1(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var _cloneRegExp = cloneRegExp$1;
var Symbol$3 = _Symbol;
var symbolProto$2 = Symbol$3 ? Symbol$3.prototype : void 0, symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : void 0;
function cloneSymbol$1(symbol) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}
var _cloneSymbol = cloneSymbol$1;
var cloneArrayBuffer$2 = _cloneArrayBuffer;
function cloneTypedArray$2(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer$2(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray$2;
var cloneArrayBuffer$1 = _cloneArrayBuffer, cloneDataView = _cloneDataView, cloneRegExp = _cloneRegExp, cloneSymbol = _cloneSymbol, cloneTypedArray$1 = _cloneTypedArray;
var boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", symbolTag$3 = "[object Symbol]";
var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
function initCloneByTag$1(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$3:
      return cloneArrayBuffer$1(object);
    case boolTag$3:
    case dateTag$3:
      return new Ctor(+object);
    case dataViewTag$4:
      return cloneDataView(object, isDeep);
    case float32Tag$2:
    case float64Tag$2:
    case int8Tag$2:
    case int16Tag$2:
    case int32Tag$2:
    case uint8Tag$2:
    case uint8ClampedTag$2:
    case uint16Tag$2:
    case uint32Tag$2:
      return cloneTypedArray$1(object, isDeep);
    case mapTag$5:
      return new Ctor();
    case numberTag$3:
    case stringTag$3:
      return new Ctor(object);
    case regexpTag$3:
      return cloneRegExp(object);
    case setTag$5:
      return new Ctor();
    case symbolTag$3:
      return cloneSymbol(object);
  }
}
var _initCloneByTag = initCloneByTag$1;
var isObject$2 = isObject_1;
var objectCreate$1 = Object.create;
var baseCreate$3 = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject$2(proto)) {
      return {};
    }
    if (objectCreate$1) {
      return objectCreate$1(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var _baseCreate = baseCreate$3;
var baseCreate$2 = _baseCreate, getPrototype$2 = _getPrototype, isPrototype$1 = _isPrototype;
function initCloneObject$2(object) {
  return typeof object.constructor == "function" && !isPrototype$1(object) ? baseCreate$2(getPrototype$2(object)) : {};
}
var _initCloneObject = initCloneObject$2;
var getTag$4 = _getTag, isObjectLike$2 = isObjectLike_1;
var mapTag$4 = "[object Map]";
function baseIsMap$1(value) {
  return isObjectLike$2(value) && getTag$4(value) == mapTag$4;
}
var _baseIsMap = baseIsMap$1;
var baseIsMap = _baseIsMap, baseUnary$2 = _baseUnary, nodeUtil$3 = _nodeUtilExports;
var nodeIsMap = nodeUtil$3 && nodeUtil$3.isMap;
var isMap$1 = nodeIsMap ? baseUnary$2(nodeIsMap) : baseIsMap;
var isMap_1 = isMap$1;
var getTag$3 = _getTag, isObjectLike$1 = isObjectLike_1;
var setTag$4 = "[object Set]";
function baseIsSet$1(value) {
  return isObjectLike$1(value) && getTag$3(value) == setTag$4;
}
var _baseIsSet = baseIsSet$1;
var baseIsSet = _baseIsSet, baseUnary$1 = _baseUnary, nodeUtil$2 = _nodeUtilExports;
var nodeIsSet = nodeUtil$2 && nodeUtil$2.isSet;
var isSet$1 = nodeIsSet ? baseUnary$1(nodeIsSet) : baseIsSet;
var isSet_1 = isSet$1;
var Stack$1 = _Stack, arrayEach$1 = _arrayEach, assignValue$1 = _assignValue, baseAssign = _baseAssign, baseAssignIn = _baseAssignIn, cloneBuffer$1 = _cloneBufferExports, copyArray$1 = _copyArray, copySymbols = _copySymbols, copySymbolsIn = _copySymbolsIn, getAllKeys$1 = _getAllKeys, getAllKeysIn = _getAllKeysIn, getTag$2 = _getTag, initCloneArray = _initCloneArray, initCloneByTag = _initCloneByTag, initCloneObject$1 = _initCloneObject, isArray$2 = isArray_1, isBuffer$2 = isBufferExports, isMap = isMap_1, isObject$1 = isObject_1, isSet = isSet_1, keys$1 = keys_1, keysIn$1 = keysIn_1;
var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
var argsTag$3 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$2 = "[object Error]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag$3] = cloneableTags[arrayTag$2] = cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$3] = cloneableTags[boolTag$2] = cloneableTags[dateTag$2] = cloneableTags[float32Tag$1] = cloneableTags[float64Tag$1] = cloneableTags[int8Tag$1] = cloneableTags[int16Tag$1] = cloneableTags[int32Tag$1] = cloneableTags[mapTag$3] = cloneableTags[numberTag$2] = cloneableTags[objectTag$4] = cloneableTags[regexpTag$2] = cloneableTags[setTag$3] = cloneableTags[stringTag$2] = cloneableTags[symbolTag$2] = cloneableTags[uint8Tag$1] = cloneableTags[uint8ClampedTag$1] = cloneableTags[uint16Tag$1] = cloneableTags[uint32Tag$1] = true;
cloneableTags[errorTag$2] = cloneableTags[funcTag$2] = cloneableTags[weakMapTag$2] = false;
function baseClone$1(value, bitmask, customizer, key, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject$1(value)) {
    return value;
  }
  var isArr = isArray$2(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray$1(value, result);
    }
  } else {
    var tag = getTag$2(value), isFunc = tag == funcTag$2 || tag == genTag$1;
    if (isBuffer$2(value)) {
      return cloneBuffer$1(value, isDeep);
    }
    if (tag == objectTag$4 || tag == argsTag$3 || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject$1(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack$1());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone$1(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone$1(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys$1 : isFlat ? keysIn$1 : keys$1;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach$1(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue$1(result, key2, baseClone$1(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var _baseClone = baseClone$1;
var baseClone = _baseClone;
var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}
var cloneDeep_1 = cloneDeep;
Object.defineProperty(mergeClasses$1, "__esModule", {
  value: true
});
mergeClasses$1.mergeClasses = void 0;
var _forOwn2$1 = forOwn_1;
var _forOwn3$1 = _interopRequireDefault$6(_forOwn2$1);
var _cloneDeep2 = cloneDeep_1;
var _cloneDeep3 = _interopRequireDefault$6(_cloneDeep2);
var _extends$e = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
function _interopRequireDefault$6(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var mergeClasses = mergeClasses$1.mergeClasses = function mergeClasses2(classes) {
  var activeNames = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var styles = classes.default && (0, _cloneDeep3.default)(classes.default) || {};
  activeNames.map(function(name) {
    var toMerge = classes[name];
    if (toMerge) {
      (0, _forOwn3$1.default)(toMerge, function(value, key) {
        if (!styles[key]) {
          styles[key] = {};
        }
        styles[key] = _extends$e({}, styles[key], toMerge[key]);
      });
    }
    return name;
  });
  return styles;
};
mergeClasses$1.default = mergeClasses;
var autoprefix$1 = {};
Object.defineProperty(autoprefix$1, "__esModule", {
  value: true
});
autoprefix$1.autoprefix = void 0;
var _forOwn2 = forOwn_1;
var _forOwn3 = _interopRequireDefault$5(_forOwn2);
var _extends$d = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
function _interopRequireDefault$5(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var transforms = {
  borderRadius: function borderRadius(value) {
    return {
      msBorderRadius: value,
      MozBorderRadius: value,
      OBorderRadius: value,
      WebkitBorderRadius: value,
      borderRadius: value
    };
  },
  boxShadow: function boxShadow(value) {
    return {
      msBoxShadow: value,
      MozBoxShadow: value,
      OBoxShadow: value,
      WebkitBoxShadow: value,
      boxShadow: value
    };
  },
  userSelect: function userSelect(value) {
    return {
      WebkitTouchCallout: value,
      KhtmlUserSelect: value,
      MozUserSelect: value,
      msUserSelect: value,
      WebkitUserSelect: value,
      userSelect: value
    };
  },
  flex: function flex(value) {
    return {
      WebkitBoxFlex: value,
      MozBoxFlex: value,
      WebkitFlex: value,
      msFlex: value,
      flex: value
    };
  },
  flexBasis: function flexBasis(value) {
    return {
      WebkitFlexBasis: value,
      flexBasis: value
    };
  },
  justifyContent: function justifyContent(value) {
    return {
      WebkitJustifyContent: value,
      justifyContent: value
    };
  },
  transition: function transition(value) {
    return {
      msTransition: value,
      MozTransition: value,
      OTransition: value,
      WebkitTransition: value,
      transition: value
    };
  },
  transform: function transform(value) {
    return {
      msTransform: value,
      MozTransform: value,
      OTransform: value,
      WebkitTransform: value,
      transform: value
    };
  },
  absolute: function absolute(value) {
    var direction = value && value.split(" ");
    return {
      position: "absolute",
      top: direction && direction[0],
      right: direction && direction[1],
      bottom: direction && direction[2],
      left: direction && direction[3]
    };
  },
  extend: function extend(name, otherElementStyles) {
    var otherStyle = otherElementStyles[name];
    if (otherStyle) {
      return otherStyle;
    }
    return {
      "extend": name
    };
  }
};
var autoprefix = autoprefix$1.autoprefix = function autoprefix2(elements) {
  var prefixed = {};
  (0, _forOwn3.default)(elements, function(styles, element) {
    var expanded = {};
    (0, _forOwn3.default)(styles, function(value, key) {
      var transform2 = transforms[key];
      if (transform2) {
        expanded = _extends$d({}, expanded, transform2(value));
      } else {
        expanded[key] = value;
      }
    });
    prefixed[element] = expanded;
  });
  return prefixed;
};
autoprefix$1.default = autoprefix;
var hover$1 = {};
Object.defineProperty(hover$1, "__esModule", {
  value: true
});
hover$1.hover = void 0;
var _extends$c = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _react$3 = reactExports;
var _react2$3 = _interopRequireDefault$4(_react$3);
function _interopRequireDefault$4(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _classCallCheck$9(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$9(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits$9(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var hover = hover$1.hover = function hover2(Component) {
  var Span = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
  return function(_React$Component) {
    _inherits$9(Hover, _React$Component);
    function Hover() {
      var _ref;
      var _temp, _this, _ret;
      _classCallCheck$9(this, Hover);
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _ret = (_temp = (_this = _possibleConstructorReturn$9(this, (_ref = Hover.__proto__ || Object.getPrototypeOf(Hover)).call.apply(_ref, [this].concat(args))), _this), _this.state = { hover: false }, _this.handleMouseOver = function() {
        return _this.setState({ hover: true });
      }, _this.handleMouseOut = function() {
        return _this.setState({ hover: false });
      }, _this.render = function() {
        return _react2$3.default.createElement(
          Span,
          { onMouseOver: _this.handleMouseOver, onMouseOut: _this.handleMouseOut },
          _react2$3.default.createElement(Component, _extends$c({}, _this.props, _this.state))
        );
      }, _temp), _possibleConstructorReturn$9(_this, _ret);
    }
    return Hover;
  }(_react2$3.default.Component);
};
hover$1.default = hover;
var active$1 = {};
Object.defineProperty(active$1, "__esModule", {
  value: true
});
active$1.active = void 0;
var _extends$b = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _react$2 = reactExports;
var _react2$2 = _interopRequireDefault$3(_react$2);
function _interopRequireDefault$3(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _classCallCheck$8(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$8(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits$8(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var active = active$1.active = function active2(Component) {
  var Span = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
  return function(_React$Component) {
    _inherits$8(Active, _React$Component);
    function Active() {
      var _ref;
      var _temp, _this, _ret;
      _classCallCheck$8(this, Active);
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _ret = (_temp = (_this = _possibleConstructorReturn$8(this, (_ref = Active.__proto__ || Object.getPrototypeOf(Active)).call.apply(_ref, [this].concat(args))), _this), _this.state = { active: false }, _this.handleMouseDown = function() {
        return _this.setState({ active: true });
      }, _this.handleMouseUp = function() {
        return _this.setState({ active: false });
      }, _this.render = function() {
        return _react2$2.default.createElement(
          Span,
          { onMouseDown: _this.handleMouseDown, onMouseUp: _this.handleMouseUp },
          _react2$2.default.createElement(Component, _extends$b({}, _this.props, _this.state))
        );
      }, _temp), _possibleConstructorReturn$8(_this, _ret);
    }
    return Active;
  }(_react2$2.default.Component);
};
active$1.default = active;
var loop = {};
Object.defineProperty(loop, "__esModule", {
  value: true
});
var loopable = function loopable2(i, length) {
  var props = {};
  var setProp = function setProp2(name) {
    var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    props[name] = value;
  };
  i === 0 && setProp("first-child");
  i === length - 1 && setProp("last-child");
  (i === 0 || i % 2 === 0) && setProp("even");
  Math.abs(i % 2) === 1 && setProp("odd");
  setProp("nth-child", i);
  return props;
};
loop.default = loopable;
Object.defineProperty(lib, "__esModule", {
  value: true
});
lib.ReactCSS = lib.loop = lib.handleActive = handleHover = lib.handleHover = lib.hover = void 0;
var _flattenNames = flattenNames$1;
var _flattenNames2 = _interopRequireDefault$2(_flattenNames);
var _mergeClasses = mergeClasses$1;
var _mergeClasses2 = _interopRequireDefault$2(_mergeClasses);
var _autoprefix = autoprefix$1;
var _autoprefix2 = _interopRequireDefault$2(_autoprefix);
var _hover2 = hover$1;
var _hover3 = _interopRequireDefault$2(_hover2);
var _active = active$1;
var _active2 = _interopRequireDefault$2(_active);
var _loop2 = loop;
var _loop3 = _interopRequireDefault$2(_loop2);
function _interopRequireDefault$2(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
lib.hover = _hover3.default;
var handleHover = lib.handleHover = _hover3.default;
lib.handleActive = _active2.default;
lib.loop = _loop3.default;
var ReactCSS = lib.ReactCSS = function ReactCSS2(classes) {
  for (var _len = arguments.length, activations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    activations[_key - 1] = arguments[_key];
  }
  var activeNames = (0, _flattenNames2.default)(activations);
  var merged = (0, _mergeClasses2.default)(classes, activeNames);
  return (0, _autoprefix2.default)(merged);
};
var _default$2 = lib.default = ReactCSS;
var calculateChange$2 = function calculateChange(e, hsl, direction, initialA, container) {
  var containerWidth = container.clientWidth;
  var containerHeight = container.clientHeight;
  var x = typeof e.pageX === "number" ? e.pageX : e.touches[0].pageX;
  var y = typeof e.pageY === "number" ? e.pageY : e.touches[0].pageY;
  var left = x - (container.getBoundingClientRect().left + window.pageXOffset);
  var top = y - (container.getBoundingClientRect().top + window.pageYOffset);
  if (direction === "vertical") {
    var a = void 0;
    if (top < 0) {
      a = 0;
    } else if (top > containerHeight) {
      a = 1;
    } else {
      a = Math.round(top * 100 / containerHeight) / 100;
    }
    if (hsl.a !== a) {
      return {
        h: hsl.h,
        s: hsl.s,
        l: hsl.l,
        a,
        source: "rgb"
      };
    }
  } else {
    var _a = void 0;
    if (left < 0) {
      _a = 0;
    } else if (left > containerWidth) {
      _a = 1;
    } else {
      _a = Math.round(left * 100 / containerWidth) / 100;
    }
    if (initialA !== _a) {
      return {
        h: hsl.h,
        s: hsl.s,
        l: hsl.l,
        a: _a,
        source: "rgb"
      };
    }
  }
  return null;
};
var checkboardCache = {};
var render = function render2(c1, c2, size, serverCanvas) {
  if (typeof document === "undefined" && !serverCanvas) {
    return null;
  }
  var canvas = serverCanvas ? new serverCanvas() : document.createElement("canvas");
  canvas.width = size * 2;
  canvas.height = size * 2;
  var ctx = canvas.getContext("2d");
  if (!ctx) {
    return null;
  }
  ctx.fillStyle = c1;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = c2;
  ctx.fillRect(0, 0, size, size);
  ctx.translate(size, size);
  ctx.fillRect(0, 0, size, size);
  return canvas.toDataURL();
};
var get$1 = function get(c1, c2, size, serverCanvas) {
  var key = c1 + "-" + c2 + "-" + size + (serverCanvas ? "-server" : "");
  if (checkboardCache[key]) {
    return checkboardCache[key];
  }
  var checkboard = render(c1, c2, size, serverCanvas);
  checkboardCache[key] = checkboard;
  return checkboard;
};
var _extends$a = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var Checkboard = function Checkboard2(_ref) {
  var white = _ref.white, grey = _ref.grey, size = _ref.size, renderers = _ref.renderers, borderRadius2 = _ref.borderRadius, boxShadow2 = _ref.boxShadow, children = _ref.children;
  var styles = _default$2({
    "default": {
      grid: {
        borderRadius: borderRadius2,
        boxShadow: boxShadow2,
        absolute: "0px 0px 0px 0px",
        background: "url(" + get$1(white, grey, size, renderers.canvas) + ") center left"
      }
    }
  });
  return reactExports.isValidElement(children) ? React.cloneElement(children, _extends$a({}, children.props, { style: _extends$a({}, children.props.style, styles.grid) })) : React.createElement("div", { style: styles.grid });
};
Checkboard.defaultProps = {
  size: 8,
  white: "transparent",
  grey: "rgba(0,0,0,.08)",
  renderers: {}
};
var _extends$9 = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _createClass$7 = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$7(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$7(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits$7(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var Alpha = function(_ref) {
  _inherits$7(Alpha2, _ref);
  function Alpha2() {
    var _ref2;
    var _temp, _this, _ret;
    _classCallCheck$7(this, Alpha2);
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return _ret = (_temp = (_this = _possibleConstructorReturn$7(this, (_ref2 = Alpha2.__proto__ || Object.getPrototypeOf(Alpha2)).call.apply(_ref2, [this].concat(args))), _this), _this.handleChange = function(e) {
      var change = calculateChange$2(e, _this.props.hsl, _this.props.direction, _this.props.a, _this.container);
      change && typeof _this.props.onChange === "function" && _this.props.onChange(change, e);
    }, _this.handleMouseDown = function(e) {
      _this.handleChange(e);
      window.addEventListener("mousemove", _this.handleChange);
      window.addEventListener("mouseup", _this.handleMouseUp);
    }, _this.handleMouseUp = function() {
      _this.unbindEventListeners();
    }, _this.unbindEventListeners = function() {
      window.removeEventListener("mousemove", _this.handleChange);
      window.removeEventListener("mouseup", _this.handleMouseUp);
    }, _temp), _possibleConstructorReturn$7(_this, _ret);
  }
  _createClass$7(Alpha2, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: "render",
    value: function render3() {
      var _this2 = this;
      var rgb = this.props.rgb;
      var styles = _default$2({
        "default": {
          alpha: {
            absolute: "0px 0px 0px 0px",
            borderRadius: this.props.radius
          },
          checkboard: {
            absolute: "0px 0px 0px 0px",
            overflow: "hidden",
            borderRadius: this.props.radius
          },
          gradient: {
            absolute: "0px 0px 0px 0px",
            background: "linear-gradient(to right, rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + ", 0) 0%,\n           rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + ", 1) 100%)",
            boxShadow: this.props.shadow,
            borderRadius: this.props.radius
          },
          container: {
            position: "relative",
            height: "100%",
            margin: "0 3px"
          },
          pointer: {
            position: "absolute",
            left: rgb.a * 100 + "%"
          },
          slider: {
            width: "4px",
            borderRadius: "1px",
            height: "8px",
            boxShadow: "0 0 2px rgba(0, 0, 0, .6)",
            background: "#fff",
            marginTop: "1px",
            transform: "translateX(-2px)"
          }
        },
        "vertical": {
          gradient: {
            background: "linear-gradient(to bottom, rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + ", 0) 0%,\n           rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + ", 1) 100%)"
          },
          pointer: {
            left: 0,
            top: rgb.a * 100 + "%"
          }
        },
        "overwrite": _extends$9({}, this.props.style)
      }, {
        vertical: this.props.direction === "vertical",
        overwrite: true
      });
      return React.createElement(
        "div",
        { style: styles.alpha },
        React.createElement(
          "div",
          { style: styles.checkboard },
          React.createElement(Checkboard, { renderers: this.props.renderers })
        ),
        React.createElement("div", { style: styles.gradient }),
        React.createElement(
          "div",
          {
            style: styles.container,
            ref: function ref(container) {
              return _this2.container = container;
            },
            onMouseDown: this.handleMouseDown,
            onTouchMove: this.handleChange,
            onTouchStart: this.handleChange
          },
          React.createElement(
            "div",
            { style: styles.pointer },
            this.props.pointer ? React.createElement(this.props.pointer, this.props) : React.createElement("div", { style: styles.slider })
          )
        )
      );
    }
  }]);
  return Alpha2;
}(reactExports.PureComponent || reactExports.Component);
var _createClass$6 = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck$6(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$6(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits$6(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var DEFAULT_ARROW_OFFSET = 1;
var UP_KEY_CODE = 38;
var DOWN_KEY_CODE = 40;
var VALID_KEY_CODES = [UP_KEY_CODE, DOWN_KEY_CODE];
var isValidKeyCode = function isValidKeyCode2(keyCode) {
  return VALID_KEY_CODES.indexOf(keyCode) > -1;
};
var getNumberValue = function getNumberValue2(value) {
  return Number(String(value).replace(/%/g, ""));
};
var idCounter = 1;
var EditableInput = function(_ref) {
  _inherits$6(EditableInput2, _ref);
  function EditableInput2(props) {
    _classCallCheck$6(this, EditableInput2);
    var _this = _possibleConstructorReturn$6(this, (EditableInput2.__proto__ || Object.getPrototypeOf(EditableInput2)).call(this));
    _this.handleBlur = function() {
      if (_this.state.blurValue) {
        _this.setState({ value: _this.state.blurValue, blurValue: null });
      }
    };
    _this.handleChange = function(e) {
      _this.setUpdatedValue(e.target.value, e);
    };
    _this.handleKeyDown = function(e) {
      var value = getNumberValue(e.target.value);
      if (!isNaN(value) && isValidKeyCode(e.keyCode)) {
        var offset = _this.getArrowOffset();
        var updatedValue = e.keyCode === UP_KEY_CODE ? value + offset : value - offset;
        _this.setUpdatedValue(updatedValue, e);
      }
    };
    _this.handleDrag = function(e) {
      if (_this.props.dragLabel) {
        var newValue = Math.round(_this.props.value + e.movementX);
        if (newValue >= 0 && newValue <= _this.props.dragMax) {
          _this.props.onChange && _this.props.onChange(_this.getValueObjectWithLabel(newValue), e);
        }
      }
    };
    _this.handleMouseDown = function(e) {
      if (_this.props.dragLabel) {
        e.preventDefault();
        _this.handleDrag(e);
        window.addEventListener("mousemove", _this.handleDrag);
        window.addEventListener("mouseup", _this.handleMouseUp);
      }
    };
    _this.handleMouseUp = function() {
      _this.unbindEventListeners();
    };
    _this.unbindEventListeners = function() {
      window.removeEventListener("mousemove", _this.handleDrag);
      window.removeEventListener("mouseup", _this.handleMouseUp);
    };
    _this.state = {
      value: String(props.value).toUpperCase(),
      blurValue: String(props.value).toUpperCase()
    };
    _this.inputId = "rc-editable-input-" + idCounter++;
    return _this;
  }
  _createClass$6(EditableInput2, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      if (this.props.value !== this.state.value && (prevProps.value !== this.props.value || prevState.value !== this.state.value)) {
        if (this.input === document.activeElement) {
          this.setState({ blurValue: String(this.props.value).toUpperCase() });
        } else {
          this.setState({ value: String(this.props.value).toUpperCase(), blurValue: !this.state.blurValue && String(this.props.value).toUpperCase() });
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: "getValueObjectWithLabel",
    value: function getValueObjectWithLabel(value) {
      return _defineProperty({}, this.props.label, value);
    }
  }, {
    key: "getArrowOffset",
    value: function getArrowOffset() {
      return this.props.arrowOffset || DEFAULT_ARROW_OFFSET;
    }
  }, {
    key: "setUpdatedValue",
    value: function setUpdatedValue(value, e) {
      var onChangeValue = this.props.label ? this.getValueObjectWithLabel(value) : value;
      this.props.onChange && this.props.onChange(onChangeValue, e);
      this.setState({ value });
    }
  }, {
    key: "render",
    value: function render3() {
      var _this2 = this;
      var styles = _default$2({
        "default": {
          wrap: {
            position: "relative"
          }
        },
        "user-override": {
          wrap: this.props.style && this.props.style.wrap ? this.props.style.wrap : {},
          input: this.props.style && this.props.style.input ? this.props.style.input : {},
          label: this.props.style && this.props.style.label ? this.props.style.label : {}
        },
        "dragLabel-true": {
          label: {
            cursor: "ew-resize"
          }
        }
      }, {
        "user-override": true
      }, this.props);
      return React.createElement(
        "div",
        { style: styles.wrap },
        React.createElement("input", {
          id: this.inputId,
          style: styles.input,
          ref: function ref(input) {
            return _this2.input = input;
          },
          value: this.state.value,
          onKeyDown: this.handleKeyDown,
          onChange: this.handleChange,
          onBlur: this.handleBlur,
          placeholder: this.props.placeholder,
          spellCheck: "false"
        }),
        this.props.label && !this.props.hideLabel ? React.createElement(
          "label",
          {
            htmlFor: this.inputId,
            style: styles.label,
            onMouseDown: this.handleMouseDown
          },
          this.props.label
        ) : null
      );
    }
  }]);
  return EditableInput2;
}(reactExports.PureComponent || reactExports.Component);
var calculateChange$1 = function calculateChange2(e, direction, hsl, container) {
  var containerWidth = container.clientWidth;
  var containerHeight = container.clientHeight;
  var x = typeof e.pageX === "number" ? e.pageX : e.touches[0].pageX;
  var y = typeof e.pageY === "number" ? e.pageY : e.touches[0].pageY;
  var left = x - (container.getBoundingClientRect().left + window.pageXOffset);
  var top = y - (container.getBoundingClientRect().top + window.pageYOffset);
  if (direction === "vertical") {
    var h = void 0;
    if (top < 0) {
      h = 359;
    } else if (top > containerHeight) {
      h = 0;
    } else {
      var percent = -(top * 100 / containerHeight) + 100;
      h = 360 * percent / 100;
    }
    if (hsl.h !== h) {
      return {
        h,
        s: hsl.s,
        l: hsl.l,
        a: hsl.a,
        source: "hsl"
      };
    }
  } else {
    var _h = void 0;
    if (left < 0) {
      _h = 0;
    } else if (left > containerWidth) {
      _h = 359;
    } else {
      var _percent = left * 100 / containerWidth;
      _h = 360 * _percent / 100;
    }
    if (hsl.h !== _h) {
      return {
        h: _h,
        s: hsl.s,
        l: hsl.l,
        a: hsl.a,
        source: "hsl"
      };
    }
  }
  return null;
};
var _createClass$5 = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$5(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$5(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits$5(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var Hue = function(_ref) {
  _inherits$5(Hue2, _ref);
  function Hue2() {
    var _ref2;
    var _temp, _this, _ret;
    _classCallCheck$5(this, Hue2);
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return _ret = (_temp = (_this = _possibleConstructorReturn$5(this, (_ref2 = Hue2.__proto__ || Object.getPrototypeOf(Hue2)).call.apply(_ref2, [this].concat(args))), _this), _this.handleChange = function(e) {
      var change = calculateChange$1(e, _this.props.direction, _this.props.hsl, _this.container);
      change && typeof _this.props.onChange === "function" && _this.props.onChange(change, e);
    }, _this.handleMouseDown = function(e) {
      _this.handleChange(e);
      window.addEventListener("mousemove", _this.handleChange);
      window.addEventListener("mouseup", _this.handleMouseUp);
    }, _this.handleMouseUp = function() {
      _this.unbindEventListeners();
    }, _temp), _possibleConstructorReturn$5(_this, _ret);
  }
  _createClass$5(Hue2, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: "unbindEventListeners",
    value: function unbindEventListeners() {
      window.removeEventListener("mousemove", this.handleChange);
      window.removeEventListener("mouseup", this.handleMouseUp);
    }
  }, {
    key: "render",
    value: function render3() {
      var _this2 = this;
      var _props$direction = this.props.direction, direction = _props$direction === void 0 ? "horizontal" : _props$direction;
      var styles = _default$2({
        "default": {
          hue: {
            absolute: "0px 0px 0px 0px",
            borderRadius: this.props.radius,
            boxShadow: this.props.shadow
          },
          container: {
            padding: "0 2px",
            position: "relative",
            height: "100%",
            borderRadius: this.props.radius
          },
          pointer: {
            position: "absolute",
            left: this.props.hsl.h * 100 / 360 + "%"
          },
          slider: {
            marginTop: "1px",
            width: "4px",
            borderRadius: "1px",
            height: "8px",
            boxShadow: "0 0 2px rgba(0, 0, 0, .6)",
            background: "#fff",
            transform: "translateX(-2px)"
          }
        },
        "vertical": {
          pointer: {
            left: "0px",
            top: -(this.props.hsl.h * 100 / 360) + 100 + "%"
          }
        }
      }, { vertical: direction === "vertical" });
      return React.createElement(
        "div",
        { style: styles.hue },
        React.createElement(
          "div",
          {
            className: "hue-" + direction,
            style: styles.container,
            ref: function ref(container) {
              return _this2.container = container;
            },
            onMouseDown: this.handleMouseDown,
            onTouchMove: this.handleChange,
            onTouchStart: this.handleChange
          },
          React.createElement(
            "style",
            null,
            "\n            .hue-horizontal {\n              background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0\n                33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n              background: -webkit-linear-gradient(to right, #f00 0%, #ff0\n                17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n            }\n\n            .hue-vertical {\n              background: linear-gradient(to top, #f00 0%, #ff0 17%, #0f0 33%,\n                #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n              background: -webkit-linear-gradient(to top, #f00 0%, #ff0 17%,\n                #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n            }\n          "
          ),
          React.createElement(
            "div",
            { style: styles.pointer },
            this.props.pointer ? React.createElement(this.props.pointer, this.props) : React.createElement("div", { style: styles.slider })
          )
        )
      );
    }
  }]);
  return Hue2;
}(reactExports.PureComponent || reactExports.Component);
var propTypesExports = {};
var propTypes = {
  get exports() {
    return propTypesExports;
  },
  set exports(v) {
    propTypesExports = v;
  }
};
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
var ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      return;
    }
    var err = new Error(
      "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
    );
    err.name = "Invariant Violation";
    throw err;
  }
  shim.isRequired = shim;
  function getShim() {
    return shim;
  }
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
{
  propTypes.exports = factoryWithThrowingShims();
}
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index = assocIndexOf(data, key);
  return index < 0 ? void 0 : data[index][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
function ListCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
function stackGet(key) {
  return this.__data__.get(key);
}
function stackHas(key) {
  return this.__data__.has(key);
}
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
const freeGlobal$1 = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal$1 || freeSelf || Function("return this")();
const root$1 = root;
var Symbol$1 = root$1.Symbol;
const Symbol$2 = Symbol$1;
var objectProto$e = Object.prototype;
var hasOwnProperty$b = objectProto$e.hasOwnProperty;
var nativeObjectToString$1 = objectProto$e.toString;
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$b.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$d = Object.prototype;
var nativeObjectToString = objectProto$d.toString;
function objectToString(value) {
  return nativeObjectToString.call(value);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root$1["__core-js_shared__"];
const coreJsData$1 = coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype, objectProto$c = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$a = objectProto$c.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var Map = getNative(root$1, "Map");
const Map$1 = Map;
var nativeCreate = getNative(Object, "create");
const nativeCreate$1 = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$b = Object.prototype;
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate$1) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$9.call(data, key) ? data[key] : void 0;
}
var objectProto$a = Object.prototype;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$8.call(data, key);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
function Hash(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$1 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map2, key) {
  var data = map2.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete(key) {
  var result = getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  var data = getMapData(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
var defineProperty = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
const defineProperty$1 = defineProperty;
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty$1) {
    defineProperty$1(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
function assignMergeValue(object, key, value) {
  if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var baseFor = createBaseFor();
const baseFor$1 = baseFor;
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$1 = moduleExports$2 ? root$1.Buffer : void 0, allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}
var Uint8Array$1 = root$1.Uint8Array;
const Uint8Array$2 = Uint8Array$1;
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
  return result;
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
function copyArray(source, array) {
  var index = -1, length = source.length;
  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}
var objectCreate = Object.create;
var baseCreate = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
const baseCreate$1 = baseCreate;
function overArg(func, transform2) {
  return function(arg) {
    return func(transform2(arg));
  };
}
var getPrototype = overArg(Object.getPrototypeOf, Object);
const getPrototype$1 = getPrototype;
var objectProto$9 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$9;
  return value === proto;
}
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate$1(getPrototype$1(object)) : {};
}
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var argsTag$2 = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$2;
}
var objectProto$8 = Object.prototype;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$8.propertyIsEnumerable;
var isArguments = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$7.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
const isArguments$1 = isArguments;
var isArray = Array.isArray;
const isArray$1 = isArray;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}
function stubFalse() {
  return false;
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var Buffer = moduleExports$1 ? root$1.Buffer : void 0;
var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse;
const isBuffer$1 = isBuffer;
var objectTag$3 = "[object Object]";
var funcProto = Function.prototype, objectProto$7 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
    return false;
  }
  var proto = getPrototype$1(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$6.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var freeProcess = moduleExports && freeGlobal$1.process;
var nodeUtil = function() {
  try {
    var types = freeModule && freeModule.require && freeModule.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
const nodeUtil$1 = nodeUtil;
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
const isTypedArray$1 = isTypedArray;
function safeGet(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var objectProto$6 = Object.prototype;
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$5.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1, length = props.length;
  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}
function baseTimes(n, iteratee) {
  var index = -1, result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var objectProto$5 = Object.prototype;
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray$1(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$4 = Object.prototype;
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$3.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray$1(srcValue), isBuff = !isArr && isBuffer$1(srcValue), isTyped = !isArr && !isBuff && isTypedArray$1(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray$1(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments$1(srcValue)) {
      newValue = objValue;
      if (isArguments$1(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue(object, key, newValue);
}
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor$1(source, function(srcValue, key) {
    stack || (stack = new Stack());
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}
function identity(value) {
  return value;
}
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var nativeMax$1 = Math.max;
function overRest(func, start, transform2) {
  start = nativeMax$1(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index = -1, length = nativeMax$1(args.length - start, 0), array = Array(length);
    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform2(array);
    return apply(func, this, otherArgs);
  };
}
function constant(value) {
  return function() {
    return value;
  };
}
var baseSetToString = !defineProperty$1 ? identity : function(func, string) {
  return defineProperty$1(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
const baseSetToString$1 = baseSetToString;
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var setToString = shortOut(baseSetToString$1);
const setToString$1 = setToString;
function baseRest(func, start) {
  return setToString$1(overRest(func, start, identity), func + "");
}
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
    return eq(object[index], value);
  }
  return false;
}
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});
const merge$1 = merge;
var Raised = function Raised2(_ref) {
  var zDepth = _ref.zDepth, radius = _ref.radius, background = _ref.background, children = _ref.children, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles;
  var styles = _default$2(merge$1({
    "default": {
      wrap: {
        position: "relative",
        display: "inline-block"
      },
      content: {
        position: "relative"
      },
      bg: {
        absolute: "0px 0px 0px 0px",
        boxShadow: "0 " + zDepth + "px " + zDepth * 4 + "px rgba(0,0,0,.24)",
        borderRadius: radius,
        background
      }
    },
    "zDepth-0": {
      bg: {
        boxShadow: "none"
      }
    },
    "zDepth-1": {
      bg: {
        boxShadow: "0 2px 10px rgba(0,0,0,.12), 0 2px 5px rgba(0,0,0,.16)"
      }
    },
    "zDepth-2": {
      bg: {
        boxShadow: "0 6px 20px rgba(0,0,0,.19), 0 8px 17px rgba(0,0,0,.2)"
      }
    },
    "zDepth-3": {
      bg: {
        boxShadow: "0 17px 50px rgba(0,0,0,.19), 0 12px 15px rgba(0,0,0,.24)"
      }
    },
    "zDepth-4": {
      bg: {
        boxShadow: "0 25px 55px rgba(0,0,0,.21), 0 16px 28px rgba(0,0,0,.22)"
      }
    },
    "zDepth-5": {
      bg: {
        boxShadow: "0 40px 77px rgba(0,0,0,.22), 0 27px 24px rgba(0,0,0,.2)"
      }
    },
    "square": {
      bg: {
        borderRadius: "0"
      }
    },
    "circle": {
      bg: {
        borderRadius: "50%"
      }
    }
  }, passedStyles), { "zDepth-1": zDepth === 1 });
  return React.createElement(
    "div",
    { style: styles.wrap },
    React.createElement("div", { style: styles.bg }),
    React.createElement(
      "div",
      { style: styles.content },
      children
    )
  );
};
Raised.propTypes = {
  background: propTypesExports.string,
  zDepth: propTypesExports.oneOf([0, 1, 2, 3, 4, 5]),
  radius: propTypesExports.number,
  styles: propTypesExports.object
};
Raised.defaultProps = {
  background: "#fff",
  zDepth: 1,
  radius: 2,
  styles: {}
};
var now = function() {
  return root$1.Date.now();
};
const now$1 = now;
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index = string.length;
  while (index-- && reWhitespace.test(string.charAt(index))) {
  }
  return index;
}
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
var symbolTag$1 = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$1;
}
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var FUNC_ERROR_TEXT$2 = "Expected a function";
var nativeMax = Math.max, nativeMin = Math.min;
function debounce(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now$1();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now$1());
  }
  function debounced() {
    var time = now$1(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var FUNC_ERROR_TEXT$1 = "Expected a function";
function throttle(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  if (isObject(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var calculateChange3 = function calculateChange4(e, hsl, container) {
  var _container$getBoundin = container.getBoundingClientRect(), containerWidth = _container$getBoundin.width, containerHeight = _container$getBoundin.height;
  var x = typeof e.pageX === "number" ? e.pageX : e.touches[0].pageX;
  var y = typeof e.pageY === "number" ? e.pageY : e.touches[0].pageY;
  var left = x - (container.getBoundingClientRect().left + window.pageXOffset);
  var top = y - (container.getBoundingClientRect().top + window.pageYOffset);
  if (left < 0) {
    left = 0;
  } else if (left > containerWidth) {
    left = containerWidth;
  }
  if (top < 0) {
    top = 0;
  } else if (top > containerHeight) {
    top = containerHeight;
  }
  var saturation = left / containerWidth;
  var bright = 1 - top / containerHeight;
  return {
    h: hsl.h,
    s: saturation,
    v: bright,
    a: hsl.a,
    source: "hsv"
  };
};
var _createClass$4 = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$4(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits$4(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var Saturation = function(_ref) {
  _inherits$4(Saturation2, _ref);
  function Saturation2(props) {
    _classCallCheck$4(this, Saturation2);
    var _this = _possibleConstructorReturn$4(this, (Saturation2.__proto__ || Object.getPrototypeOf(Saturation2)).call(this, props));
    _this.handleChange = function(e) {
      typeof _this.props.onChange === "function" && _this.throttle(_this.props.onChange, calculateChange3(e, _this.props.hsl, _this.container), e);
    };
    _this.handleMouseDown = function(e) {
      _this.handleChange(e);
      var renderWindow = _this.getContainerRenderWindow();
      renderWindow.addEventListener("mousemove", _this.handleChange);
      renderWindow.addEventListener("mouseup", _this.handleMouseUp);
    };
    _this.handleMouseUp = function() {
      _this.unbindEventListeners();
    };
    _this.throttle = throttle(function(fn, data, e) {
      fn(data, e);
    }, 50);
    return _this;
  }
  _createClass$4(Saturation2, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.throttle.cancel();
      this.unbindEventListeners();
    }
  }, {
    key: "getContainerRenderWindow",
    value: function getContainerRenderWindow() {
      var container = this.container;
      var renderWindow = window;
      while (!renderWindow.document.contains(container) && renderWindow.parent !== renderWindow) {
        renderWindow = renderWindow.parent;
      }
      return renderWindow;
    }
  }, {
    key: "unbindEventListeners",
    value: function unbindEventListeners() {
      var renderWindow = this.getContainerRenderWindow();
      renderWindow.removeEventListener("mousemove", this.handleChange);
      renderWindow.removeEventListener("mouseup", this.handleMouseUp);
    }
  }, {
    key: "render",
    value: function render3() {
      var _this2 = this;
      var _ref2 = this.props.style || {}, color = _ref2.color, white = _ref2.white, black = _ref2.black, pointer = _ref2.pointer, circle = _ref2.circle;
      var styles = _default$2({
        "default": {
          color: {
            absolute: "0px 0px 0px 0px",
            background: "hsl(" + this.props.hsl.h + ",100%, 50%)",
            borderRadius: this.props.radius
          },
          white: {
            absolute: "0px 0px 0px 0px",
            borderRadius: this.props.radius
          },
          black: {
            absolute: "0px 0px 0px 0px",
            boxShadow: this.props.shadow,
            borderRadius: this.props.radius
          },
          pointer: {
            position: "absolute",
            top: -(this.props.hsv.v * 100) + 100 + "%",
            left: this.props.hsv.s * 100 + "%",
            cursor: "default"
          },
          circle: {
            width: "4px",
            height: "4px",
            boxShadow: "0 0 0 1.5px #fff, inset 0 0 1px 1px rgba(0,0,0,.3),\n            0 0 1px 2px rgba(0,0,0,.4)",
            borderRadius: "50%",
            cursor: "hand",
            transform: "translate(-2px, -2px)"
          }
        },
        "custom": {
          color,
          white,
          black,
          pointer,
          circle
        }
      }, { "custom": !!this.props.style });
      return React.createElement(
        "div",
        {
          style: styles.color,
          ref: function ref(container) {
            return _this2.container = container;
          },
          onMouseDown: this.handleMouseDown,
          onTouchMove: this.handleChange,
          onTouchStart: this.handleChange
        },
        React.createElement(
          "style",
          null,
          "\n          .saturation-white {\n            background: -webkit-linear-gradient(to right, #fff, rgba(255,255,255,0));\n            background: linear-gradient(to right, #fff, rgba(255,255,255,0));\n          }\n          .saturation-black {\n            background: -webkit-linear-gradient(to top, #000, rgba(0,0,0,0));\n            background: linear-gradient(to top, #000, rgba(0,0,0,0));\n          }\n        "
        ),
        React.createElement(
          "div",
          { style: styles.white, className: "saturation-white" },
          React.createElement("div", { style: styles.black, className: "saturation-black" }),
          React.createElement(
            "div",
            { style: styles.pointer },
            this.props.pointer ? React.createElement(this.props.pointer, this.props) : React.createElement("div", { style: styles.circle })
          )
        )
      );
    }
  }]);
  return Saturation2;
}(reactExports.PureComponent || reactExports.Component);
function arrayEach(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}
var nativeKeys = overArg(Object.keys, Object);
const nativeKeys$1 = nativeKeys;
var objectProto$3 = Object.prototype;
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys$1(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$2.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function baseForOwn(object, iteratee) {
  return object && baseFor$1(object, iteratee, keys);
}
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index-- : ++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var baseEach = createBaseEach(baseForOwn);
const baseEach$1 = baseEach;
function castFunction(value) {
  return typeof value == "function" ? value : identity;
}
function forEach(collection, iteratee) {
  var func = isArray$1(collection) ? arrayEach : baseEach$1;
  return func(collection, castFunction(iteratee));
}
var tinycolorExports = {};
var tinycolor$1 = {
  get exports() {
    return tinycolorExports;
  },
  set exports(v) {
    tinycolorExports = v;
  }
};
(function(module2) {
  (function(Math2) {
    var trimLeft = /^\s+/, trimRight = /\s+$/, tinyCounter = 0, mathRound = Math2.round, mathMin = Math2.min, mathMax = Math2.max, mathRandom = Math2.random;
    function tinycolor2(color, opts) {
      color = color ? color : "";
      opts = opts || {};
      if (color instanceof tinycolor2) {
        return color;
      }
      if (!(this instanceof tinycolor2)) {
        return new tinycolor2(color, opts);
      }
      var rgb = inputToRGB(color);
      this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = mathRound(100 * this._a) / 100, this._format = opts.format || rgb.format;
      this._gradientType = opts.gradientType;
      if (this._r < 1) {
        this._r = mathRound(this._r);
      }
      if (this._g < 1) {
        this._g = mathRound(this._g);
      }
      if (this._b < 1) {
        this._b = mathRound(this._b);
      }
      this._ok = rgb.ok;
      this._tc_id = tinyCounter++;
    }
    tinycolor2.prototype = {
      isDark: function() {
        return this.getBrightness() < 128;
      },
      isLight: function() {
        return !this.isDark();
      },
      isValid: function() {
        return this._ok;
      },
      getOriginalInput: function() {
        return this._originalInput;
      },
      getFormat: function() {
        return this._format;
      },
      getAlpha: function() {
        return this._a;
      },
      getBrightness: function() {
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
      },
      getLuminance: function() {
        var rgb = this.toRgb();
        var RsRGB, GsRGB, BsRGB, R, G, B;
        RsRGB = rgb.r / 255;
        GsRGB = rgb.g / 255;
        BsRGB = rgb.b / 255;
        if (RsRGB <= 0.03928) {
          R = RsRGB / 12.92;
        } else {
          R = Math2.pow((RsRGB + 0.055) / 1.055, 2.4);
        }
        if (GsRGB <= 0.03928) {
          G = GsRGB / 12.92;
        } else {
          G = Math2.pow((GsRGB + 0.055) / 1.055, 2.4);
        }
        if (BsRGB <= 0.03928) {
          B = BsRGB / 12.92;
        } else {
          B = Math2.pow((BsRGB + 0.055) / 1.055, 2.4);
        }
        return 0.2126 * R + 0.7152 * G + 0.0722 * B;
      },
      setAlpha: function(value) {
        this._a = boundAlpha(value);
        this._roundA = mathRound(100 * this._a) / 100;
        return this;
      },
      toHsv: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
      },
      toHsvString: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
        return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
      },
      toHsl: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
      },
      toHslString: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
        return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
      },
      toHex: function(allow3Char) {
        return rgbToHex(this._r, this._g, this._b, allow3Char);
      },
      toHexString: function(allow3Char) {
        return "#" + this.toHex(allow3Char);
      },
      toHex8: function(allow4Char) {
        return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
      },
      toHex8String: function(allow4Char) {
        return "#" + this.toHex8(allow4Char);
      },
      toRgb: function() {
        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
      },
      toRgbString: function() {
        return this._a == 1 ? "rgb(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" : "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
      },
      toPercentageRgb: function() {
        return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
      },
      toPercentageRgbString: function() {
        return this._a == 1 ? "rgb(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" : "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
      },
      toName: function() {
        if (this._a === 0) {
          return "transparent";
        }
        if (this._a < 1) {
          return false;
        }
        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
      },
      toFilter: function(secondColor) {
        var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? "GradientType = 1, " : "";
        if (secondColor) {
          var s = tinycolor2(secondColor);
          secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
        }
        return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
      },
      toString: function(format) {
        var formatSet = !!format;
        format = format || this._format;
        var formattedString = false;
        var hasAlpha = this._a < 1 && this._a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
        if (needsAlphaFormat) {
          if (format === "name" && this._a === 0) {
            return this.toName();
          }
          return this.toRgbString();
        }
        if (format === "rgb") {
          formattedString = this.toRgbString();
        }
        if (format === "prgb") {
          formattedString = this.toPercentageRgbString();
        }
        if (format === "hex" || format === "hex6") {
          formattedString = this.toHexString();
        }
        if (format === "hex3") {
          formattedString = this.toHexString(true);
        }
        if (format === "hex4") {
          formattedString = this.toHex8String(true);
        }
        if (format === "hex8") {
          formattedString = this.toHex8String();
        }
        if (format === "name") {
          formattedString = this.toName();
        }
        if (format === "hsl") {
          formattedString = this.toHslString();
        }
        if (format === "hsv") {
          formattedString = this.toHsvString();
        }
        return formattedString || this.toHexString();
      },
      clone: function() {
        return tinycolor2(this.toString());
      },
      _applyModification: function(fn, args) {
        var color = fn.apply(null, [this].concat([].slice.call(args)));
        this._r = color._r;
        this._g = color._g;
        this._b = color._b;
        this.setAlpha(color._a);
        return this;
      },
      lighten: function() {
        return this._applyModification(lighten, arguments);
      },
      brighten: function() {
        return this._applyModification(brighten, arguments);
      },
      darken: function() {
        return this._applyModification(darken, arguments);
      },
      desaturate: function() {
        return this._applyModification(desaturate, arguments);
      },
      saturate: function() {
        return this._applyModification(saturate, arguments);
      },
      greyscale: function() {
        return this._applyModification(greyscale, arguments);
      },
      spin: function() {
        return this._applyModification(spin, arguments);
      },
      _applyCombination: function(fn, args) {
        return fn.apply(null, [this].concat([].slice.call(args)));
      },
      analogous: function() {
        return this._applyCombination(analogous, arguments);
      },
      complement: function() {
        return this._applyCombination(complement, arguments);
      },
      monochromatic: function() {
        return this._applyCombination(monochromatic, arguments);
      },
      splitcomplement: function() {
        return this._applyCombination(splitcomplement, arguments);
      },
      triad: function() {
        return this._applyCombination(triad, arguments);
      },
      tetrad: function() {
        return this._applyCombination(tetrad, arguments);
      }
    };
    tinycolor2.fromRatio = function(color, opts) {
      if (typeof color == "object") {
        var newColor = {};
        for (var i in color) {
          if (color.hasOwnProperty(i)) {
            if (i === "a") {
              newColor[i] = color[i];
            } else {
              newColor[i] = convertToPercentage(color[i]);
            }
          }
        }
        color = newColor;
      }
      return tinycolor2(color, opts);
    };
    function inputToRGB(color) {
      var rgb = { r: 0, g: 0, b: 0 };
      var a = 1;
      var s = null;
      var v = null;
      var l = null;
      var ok = false;
      var format = false;
      if (typeof color == "string") {
        color = stringInputToObject(color);
      }
      if (typeof color == "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
          rgb = rgbToRgb(color.r, color.g, color.b);
          ok = true;
          format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
          s = convertToPercentage(color.s);
          v = convertToPercentage(color.v);
          rgb = hsvToRgb(color.h, s, v);
          ok = true;
          format = "hsv";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
          s = convertToPercentage(color.s);
          l = convertToPercentage(color.l);
          rgb = hslToRgb(color.h, s, l);
          ok = true;
          format = "hsl";
        }
        if (color.hasOwnProperty("a")) {
          a = color.a;
        }
      }
      a = boundAlpha(a);
      return {
        ok,
        format: color.format || format,
        r: mathMin(255, mathMax(rgb.r, 0)),
        g: mathMin(255, mathMax(rgb.g, 0)),
        b: mathMin(255, mathMax(rgb.b, 0)),
        a
      };
    }
    function rgbToRgb(r, g, b) {
      return {
        r: bound01(r, 255) * 255,
        g: bound01(g, 255) * 255,
        b: bound01(b, 255) * 255
      };
    }
    function rgbToHsl(r, g, b) {
      r = bound01(r, 255);
      g = bound01(g, 255);
      b = bound01(b, 255);
      var max = mathMax(r, g, b), min = mathMin(r, g, b);
      var h, s, l = (max + min) / 2;
      if (max == min) {
        h = s = 0;
      } else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }
      return { h, s, l };
    }
    function hslToRgb(h, s, l) {
      var r, g, b;
      h = bound01(h, 360);
      s = bound01(s, 100);
      l = bound01(l, 100);
      function hue2rgb(p2, q2, t) {
        if (t < 0)
          t += 1;
        if (t > 1)
          t -= 1;
        if (t < 1 / 6)
          return p2 + (q2 - p2) * 6 * t;
        if (t < 1 / 2)
          return q2;
        if (t < 2 / 3)
          return p2 + (q2 - p2) * (2 / 3 - t) * 6;
        return p2;
      }
      if (s === 0) {
        r = g = b = l;
      } else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
      }
      return { r: r * 255, g: g * 255, b: b * 255 };
    }
    function rgbToHsv(r, g, b) {
      r = bound01(r, 255);
      g = bound01(g, 255);
      b = bound01(b, 255);
      var max = mathMax(r, g, b), min = mathMin(r, g, b);
      var h, s, v = max;
      var d = max - min;
      s = max === 0 ? 0 : d / max;
      if (max == min) {
        h = 0;
      } else {
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }
      return { h, s, v };
    }
    function hsvToRgb(h, s, v) {
      h = bound01(h, 360) * 6;
      s = bound01(s, 100);
      v = bound01(v, 100);
      var i = Math2.floor(h), f = h - i, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), mod = i % 6, r = [v, q, p, p, t, v][mod], g = [t, v, v, q, p, p][mod], b = [p, p, t, v, v, q][mod];
      return { r: r * 255, g: g * 255, b: b * 255 };
    }
    function rgbToHex(r, g, b, allow3Char) {
      var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
      ];
      if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
      }
      return hex.join("");
    }
    function rgbaToHex(r, g, b, a, allow4Char) {
      var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16)),
        pad2(convertDecimalToHex(a))
      ];
      if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
      }
      return hex.join("");
    }
    function rgbaToArgbHex(r, g, b, a) {
      var hex = [
        pad2(convertDecimalToHex(a)),
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
      ];
      return hex.join("");
    }
    tinycolor2.equals = function(color1, color2) {
      if (!color1 || !color2) {
        return false;
      }
      return tinycolor2(color1).toRgbString() == tinycolor2(color2).toRgbString();
    };
    tinycolor2.random = function() {
      return tinycolor2.fromRatio({
        r: mathRandom(),
        g: mathRandom(),
        b: mathRandom()
      });
    };
    function desaturate(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor2(color).toHsl();
      hsl.s -= amount / 100;
      hsl.s = clamp01(hsl.s);
      return tinycolor2(hsl);
    }
    function saturate(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor2(color).toHsl();
      hsl.s += amount / 100;
      hsl.s = clamp01(hsl.s);
      return tinycolor2(hsl);
    }
    function greyscale(color) {
      return tinycolor2(color).desaturate(100);
    }
    function lighten(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor2(color).toHsl();
      hsl.l += amount / 100;
      hsl.l = clamp01(hsl.l);
      return tinycolor2(hsl);
    }
    function brighten(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var rgb = tinycolor2(color).toRgb();
      rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * -(amount / 100))));
      rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * -(amount / 100))));
      rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * -(amount / 100))));
      return tinycolor2(rgb);
    }
    function darken(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor2(color).toHsl();
      hsl.l -= amount / 100;
      hsl.l = clamp01(hsl.l);
      return tinycolor2(hsl);
    }
    function spin(color, amount) {
      var hsl = tinycolor2(color).toHsl();
      var hue = (hsl.h + amount) % 360;
      hsl.h = hue < 0 ? 360 + hue : hue;
      return tinycolor2(hsl);
    }
    function complement(color) {
      var hsl = tinycolor2(color).toHsl();
      hsl.h = (hsl.h + 180) % 360;
      return tinycolor2(hsl);
    }
    function triad(color) {
      var hsl = tinycolor2(color).toHsl();
      var h = hsl.h;
      return [
        tinycolor2(color),
        tinycolor2({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
        tinycolor2({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
      ];
    }
    function tetrad(color) {
      var hsl = tinycolor2(color).toHsl();
      var h = hsl.h;
      return [
        tinycolor2(color),
        tinycolor2({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
        tinycolor2({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
        tinycolor2({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
      ];
    }
    function splitcomplement(color) {
      var hsl = tinycolor2(color).toHsl();
      var h = hsl.h;
      return [
        tinycolor2(color),
        tinycolor2({ h: (h + 72) % 360, s: hsl.s, l: hsl.l }),
        tinycolor2({ h: (h + 216) % 360, s: hsl.s, l: hsl.l })
      ];
    }
    function analogous(color, results, slices) {
      results = results || 6;
      slices = slices || 30;
      var hsl = tinycolor2(color).toHsl();
      var part = 360 / slices;
      var ret = [tinycolor2(color)];
      for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(tinycolor2(hsl));
      }
      return ret;
    }
    function monochromatic(color, results) {
      results = results || 6;
      var hsv = tinycolor2(color).toHsv();
      var h = hsv.h, s = hsv.s, v = hsv.v;
      var ret = [];
      var modification = 1 / results;
      while (results--) {
        ret.push(tinycolor2({ h, s, v }));
        v = (v + modification) % 1;
      }
      return ret;
    }
    tinycolor2.mix = function(color1, color2, amount) {
      amount = amount === 0 ? 0 : amount || 50;
      var rgb1 = tinycolor2(color1).toRgb();
      var rgb2 = tinycolor2(color2).toRgb();
      var p = amount / 100;
      var rgba = {
        r: (rgb2.r - rgb1.r) * p + rgb1.r,
        g: (rgb2.g - rgb1.g) * p + rgb1.g,
        b: (rgb2.b - rgb1.b) * p + rgb1.b,
        a: (rgb2.a - rgb1.a) * p + rgb1.a
      };
      return tinycolor2(rgba);
    };
    tinycolor2.readability = function(color1, color2) {
      var c1 = tinycolor2(color1);
      var c2 = tinycolor2(color2);
      return (Math2.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math2.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
    };
    tinycolor2.isReadable = function(color1, color2, wcag2) {
      var readability = tinycolor2.readability(color1, color2);
      var wcag2Parms, out;
      out = false;
      wcag2Parms = validateWCAG2Parms(wcag2);
      switch (wcag2Parms.level + wcag2Parms.size) {
        case "AAsmall":
        case "AAAlarge":
          out = readability >= 4.5;
          break;
        case "AAlarge":
          out = readability >= 3;
          break;
        case "AAAsmall":
          out = readability >= 7;
          break;
      }
      return out;
    };
    tinycolor2.mostReadable = function(baseColor, colorList, args) {
      var bestColor = null;
      var bestScore = 0;
      var readability;
      var includeFallbackColors, level, size;
      args = args || {};
      includeFallbackColors = args.includeFallbackColors;
      level = args.level;
      size = args.size;
      for (var i = 0; i < colorList.length; i++) {
        readability = tinycolor2.readability(baseColor, colorList[i]);
        if (readability > bestScore) {
          bestScore = readability;
          bestColor = tinycolor2(colorList[i]);
        }
      }
      if (tinycolor2.isReadable(baseColor, bestColor, { "level": level, "size": size }) || !includeFallbackColors) {
        return bestColor;
      } else {
        args.includeFallbackColors = false;
        return tinycolor2.mostReadable(baseColor, ["#fff", "#000"], args);
      }
    };
    var names = tinycolor2.names = {
      aliceblue: "f0f8ff",
      antiquewhite: "faebd7",
      aqua: "0ff",
      aquamarine: "7fffd4",
      azure: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "000",
      blanchedalmond: "ffebcd",
      blue: "00f",
      blueviolet: "8a2be2",
      brown: "a52a2a",
      burlywood: "deb887",
      burntsienna: "ea7e5d",
      cadetblue: "5f9ea0",
      chartreuse: "7fff00",
      chocolate: "d2691e",
      coral: "ff7f50",
      cornflowerblue: "6495ed",
      cornsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "0ff",
      darkblue: "00008b",
      darkcyan: "008b8b",
      darkgoldenrod: "b8860b",
      darkgray: "a9a9a9",
      darkgreen: "006400",
      darkgrey: "a9a9a9",
      darkkhaki: "bdb76b",
      darkmagenta: "8b008b",
      darkolivegreen: "556b2f",
      darkorange: "ff8c00",
      darkorchid: "9932cc",
      darkred: "8b0000",
      darksalmon: "e9967a",
      darkseagreen: "8fbc8f",
      darkslateblue: "483d8b",
      darkslategray: "2f4f4f",
      darkslategrey: "2f4f4f",
      darkturquoise: "00ced1",
      darkviolet: "9400d3",
      deeppink: "ff1493",
      deepskyblue: "00bfff",
      dimgray: "696969",
      dimgrey: "696969",
      dodgerblue: "1e90ff",
      firebrick: "b22222",
      floralwhite: "fffaf0",
      forestgreen: "228b22",
      fuchsia: "f0f",
      gainsboro: "dcdcdc",
      ghostwhite: "f8f8ff",
      gold: "ffd700",
      goldenrod: "daa520",
      gray: "808080",
      green: "008000",
      greenyellow: "adff2f",
      grey: "808080",
      honeydew: "f0fff0",
      hotpink: "ff69b4",
      indianred: "cd5c5c",
      indigo: "4b0082",
      ivory: "fffff0",
      khaki: "f0e68c",
      lavender: "e6e6fa",
      lavenderblush: "fff0f5",
      lawngreen: "7cfc00",
      lemonchiffon: "fffacd",
      lightblue: "add8e6",
      lightcoral: "f08080",
      lightcyan: "e0ffff",
      lightgoldenrodyellow: "fafad2",
      lightgray: "d3d3d3",
      lightgreen: "90ee90",
      lightgrey: "d3d3d3",
      lightpink: "ffb6c1",
      lightsalmon: "ffa07a",
      lightseagreen: "20b2aa",
      lightskyblue: "87cefa",
      lightslategray: "789",
      lightslategrey: "789",
      lightsteelblue: "b0c4de",
      lightyellow: "ffffe0",
      lime: "0f0",
      limegreen: "32cd32",
      linen: "faf0e6",
      magenta: "f0f",
      maroon: "800000",
      mediumaquamarine: "66cdaa",
      mediumblue: "0000cd",
      mediumorchid: "ba55d3",
      mediumpurple: "9370db",
      mediumseagreen: "3cb371",
      mediumslateblue: "7b68ee",
      mediumspringgreen: "00fa9a",
      mediumturquoise: "48d1cc",
      mediumvioletred: "c71585",
      midnightblue: "191970",
      mintcream: "f5fffa",
      mistyrose: "ffe4e1",
      moccasin: "ffe4b5",
      navajowhite: "ffdead",
      navy: "000080",
      oldlace: "fdf5e6",
      olive: "808000",
      olivedrab: "6b8e23",
      orange: "ffa500",
      orangered: "ff4500",
      orchid: "da70d6",
      palegoldenrod: "eee8aa",
      palegreen: "98fb98",
      paleturquoise: "afeeee",
      palevioletred: "db7093",
      papayawhip: "ffefd5",
      peachpuff: "ffdab9",
      peru: "cd853f",
      pink: "ffc0cb",
      plum: "dda0dd",
      powderblue: "b0e0e6",
      purple: "800080",
      rebeccapurple: "663399",
      red: "f00",
      rosybrown: "bc8f8f",
      royalblue: "4169e1",
      saddlebrown: "8b4513",
      salmon: "fa8072",
      sandybrown: "f4a460",
      seagreen: "2e8b57",
      seashell: "fff5ee",
      sienna: "a0522d",
      silver: "c0c0c0",
      skyblue: "87ceeb",
      slateblue: "6a5acd",
      slategray: "708090",
      slategrey: "708090",
      snow: "fffafa",
      springgreen: "00ff7f",
      steelblue: "4682b4",
      tan: "d2b48c",
      teal: "008080",
      thistle: "d8bfd8",
      tomato: "ff6347",
      turquoise: "40e0d0",
      violet: "ee82ee",
      wheat: "f5deb3",
      white: "fff",
      whitesmoke: "f5f5f5",
      yellow: "ff0",
      yellowgreen: "9acd32"
    };
    var hexNames = tinycolor2.hexNames = flip(names);
    function flip(o) {
      var flipped = {};
      for (var i in o) {
        if (o.hasOwnProperty(i)) {
          flipped[o[i]] = i;
        }
      }
      return flipped;
    }
    function boundAlpha(a) {
      a = parseFloat(a);
      if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
      }
      return a;
    }
    function bound01(n, max) {
      if (isOnePointZero(n)) {
        n = "100%";
      }
      var processPercent = isPercentage(n);
      n = mathMin(max, mathMax(0, parseFloat(n)));
      if (processPercent) {
        n = parseInt(n * max, 10) / 100;
      }
      if (Math2.abs(n - max) < 1e-6) {
        return 1;
      }
      return n % max / parseFloat(max);
    }
    function clamp01(val) {
      return mathMin(1, mathMax(0, val));
    }
    function parseIntFromHex(val) {
      return parseInt(val, 16);
    }
    function isOnePointZero(n) {
      return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
    }
    function isPercentage(n) {
      return typeof n === "string" && n.indexOf("%") != -1;
    }
    function pad2(c) {
      return c.length == 1 ? "0" + c : "" + c;
    }
    function convertToPercentage(n) {
      if (n <= 1) {
        n = n * 100 + "%";
      }
      return n;
    }
    function convertDecimalToHex(d) {
      return Math2.round(parseFloat(d) * 255).toString(16);
    }
    function convertHexToDecimal(h) {
      return parseIntFromHex(h) / 255;
    }
    var matchers = function() {
      var CSS_INTEGER = "[-\\+]?\\d+%?";
      var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
      var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
      var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
      var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
      return {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
      };
    }();
    function isValidCSSUnit(color) {
      return !!matchers.CSS_UNIT.exec(color);
    }
    function stringInputToObject(color) {
      color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
      var named = false;
      if (names[color]) {
        color = names[color];
        named = true;
      } else if (color == "transparent") {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
      }
      var match;
      if (match = matchers.rgb.exec(color)) {
        return { r: match[1], g: match[2], b: match[3] };
      }
      if (match = matchers.rgba.exec(color)) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
      }
      if (match = matchers.hsl.exec(color)) {
        return { h: match[1], s: match[2], l: match[3] };
      }
      if (match = matchers.hsla.exec(color)) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
      }
      if (match = matchers.hsv.exec(color)) {
        return { h: match[1], s: match[2], v: match[3] };
      }
      if (match = matchers.hsva.exec(color)) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
      }
      if (match = matchers.hex8.exec(color)) {
        return {
          r: parseIntFromHex(match[1]),
          g: parseIntFromHex(match[2]),
          b: parseIntFromHex(match[3]),
          a: convertHexToDecimal(match[4]),
          format: named ? "name" : "hex8"
        };
      }
      if (match = matchers.hex6.exec(color)) {
        return {
          r: parseIntFromHex(match[1]),
          g: parseIntFromHex(match[2]),
          b: parseIntFromHex(match[3]),
          format: named ? "name" : "hex"
        };
      }
      if (match = matchers.hex4.exec(color)) {
        return {
          r: parseIntFromHex(match[1] + "" + match[1]),
          g: parseIntFromHex(match[2] + "" + match[2]),
          b: parseIntFromHex(match[3] + "" + match[3]),
          a: convertHexToDecimal(match[4] + "" + match[4]),
          format: named ? "name" : "hex8"
        };
      }
      if (match = matchers.hex3.exec(color)) {
        return {
          r: parseIntFromHex(match[1] + "" + match[1]),
          g: parseIntFromHex(match[2] + "" + match[2]),
          b: parseIntFromHex(match[3] + "" + match[3]),
          format: named ? "name" : "hex"
        };
      }
      return false;
    }
    function validateWCAG2Parms(parms) {
      var level, size;
      parms = parms || { "level": "AA", "size": "small" };
      level = (parms.level || "AA").toUpperCase();
      size = (parms.size || "small").toLowerCase();
      if (level !== "AA" && level !== "AAA") {
        level = "AA";
      }
      if (size !== "small" && size !== "large") {
        size = "small";
      }
      return { "level": level, "size": size };
    }
    if (module2.exports) {
      module2.exports = tinycolor2;
    } else {
      window.tinycolor = tinycolor2;
    }
  })(Math);
})(tinycolor$1);
const tinycolor = tinycolorExports;
var simpleCheckForValidColor = function simpleCheckForValidColor2(data) {
  var keysToCheck = ["r", "g", "b", "a", "h", "s", "l", "v"];
  var checked = 0;
  var passed = 0;
  forEach(keysToCheck, function(letter) {
    if (data[letter]) {
      checked += 1;
      if (!isNaN(data[letter])) {
        passed += 1;
      }
      if (letter === "s" || letter === "l") {
        var percentPatt = /^\d+%$/;
        if (percentPatt.test(data[letter])) {
          passed += 1;
        }
      }
    }
  });
  return checked === passed ? data : false;
};
var toState = function toState2(data, oldHue) {
  var color = data.hex ? tinycolor(data.hex) : tinycolor(data);
  var hsl = color.toHsl();
  var hsv = color.toHsv();
  var rgb = color.toRgb();
  var hex = color.toHex();
  if (hsl.s === 0) {
    hsl.h = oldHue || 0;
    hsv.h = oldHue || 0;
  }
  var transparent = hex === "000000" && rgb.a === 0;
  return {
    hsl,
    hex: transparent ? "transparent" : "#" + hex,
    rgb,
    hsv,
    oldHue: data.h || oldHue || hsl.h,
    source: data.source
  };
};
var isValidHex = function isValidHex2(hex) {
  if (hex === "transparent") {
    return true;
  }
  var lh = String(hex).charAt(0) === "#" ? 1 : 0;
  return hex.length !== 4 + lh && hex.length < 7 + lh && tinycolor(hex).isValid();
};
var getContrastingColor = function getContrastingColor2(data) {
  if (!data) {
    return "#fff";
  }
  var col = toState(data);
  if (col.hex === "transparent") {
    return "rgba(0,0,0,0.4)";
  }
  var yiq = (col.rgb.r * 299 + col.rgb.g * 587 + col.rgb.b * 114) / 1e3;
  return yiq >= 128 ? "#000" : "#fff";
};
var isvalidColorString = function isvalidColorString2(string, type) {
  var stringWithoutDegree = string.replace("", "");
  return tinycolor(type + " (" + stringWithoutDegree + ")")._ok;
};
var _extends$8 = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _createClass$3 = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$3(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits$3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var ColorWrap = function ColorWrap2(Picker) {
  var ColorPicker = function(_ref) {
    _inherits$3(ColorPicker2, _ref);
    function ColorPicker2(props) {
      _classCallCheck$3(this, ColorPicker2);
      var _this = _possibleConstructorReturn$3(this, (ColorPicker2.__proto__ || Object.getPrototypeOf(ColorPicker2)).call(this));
      _this.handleChange = function(data, event) {
        var isValidColor = simpleCheckForValidColor(data);
        if (isValidColor) {
          var colors = toState(data, data.h || _this.state.oldHue);
          _this.setState(colors);
          _this.props.onChangeComplete && _this.debounce(_this.props.onChangeComplete, colors, event);
          _this.props.onChange && _this.props.onChange(colors, event);
        }
      };
      _this.handleSwatchHover = function(data, event) {
        var isValidColor = simpleCheckForValidColor(data);
        if (isValidColor) {
          var colors = toState(data, data.h || _this.state.oldHue);
          _this.props.onSwatchHover && _this.props.onSwatchHover(colors, event);
        }
      };
      _this.state = _extends$8({}, toState(props.color, 0));
      _this.debounce = debounce(function(fn, data, event) {
        fn(data, event);
      }, 100);
      return _this;
    }
    _createClass$3(ColorPicker2, [{
      key: "render",
      value: function render3() {
        var optionalEvents = {};
        if (this.props.onSwatchHover) {
          optionalEvents.onSwatchHover = this.handleSwatchHover;
        }
        return React.createElement(Picker, _extends$8({}, this.props, this.state, {
          onChange: this.handleChange
        }, optionalEvents));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(nextProps, state) {
        return _extends$8({}, toState(nextProps.color, state.oldHue));
      }
    }]);
    return ColorPicker2;
  }(reactExports.PureComponent || reactExports.Component);
  ColorPicker.propTypes = _extends$8({}, Picker.propTypes);
  ColorPicker.defaultProps = _extends$8({}, Picker.defaultProps, {
    color: {
      h: 250,
      s: 0.5,
      l: 0.2,
      a: 1
    }
  });
  return ColorPicker;
};
var _extends$7 = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _createClass$2 = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$2(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits$2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var handleFocus = function handleFocus2(Component) {
  var Span = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
  return function(_React$Component) {
    _inherits$2(Focus, _React$Component);
    function Focus() {
      var _ref;
      var _temp, _this, _ret;
      _classCallCheck$2(this, Focus);
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _ret = (_temp = (_this = _possibleConstructorReturn$2(this, (_ref = Focus.__proto__ || Object.getPrototypeOf(Focus)).call.apply(_ref, [this].concat(args))), _this), _this.state = { focus: false }, _this.handleFocus = function() {
        return _this.setState({ focus: true });
      }, _this.handleBlur = function() {
        return _this.setState({ focus: false });
      }, _temp), _possibleConstructorReturn$2(_this, _ret);
    }
    _createClass$2(Focus, [{
      key: "render",
      value: function render3() {
        return React.createElement(
          Span,
          { onFocus: this.handleFocus, onBlur: this.handleBlur },
          React.createElement(Component, _extends$7({}, this.props, this.state))
        );
      }
    }]);
    return Focus;
  }(React.Component);
};
var _extends$6 = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var ENTER = 13;
var Swatch = function Swatch2(_ref) {
  var color = _ref.color, style = _ref.style, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, onHover = _ref.onHover, _ref$title = _ref.title, title = _ref$title === void 0 ? color : _ref$title, children = _ref.children, focus = _ref.focus, _ref$focusStyle = _ref.focusStyle, focusStyle = _ref$focusStyle === void 0 ? {} : _ref$focusStyle;
  var transparent = color === "transparent";
  var styles = _default$2({
    default: {
      swatch: _extends$6({
        background: color,
        height: "100%",
        width: "100%",
        cursor: "pointer",
        position: "relative",
        outline: "none"
      }, style, focus ? focusStyle : {})
    }
  });
  var handleClick = function handleClick2(e) {
    return onClick(color, e);
  };
  var handleKeyDown = function handleKeyDown2(e) {
    return e.keyCode === ENTER && onClick(color, e);
  };
  var handleHover2 = function handleHover3(e) {
    return onHover(color, e);
  };
  var optionalEvents = {};
  if (onHover) {
    optionalEvents.onMouseOver = handleHover2;
  }
  return React.createElement(
    "div",
    _extends$6({
      style: styles.swatch,
      onClick: handleClick,
      title,
      tabIndex: 0,
      onKeyDown: handleKeyDown
    }, optionalEvents),
    children,
    transparent && React.createElement(Checkboard, {
      borderRadius: styles.swatch.borderRadius,
      boxShadow: "inset 0 0 0 1px rgba(0,0,0,0.1)"
    })
  );
};
const Swatch$1 = handleFocus(Swatch);
var AlphaPointer = function AlphaPointer2(_ref) {
  var direction = _ref.direction;
  var styles = _default$2({
    "default": {
      picker: {
        width: "18px",
        height: "18px",
        borderRadius: "50%",
        transform: "translate(-9px, -1px)",
        backgroundColor: "rgb(248, 248, 248)",
        boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
      }
    },
    "vertical": {
      picker: {
        transform: "translate(-3px, -9px)"
      }
    }
  }, { vertical: direction === "vertical" });
  return React.createElement("div", { style: styles.picker });
};
var _extends$5 = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var AlphaPicker = function AlphaPicker2(_ref) {
  var rgb = _ref.rgb, hsl = _ref.hsl, width = _ref.width, height = _ref.height, onChange = _ref.onChange, direction = _ref.direction, style = _ref.style, renderers = _ref.renderers, pointer = _ref.pointer, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles = _default$2({
    "default": {
      picker: {
        position: "relative",
        width,
        height
      },
      alpha: {
        radius: "2px",
        style
      }
    }
  });
  return React.createElement(
    "div",
    { style: styles.picker, className: "alpha-picker " + className },
    React.createElement(Alpha, _extends$5({}, styles.alpha, {
      rgb,
      hsl,
      pointer,
      renderers,
      onChange,
      direction
    }))
  );
};
AlphaPicker.defaultProps = {
  width: "316px",
  height: "16px",
  direction: "horizontal",
  pointer: AlphaPointer
};
ColorWrap(AlphaPicker);
function arrayMap(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
function setCacheHas(value) {
  return this.__data__.has(value);
}
function SetCache(values) {
  var index = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();
  while (++index < length) {
    this.add(values[index]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}
function cacheHas(cache, key) {
  return cache.has(key);
}
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index < arrLength) {
    var arrValue = array[index], othValue = other[index];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
function mapToArray(map2) {
  var index = -1, result = Array(map2.size);
  map2.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}
function setToArray(set) {
  var index = -1, result = Array(set.size);
  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag$1 = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]";
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$1:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$2(object), new Uint8Array$2(other))) {
        return false;
      }
      return true;
    case boolTag:
    case dateTag:
    case numberTag:
      return eq(+object, +other);
    case errorTag:
      return object.name == other.name && object.message == other.message;
    case regexpTag:
    case stringTag:
      return object == other + "";
    case mapTag$1:
      var convert = mapToArray;
    case setTag$1:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
function arrayPush(array, values) {
  var index = -1, length = values.length, offset = array.length;
  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
}
function arrayFilter(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
function stubArray() {
  return [];
}
var objectProto$2 = Object.prototype;
var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
const getSymbols$1 = getSymbols;
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols$1);
}
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var DataView = getNative(root$1, "DataView");
const DataView$1 = DataView;
var Promise$1 = getNative(root$1, "Promise");
const Promise$2 = Promise$1;
var Set$1 = getNative(root$1, "Set");
const Set$2 = Set$1;
var WeakMap = getNative(root$1, "WeakMap");
const WeakMap$1 = WeakMap;
var mapTag = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
var dataViewTag = "[object DataView]";
var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$1);
var getTag = baseGetTag;
if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag || Map$1 && getTag(new Map$1()) != mapTag || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag) {
  getTag = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}
const getTag$1 = getTag;
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$1(object), othIsArr = isArray$1(other), objTag = objIsArr ? arrayTag : getTag$1(object), othTag = othIsArr ? arrayTag : getTag$1(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$1(object)) {
    if (!isBuffer$1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray$1(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length, length = index, noCustomizer = !customizer;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
function isStrictComparable(value) {
  return value === value && !isObject(value);
}
function getMatchData(object) {
  var result = keys(object), length = result.length;
  while (length--) {
    var key = result[length], value = object[key];
    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray$1(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
const stringToPath$1 = stringToPath;
var INFINITY$1 = 1 / 0;
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$1(value)) {
    return arrayMap(value, baseToString) + "";
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function castPath(value, object) {
  if (isArray$1(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath$1(toString(value));
}
var INFINITY = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function baseGet(object, path) {
  path = castPath(path, object);
  var index = 0, length = path.length;
  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return index && index == length ? object : void 0;
}
function get2(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet(object, path);
  return result === void 0 ? defaultValue : result;
}
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index = -1, length = path.length, result = false;
  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray$1(object) || isArguments$1(object));
}
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get2(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == "object") {
    return isArray$1(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
function baseMap(collection, iteratee) {
  var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
  baseEach$1(collection, function(value, key, collection2) {
    result[++index] = iteratee(value, key, collection2);
  });
  return result;
}
function map(collection, iteratee) {
  var func = isArray$1(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee));
}
var BlockSwatches = function BlockSwatches2(_ref) {
  var colors = _ref.colors, onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover;
  var styles = _default$2({
    "default": {
      swatches: {
        marginRight: "-10px"
      },
      swatch: {
        width: "22px",
        height: "22px",
        float: "left",
        marginRight: "10px",
        marginBottom: "10px",
        borderRadius: "4px"
      },
      clear: {
        clear: "both"
      }
    }
  });
  return React.createElement(
    "div",
    { style: styles.swatches },
    map(colors, function(c) {
      return React.createElement(Swatch$1, {
        key: c,
        color: c,
        style: styles.swatch,
        onClick,
        onHover: onSwatchHover,
        focusStyle: {
          boxShadow: "0 0 4px " + c
        }
      });
    }),
    React.createElement("div", { style: styles.clear })
  );
};
var Block = function Block2(_ref) {
  var onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, hex = _ref.hex, colors = _ref.colors, width = _ref.width, triangle = _ref.triangle, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var transparent = hex === "transparent";
  var handleChange = function handleChange2(hexCode, e) {
    isValidHex(hexCode) && onChange({
      hex: hexCode,
      source: "hex"
    }, e);
  };
  var styles = _default$2(merge$1({
    "default": {
      card: {
        width,
        background: "#fff",
        boxShadow: "0 1px rgba(0,0,0,.1)",
        borderRadius: "6px",
        position: "relative"
      },
      head: {
        height: "110px",
        background: hex,
        borderRadius: "6px 6px 0 0",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        position: "relative"
      },
      body: {
        padding: "10px"
      },
      label: {
        fontSize: "18px",
        color: getContrastingColor(hex),
        position: "relative"
      },
      triangle: {
        width: "0px",
        height: "0px",
        borderStyle: "solid",
        borderWidth: "0 10px 10px 10px",
        borderColor: "transparent transparent " + hex + " transparent",
        position: "absolute",
        top: "-10px",
        left: "50%",
        marginLeft: "-10px"
      },
      input: {
        width: "100%",
        fontSize: "12px",
        color: "#666",
        border: "0px",
        outline: "none",
        height: "22px",
        boxShadow: "inset 0 0 0 1px #ddd",
        borderRadius: "4px",
        padding: "0 7px",
        boxSizing: "border-box"
      }
    },
    "hide-triangle": {
      triangle: {
        display: "none"
      }
    }
  }, passedStyles), { "hide-triangle": triangle === "hide" });
  return React.createElement(
    "div",
    { style: styles.card, className: "block-picker " + className },
    React.createElement("div", { style: styles.triangle }),
    React.createElement(
      "div",
      { style: styles.head },
      transparent && React.createElement(Checkboard, { borderRadius: "6px 6px 0 0" }),
      React.createElement(
        "div",
        { style: styles.label },
        hex
      )
    ),
    React.createElement(
      "div",
      { style: styles.body },
      React.createElement(BlockSwatches, { colors, onClick: handleChange, onSwatchHover }),
      React.createElement(EditableInput, {
        style: { input: styles.input },
        value: hex,
        onChange: handleChange
      })
    )
  );
};
Block.propTypes = {
  width: propTypesExports.oneOfType([propTypesExports.string, propTypesExports.number]),
  colors: propTypesExports.arrayOf(propTypesExports.string),
  triangle: propTypesExports.oneOf(["top", "hide"]),
  styles: propTypesExports.object
};
Block.defaultProps = {
  width: 170,
  colors: ["#D9E3F0", "#F47373", "#697689", "#37D67A", "#2CCCE4", "#555555", "#dce775", "#ff8a65", "#ba68c8"],
  triangle: "top",
  styles: {}
};
ColorWrap(Block);
var red = { "50": "#ffebee", "100": "#ffcdd2", "200": "#ef9a9a", "300": "#e57373", "400": "#ef5350", "500": "#f44336", "600": "#e53935", "700": "#d32f2f", "800": "#c62828", "900": "#b71c1c", "a100": "#ff8a80", "a200": "#ff5252", "a400": "#ff1744", "a700": "#d50000" };
var pink = { "50": "#fce4ec", "100": "#f8bbd0", "200": "#f48fb1", "300": "#f06292", "400": "#ec407a", "500": "#e91e63", "600": "#d81b60", "700": "#c2185b", "800": "#ad1457", "900": "#880e4f", "a100": "#ff80ab", "a200": "#ff4081", "a400": "#f50057", "a700": "#c51162" };
var purple = { "50": "#f3e5f5", "100": "#e1bee7", "200": "#ce93d8", "300": "#ba68c8", "400": "#ab47bc", "500": "#9c27b0", "600": "#8e24aa", "700": "#7b1fa2", "800": "#6a1b9a", "900": "#4a148c", "a100": "#ea80fc", "a200": "#e040fb", "a400": "#d500f9", "a700": "#aa00ff" };
var deepPurple = { "50": "#ede7f6", "100": "#d1c4e9", "200": "#b39ddb", "300": "#9575cd", "400": "#7e57c2", "500": "#673ab7", "600": "#5e35b1", "700": "#512da8", "800": "#4527a0", "900": "#311b92", "a100": "#b388ff", "a200": "#7c4dff", "a400": "#651fff", "a700": "#6200ea" };
var indigo = { "50": "#e8eaf6", "100": "#c5cae9", "200": "#9fa8da", "300": "#7986cb", "400": "#5c6bc0", "500": "#3f51b5", "600": "#3949ab", "700": "#303f9f", "800": "#283593", "900": "#1a237e", "a100": "#8c9eff", "a200": "#536dfe", "a400": "#3d5afe", "a700": "#304ffe" };
var blue = { "50": "#e3f2fd", "100": "#bbdefb", "200": "#90caf9", "300": "#64b5f6", "400": "#42a5f5", "500": "#2196f3", "600": "#1e88e5", "700": "#1976d2", "800": "#1565c0", "900": "#0d47a1", "a100": "#82b1ff", "a200": "#448aff", "a400": "#2979ff", "a700": "#2962ff" };
var lightBlue = { "50": "#e1f5fe", "100": "#b3e5fc", "200": "#81d4fa", "300": "#4fc3f7", "400": "#29b6f6", "500": "#03a9f4", "600": "#039be5", "700": "#0288d1", "800": "#0277bd", "900": "#01579b", "a100": "#80d8ff", "a200": "#40c4ff", "a400": "#00b0ff", "a700": "#0091ea" };
var cyan = { "50": "#e0f7fa", "100": "#b2ebf2", "200": "#80deea", "300": "#4dd0e1", "400": "#26c6da", "500": "#00bcd4", "600": "#00acc1", "700": "#0097a7", "800": "#00838f", "900": "#006064", "a100": "#84ffff", "a200": "#18ffff", "a400": "#00e5ff", "a700": "#00b8d4" };
var teal = { "50": "#e0f2f1", "100": "#b2dfdb", "200": "#80cbc4", "300": "#4db6ac", "400": "#26a69a", "500": "#009688", "600": "#00897b", "700": "#00796b", "800": "#00695c", "900": "#004d40", "a100": "#a7ffeb", "a200": "#64ffda", "a400": "#1de9b6", "a700": "#00bfa5" };
var green = { "50": "#e8f5e9", "100": "#c8e6c9", "200": "#a5d6a7", "300": "#81c784", "400": "#66bb6a", "500": "#4caf50", "600": "#43a047", "700": "#388e3c", "800": "#2e7d32", "900": "#1b5e20", "a100": "#b9f6ca", "a200": "#69f0ae", "a400": "#00e676", "a700": "#00c853" };
var lightGreen = { "50": "#f1f8e9", "100": "#dcedc8", "200": "#c5e1a5", "300": "#aed581", "400": "#9ccc65", "500": "#8bc34a", "600": "#7cb342", "700": "#689f38", "800": "#558b2f", "900": "#33691e", "a100": "#ccff90", "a200": "#b2ff59", "a400": "#76ff03", "a700": "#64dd17" };
var lime = { "50": "#f9fbe7", "100": "#f0f4c3", "200": "#e6ee9c", "300": "#dce775", "400": "#d4e157", "500": "#cddc39", "600": "#c0ca33", "700": "#afb42b", "800": "#9e9d24", "900": "#827717", "a100": "#f4ff81", "a200": "#eeff41", "a400": "#c6ff00", "a700": "#aeea00" };
var yellow = { "50": "#fffde7", "100": "#fff9c4", "200": "#fff59d", "300": "#fff176", "400": "#ffee58", "500": "#ffeb3b", "600": "#fdd835", "700": "#fbc02d", "800": "#f9a825", "900": "#f57f17", "a100": "#ffff8d", "a200": "#ffff00", "a400": "#ffea00", "a700": "#ffd600" };
var amber = { "50": "#fff8e1", "100": "#ffecb3", "200": "#ffe082", "300": "#ffd54f", "400": "#ffca28", "500": "#ffc107", "600": "#ffb300", "700": "#ffa000", "800": "#ff8f00", "900": "#ff6f00", "a100": "#ffe57f", "a200": "#ffd740", "a400": "#ffc400", "a700": "#ffab00" };
var orange = { "50": "#fff3e0", "100": "#ffe0b2", "200": "#ffcc80", "300": "#ffb74d", "400": "#ffa726", "500": "#ff9800", "600": "#fb8c00", "700": "#f57c00", "800": "#ef6c00", "900": "#e65100", "a100": "#ffd180", "a200": "#ffab40", "a400": "#ff9100", "a700": "#ff6d00" };
var deepOrange = { "50": "#fbe9e7", "100": "#ffccbc", "200": "#ffab91", "300": "#ff8a65", "400": "#ff7043", "500": "#ff5722", "600": "#f4511e", "700": "#e64a19", "800": "#d84315", "900": "#bf360c", "a100": "#ff9e80", "a200": "#ff6e40", "a400": "#ff3d00", "a700": "#dd2c00" };
var brown = { "50": "#efebe9", "100": "#d7ccc8", "200": "#bcaaa4", "300": "#a1887f", "400": "#8d6e63", "500": "#795548", "600": "#6d4c41", "700": "#5d4037", "800": "#4e342e", "900": "#3e2723" };
var blueGrey = { "50": "#eceff1", "100": "#cfd8dc", "200": "#b0bec5", "300": "#90a4ae", "400": "#78909c", "500": "#607d8b", "600": "#546e7a", "700": "#455a64", "800": "#37474f", "900": "#263238" };
var CircleSwatch = function CircleSwatch2(_ref) {
  var color = _ref.color, onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover, hover3 = _ref.hover, active3 = _ref.active, circleSize = _ref.circleSize, circleSpacing = _ref.circleSpacing;
  var styles = _default$2({
    "default": {
      swatch: {
        width: circleSize,
        height: circleSize,
        marginRight: circleSpacing,
        marginBottom: circleSpacing,
        transform: "scale(1)",
        transition: "100ms transform ease"
      },
      Swatch: {
        borderRadius: "50%",
        background: "transparent",
        boxShadow: "inset 0 0 0 " + (circleSize / 2 + 1) + "px " + color,
        transition: "100ms box-shadow ease"
      }
    },
    "hover": {
      swatch: {
        transform: "scale(1.2)"
      }
    },
    "active": {
      Swatch: {
        boxShadow: "inset 0 0 0 3px " + color
      }
    }
  }, { hover: hover3, active: active3 });
  return React.createElement(
    "div",
    { style: styles.swatch },
    React.createElement(Swatch$1, {
      style: styles.Swatch,
      color,
      onClick,
      onHover: onSwatchHover,
      focusStyle: { boxShadow: styles.Swatch.boxShadow + ", 0 0 5px " + color }
    })
  );
};
CircleSwatch.defaultProps = {
  circleSize: 28,
  circleSpacing: 14
};
const CircleSwatch$1 = handleHover(CircleSwatch);
var Circle = function Circle2(_ref) {
  var width = _ref.width, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, colors = _ref.colors, hex = _ref.hex, circleSize = _ref.circleSize, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, circleSpacing = _ref.circleSpacing, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles = _default$2(merge$1({
    "default": {
      card: {
        width,
        display: "flex",
        flexWrap: "wrap",
        marginRight: -circleSpacing,
        marginBottom: -circleSpacing
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(hexCode, e) {
    return onChange({ hex: hexCode, source: "hex" }, e);
  };
  return React.createElement(
    "div",
    { style: styles.card, className: "circle-picker " + className },
    map(colors, function(c) {
      return React.createElement(CircleSwatch$1, {
        key: c,
        color: c,
        onClick: handleChange,
        onSwatchHover,
        active: hex === c.toLowerCase(),
        circleSize,
        circleSpacing
      });
    })
  );
};
Circle.propTypes = {
  width: propTypesExports.oneOfType([propTypesExports.string, propTypesExports.number]),
  circleSize: propTypesExports.number,
  circleSpacing: propTypesExports.number,
  styles: propTypesExports.object
};
Circle.defaultProps = {
  width: 252,
  circleSize: 28,
  circleSpacing: 14,
  colors: [red["500"], pink["500"], purple["500"], deepPurple["500"], indigo["500"], blue["500"], lightBlue["500"], cyan["500"], teal["500"], green["500"], lightGreen["500"], lime["500"], yellow["500"], amber["500"], orange["500"], deepOrange["500"], brown["500"], blueGrey["500"]],
  styles: {}
};
ColorWrap(Circle);
function isUndefined(value) {
  return value === void 0;
}
var UnfoldMoreHorizontalIcon = {};
Object.defineProperty(UnfoldMoreHorizontalIcon, "__esModule", {
  value: true
});
var _extends$4 = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _react$1 = reactExports;
var _react2$1 = _interopRequireDefault$1(_react$1);
function _interopRequireDefault$1(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _objectWithoutProperties$1(obj, keys2) {
  var target = {};
  for (var i in obj) {
    if (keys2.indexOf(i) >= 0)
      continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i))
      continue;
    target[i] = obj[i];
  }
  return target;
}
var DEFAULT_SIZE$1 = 24;
var _default$1 = UnfoldMoreHorizontalIcon.default = function(_ref) {
  var _ref$fill = _ref.fill, fill = _ref$fill === void 0 ? "currentColor" : _ref$fill, _ref$width = _ref.width, width = _ref$width === void 0 ? DEFAULT_SIZE$1 : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? DEFAULT_SIZE$1 : _ref$height, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style, props = _objectWithoutProperties$1(_ref, ["fill", "width", "height", "style"]);
  return _react2$1.default.createElement(
    "svg",
    _extends$4({
      viewBox: "0 0 " + DEFAULT_SIZE$1 + " " + DEFAULT_SIZE$1,
      style: _extends$4({ fill, width, height }, style)
    }, props),
    _react2$1.default.createElement("path", { d: "M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z" })
  );
};
var _createClass$1 = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$1(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var ChromeFields = function(_React$Component) {
  _inherits$1(ChromeFields2, _React$Component);
  function ChromeFields2(props) {
    _classCallCheck$1(this, ChromeFields2);
    var _this = _possibleConstructorReturn$1(this, (ChromeFields2.__proto__ || Object.getPrototypeOf(ChromeFields2)).call(this));
    _this.toggleViews = function() {
      if (_this.state.view === "hex") {
        _this.setState({ view: "rgb" });
      } else if (_this.state.view === "rgb") {
        _this.setState({ view: "hsl" });
      } else if (_this.state.view === "hsl") {
        if (_this.props.hsl.a === 1) {
          _this.setState({ view: "hex" });
        } else {
          _this.setState({ view: "rgb" });
        }
      }
    };
    _this.handleChange = function(data, e) {
      if (data.hex) {
        isValidHex(data.hex) && _this.props.onChange({
          hex: data.hex,
          source: "hex"
        }, e);
      } else if (data.r || data.g || data.b) {
        _this.props.onChange({
          r: data.r || _this.props.rgb.r,
          g: data.g || _this.props.rgb.g,
          b: data.b || _this.props.rgb.b,
          source: "rgb"
        }, e);
      } else if (data.a) {
        if (data.a < 0) {
          data.a = 0;
        } else if (data.a > 1) {
          data.a = 1;
        }
        _this.props.onChange({
          h: _this.props.hsl.h,
          s: _this.props.hsl.s,
          l: _this.props.hsl.l,
          a: Math.round(data.a * 100) / 100,
          source: "rgb"
        }, e);
      } else if (data.h || data.s || data.l) {
        if (typeof data.s === "string" && data.s.includes("%")) {
          data.s = data.s.replace("%", "");
        }
        if (typeof data.l === "string" && data.l.includes("%")) {
          data.l = data.l.replace("%", "");
        }
        if (data.s == 1) {
          data.s = 0.01;
        } else if (data.l == 1) {
          data.l = 0.01;
        }
        _this.props.onChange({
          h: data.h || _this.props.hsl.h,
          s: Number(!isUndefined(data.s) ? data.s : _this.props.hsl.s),
          l: Number(!isUndefined(data.l) ? data.l : _this.props.hsl.l),
          source: "hsl"
        }, e);
      }
    };
    _this.showHighlight = function(e) {
      e.currentTarget.style.background = "#eee";
    };
    _this.hideHighlight = function(e) {
      e.currentTarget.style.background = "transparent";
    };
    if (props.hsl.a !== 1 && props.view === "hex") {
      _this.state = {
        view: "rgb"
      };
    } else {
      _this.state = {
        view: props.view
      };
    }
    return _this;
  }
  _createClass$1(ChromeFields2, [{
    key: "render",
    value: function render3() {
      var _this2 = this;
      var styles = _default$2({
        "default": {
          wrap: {
            paddingTop: "16px",
            display: "flex"
          },
          fields: {
            flex: "1",
            display: "flex",
            marginLeft: "-6px"
          },
          field: {
            paddingLeft: "6px",
            width: "100%"
          },
          alpha: {
            paddingLeft: "6px",
            width: "100%"
          },
          toggle: {
            width: "32px",
            textAlign: "right",
            position: "relative"
          },
          icon: {
            marginRight: "-4px",
            marginTop: "12px",
            cursor: "pointer",
            position: "relative"
          },
          iconHighlight: {
            position: "absolute",
            width: "24px",
            height: "28px",
            background: "#eee",
            borderRadius: "4px",
            top: "10px",
            left: "12px",
            display: "none"
          },
          input: {
            fontSize: "11px",
            color: "#333",
            width: "100%",
            borderRadius: "2px",
            border: "none",
            boxShadow: "inset 0 0 0 1px #dadada",
            height: "21px",
            textAlign: "center"
          },
          label: {
            textTransform: "uppercase",
            fontSize: "11px",
            lineHeight: "11px",
            color: "#969696",
            textAlign: "center",
            display: "block",
            marginTop: "12px"
          },
          svg: {
            fill: "#333",
            width: "24px",
            height: "24px",
            border: "1px transparent solid",
            borderRadius: "5px"
          }
        },
        "disableAlpha": {
          alpha: {
            display: "none"
          }
        }
      }, this.props, this.state);
      var fields = void 0;
      if (this.state.view === "hex") {
        fields = React.createElement(
          "div",
          { style: styles.fields, className: "flexbox-fix" },
          React.createElement(
            "div",
            { style: styles.field },
            React.createElement(EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: "hex",
              value: this.props.hex,
              onChange: this.handleChange
            })
          )
        );
      } else if (this.state.view === "rgb") {
        fields = React.createElement(
          "div",
          { style: styles.fields, className: "flexbox-fix" },
          React.createElement(
            "div",
            { style: styles.field },
            React.createElement(EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: "r",
              value: this.props.rgb.r,
              onChange: this.handleChange
            })
          ),
          React.createElement(
            "div",
            { style: styles.field },
            React.createElement(EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: "g",
              value: this.props.rgb.g,
              onChange: this.handleChange
            })
          ),
          React.createElement(
            "div",
            { style: styles.field },
            React.createElement(EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: "b",
              value: this.props.rgb.b,
              onChange: this.handleChange
            })
          ),
          React.createElement(
            "div",
            { style: styles.alpha },
            React.createElement(EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: "a",
              value: this.props.rgb.a,
              arrowOffset: 0.01,
              onChange: this.handleChange
            })
          )
        );
      } else if (this.state.view === "hsl") {
        fields = React.createElement(
          "div",
          { style: styles.fields, className: "flexbox-fix" },
          React.createElement(
            "div",
            { style: styles.field },
            React.createElement(EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: "h",
              value: Math.round(this.props.hsl.h),
              onChange: this.handleChange
            })
          ),
          React.createElement(
            "div",
            { style: styles.field },
            React.createElement(EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: "s",
              value: Math.round(this.props.hsl.s * 100) + "%",
              onChange: this.handleChange
            })
          ),
          React.createElement(
            "div",
            { style: styles.field },
            React.createElement(EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: "l",
              value: Math.round(this.props.hsl.l * 100) + "%",
              onChange: this.handleChange
            })
          ),
          React.createElement(
            "div",
            { style: styles.alpha },
            React.createElement(EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: "a",
              value: this.props.hsl.a,
              arrowOffset: 0.01,
              onChange: this.handleChange
            })
          )
        );
      }
      return React.createElement(
        "div",
        { style: styles.wrap, className: "flexbox-fix" },
        fields,
        React.createElement(
          "div",
          { style: styles.toggle },
          React.createElement(
            "div",
            { style: styles.icon, onClick: this.toggleViews, ref: function ref(icon) {
              return _this2.icon = icon;
            } },
            React.createElement(_default$1, {
              style: styles.svg,
              onMouseOver: this.showHighlight,
              onMouseEnter: this.showHighlight,
              onMouseOut: this.hideHighlight
            })
          )
        )
      );
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, state) {
      if (nextProps.hsl.a !== 1 && state.view === "hex") {
        return { view: "rgb" };
      }
      return null;
    }
  }]);
  return ChromeFields2;
}(React.Component);
ChromeFields.defaultProps = {
  view: "hex"
};
var ChromePointer = function ChromePointer2() {
  var styles = _default$2({
    "default": {
      picker: {
        width: "12px",
        height: "12px",
        borderRadius: "6px",
        transform: "translate(-6px, -1px)",
        backgroundColor: "rgb(248, 248, 248)",
        boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
      }
    }
  });
  return React.createElement("div", { style: styles.picker });
};
var ChromePointerCircle = function ChromePointerCircle2() {
  var styles = _default$2({
    "default": {
      picker: {
        width: "12px",
        height: "12px",
        borderRadius: "6px",
        boxShadow: "inset 0 0 0 1px #fff",
        transform: "translate(-6px, -6px)"
      }
    }
  });
  return React.createElement("div", { style: styles.picker });
};
var Chrome = function Chrome2(_ref) {
  var width = _ref.width, onChange = _ref.onChange, disableAlpha = _ref.disableAlpha, rgb = _ref.rgb, hsl = _ref.hsl, hsv = _ref.hsv, hex = _ref.hex, renderers = _ref.renderers, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className, defaultView = _ref.defaultView;
  var styles = _default$2(merge$1({
    "default": {
      picker: {
        width,
        background: "#fff",
        borderRadius: "2px",
        boxShadow: "0 0 2px rgba(0,0,0,.3), 0 4px 8px rgba(0,0,0,.3)",
        boxSizing: "initial",
        fontFamily: "Menlo"
      },
      saturation: {
        width: "100%",
        paddingBottom: "55%",
        position: "relative",
        borderRadius: "2px 2px 0 0",
        overflow: "hidden"
      },
      Saturation: {
        radius: "2px 2px 0 0"
      },
      body: {
        padding: "16px 16px 12px"
      },
      controls: {
        display: "flex"
      },
      color: {
        width: "32px"
      },
      swatch: {
        marginTop: "6px",
        width: "16px",
        height: "16px",
        borderRadius: "8px",
        position: "relative",
        overflow: "hidden"
      },
      active: {
        absolute: "0px 0px 0px 0px",
        borderRadius: "8px",
        boxShadow: "inset 0 0 0 1px rgba(0,0,0,.1)",
        background: "rgba(" + rgb.r + ", " + rgb.g + ", " + rgb.b + ", " + rgb.a + ")",
        zIndex: "2"
      },
      toggles: {
        flex: "1"
      },
      hue: {
        height: "10px",
        position: "relative",
        marginBottom: "8px"
      },
      Hue: {
        radius: "2px"
      },
      alpha: {
        height: "10px",
        position: "relative"
      },
      Alpha: {
        radius: "2px"
      }
    },
    "disableAlpha": {
      color: {
        width: "22px"
      },
      alpha: {
        display: "none"
      },
      hue: {
        marginBottom: "0px"
      },
      swatch: {
        width: "10px",
        height: "10px",
        marginTop: "0px"
      }
    }
  }, passedStyles), { disableAlpha });
  return React.createElement(
    "div",
    { style: styles.picker, className: "chrome-picker " + className },
    React.createElement(
      "div",
      { style: styles.saturation },
      React.createElement(Saturation, {
        style: styles.Saturation,
        hsl,
        hsv,
        pointer: ChromePointerCircle,
        onChange
      })
    ),
    React.createElement(
      "div",
      { style: styles.body },
      React.createElement(
        "div",
        { style: styles.controls, className: "flexbox-fix" },
        React.createElement(
          "div",
          { style: styles.color },
          React.createElement(
            "div",
            { style: styles.swatch },
            React.createElement("div", { style: styles.active }),
            React.createElement(Checkboard, { renderers })
          )
        ),
        React.createElement(
          "div",
          { style: styles.toggles },
          React.createElement(
            "div",
            { style: styles.hue },
            React.createElement(Hue, {
              style: styles.Hue,
              hsl,
              pointer: ChromePointer,
              onChange
            })
          ),
          React.createElement(
            "div",
            { style: styles.alpha },
            React.createElement(Alpha, {
              style: styles.Alpha,
              rgb,
              hsl,
              pointer: ChromePointer,
              renderers,
              onChange
            })
          )
        )
      ),
      React.createElement(ChromeFields, {
        rgb,
        hsl,
        hex,
        view: defaultView,
        onChange,
        disableAlpha
      })
    )
  );
};
Chrome.propTypes = {
  width: propTypesExports.oneOfType([propTypesExports.string, propTypesExports.number]),
  disableAlpha: propTypesExports.bool,
  styles: propTypesExports.object,
  defaultView: propTypesExports.oneOf(["hex", "rgb", "hsl"])
};
Chrome.defaultProps = {
  width: 225,
  disableAlpha: false,
  styles: {}
};
ColorWrap(Chrome);
var CompactColor = function CompactColor2(_ref) {
  var color = _ref.color, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, onSwatchHover = _ref.onSwatchHover, active3 = _ref.active;
  var styles = _default$2({
    "default": {
      color: {
        background: color,
        width: "15px",
        height: "15px",
        float: "left",
        marginRight: "5px",
        marginBottom: "5px",
        position: "relative",
        cursor: "pointer"
      },
      dot: {
        absolute: "5px 5px 5px 5px",
        background: getContrastingColor(color),
        borderRadius: "50%",
        opacity: "0"
      }
    },
    "active": {
      dot: {
        opacity: "1"
      }
    },
    "color-#FFFFFF": {
      color: {
        boxShadow: "inset 0 0 0 1px #ddd"
      },
      dot: {
        background: "#000"
      }
    },
    "transparent": {
      dot: {
        background: "#000"
      }
    }
  }, { active: active3, "color-#FFFFFF": color === "#FFFFFF", "transparent": color === "transparent" });
  return React.createElement(
    Swatch$1,
    {
      style: styles.color,
      color,
      onClick,
      onHover: onSwatchHover,
      focusStyle: { boxShadow: "0 0 4px " + color }
    },
    React.createElement("div", { style: styles.dot })
  );
};
var CompactFields = function CompactFields2(_ref) {
  var hex = _ref.hex, rgb = _ref.rgb, onChange = _ref.onChange;
  var styles = _default$2({
    "default": {
      fields: {
        display: "flex",
        paddingBottom: "6px",
        paddingRight: "5px",
        position: "relative"
      },
      active: {
        position: "absolute",
        top: "6px",
        left: "5px",
        height: "9px",
        width: "9px",
        background: hex
      },
      HEXwrap: {
        flex: "6",
        position: "relative"
      },
      HEXinput: {
        width: "80%",
        padding: "0px",
        paddingLeft: "20%",
        border: "none",
        outline: "none",
        background: "none",
        fontSize: "12px",
        color: "#333",
        height: "16px"
      },
      HEXlabel: {
        display: "none"
      },
      RGBwrap: {
        flex: "3",
        position: "relative"
      },
      RGBinput: {
        width: "70%",
        padding: "0px",
        paddingLeft: "30%",
        border: "none",
        outline: "none",
        background: "none",
        fontSize: "12px",
        color: "#333",
        height: "16px"
      },
      RGBlabel: {
        position: "absolute",
        top: "3px",
        left: "0px",
        lineHeight: "16px",
        textTransform: "uppercase",
        fontSize: "12px",
        color: "#999"
      }
    }
  });
  var handleChange = function handleChange2(data, e) {
    if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        source: "rgb"
      }, e);
    } else {
      onChange({
        hex: data.hex,
        source: "hex"
      }, e);
    }
  };
  return React.createElement(
    "div",
    { style: styles.fields, className: "flexbox-fix" },
    React.createElement("div", { style: styles.active }),
    React.createElement(EditableInput, {
      style: { wrap: styles.HEXwrap, input: styles.HEXinput, label: styles.HEXlabel },
      label: "hex",
      value: hex,
      onChange: handleChange
    }),
    React.createElement(EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: "r",
      value: rgb.r,
      onChange: handleChange
    }),
    React.createElement(EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: "g",
      value: rgb.g,
      onChange: handleChange
    }),
    React.createElement(EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: "b",
      value: rgb.b,
      onChange: handleChange
    })
  );
};
var Compact = function Compact2(_ref) {
  var onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, colors = _ref.colors, hex = _ref.hex, rgb = _ref.rgb, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles = _default$2(merge$1({
    "default": {
      Compact: {
        background: "#f6f6f6",
        radius: "4px"
      },
      compact: {
        paddingTop: "5px",
        paddingLeft: "5px",
        boxSizing: "initial",
        width: "240px"
      },
      clear: {
        clear: "both"
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(data, e) {
    if (data.hex) {
      isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: "hex"
      }, e);
    } else {
      onChange(data, e);
    }
  };
  return React.createElement(
    Raised,
    { style: styles.Compact, styles: passedStyles },
    React.createElement(
      "div",
      { style: styles.compact, className: "compact-picker " + className },
      React.createElement(
        "div",
        null,
        map(colors, function(c) {
          return React.createElement(CompactColor, {
            key: c,
            color: c,
            active: c.toLowerCase() === hex,
            onClick: handleChange,
            onSwatchHover
          });
        }),
        React.createElement("div", { style: styles.clear })
      ),
      React.createElement(CompactFields, { hex, rgb, onChange: handleChange })
    )
  );
};
Compact.propTypes = {
  colors: propTypesExports.arrayOf(propTypesExports.string),
  styles: propTypesExports.object
};
Compact.defaultProps = {
  colors: ["#4D4D4D", "#999999", "#FFFFFF", "#F44E3B", "#FE9200", "#FCDC00", "#DBDF00", "#A4DD00", "#68CCCA", "#73D8FF", "#AEA1FF", "#FDA1FF", "#333333", "#808080", "#cccccc", "#D33115", "#E27300", "#FCC400", "#B0BC00", "#68BC00", "#16A5A5", "#009CE0", "#7B64FF", "#FA28FF", "#000000", "#666666", "#B3B3B3", "#9F0500", "#C45100", "#FB9E00", "#808900", "#194D33", "#0C797D", "#0062B1", "#653294", "#AB149E"],
  styles: {}
};
ColorWrap(Compact);
var GithubSwatch = function GithubSwatch2(_ref) {
  var hover3 = _ref.hover, color = _ref.color, onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover;
  var hoverSwatch = {
    position: "relative",
    zIndex: "2",
    outline: "2px solid #fff",
    boxShadow: "0 0 5px 2px rgba(0,0,0,0.25)"
  };
  var styles = _default$2({
    "default": {
      swatch: {
        width: "25px",
        height: "25px",
        fontSize: "0"
      }
    },
    "hover": {
      swatch: hoverSwatch
    }
  }, { hover: hover3 });
  return React.createElement(
    "div",
    { style: styles.swatch },
    React.createElement(Swatch$1, {
      color,
      onClick,
      onHover: onSwatchHover,
      focusStyle: hoverSwatch
    })
  );
};
const GithubSwatch$1 = handleHover(GithubSwatch);
var Github = function Github2(_ref) {
  var width = _ref.width, colors = _ref.colors, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, triangle = _ref.triangle, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles = _default$2(merge$1({
    "default": {
      card: {
        width,
        background: "#fff",
        border: "1px solid rgba(0,0,0,0.2)",
        boxShadow: "0 3px 12px rgba(0,0,0,0.15)",
        borderRadius: "4px",
        position: "relative",
        padding: "5px",
        display: "flex",
        flexWrap: "wrap"
      },
      triangle: {
        position: "absolute",
        border: "7px solid transparent",
        borderBottomColor: "#fff"
      },
      triangleShadow: {
        position: "absolute",
        border: "8px solid transparent",
        borderBottomColor: "rgba(0,0,0,0.15)"
      }
    },
    "hide-triangle": {
      triangle: {
        display: "none"
      },
      triangleShadow: {
        display: "none"
      }
    },
    "top-left-triangle": {
      triangle: {
        top: "-14px",
        left: "10px"
      },
      triangleShadow: {
        top: "-16px",
        left: "9px"
      }
    },
    "top-right-triangle": {
      triangle: {
        top: "-14px",
        right: "10px"
      },
      triangleShadow: {
        top: "-16px",
        right: "9px"
      }
    },
    "bottom-left-triangle": {
      triangle: {
        top: "35px",
        left: "10px",
        transform: "rotate(180deg)"
      },
      triangleShadow: {
        top: "37px",
        left: "9px",
        transform: "rotate(180deg)"
      }
    },
    "bottom-right-triangle": {
      triangle: {
        top: "35px",
        right: "10px",
        transform: "rotate(180deg)"
      },
      triangleShadow: {
        top: "37px",
        right: "9px",
        transform: "rotate(180deg)"
      }
    }
  }, passedStyles), {
    "hide-triangle": triangle === "hide",
    "top-left-triangle": triangle === "top-left",
    "top-right-triangle": triangle === "top-right",
    "bottom-left-triangle": triangle === "bottom-left",
    "bottom-right-triangle": triangle === "bottom-right"
  });
  var handleChange = function handleChange2(hex, e) {
    return onChange({ hex, source: "hex" }, e);
  };
  return React.createElement(
    "div",
    { style: styles.card, className: "github-picker " + className },
    React.createElement("div", { style: styles.triangleShadow }),
    React.createElement("div", { style: styles.triangle }),
    map(colors, function(c) {
      return React.createElement(GithubSwatch$1, {
        color: c,
        key: c,
        onClick: handleChange,
        onSwatchHover
      });
    })
  );
};
Github.propTypes = {
  width: propTypesExports.oneOfType([propTypesExports.string, propTypesExports.number]),
  colors: propTypesExports.arrayOf(propTypesExports.string),
  triangle: propTypesExports.oneOf(["hide", "top-left", "top-right", "bottom-left", "bottom-right"]),
  styles: propTypesExports.object
};
Github.defaultProps = {
  width: 200,
  colors: ["#B80000", "#DB3E00", "#FCCB00", "#008B02", "#006B76", "#1273DE", "#004DCF", "#5300EB", "#EB9694", "#FAD0C3", "#FEF3BD", "#C1E1C5", "#BEDADC", "#C4DEF6", "#BED3F3", "#D4C4FB"],
  triangle: "top-left",
  styles: {}
};
ColorWrap(Github);
var SliderPointer$1 = function SliderPointer(_ref) {
  var direction = _ref.direction;
  var styles = _default$2({
    "default": {
      picker: {
        width: "18px",
        height: "18px",
        borderRadius: "50%",
        transform: "translate(-9px, -1px)",
        backgroundColor: "rgb(248, 248, 248)",
        boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
      }
    },
    "vertical": {
      picker: {
        transform: "translate(-3px, -9px)"
      }
    }
  }, { vertical: direction === "vertical" });
  return React.createElement("div", { style: styles.picker });
};
var _extends$3 = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var HuePicker = function HuePicker2(_ref) {
  var width = _ref.width, height = _ref.height, onChange = _ref.onChange, hsl = _ref.hsl, direction = _ref.direction, pointer = _ref.pointer, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles = _default$2(merge$1({
    "default": {
      picker: {
        position: "relative",
        width,
        height
      },
      hue: {
        radius: "2px"
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(data) {
    return onChange({ a: 1, h: data.h, l: 0.5, s: 1 });
  };
  return React.createElement(
    "div",
    { style: styles.picker, className: "hue-picker " + className },
    React.createElement(Hue, _extends$3({}, styles.hue, {
      hsl,
      pointer,
      onChange: handleChange,
      direction
    }))
  );
};
HuePicker.propTypes = {
  styles: propTypesExports.object
};
HuePicker.defaultProps = {
  width: "316px",
  height: "16px",
  direction: "horizontal",
  pointer: SliderPointer$1,
  styles: {}
};
ColorWrap(HuePicker);
var Material = function Material2(_ref) {
  var onChange = _ref.onChange, hex = _ref.hex, rgb = _ref.rgb, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles = _default$2(merge$1({
    "default": {
      material: {
        width: "98px",
        height: "98px",
        padding: "16px",
        fontFamily: "Roboto"
      },
      HEXwrap: {
        position: "relative"
      },
      HEXinput: {
        width: "100%",
        marginTop: "12px",
        fontSize: "15px",
        color: "#333",
        padding: "0px",
        border: "0px",
        borderBottom: "2px solid " + hex,
        outline: "none",
        height: "30px"
      },
      HEXlabel: {
        position: "absolute",
        top: "0px",
        left: "0px",
        fontSize: "11px",
        color: "#999999",
        textTransform: "capitalize"
      },
      Hex: {
        style: {}
      },
      RGBwrap: {
        position: "relative"
      },
      RGBinput: {
        width: "100%",
        marginTop: "12px",
        fontSize: "15px",
        color: "#333",
        padding: "0px",
        border: "0px",
        borderBottom: "1px solid #eee",
        outline: "none",
        height: "30px"
      },
      RGBlabel: {
        position: "absolute",
        top: "0px",
        left: "0px",
        fontSize: "11px",
        color: "#999999",
        textTransform: "capitalize"
      },
      split: {
        display: "flex",
        marginRight: "-10px",
        paddingTop: "11px"
      },
      third: {
        flex: "1",
        paddingRight: "10px"
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(data, e) {
    if (data.hex) {
      isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: "hex"
      }, e);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        source: "rgb"
      }, e);
    }
  };
  return React.createElement(
    Raised,
    { styles: passedStyles },
    React.createElement(
      "div",
      { style: styles.material, className: "material-picker " + className },
      React.createElement(EditableInput, {
        style: { wrap: styles.HEXwrap, input: styles.HEXinput, label: styles.HEXlabel },
        label: "hex",
        value: hex,
        onChange: handleChange
      }),
      React.createElement(
        "div",
        { style: styles.split, className: "flexbox-fix" },
        React.createElement(
          "div",
          { style: styles.third },
          React.createElement(EditableInput, {
            style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
            label: "r",
            value: rgb.r,
            onChange: handleChange
          })
        ),
        React.createElement(
          "div",
          { style: styles.third },
          React.createElement(EditableInput, {
            style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
            label: "g",
            value: rgb.g,
            onChange: handleChange
          })
        ),
        React.createElement(
          "div",
          { style: styles.third },
          React.createElement(EditableInput, {
            style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
            label: "b",
            value: rgb.b,
            onChange: handleChange
          })
        )
      )
    )
  );
};
ColorWrap(Material);
var PhotoshopPicker = function PhotoshopPicker2(_ref) {
  var onChange = _ref.onChange, rgb = _ref.rgb, hsv = _ref.hsv, hex = _ref.hex;
  var styles = _default$2({
    "default": {
      fields: {
        paddingTop: "5px",
        paddingBottom: "9px",
        width: "80px",
        position: "relative"
      },
      divider: {
        height: "5px"
      },
      RGBwrap: {
        position: "relative"
      },
      RGBinput: {
        marginLeft: "40%",
        width: "40%",
        height: "18px",
        border: "1px solid #888888",
        boxShadow: "inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC",
        marginBottom: "5px",
        fontSize: "13px",
        paddingLeft: "3px",
        marginRight: "10px"
      },
      RGBlabel: {
        left: "0px",
        top: "0px",
        width: "34px",
        textTransform: "uppercase",
        fontSize: "13px",
        height: "18px",
        lineHeight: "22px",
        position: "absolute"
      },
      HEXwrap: {
        position: "relative"
      },
      HEXinput: {
        marginLeft: "20%",
        width: "80%",
        height: "18px",
        border: "1px solid #888888",
        boxShadow: "inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC",
        marginBottom: "6px",
        fontSize: "13px",
        paddingLeft: "3px"
      },
      HEXlabel: {
        position: "absolute",
        top: "0px",
        left: "0px",
        width: "14px",
        textTransform: "uppercase",
        fontSize: "13px",
        height: "18px",
        lineHeight: "22px"
      },
      fieldSymbols: {
        position: "absolute",
        top: "5px",
        right: "-7px",
        fontSize: "13px"
      },
      symbol: {
        height: "20px",
        lineHeight: "22px",
        paddingBottom: "7px"
      }
    }
  });
  var handleChange = function handleChange2(data, e) {
    if (data["#"]) {
      isValidHex(data["#"]) && onChange({
        hex: data["#"],
        source: "hex"
      }, e);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        source: "rgb"
      }, e);
    } else if (data.h || data.s || data.v) {
      onChange({
        h: data.h || hsv.h,
        s: data.s || hsv.s,
        v: data.v || hsv.v,
        source: "hsv"
      }, e);
    }
  };
  return React.createElement(
    "div",
    { style: styles.fields },
    React.createElement(EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: "h",
      value: Math.round(hsv.h),
      onChange: handleChange
    }),
    React.createElement(EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: "s",
      value: Math.round(hsv.s * 100),
      onChange: handleChange
    }),
    React.createElement(EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: "v",
      value: Math.round(hsv.v * 100),
      onChange: handleChange
    }),
    React.createElement("div", { style: styles.divider }),
    React.createElement(EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: "r",
      value: rgb.r,
      onChange: handleChange
    }),
    React.createElement(EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: "g",
      value: rgb.g,
      onChange: handleChange
    }),
    React.createElement(EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: "b",
      value: rgb.b,
      onChange: handleChange
    }),
    React.createElement("div", { style: styles.divider }),
    React.createElement(EditableInput, {
      style: { wrap: styles.HEXwrap, input: styles.HEXinput, label: styles.HEXlabel },
      label: "#",
      value: hex.replace("#", ""),
      onChange: handleChange
    }),
    React.createElement(
      "div",
      { style: styles.fieldSymbols },
      React.createElement(
        "div",
        { style: styles.symbol },
        ""
      ),
      React.createElement(
        "div",
        { style: styles.symbol },
        "%"
      ),
      React.createElement(
        "div",
        { style: styles.symbol },
        "%"
      )
    )
  );
};
var PhotoshopPointerCircle$1 = function PhotoshopPointerCircle(_ref) {
  var hsl = _ref.hsl;
  var styles = _default$2({
    "default": {
      picker: {
        width: "12px",
        height: "12px",
        borderRadius: "6px",
        boxShadow: "inset 0 0 0 1px #fff",
        transform: "translate(-6px, -6px)"
      }
    },
    "black-outline": {
      picker: {
        boxShadow: "inset 0 0 0 1px #000"
      }
    }
  }, { "black-outline": hsl.l > 0.5 });
  return React.createElement("div", { style: styles.picker });
};
var PhotoshopPointerCircle2 = function PhotoshopPointerCircle3() {
  var styles = _default$2({
    "default": {
      triangle: {
        width: 0,
        height: 0,
        borderStyle: "solid",
        borderWidth: "4px 0 4px 6px",
        borderColor: "transparent transparent transparent #fff",
        position: "absolute",
        top: "1px",
        left: "1px"
      },
      triangleBorder: {
        width: 0,
        height: 0,
        borderStyle: "solid",
        borderWidth: "5px 0 5px 8px",
        borderColor: "transparent transparent transparent #555"
      },
      left: {
        Extend: "triangleBorder",
        transform: "translate(-13px, -4px)"
      },
      leftInside: {
        Extend: "triangle",
        transform: "translate(-8px, -5px)"
      },
      right: {
        Extend: "triangleBorder",
        transform: "translate(20px, -14px) rotate(180deg)"
      },
      rightInside: {
        Extend: "triangle",
        transform: "translate(-8px, -5px)"
      }
    }
  });
  return React.createElement(
    "div",
    { style: styles.pointer },
    React.createElement(
      "div",
      { style: styles.left },
      React.createElement("div", { style: styles.leftInside })
    ),
    React.createElement(
      "div",
      { style: styles.right },
      React.createElement("div", { style: styles.rightInside })
    )
  );
};
var PhotoshopButton = function PhotoshopButton2(_ref) {
  var onClick = _ref.onClick, label = _ref.label, children = _ref.children, active3 = _ref.active;
  var styles = _default$2({
    "default": {
      button: {
        backgroundImage: "linear-gradient(-180deg, #FFFFFF 0%, #E6E6E6 100%)",
        border: "1px solid #878787",
        borderRadius: "2px",
        height: "20px",
        boxShadow: "0 1px 0 0 #EAEAEA",
        fontSize: "14px",
        color: "#000",
        lineHeight: "20px",
        textAlign: "center",
        marginBottom: "10px",
        cursor: "pointer"
      }
    },
    "active": {
      button: {
        boxShadow: "0 0 0 1px #878787"
      }
    }
  }, { active: active3 });
  return React.createElement(
    "div",
    { style: styles.button, onClick },
    label || children
  );
};
var PhotoshopPreviews = function PhotoshopPreviews2(_ref) {
  var rgb = _ref.rgb, currentColor = _ref.currentColor;
  var styles = _default$2({
    "default": {
      swatches: {
        border: "1px solid #B3B3B3",
        borderBottom: "1px solid #F0F0F0",
        marginBottom: "2px",
        marginTop: "1px"
      },
      new: {
        height: "34px",
        background: "rgb(" + rgb.r + "," + rgb.g + ", " + rgb.b + ")",
        boxShadow: "inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 1px 0 #000"
      },
      current: {
        height: "34px",
        background: currentColor,
        boxShadow: "inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 -1px 0 #000"
      },
      label: {
        fontSize: "14px",
        color: "#000",
        textAlign: "center"
      }
    }
  });
  return React.createElement(
    "div",
    null,
    React.createElement(
      "div",
      { style: styles.label },
      "new"
    ),
    React.createElement(
      "div",
      { style: styles.swatches },
      React.createElement("div", { style: styles.new }),
      React.createElement("div", { style: styles.current })
    ),
    React.createElement(
      "div",
      { style: styles.label },
      "current"
    )
  );
};
var _createClass = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var Photoshop = function(_React$Component) {
  _inherits(Photoshop2, _React$Component);
  function Photoshop2(props) {
    _classCallCheck(this, Photoshop2);
    var _this = _possibleConstructorReturn(this, (Photoshop2.__proto__ || Object.getPrototypeOf(Photoshop2)).call(this));
    _this.state = {
      currentColor: props.hex
    };
    return _this;
  }
  _createClass(Photoshop2, [{
    key: "render",
    value: function render3() {
      var _props = this.props, _props$styles = _props.styles, passedStyles = _props$styles === void 0 ? {} : _props$styles, _props$className = _props.className, className = _props$className === void 0 ? "" : _props$className;
      var styles = _default$2(merge$1({
        "default": {
          picker: {
            background: "#DCDCDC",
            borderRadius: "4px",
            boxShadow: "0 0 0 1px rgba(0,0,0,.25), 0 8px 16px rgba(0,0,0,.15)",
            boxSizing: "initial",
            width: "513px"
          },
          head: {
            backgroundImage: "linear-gradient(-180deg, #F0F0F0 0%, #D4D4D4 100%)",
            borderBottom: "1px solid #B1B1B1",
            boxShadow: "inset 0 1px 0 0 rgba(255,255,255,.2), inset 0 -1px 0 0 rgba(0,0,0,.02)",
            height: "23px",
            lineHeight: "24px",
            borderRadius: "4px 4px 0 0",
            fontSize: "13px",
            color: "#4D4D4D",
            textAlign: "center"
          },
          body: {
            padding: "15px 15px 0",
            display: "flex"
          },
          saturation: {
            width: "256px",
            height: "256px",
            position: "relative",
            border: "2px solid #B3B3B3",
            borderBottom: "2px solid #F0F0F0",
            overflow: "hidden"
          },
          hue: {
            position: "relative",
            height: "256px",
            width: "19px",
            marginLeft: "10px",
            border: "2px solid #B3B3B3",
            borderBottom: "2px solid #F0F0F0"
          },
          controls: {
            width: "180px",
            marginLeft: "10px"
          },
          top: {
            display: "flex"
          },
          previews: {
            width: "60px"
          },
          actions: {
            flex: "1",
            marginLeft: "20px"
          }
        }
      }, passedStyles));
      return React.createElement(
        "div",
        { style: styles.picker, className: "photoshop-picker " + className },
        React.createElement(
          "div",
          { style: styles.head },
          this.props.header
        ),
        React.createElement(
          "div",
          { style: styles.body, className: "flexbox-fix" },
          React.createElement(
            "div",
            { style: styles.saturation },
            React.createElement(Saturation, {
              hsl: this.props.hsl,
              hsv: this.props.hsv,
              pointer: PhotoshopPointerCircle$1,
              onChange: this.props.onChange
            })
          ),
          React.createElement(
            "div",
            { style: styles.hue },
            React.createElement(Hue, {
              direction: "vertical",
              hsl: this.props.hsl,
              pointer: PhotoshopPointerCircle2,
              onChange: this.props.onChange
            })
          ),
          React.createElement(
            "div",
            { style: styles.controls },
            React.createElement(
              "div",
              { style: styles.top, className: "flexbox-fix" },
              React.createElement(
                "div",
                { style: styles.previews },
                React.createElement(PhotoshopPreviews, {
                  rgb: this.props.rgb,
                  currentColor: this.state.currentColor
                })
              ),
              React.createElement(
                "div",
                { style: styles.actions },
                React.createElement(PhotoshopButton, { label: "OK", onClick: this.props.onAccept, active: true }),
                React.createElement(PhotoshopButton, { label: "Cancel", onClick: this.props.onCancel }),
                React.createElement(PhotoshopPicker, {
                  onChange: this.props.onChange,
                  rgb: this.props.rgb,
                  hsv: this.props.hsv,
                  hex: this.props.hex
                })
              )
            )
          )
        )
      );
    }
  }]);
  return Photoshop2;
}(React.Component);
Photoshop.propTypes = {
  header: propTypesExports.string,
  styles: propTypesExports.object
};
Photoshop.defaultProps = {
  header: "Color Picker",
  styles: {}
};
ColorWrap(Photoshop);
var SketchFields = function SketchFields2(_ref) {
  var onChange = _ref.onChange, rgb = _ref.rgb, hsl = _ref.hsl, hex = _ref.hex, disableAlpha = _ref.disableAlpha;
  var styles = _default$2({
    "default": {
      fields: {
        display: "flex",
        paddingTop: "4px"
      },
      single: {
        flex: "1",
        paddingLeft: "6px"
      },
      alpha: {
        flex: "1",
        paddingLeft: "6px"
      },
      double: {
        flex: "2"
      },
      input: {
        width: "80%",
        padding: "4px 10% 3px",
        border: "none",
        boxShadow: "inset 0 0 0 1px #ccc",
        fontSize: "11px"
      },
      label: {
        display: "block",
        textAlign: "center",
        fontSize: "11px",
        color: "#222",
        paddingTop: "3px",
        paddingBottom: "4px",
        textTransform: "capitalize"
      }
    },
    "disableAlpha": {
      alpha: {
        display: "none"
      }
    }
  }, { disableAlpha });
  var handleChange = function handleChange2(data, e) {
    if (data.hex) {
      isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: "hex"
      }, e);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        a: rgb.a,
        source: "rgb"
      }, e);
    } else if (data.a) {
      if (data.a < 0) {
        data.a = 0;
      } else if (data.a > 100) {
        data.a = 100;
      }
      data.a /= 100;
      onChange({
        h: hsl.h,
        s: hsl.s,
        l: hsl.l,
        a: data.a,
        source: "rgb"
      }, e);
    }
  };
  return React.createElement(
    "div",
    { style: styles.fields, className: "flexbox-fix" },
    React.createElement(
      "div",
      { style: styles.double },
      React.createElement(EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: "hex",
        value: hex.replace("#", ""),
        onChange: handleChange
      })
    ),
    React.createElement(
      "div",
      { style: styles.single },
      React.createElement(EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: "r",
        value: rgb.r,
        onChange: handleChange,
        dragLabel: "true",
        dragMax: "255"
      })
    ),
    React.createElement(
      "div",
      { style: styles.single },
      React.createElement(EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: "g",
        value: rgb.g,
        onChange: handleChange,
        dragLabel: "true",
        dragMax: "255"
      })
    ),
    React.createElement(
      "div",
      { style: styles.single },
      React.createElement(EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: "b",
        value: rgb.b,
        onChange: handleChange,
        dragLabel: "true",
        dragMax: "255"
      })
    ),
    React.createElement(
      "div",
      { style: styles.alpha },
      React.createElement(EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: "a",
        value: Math.round(rgb.a * 100),
        onChange: handleChange,
        dragLabel: "true",
        dragMax: "100"
      })
    )
  );
};
var _extends$2 = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var SketchPresetColors = function SketchPresetColors2(_ref) {
  var colors = _ref.colors, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, onSwatchHover = _ref.onSwatchHover;
  var styles = _default$2({
    "default": {
      colors: {
        margin: "0 -10px",
        padding: "10px 0 0 10px",
        borderTop: "1px solid #eee",
        display: "flex",
        flexWrap: "wrap",
        position: "relative"
      },
      swatchWrap: {
        width: "16px",
        height: "16px",
        margin: "0 10px 10px 0"
      },
      swatch: {
        borderRadius: "3px",
        boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15)"
      }
    },
    "no-presets": {
      colors: {
        display: "none"
      }
    }
  }, {
    "no-presets": !colors || !colors.length
  });
  var handleClick = function handleClick2(hex, e) {
    onClick({
      hex,
      source: "hex"
    }, e);
  };
  return React.createElement(
    "div",
    { style: styles.colors, className: "flexbox-fix" },
    colors.map(function(colorObjOrString) {
      var c = typeof colorObjOrString === "string" ? { color: colorObjOrString } : colorObjOrString;
      var key = "" + c.color + (c.title || "");
      return React.createElement(
        "div",
        { key, style: styles.swatchWrap },
        React.createElement(Swatch$1, _extends$2({}, c, {
          style: styles.swatch,
          onClick: handleClick,
          onHover: onSwatchHover,
          focusStyle: {
            boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15), 0 0 4px " + c.color
          }
        }))
      );
    })
  );
};
SketchPresetColors.propTypes = {
  colors: propTypesExports.arrayOf(propTypesExports.oneOfType([propTypesExports.string, propTypesExports.shape({
    color: propTypesExports.string,
    title: propTypesExports.string
  })])).isRequired
};
var _extends$1 = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var Sketch = function Sketch2(_ref) {
  var width = _ref.width, rgb = _ref.rgb, hex = _ref.hex, hsv = _ref.hsv, hsl = _ref.hsl, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, disableAlpha = _ref.disableAlpha, presetColors = _ref.presetColors, renderers = _ref.renderers, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles = _default$2(merge$1({
    "default": _extends$1({
      picker: {
        width,
        padding: "10px 10px 0",
        boxSizing: "initial",
        background: "#fff",
        borderRadius: "4px",
        boxShadow: "0 0 0 1px rgba(0,0,0,.15), 0 8px 16px rgba(0,0,0,.15)"
      },
      saturation: {
        width: "100%",
        paddingBottom: "75%",
        position: "relative",
        overflow: "hidden"
      },
      Saturation: {
        radius: "3px",
        shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
      },
      controls: {
        display: "flex"
      },
      sliders: {
        padding: "4px 0",
        flex: "1"
      },
      color: {
        width: "24px",
        height: "24px",
        position: "relative",
        marginTop: "4px",
        marginLeft: "4px",
        borderRadius: "3px"
      },
      activeColor: {
        absolute: "0px 0px 0px 0px",
        borderRadius: "2px",
        background: "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + "," + rgb.a + ")",
        boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
      },
      hue: {
        position: "relative",
        height: "10px",
        overflow: "hidden"
      },
      Hue: {
        radius: "2px",
        shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
      },
      alpha: {
        position: "relative",
        height: "10px",
        marginTop: "4px",
        overflow: "hidden"
      },
      Alpha: {
        radius: "2px",
        shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
      }
    }, passedStyles),
    "disableAlpha": {
      color: {
        height: "10px"
      },
      hue: {
        height: "10px"
      },
      alpha: {
        display: "none"
      }
    }
  }, passedStyles), { disableAlpha });
  return React.createElement(
    "div",
    { style: styles.picker, className: "sketch-picker " + className },
    React.createElement(
      "div",
      { style: styles.saturation },
      React.createElement(Saturation, {
        style: styles.Saturation,
        hsl,
        hsv,
        onChange
      })
    ),
    React.createElement(
      "div",
      { style: styles.controls, className: "flexbox-fix" },
      React.createElement(
        "div",
        { style: styles.sliders },
        React.createElement(
          "div",
          { style: styles.hue },
          React.createElement(Hue, {
            style: styles.Hue,
            hsl,
            onChange
          })
        ),
        React.createElement(
          "div",
          { style: styles.alpha },
          React.createElement(Alpha, {
            style: styles.Alpha,
            rgb,
            hsl,
            renderers,
            onChange
          })
        )
      ),
      React.createElement(
        "div",
        { style: styles.color },
        React.createElement(Checkboard, null),
        React.createElement("div", { style: styles.activeColor })
      )
    ),
    React.createElement(SketchFields, {
      rgb,
      hsl,
      hex,
      onChange,
      disableAlpha
    }),
    React.createElement(SketchPresetColors, {
      colors: presetColors,
      onClick: onChange,
      onSwatchHover
    })
  );
};
Sketch.propTypes = {
  disableAlpha: propTypesExports.bool,
  width: propTypesExports.oneOfType([propTypesExports.string, propTypesExports.number]),
  styles: propTypesExports.object
};
Sketch.defaultProps = {
  disableAlpha: false,
  width: 200,
  styles: {},
  presetColors: ["#D0021B", "#F5A623", "#F8E71C", "#8B572A", "#7ED321", "#417505", "#BD10E0", "#9013FE", "#4A90E2", "#50E3C2", "#B8E986", "#000000", "#4A4A4A", "#9B9B9B", "#FFFFFF"]
};
const SketchPicker = ColorWrap(Sketch);
var SliderSwatch = function SliderSwatch2(_ref) {
  var hsl = _ref.hsl, offset = _ref.offset, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, active3 = _ref.active, first = _ref.first, last = _ref.last;
  var styles = _default$2({
    "default": {
      swatch: {
        height: "12px",
        background: "hsl(" + hsl.h + ", 50%, " + offset * 100 + "%)",
        cursor: "pointer"
      }
    },
    "first": {
      swatch: {
        borderRadius: "2px 0 0 2px"
      }
    },
    "last": {
      swatch: {
        borderRadius: "0 2px 2px 0"
      }
    },
    "active": {
      swatch: {
        transform: "scaleY(1.8)",
        borderRadius: "3.6px/2px"
      }
    }
  }, { active: active3, first, last });
  var handleClick = function handleClick2(e) {
    return onClick({
      h: hsl.h,
      s: 0.5,
      l: offset,
      source: "hsl"
    }, e);
  };
  return React.createElement("div", { style: styles.swatch, onClick: handleClick });
};
var SliderSwatches = function SliderSwatches2(_ref) {
  var onClick = _ref.onClick, hsl = _ref.hsl;
  var styles = _default$2({
    "default": {
      swatches: {
        marginTop: "20px"
      },
      swatch: {
        boxSizing: "border-box",
        width: "20%",
        paddingRight: "1px",
        float: "left"
      },
      clear: {
        clear: "both"
      }
    }
  });
  var epsilon = 0.1;
  return React.createElement(
    "div",
    { style: styles.swatches },
    React.createElement(
      "div",
      { style: styles.swatch },
      React.createElement(SliderSwatch, {
        hsl,
        offset: ".80",
        active: Math.abs(hsl.l - 0.8) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
        onClick,
        first: true
      })
    ),
    React.createElement(
      "div",
      { style: styles.swatch },
      React.createElement(SliderSwatch, {
        hsl,
        offset: ".65",
        active: Math.abs(hsl.l - 0.65) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
        onClick
      })
    ),
    React.createElement(
      "div",
      { style: styles.swatch },
      React.createElement(SliderSwatch, {
        hsl,
        offset: ".50",
        active: Math.abs(hsl.l - 0.5) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
        onClick
      })
    ),
    React.createElement(
      "div",
      { style: styles.swatch },
      React.createElement(SliderSwatch, {
        hsl,
        offset: ".35",
        active: Math.abs(hsl.l - 0.35) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
        onClick
      })
    ),
    React.createElement(
      "div",
      { style: styles.swatch },
      React.createElement(SliderSwatch, {
        hsl,
        offset: ".20",
        active: Math.abs(hsl.l - 0.2) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
        onClick,
        last: true
      })
    ),
    React.createElement("div", { style: styles.clear })
  );
};
var SliderPointer2 = function SliderPointer3() {
  var styles = _default$2({
    "default": {
      picker: {
        width: "14px",
        height: "14px",
        borderRadius: "6px",
        transform: "translate(-7px, -1px)",
        backgroundColor: "rgb(248, 248, 248)",
        boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
      }
    }
  });
  return React.createElement("div", { style: styles.picker });
};
var Slider = function Slider2(_ref) {
  var hsl = _ref.hsl, onChange = _ref.onChange, pointer = _ref.pointer, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles = _default$2(merge$1({
    "default": {
      hue: {
        height: "12px",
        position: "relative"
      },
      Hue: {
        radius: "2px"
      }
    }
  }, passedStyles));
  return React.createElement(
    "div",
    { style: styles.wrap || {}, className: "slider-picker " + className },
    React.createElement(
      "div",
      { style: styles.hue },
      React.createElement(Hue, {
        style: styles.Hue,
        hsl,
        pointer,
        onChange
      })
    ),
    React.createElement(
      "div",
      { style: styles.swatches },
      React.createElement(SliderSwatches, { hsl, onClick: onChange })
    )
  );
};
Slider.propTypes = {
  styles: propTypesExports.object
};
Slider.defaultProps = {
  pointer: SliderPointer2,
  styles: {}
};
ColorWrap(Slider);
var CheckIcon = {};
Object.defineProperty(CheckIcon, "__esModule", {
  value: true
});
var _extends = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _react = reactExports;
var _react2 = _interopRequireDefault(_react);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _objectWithoutProperties(obj, keys2) {
  var target = {};
  for (var i in obj) {
    if (keys2.indexOf(i) >= 0)
      continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i))
      continue;
    target[i] = obj[i];
  }
  return target;
}
var DEFAULT_SIZE = 24;
var _default = CheckIcon.default = function(_ref) {
  var _ref$fill = _ref.fill, fill = _ref$fill === void 0 ? "currentColor" : _ref$fill, _ref$width = _ref.width, width = _ref$width === void 0 ? DEFAULT_SIZE : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? DEFAULT_SIZE : _ref$height, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style, props = _objectWithoutProperties(_ref, ["fill", "width", "height", "style"]);
  return _react2.default.createElement(
    "svg",
    _extends({
      viewBox: "0 0 " + DEFAULT_SIZE + " " + DEFAULT_SIZE,
      style: _extends({ fill, width, height }, style)
    }, props),
    _react2.default.createElement("path", { d: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" })
  );
};
var SwatchesColor = function SwatchesColor2(_ref) {
  var color = _ref.color, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, onSwatchHover = _ref.onSwatchHover, first = _ref.first, last = _ref.last, active3 = _ref.active;
  var styles = _default$2({
    "default": {
      color: {
        width: "40px",
        height: "24px",
        cursor: "pointer",
        background: color,
        marginBottom: "1px"
      },
      check: {
        color: getContrastingColor(color),
        marginLeft: "8px",
        display: "none"
      }
    },
    "first": {
      color: {
        overflow: "hidden",
        borderRadius: "2px 2px 0 0"
      }
    },
    "last": {
      color: {
        overflow: "hidden",
        borderRadius: "0 0 2px 2px"
      }
    },
    "active": {
      check: {
        display: "block"
      }
    },
    "color-#FFFFFF": {
      color: {
        boxShadow: "inset 0 0 0 1px #ddd"
      },
      check: {
        color: "#333"
      }
    },
    "transparent": {
      check: {
        color: "#333"
      }
    }
  }, {
    first,
    last,
    active: active3,
    "color-#FFFFFF": color === "#FFFFFF",
    "transparent": color === "transparent"
  });
  return React.createElement(
    Swatch$1,
    {
      color,
      style: styles.color,
      onClick,
      onHover: onSwatchHover,
      focusStyle: { boxShadow: "0 0 4px " + color }
    },
    React.createElement(
      "div",
      { style: styles.check },
      React.createElement(_default, null)
    )
  );
};
var SwatchesGroup = function SwatchesGroup2(_ref) {
  var onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover, group = _ref.group, active3 = _ref.active;
  var styles = _default$2({
    "default": {
      group: {
        paddingBottom: "10px",
        width: "40px",
        float: "left",
        marginRight: "10px"
      }
    }
  });
  return React.createElement(
    "div",
    { style: styles.group },
    map(group, function(color, i) {
      return React.createElement(SwatchesColor, {
        key: color,
        color,
        active: color.toLowerCase() === active3,
        first: i === 0,
        last: i === group.length - 1,
        onClick,
        onSwatchHover
      });
    })
  );
};
var Swatches = function Swatches2(_ref) {
  var width = _ref.width, height = _ref.height, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, colors = _ref.colors, hex = _ref.hex, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles = _default$2(merge$1({
    "default": {
      picker: {
        width,
        height
      },
      overflow: {
        height,
        overflowY: "scroll"
      },
      body: {
        padding: "16px 0 6px 16px"
      },
      clear: {
        clear: "both"
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(data, e) {
    return onChange({ hex: data, source: "hex" }, e);
  };
  return React.createElement(
    "div",
    { style: styles.picker, className: "swatches-picker " + className },
    React.createElement(
      Raised,
      null,
      React.createElement(
        "div",
        { style: styles.overflow },
        React.createElement(
          "div",
          { style: styles.body },
          map(colors, function(group) {
            return React.createElement(SwatchesGroup, {
              key: group.toString(),
              group,
              active: hex,
              onClick: handleChange,
              onSwatchHover
            });
          }),
          React.createElement("div", { style: styles.clear })
        )
      )
    )
  );
};
Swatches.propTypes = {
  width: propTypesExports.oneOfType([propTypesExports.string, propTypesExports.number]),
  height: propTypesExports.oneOfType([propTypesExports.string, propTypesExports.number]),
  colors: propTypesExports.arrayOf(propTypesExports.arrayOf(propTypesExports.string)),
  styles: propTypesExports.object
  /* eslint-disable max-len */
};
Swatches.defaultProps = {
  width: 320,
  height: 240,
  colors: [[red["900"], red["700"], red["500"], red["300"], red["100"]], [pink["900"], pink["700"], pink["500"], pink["300"], pink["100"]], [purple["900"], purple["700"], purple["500"], purple["300"], purple["100"]], [deepPurple["900"], deepPurple["700"], deepPurple["500"], deepPurple["300"], deepPurple["100"]], [indigo["900"], indigo["700"], indigo["500"], indigo["300"], indigo["100"]], [blue["900"], blue["700"], blue["500"], blue["300"], blue["100"]], [lightBlue["900"], lightBlue["700"], lightBlue["500"], lightBlue["300"], lightBlue["100"]], [cyan["900"], cyan["700"], cyan["500"], cyan["300"], cyan["100"]], [teal["900"], teal["700"], teal["500"], teal["300"], teal["100"]], ["#194D33", green["700"], green["500"], green["300"], green["100"]], [lightGreen["900"], lightGreen["700"], lightGreen["500"], lightGreen["300"], lightGreen["100"]], [lime["900"], lime["700"], lime["500"], lime["300"], lime["100"]], [yellow["900"], yellow["700"], yellow["500"], yellow["300"], yellow["100"]], [amber["900"], amber["700"], amber["500"], amber["300"], amber["100"]], [orange["900"], orange["700"], orange["500"], orange["300"], orange["100"]], [deepOrange["900"], deepOrange["700"], deepOrange["500"], deepOrange["300"], deepOrange["100"]], [brown["900"], brown["700"], brown["500"], brown["300"], brown["100"]], [blueGrey["900"], blueGrey["700"], blueGrey["500"], blueGrey["300"], blueGrey["100"]], ["#000000", "#525252", "#969696", "#D9D9D9", "#FFFFFF"]],
  styles: {}
};
ColorWrap(Swatches);
var Twitter = function Twitter2(_ref) {
  var onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, hex = _ref.hex, colors = _ref.colors, width = _ref.width, triangle = _ref.triangle, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles = _default$2(merge$1({
    "default": {
      card: {
        width,
        background: "#fff",
        border: "0 solid rgba(0,0,0,0.25)",
        boxShadow: "0 1px 4px rgba(0,0,0,0.25)",
        borderRadius: "4px",
        position: "relative"
      },
      body: {
        padding: "15px 9px 9px 15px"
      },
      label: {
        fontSize: "18px",
        color: "#fff"
      },
      triangle: {
        width: "0px",
        height: "0px",
        borderStyle: "solid",
        borderWidth: "0 9px 10px 9px",
        borderColor: "transparent transparent #fff transparent",
        position: "absolute"
      },
      triangleShadow: {
        width: "0px",
        height: "0px",
        borderStyle: "solid",
        borderWidth: "0 9px 10px 9px",
        borderColor: "transparent transparent rgba(0,0,0,.1) transparent",
        position: "absolute"
      },
      hash: {
        background: "#F0F0F0",
        height: "30px",
        width: "30px",
        borderRadius: "4px 0 0 4px",
        float: "left",
        color: "#98A1A4",
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      },
      input: {
        width: "100px",
        fontSize: "14px",
        color: "#666",
        border: "0px",
        outline: "none",
        height: "28px",
        boxShadow: "inset 0 0 0 1px #F0F0F0",
        boxSizing: "content-box",
        borderRadius: "0 4px 4px 0",
        float: "left",
        paddingLeft: "8px"
      },
      swatch: {
        width: "30px",
        height: "30px",
        float: "left",
        borderRadius: "4px",
        margin: "0 6px 6px 0"
      },
      clear: {
        clear: "both"
      }
    },
    "hide-triangle": {
      triangle: {
        display: "none"
      },
      triangleShadow: {
        display: "none"
      }
    },
    "top-left-triangle": {
      triangle: {
        top: "-10px",
        left: "12px"
      },
      triangleShadow: {
        top: "-11px",
        left: "12px"
      }
    },
    "top-right-triangle": {
      triangle: {
        top: "-10px",
        right: "12px"
      },
      triangleShadow: {
        top: "-11px",
        right: "12px"
      }
    }
  }, passedStyles), {
    "hide-triangle": triangle === "hide",
    "top-left-triangle": triangle === "top-left",
    "top-right-triangle": triangle === "top-right"
  });
  var handleChange = function handleChange2(hexcode, e) {
    isValidHex(hexcode) && onChange({
      hex: hexcode,
      source: "hex"
    }, e);
  };
  return React.createElement(
    "div",
    { style: styles.card, className: "twitter-picker " + className },
    React.createElement("div", { style: styles.triangleShadow }),
    React.createElement("div", { style: styles.triangle }),
    React.createElement(
      "div",
      { style: styles.body },
      map(colors, function(c, i) {
        return React.createElement(Swatch$1, {
          key: i,
          color: c,
          hex: c,
          style: styles.swatch,
          onClick: handleChange,
          onHover: onSwatchHover,
          focusStyle: {
            boxShadow: "0 0 4px " + c
          }
        });
      }),
      React.createElement(
        "div",
        { style: styles.hash },
        "#"
      ),
      React.createElement(EditableInput, {
        label: null,
        style: { input: styles.input },
        value: hex.replace("#", ""),
        onChange: handleChange
      }),
      React.createElement("div", { style: styles.clear })
    )
  );
};
Twitter.propTypes = {
  width: propTypesExports.oneOfType([propTypesExports.string, propTypesExports.number]),
  triangle: propTypesExports.oneOf(["hide", "top-left", "top-right"]),
  colors: propTypesExports.arrayOf(propTypesExports.string),
  styles: propTypesExports.object
};
Twitter.defaultProps = {
  width: 276,
  colors: ["#FF6900", "#FCB900", "#7BDCB5", "#00D084", "#8ED1FC", "#0693E3", "#ABB8C3", "#EB144C", "#F78DA7", "#9900EF"],
  triangle: "top-left",
  styles: {}
};
ColorWrap(Twitter);
var GooglePointerCircle = function GooglePointerCircle2(props) {
  var styles = _default$2({
    "default": {
      picker: {
        width: "20px",
        height: "20px",
        borderRadius: "22px",
        border: "2px #fff solid",
        transform: "translate(-12px, -13px)",
        background: "hsl(" + Math.round(props.hsl.h) + ", " + Math.round(props.hsl.s * 100) + "%, " + Math.round(props.hsl.l * 100) + "%)"
      }
    }
  });
  return React.createElement("div", { style: styles.picker });
};
GooglePointerCircle.propTypes = {
  hsl: propTypesExports.shape({
    h: propTypesExports.number,
    s: propTypesExports.number,
    l: propTypesExports.number,
    a: propTypesExports.number
  })
};
GooglePointerCircle.defaultProps = {
  hsl: { a: 1, h: 249.94, l: 0.2, s: 0.5 }
};
var GooglePointer = function GooglePointer2(props) {
  var styles = _default$2({
    "default": {
      picker: {
        width: "20px",
        height: "20px",
        borderRadius: "22px",
        transform: "translate(-10px, -7px)",
        background: "hsl(" + Math.round(props.hsl.h) + ", 100%, 50%)",
        border: "2px white solid"
      }
    }
  });
  return React.createElement("div", { style: styles.picker });
};
GooglePointer.propTypes = {
  hsl: propTypesExports.shape({
    h: propTypesExports.number,
    s: propTypesExports.number,
    l: propTypesExports.number,
    a: propTypesExports.number
  })
};
GooglePointer.defaultProps = {
  hsl: { a: 1, h: 249.94, l: 0.2, s: 0.5 }
};
var GoogleFields = function GoogleFields2(_ref) {
  var onChange = _ref.onChange, rgb = _ref.rgb, hsl = _ref.hsl, hex = _ref.hex, hsv = _ref.hsv;
  var handleChange = function handleChange2(data, e) {
    if (data.hex) {
      isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: "hex"
      }, e);
    } else if (data.rgb) {
      var values = data.rgb.split(",");
      isvalidColorString(data.rgb, "rgb") && onChange({
        r: values[0],
        g: values[1],
        b: values[2],
        a: 1,
        source: "rgb"
      }, e);
    } else if (data.hsv) {
      var _values = data.hsv.split(",");
      if (isvalidColorString(data.hsv, "hsv")) {
        _values[2] = _values[2].replace("%", "");
        _values[1] = _values[1].replace("%", "");
        _values[0] = _values[0].replace("", "");
        if (_values[1] == 1) {
          _values[1] = 0.01;
        } else if (_values[2] == 1) {
          _values[2] = 0.01;
        }
        onChange({
          h: Number(_values[0]),
          s: Number(_values[1]),
          v: Number(_values[2]),
          source: "hsv"
        }, e);
      }
    } else if (data.hsl) {
      var _values2 = data.hsl.split(",");
      if (isvalidColorString(data.hsl, "hsl")) {
        _values2[2] = _values2[2].replace("%", "");
        _values2[1] = _values2[1].replace("%", "");
        _values2[0] = _values2[0].replace("", "");
        if (hsvValue[1] == 1) {
          hsvValue[1] = 0.01;
        } else if (hsvValue[2] == 1) {
          hsvValue[2] = 0.01;
        }
        onChange({
          h: Number(_values2[0]),
          s: Number(_values2[1]),
          v: Number(_values2[2]),
          source: "hsl"
        }, e);
      }
    }
  };
  var styles = _default$2({
    "default": {
      wrap: {
        display: "flex",
        height: "100px",
        marginTop: "4px"
      },
      fields: {
        width: "100%"
      },
      column: {
        paddingTop: "10px",
        display: "flex",
        justifyContent: "space-between"
      },
      double: {
        padding: "0px 4.4px",
        boxSizing: "border-box"
      },
      input: {
        width: "100%",
        height: "38px",
        boxSizing: "border-box",
        padding: "4px 10% 3px",
        textAlign: "center",
        border: "1px solid #dadce0",
        fontSize: "11px",
        textTransform: "lowercase",
        borderRadius: "5px",
        outline: "none",
        fontFamily: "Roboto,Arial,sans-serif"
      },
      input2: {
        height: "38px",
        width: "100%",
        border: "1px solid #dadce0",
        boxSizing: "border-box",
        fontSize: "11px",
        textTransform: "lowercase",
        borderRadius: "5px",
        outline: "none",
        paddingLeft: "10px",
        fontFamily: "Roboto,Arial,sans-serif"
      },
      label: {
        textAlign: "center",
        fontSize: "12px",
        background: "#fff",
        position: "absolute",
        textTransform: "uppercase",
        color: "#3c4043",
        width: "35px",
        top: "-6px",
        left: "0",
        right: "0",
        marginLeft: "auto",
        marginRight: "auto",
        fontFamily: "Roboto,Arial,sans-serif"
      },
      label2: {
        left: "10px",
        textAlign: "center",
        fontSize: "12px",
        background: "#fff",
        position: "absolute",
        textTransform: "uppercase",
        color: "#3c4043",
        width: "32px",
        top: "-6px",
        fontFamily: "Roboto,Arial,sans-serif"
      },
      single: {
        flexGrow: "1",
        margin: "0px 4.4px"
      }
    }
  });
  var rgbValue = rgb.r + ", " + rgb.g + ", " + rgb.b;
  var hslValue = Math.round(hsl.h) + ", " + Math.round(hsl.s * 100) + "%, " + Math.round(hsl.l * 100) + "%";
  var hsvValue = Math.round(hsv.h) + ", " + Math.round(hsv.s * 100) + "%, " + Math.round(hsv.v * 100) + "%";
  return React.createElement(
    "div",
    { style: styles.wrap, className: "flexbox-fix" },
    React.createElement(
      "div",
      { style: styles.fields },
      React.createElement(
        "div",
        { style: styles.double },
        React.createElement(EditableInput, {
          style: { input: styles.input, label: styles.label },
          label: "hex",
          value: hex,
          onChange: handleChange
        })
      ),
      React.createElement(
        "div",
        { style: styles.column },
        React.createElement(
          "div",
          { style: styles.single },
          React.createElement(EditableInput, {
            style: { input: styles.input2, label: styles.label2 },
            label: "rgb",
            value: rgbValue,
            onChange: handleChange
          })
        ),
        React.createElement(
          "div",
          { style: styles.single },
          React.createElement(EditableInput, {
            style: { input: styles.input2, label: styles.label2 },
            label: "hsv",
            value: hsvValue,
            onChange: handleChange
          })
        ),
        React.createElement(
          "div",
          { style: styles.single },
          React.createElement(EditableInput, {
            style: { input: styles.input2, label: styles.label2 },
            label: "hsl",
            value: hslValue,
            onChange: handleChange
          })
        )
      )
    )
  );
};
var Google = function Google2(_ref) {
  var width = _ref.width, onChange = _ref.onChange, rgb = _ref.rgb, hsl = _ref.hsl, hsv = _ref.hsv, hex = _ref.hex, header = _ref.header, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles = _default$2(merge$1({
    "default": {
      picker: {
        width,
        background: "#fff",
        border: "1px solid #dfe1e5",
        boxSizing: "initial",
        display: "flex",
        flexWrap: "wrap",
        borderRadius: "8px 8px 0px 0px"
      },
      head: {
        height: "57px",
        width: "100%",
        paddingTop: "16px",
        paddingBottom: "16px",
        paddingLeft: "16px",
        fontSize: "20px",
        boxSizing: "border-box",
        fontFamily: "Roboto-Regular,HelveticaNeue,Arial,sans-serif"
      },
      saturation: {
        width: "70%",
        padding: "0px",
        position: "relative",
        overflow: "hidden"
      },
      swatch: {
        width: "30%",
        height: "228px",
        padding: "0px",
        background: "rgba(" + rgb.r + ", " + rgb.g + ", " + rgb.b + ", 1)",
        position: "relative",
        overflow: "hidden"
      },
      body: {
        margin: "auto",
        width: "95%"
      },
      controls: {
        display: "flex",
        boxSizing: "border-box",
        height: "52px",
        paddingTop: "22px"
      },
      color: {
        width: "32px"
      },
      hue: {
        height: "8px",
        position: "relative",
        margin: "0px 16px 0px 16px",
        width: "100%"
      },
      Hue: {
        radius: "2px"
      }
    }
  }, passedStyles));
  return React.createElement(
    "div",
    { style: styles.picker, className: "google-picker " + className },
    React.createElement(
      "div",
      { style: styles.head },
      header
    ),
    React.createElement("div", { style: styles.swatch }),
    React.createElement(
      "div",
      { style: styles.saturation },
      React.createElement(Saturation, {
        hsl,
        hsv,
        pointer: GooglePointerCircle,
        onChange
      })
    ),
    React.createElement(
      "div",
      { style: styles.body },
      React.createElement(
        "div",
        { style: styles.controls, className: "flexbox-fix" },
        React.createElement(
          "div",
          { style: styles.hue },
          React.createElement(Hue, {
            style: styles.Hue,
            hsl,
            radius: "4px",
            pointer: GooglePointer,
            onChange
          })
        )
      ),
      React.createElement(GoogleFields, {
        rgb,
        hsl,
        hex,
        hsv,
        onChange
      })
    )
  );
};
Google.propTypes = {
  width: propTypesExports.oneOfType([propTypesExports.string, propTypesExports.number]),
  styles: propTypesExports.object,
  header: propTypesExports.string
};
Google.defaultProps = {
  width: 652,
  styles: {},
  header: "Color picker"
};
ColorWrap(Google);
const Nav$1 = "";
const Widget = ({ type, lineColor, landColor, lineWidth, handleColorChange, setLineWidth }) => {
  if (type === "landColor") {
    return /* @__PURE__ */ jsxs("div", { className: "option-widget", style: { display: "block" }, children: [
      /* @__PURE__ */ jsx("h4", { children: "Land Color" }),
      /* @__PURE__ */ jsx(SketchPicker, { color: landColor, onChangeComplete: (color) => handleColorChange(color, "land-color") })
    ] });
  }
  if (type === "lineColor") {
    return /* @__PURE__ */ jsxs("div", { className: "option-widget", style: { display: "block" }, children: [
      /* @__PURE__ */ jsx("h4", { children: "Line Color" }),
      /* @__PURE__ */ jsx(SketchPicker, { color: lineColor, onChangeComplete: (color) => handleColorChange(color, "line-color") })
    ] });
  }
  if (type === "lineWidth") {
    return /* @__PURE__ */ jsxs("div", { className: "option-widget", style: { display: "block" }, children: [
      /* @__PURE__ */ jsx("h4", { children: "Line Width" }),
      /* @__PURE__ */ jsx("input", { onChange: (e) => setLineWidth(parseFloat(e.target.value)), value: lineWidth, type: "range", min: "0.5", max: "1.5", step: "0.1" })
    ] });
  }
  return /* @__PURE__ */ jsx("div", { style: { display: "none" } });
};
const Nav = ({ setPlaces, setLineWidth, setContours, setLineColor, setLandColor, map: map2, landColor, lineColor }) => {
  const docs = reactExports.useRef(null);
  const options = reactExports.useRef(null);
  const [currentWidget, setCurrentWidget] = reactExports.useState("");
  reactExports.useEffect((prevWidget) => {
  }, [currentWidget]);
  const setCurrentWidgetWrapper = (type) => {
    setCurrentWidget((prevProps) => {
      if (type !== prevProps) {
        return type;
      }
      return "";
    });
  };
  const toggleDocs = (e) => {
    if (docs.current.style.maxHeight === "0px" || !docs.current.style.maxHeight) {
      return docs.current.style.maxHeight = "500px";
    }
    docs.current.style.maxHeight = "0px";
  };
  const toggleOptions = (e) => {
    if (options.current.style.maxHeight === "0px" || !options.current.style.maxHeight) {
      return options.current.style.maxHeight = "500px";
    }
    setCurrentWidget("");
    options.current.style.maxHeight = "0px";
  };
  const togglePlaces = (e) => setPlaces((prevState) => !prevState);
  const toggleContours = (e) => setContours((prevState) => !prevState);
  const handleColorChange = (color, property2) => {
    switch (property2) {
      case "line-color":
        setLineColor(color.hex);
        break;
      case "land-color":
        setLandColor(color.hex);
        break;
    }
  };
  const takePhoto = (e) => {
    let img = map2.getCanvas().toDataURL();
    console.log(img);
    var download = document.createElement("a");
    download.href = img;
    download.target = "_blank";
    download.download = "map";
    let evt = document.createEvent("MouseEvents");
    evt.initMouseEvent(
      "click",
      true,
      true,
      window,
      1,
      0,
      0,
      0,
      0,
      false,
      false,
      false,
      false,
      0,
      null
    );
    download.dispatchEvent(evt);
  };
  return /* @__PURE__ */ jsxs("div", { id: "topo-nav", children: [
    /* @__PURE__ */ jsxs("div", { id: "nav-panel", children: [
      /* @__PURE__ */ jsx("h2", { id: "title", children: "TOPO" }),
      /* @__PURE__ */ jsxs("ul", { id: "nav-list", children: [
        /* @__PURE__ */ jsx("li", { onClick: toggleDocs, children: "Documentation" }),
        /* @__PURE__ */ jsx("li", { ref: docs, id: "docs-container", children: /* @__PURE__ */ jsx("p", { children: "Welcome to Topo! This is a map where you can create photos of contours on maps and edit the contour line colors and land color. Try editing this map using the options button below!" }) }),
        /* @__PURE__ */ jsx("li", { onClick: toggleOptions, children: "Options" }),
        /* @__PURE__ */ jsx("li", { ref: options, id: "option-container", children: /* @__PURE__ */ jsxs("ul", { id: "option-list", children: [
          /* @__PURE__ */ jsx("li", { onClick: () => setCurrentWidgetWrapper("landColor"), children: "Land Color" }),
          /* @__PURE__ */ jsx("li", { onClick: () => setCurrentWidgetWrapper("lineColor"), children: "Contour Line Color" }),
          /* @__PURE__ */ jsx("li", { onClick: () => setCurrentWidgetWrapper("lineWidth"), children: "Contour Line Width" }),
          /* @__PURE__ */ jsx("li", { onClick: toggleContours, children: "Toggle Contours" }),
          /* @__PURE__ */ jsx("li", { onClick: togglePlaces, children: "Toggle Places" })
        ] }) }),
        /* @__PURE__ */ jsx("li", { onClick: takePhoto, children: "Download Map" })
      ] })
    ] }),
    /* @__PURE__ */ jsx("div", { id: "nav-widgets", children: /* @__PURE__ */ jsx(
      Widget,
      {
        type: currentWidget,
        landColor,
        lineColor,
        handleColorChange,
        setLineWidth
      }
    ) })
  ] });
};
const App$1 = "";
mapboxgl.accessToken = "pk.eyJ1IjoiZGNoaWNjaG9uIiwiYSI6ImNrMm5saGJsczB0emYzYm05dzV4c2lnMDMifQ.mHFtuW251o5kz5nKxKvc-A";
const App = () => {
  const mapContainer = reactExports.useRef(null);
  const [map2, setMap] = reactExports.useState(null);
  const [landColor, setLandColor] = reactExports.useState("hsl(185, 0%, 18%)");
  const [lineColor, setLineColor] = reactExports.useState("#85ceff");
  const [lineWidth, setLineWidth] = reactExports.useState(1);
  const [contours, setContours] = reactExports.useState(true);
  const [places, setPlaces] = reactExports.useState(true);
  reactExports.useEffect(() => {
    if (mapContainer.current.children.length !== 0)
      return;
    let lng = -70.9;
    let lat = 42.35;
    let zoom = 9;
    let longitude = window.localStorage.getItem("lng");
    let latitude = window.localStorage.getItem("lat");
    let zoomStore = window.localStorage.getItem("zoom");
    if (parseFloat(longitude) && parseFloat(latitude) && parseFloat(zoomStore)) {
      lng = longitude;
      lat = latitude;
      zoom = zoomStore;
    }
    const newMap = new mapboxgl.Map({
      container: mapContainer.current,
      style: "mapbox://styles/dchicchon/ckvb5lorxb4ep14p13vc4exqp",
      center: [lng, lat],
      zoom,
      preserveDrawingBuffer: true
    });
    newMap.on("load", () => {
      newMap.addSource("places", {
        type: "vector",
        url: "mapbox://mapbox.mapbox-streets-v8"
      });
      newMap.addLayer({
        id: "places",
        type: "symbol",
        source: "places",
        "source-layer": "place_label",
        layout: {
          "text-field": ["get", "name"],
          "text-size": 12,
          "text-offset": [0, -1.5]
        },
        paint: {
          "text-color": "#fff",
          "text-halo-color": "#333333",
          "text-halo-width": 1
        }
      });
      newMap.addLayer({
        id: "POI",
        type: "symbol",
        source: "places",
        "source-layer": "poi_label",
        layout: {
          "text-field": ["get", "name"],
          "text-size": 12,
          "text-offset": [0, -1.5]
        },
        paint: {
          "text-color": "#fff",
          "text-halo-color": "#333333",
          "text-halo-width": 1
        }
      });
      newMap.addSource("terrain", {
        type: "vector",
        url: "mapbox://mapbox.mapbox-terrain-v2"
      });
      newMap.addLayer({
        "id": "contours",
        "type": "line",
        "source": "terrain",
        "source-layer": "contour",
        "layout": {
          // Make the layer visible by default.
          "visibility": "visible",
          "line-join": "round",
          "line-cap": "round"
        },
        "paint": {
          "line-color": lineColor,
          "line-width": lineWidth
        }
      });
    });
    newMap.on("move", () => {
      window.localStorage.setItem("lng", newMap.getCenter().lng.toFixed(4));
      window.localStorage.setItem("lat", newMap.getCenter().lat.toFixed(4));
      window.localStorage.setItem("zoom", newMap.getZoom().toFixed(2));
    });
    setMap(newMap);
  }, []);
  reactExports.useEffect(() => {
    if (!map2)
      return;
    map2.setPaintProperty("land", "background-color", landColor);
    map2.setPaintProperty("water-shadow", "fill-color", landColor);
    map2.setPaintProperty("waterway-shadow", "line-color", landColor);
    map2.setPaintProperty("waterway", "line-color", landColor);
  }, [landColor]);
  reactExports.useEffect(() => {
    if (!map2)
      return;
    map2.setPaintProperty("contours", "line-color", lineColor);
  }, [lineColor]);
  reactExports.useEffect(() => {
    if (!map2)
      return;
    map2.setPaintProperty("contours", "line-width", lineWidth);
  }, [lineWidth]);
  reactExports.useEffect(() => {
    if (!map2)
      return;
    console.log("Toggle Contours");
    const newVisibleProperty = contours ? "visible" : "none";
    map2.setLayoutProperty("contours", "visibility", newVisibleProperty);
  }, [contours]);
  reactExports.useEffect(() => {
    if (!map2)
      return;
    const newVisibleProperty = places ? "visible" : "none";
    map2.setLayoutProperty("places", "visibility", newVisibleProperty);
    map2.setLayoutProperty("POI", "visibility", newVisibleProperty);
  }, [places]);
  return (
    // <div style={{ width: '100%', height: '100%' }}>
    /* @__PURE__ */ jsxs("div", { id: "main", children: [
      /* @__PURE__ */ jsx(
        Nav,
        {
          map: map2,
          landColor,
          setLandColor,
          lineColor,
          setLineColor,
          lineWidth,
          setLineWidth,
          setPlaces,
          setContours
        }
      ),
      /* @__PURE__ */ jsx("div", { ref: mapContainer, id: "map-container" })
    ] })
  );
};
export {
  App as default
};
//# sourceMappingURL=App-31e68e18.js.map
